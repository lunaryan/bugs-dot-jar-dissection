[
    {
        "files": 2,
        "nb_test": 4,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.monitor.util.celltypes.PreciseNumberTypeTest"
        ],
        "patch": "diff --git a/server/monitor/src/main/java/org/apache/accumulo/monitor/servlets/PreciseNumberType.java b/server/monitor/src/main/java/org/apache/accumulo/monitor/servlets/PreciseNumberType.java\nindex 66f97e125..1642fc247 100644\n--- a/server/monitor/src/main/java/org/apache/accumulo/monitor/servlets/PreciseNumberType.java\n+++ b/server/monitor/src/main/java/org/apache/accumulo/monitor/servlets/PreciseNumberType.java\n@@ -24,9 +24,16 @@ public PreciseNumberType(int warnMin, int warnMax, int errMin, int errMax) {\n     super(warnMin, warnMax, errMin, errMax);\n   }\n   \n-  public PreciseNumberType() {}\n-  \n-  public static String bigNumber(long big, String[] SUFFIXES, long base) {\n-    return String.format(\"%,d\", big);\n+  @Override\n+  public String format(Object obj) {\n+    int i = (Integer)obj;\n+    String display = String.format(\"%,d\", obj);\n+    if (i < errMin || i > errMax)\n+      return String.format(\"<span class='error'>%s</span>\", display);\n+    if (i < warnMin || i > warnMax)\n+      return String.format(\"<span class='warning'>%s</span>\", display);\n+    return display;\n   }\n+\n+  public PreciseNumberType() {}\n }\ndiff --git a/server/monitor/src/main/java/org/apache/accumulo/monitor/util/celltypes/NumberType.java b/server/monitor/src/main/java/org/apache/accumulo/monitor/util/celltypes/NumberType.java\nindex d311603ef..b28572723 100644\n--- a/server/monitor/src/main/java/org/apache/accumulo/monitor/util/celltypes/NumberType.java\n+++ b/server/monitor/src/main/java/org/apache/accumulo/monitor/util/celltypes/NumberType.java\n@@ -20,7 +20,7 @@\n \n public class NumberType<T extends Number> extends CellType<T> {\n   \n-  private T warnMin, warnMax, errMin, errMax;\n+  protected final T warnMin, warnMax, errMin, errMax;\n   \n   public NumberType(T warnMin, T warnMax, T errMin, T errMax) {\n     this.warnMin = warnMin;\n",
        "project": "accumulo",
        "linesAdd": 12,
        "jira_id": "3408",
        "nb_skipped": 0,
        "commit": "81d25bc2",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 188,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.server.fs.VolumeManagerImplTest"
        ],
        "patch": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java b/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\nindex 0cfb457ef..877b9a664 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\n@@ -219,16 +219,6 @@ protected void ensureSyncIsEnabled() {\n       final String volumeName = entry.getKey();\n       FileSystem fs = entry.getValue().getFileSystem();\n \n-      if (ViewFSUtils.isViewFS(fs)) {\n-        try {\n-          FileSystem resolvedFs = ViewFSUtils.resolvePath(fs, new Path(\"/\")).getFileSystem(fs.getConf());\n-          log.debug(\"resolved \" + fs.getUri() + \" to \" + resolvedFs.getUri() + \" for sync check\");\n-          fs = resolvedFs;\n-        } catch (IOException e) {\n-          log.warn(\"Failed to resolve \" + fs.getUri(), e);\n-        }\n-      }\n-\n       if (fs instanceof DistributedFileSystem) {\n         final String DFS_DURABLE_SYNC = \"dfs.durable.sync\", DFS_SUPPORT_APPEND = \"dfs.support.append\";\n         final String ticketMessage = \"See ACCUMULO-623 and ACCUMULO-1637 for more details.\";\n@@ -410,6 +400,9 @@ public static VolumeManager get(AccumuloConfiguration conf) throws IOException {\n         // Cannot re-define the default volume\n         throw new IllegalArgumentException();\n \n+      if (volumeUriOrDir.startsWith(\"viewfs\"))\n+        throw new IllegalArgumentException();\n+\n       // We require a URI here, fail if it doesn't look like one\n       if (volumeUriOrDir.contains(\":\")) {\n         volumes.put(volumeUriOrDir, VolumeConfiguration.create(new Path(volumeUriOrDir), hadoopConf));\n@@ -426,16 +419,6 @@ public boolean isReady() throws IOException {\n     for (Volume volume : getFileSystems().values()) {\n       FileSystem fs = volume.getFileSystem();\n \n-      if (ViewFSUtils.isViewFS(fs)) {\n-        try {\n-          FileSystem resolvedFs = ViewFSUtils.resolvePath(fs, new Path(\"/\")).getFileSystem(fs.getConf());\n-          log.debug(\"resolved \" + fs.getUri() + \" to \" + resolvedFs.getUri() + \" for ready check\");\n-          fs = resolvedFs;\n-        } catch (IOException e) {\n-          log.warn(\"Failed to resolve \" + fs.getUri(), e);\n-        }\n-      }\n-\n       if (!(fs instanceof DistributedFileSystem))\n         continue;\n       DistributedFileSystem dfs = (DistributedFileSystem) fs;\n",
        "project": "accumulo",
        "linesAdd": 3,
        "jira_id": "3006",
        "nb_skipped": 2,
        "commit": "d6472040",
        "nb_failure": 0,
        "linesRem": 20,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 64,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.server.constraints.MetadataConstraintsTest"
        ],
        "patch": "diff --git a/server/src/main/java/org/apache/accumulo/server/constraints/MetadataConstraints.java b/server/src/main/java/org/apache/accumulo/server/constraints/MetadataConstraints.java\nindex bd19d1fce..463b7b02d 100644\n--- a/server/src/main/java/org/apache/accumulo/server/constraints/MetadataConstraints.java\n+++ b/server/src/main/java/org/apache/accumulo/server/constraints/MetadataConstraints.java\n@@ -34,6 +34,7 @@\n import org.apache.accumulo.server.client.HdfsZooInstance;\n import org.apache.accumulo.server.zookeeper.ZooCache;\n import org.apache.accumulo.server.zookeeper.ZooLock;\n+import org.apache.accumulo.server.zookeeper.TransactionWatcher.ZooArbitrator;\n import org.apache.hadoop.io.Text;\n import org.apache.log4j.Logger;\n \n@@ -72,6 +73,22 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n     return false;\n   }\n   \n+  static private ArrayList<Short> addViolation(ArrayList<Short> lst, int violation) {\n+    if (lst == null)\n+      lst = new ArrayList<Short>();\n+    lst.add((short)violation);\n+    return lst;\n+  }\n+  \n+  static private ArrayList<Short> addIfNotPresent(ArrayList<Short> lst, int intViolation) {\n+    if (lst == null)\n+      return addViolation(lst, intViolation);\n+    short violation = (short)intViolation;\n+    if (!lst.contains(violation))\n+      return addViolation(lst, intViolation);\n+    return lst;\n+  }\n+  \n   public List<Short> check(Environment env, Mutation mutation) {\n     \n     ArrayList<Short> violations = null;\n@@ -96,44 +113,30 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n         break;\n       \n       if (!validTableNameChars[0xff & b]) {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        if (!violations.contains((short) 4))\n-          violations.add((short) 4);\n+        violations = addIfNotPresent(violations, 4);\n       }\n     }\n     \n     if (!containsSemiC) {\n       // see if last row char is <\n       if (row.length == 0 || row[row.length - 1] != '<') {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        if (!violations.contains((short) 4))\n-          violations.add((short) 4);\n+        violations = addIfNotPresent(violations, 4);\n       }\n     } else {\n       if (row.length == 0) {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        if (!violations.contains((short) 4))\n-          violations.add((short) 4);\n+        violations = addIfNotPresent(violations, 4);\n       }\n     }\n     \n     if (row.length > 0 && row[0] == '!') {\n       if (row.length < 3 || row[1] != '0' || (row[2] != '<' && row[2] != ';')) {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        if (!violations.contains((short) 4))\n-          violations.add((short) 4);\n+        violations = addIfNotPresent(violations, 4);\n       }\n     }\n     \n     // ensure row is not less than Constants.METADATA_TABLE_ID\n     if (new Text(row).compareTo(new Text(Constants.METADATA_TABLE_ID)) < 0) {\n-      if (violations == null)\n-        violations = new ArrayList<Short>();\n-      violations.add((short) 5);\n+      violations = addViolation(violations, 5);\n     }\n     \n     for (ColumnUpdate columnUpdate : colUpdates) {\n@@ -141,17 +144,13 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n       \n       if (columnUpdate.isDeleted()) {\n         if (!isValidColumn(columnUpdate)) {\n-          if (violations == null)\n-            violations = new ArrayList<Short>();\n-          violations.add((short) 2);\n+          violations = addViolation(violations, 2);\n         }\n         continue;\n       }\n       \n       if (columnUpdate.getValue().length == 0 && !columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        violations.add((short) 6);\n+        violations = addViolation(violations, 6);\n       }\n       \n       if (columnFamily.equals(Constants.METADATA_DATAFILE_COLUMN_FAMILY)) {\n@@ -159,26 +158,49 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n           DataFileValue dfv = new DataFileValue(columnUpdate.getValue());\n           \n           if (dfv.getSize() < 0 || dfv.getNumEntries() < 0) {\n-            if (violations == null)\n-              violations = new ArrayList<Short>();\n-            violations.add((short) 1);\n+            violations = addViolation(violations, 1);\n           }\n         } catch (NumberFormatException nfe) {\n-          if (violations == null)\n-            violations = new ArrayList<Short>();\n-          violations.add((short) 1);\n+          violations = addViolation(violations, 1);\n         } catch (ArrayIndexOutOfBoundsException aiooe) {\n-          if (violations == null)\n-            violations = new ArrayList<Short>();\n-          violations.add((short) 1);\n+          violations = addViolation(violations, 1);\n         }\n       } else if (columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\n         \n+      } else if (columnFamily.equals(Constants.METADATA_BULKFILE_COLUMN_FAMILY)) {\n+        if (!columnUpdate.isDeleted()) {\n+          // splits, which also write the time reference, are allowed to write this reference even when\n+          // the transaction is not running because the other half of the tablet is holding a reference\n+          // to the file.\n+          boolean isSplitMutation = false;\n+          // When a tablet is assigned, it re-writes the metadata.  It should probably only update the location information, \n+          // but it writes everything.  We allow it to re-write the bulk information if it is setting the location. \n+          // See ACCUMULO-1230. \n+          boolean isLocationMutation = false;\n+          for (ColumnUpdate update : mutation.getUpdates()) {\n+            if (new ColumnFQ(update).equals(Constants.METADATA_TIME_COLUMN)) {\n+              isSplitMutation = true;\n+            }\n+            if (update.getColumnFamily().equals(Constants.METADATA_CURRENT_LOCATION_COLUMN_FAMILY)) {\n+              isLocationMutation = true;\n+            }\n+          }\n+          \n+          if (!isSplitMutation && !isLocationMutation) {\n+            String tidString = new String(columnUpdate.getValue());\n+            long tid = Long.parseLong(tidString);\n+            try {\n+              if (!new ZooArbitrator().transactionAlive(Constants.BULK_ARBITRATOR_TYPE, tid)) {\n+                violations = addViolation(violations, 8);\n+              }\n+            } catch (Exception ex) {\n+              violations = addViolation(violations, 8);\n+            }\n+          }\n+        }\n       } else {\n         if (!isValidColumn(columnUpdate)) {\n-          if (violations == null)\n-            violations = new ArrayList<Short>();\n-          violations.add((short) 2);\n+          violations = addViolation(violations, 2);\n         } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_PREV_ROW_COLUMN) && columnUpdate.getValue().length > 0\n             && (violations == null || !violations.contains((short) 4))) {\n           KeyExtent ke = new KeyExtent(new Text(mutation.getRow()), (Text) null);\n@@ -188,9 +210,7 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n           boolean prevEndRowLessThanEndRow = per == null || ke.getEndRow() == null || per.compareTo(ke.getEndRow()) < 0;\n           \n           if (!prevEndRowLessThanEndRow) {\n-            if (violations == null)\n-              violations = new ArrayList<Short>();\n-            violations.add((short) 3);\n+            violations = addViolation(violations, 3);\n           }\n         } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_LOCK_COLUMN)) {\n           if (zooCache == null) {\n@@ -211,9 +231,7 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n           }\n           \n           if (!lockHeld) {\n-            if (violations == null)\n-              violations = new ArrayList<Short>();\n-            violations.add((short) 7);\n+            violations = addViolation(violations, 7);\n           }\n         }\n         \n@@ -221,7 +239,10 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n     }\n     \n     if (violations != null) {\n-      log.debug(\" violating metadata mutation : \" + mutation);\n+      log.debug(\"violating metadata mutation : \" + new String(mutation.getRow()));\n+      for (ColumnUpdate update : mutation.getUpdates()) {\n+        log.debug(\" update: \" + new String(update.getColumnFamily()) + \":\" + new String(update.getColumnQualifier()) + \" value \" + (update.isDeleted() ? \"[delete]\" : new String(update.getValue())));\n+      }\n     }\n     \n     return violations;\n@@ -243,6 +264,8 @@ public String getViolationDescription(short violationCode) {\n         return \"Empty values are not allowed for any \" + Constants.METADATA_TABLE_NAME + \" column\";\n       case 7:\n         return \"Lock not held in zookeeper by writer\";\n+      case 8:\n+        return \"Bulk load transaction no longer running\";\n     }\n     return null;\n   }\n",
        "project": "accumulo",
        "linesAdd": 61,
        "jira_id": "1044",
        "nb_skipped": 0,
        "commit": "ea2f9856",
        "nb_failure": 1,
        "linesRem": 44,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 697,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.util.shell.ShellConfigTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\nindex b187a763c..a7ab8db2f 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n@@ -286,8 +286,7 @@ public boolean config(String... args) {\n \n     // process default parameters if unspecified\n     try {\n-      boolean hasToken = (token != null);\n-      boolean hasTokenOptions = !loginOptions.isEmpty();\n+      final boolean hasToken = (token != null);\n \n       if (hasToken && password != null) {\n         throw new ParameterException(\"Can not supply '--pass' option with '--tokenClass' option\");\n@@ -300,16 +299,15 @@ public void run() {\n         }\n       });\n \n-      // Need either both a token and options, or neither, but not just one.\n-      if (hasToken != hasTokenOptions) {\n-        throw new ParameterException(\"Must supply either both or neither of '--tokenClass' and '--tokenProperty'\");\n-      } else if (hasToken) { // implied hasTokenOptions\n+      if (hasToken) { // implied hasTokenOptions\n         // Fully qualified name so we don't shadow java.util.Properties\n         org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties props;\n         // and line wrap it because the package name is so long\n         props = new org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties();\n \n+        if (!loginOptions.isEmpty()) {\n           props.putAllStrings(loginOptions);\n+        }\n         token.init(props);\n       } else {\n         // Read password if the user explicitly asked for it, or didn't specify anything at all\n",
        "project": "accumulo",
        "linesAdd": 4,
        "jira_id": "3424",
        "nb_skipped": 2,
        "commit": "27d4ee21",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 403,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mapreduce.AccumuloInputFormatTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/lib/util/InputConfigurator.java b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/lib/util/InputConfigurator.java\nindex ff1410704..b0e649b74 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/lib/util/InputConfigurator.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/lib/util/InputConfigurator.java\n@@ -238,8 +238,15 @@ public static void fetchColumns(Class<?> implementingClass, Configuration conf,\n    */\n   public static Set<Pair<Text,Text>> getFetchedColumns(Class<?> implementingClass, Configuration conf) {\n     ArgumentChecker.notNull(conf);\n-\n-    return deserializeFetchedColumns(conf.getStringCollection(enumToConfKey(implementingClass, ScanOpts.COLUMNS)));\n+    String confValue = conf.get(enumToConfKey(implementingClass, ScanOpts.COLUMNS));\n+    List<String> serialized = new ArrayList<String>();\n+    if (confValue != null) {\n+      // Split and include any trailing empty strings to allow empty column families\n+      for (String val : confValue.split(\",\", -1)) {\n+        serialized.add(val);\n+      }\n+    }\n+    return deserializeFetchedColumns(serialized);\n   }\n \n   public static Set<Pair<Text,Text>> deserializeFetchedColumns(Collection<String> serialized) {\n",
        "project": "accumulo",
        "linesAdd": 8,
        "jira_id": "1661",
        "nb_skipped": 0,
        "commit": "13eb19c2",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 30,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.start.classloader.vfs.AccumuloReloadingVFSClassLoaderTest",
            "org.apache.accumulo.start.classloader.vfs.ContextManagerTest"
        ],
        "patch": "diff --git a/start/src/main/java/org/apache/accumulo/start/classloader/vfs/AccumuloVFSClassLoader.java b/start/src/main/java/org/apache/accumulo/start/classloader/vfs/AccumuloVFSClassLoader.java\nindex b1e829a80..eb653bcbd 100644\n--- a/start/src/main/java/org/apache/accumulo/start/classloader/vfs/AccumuloVFSClassLoader.java\n+++ b/start/src/main/java/org/apache/accumulo/start/classloader/vfs/AccumuloVFSClassLoader.java\n@@ -134,10 +134,15 @@ public void run() {\n       \n       switch (fo.getType()) {\n         case FILE:\n-        case FOLDER:\n           classpath.add(fo);\n           pathsToMonitor.add(fo);\n           break;\n+        case FOLDER:\n+          pathsToMonitor.add(fo);\n+          for (FileObject child : fo.getChildren()) {\n+            classpath.add(child);\n+          }\n+          break;\n         case IMAGINARY:\n           // assume its a pattern\n           String pattern = fo.getName().getBaseName();\n",
        "project": "accumulo",
        "linesAdd": 6,
        "jira_id": "1514",
        "nb_skipped": 0,
        "commit": "fb25913c",
        "nb_failure": 5,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 34,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.proxy.SimpleTest"
        ],
        "patch": "diff --git a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\nindex cec8cfccc..ee993b984 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n@@ -1171,17 +1171,17 @@ private void addUpdatesToMutation(HashMap<Text,ColumnVisibility> vizMap, Mutatio\n       if (update.isSetValue())\n         value = update.getValue();\n       if (update.isSetTimestamp()) {\n-        if (update.isSetDeleteCell()) {\n-          m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\n-        } else {\n         if (update.isSetDeleteCell()) {\n           m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\n         } else {\n           m.put(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp(), value);\n         }\n-        }\n       } else {\n-        m.put(update.getColFamily(), update.getColQualifier(), viz, value);\n+        if (update.isSetDeleteCell()) {\n+          m.putDelete(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz);\n+        } else {\n+          m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, new Value(value));\n+        }\n       }\n     }\n   }\n",
        "project": "accumulo",
        "linesAdd": 5,
        "jira_id": "1800",
        "nb_skipped": 0,
        "commit": "8ec4cb84",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 0,
        "nb_test": 18,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.examples.wikisearch.ingest.WikipediaInputSplitTest"
        ],
        "patch": "",
        "project": "accumulo",
        "linesAdd": 0,
        "jira_id": "366",
        "nb_skipped": 0,
        "commit": "db4a291f",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 284,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mock.MockConnectorTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java b/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\nindex ae167096b..2fe637afb 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n@@ -69,9 +69,9 @@ public int compareTo(Key o) {\n       if (o instanceof MockMemKey) {\n         MockMemKey other = (MockMemKey) o;\n         if (count < other.count)\n-          return -1;\n-        if (count > other.count)\n           return 1;\n+        if (count > other.count)\n+          return -1;\n       } else {\n         return 1;\n       }\n",
        "project": "accumulo",
        "linesAdd": 2,
        "jira_id": "218",
        "nb_skipped": 0,
        "commit": "15476a0d",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 4,
        "nb_test": 294,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mock.MockTableOperationsTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsImpl.java b/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsImpl.java\nindex c35d7fa46..ea4f31142 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsImpl.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsImpl.java\n@@ -190,11 +190,7 @@ public void create(String tableName, boolean limitVersion, TimeType timeType) th\n     \n     List<ByteBuffer> args = Arrays.asList(ByteBuffer.wrap(tableName.getBytes()), ByteBuffer.wrap(timeType.name().getBytes()));\n     \n-    Map<String,String> opts;\n-    if (limitVersion) {\n-      opts = IteratorUtil.generateInitialTableProperties();\n-    } else\n-      opts = Collections.emptyMap();\n+    Map<String,String> opts = IteratorUtil.generateInitialTableProperties(limitVersion);\n     \n     try {\n       doTableOperation(TableOperation.CREATE, args, opts);\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\nindex f558822b0..9289608df 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n@@ -88,9 +88,9 @@ public int compareTo(Key o) {\n   private TimeType timeType;\n   SortedSet<Text> splits = new TreeSet<Text>();\n   \n-  MockTable(boolean useVersions, TimeType timeType) {\n+  MockTable(boolean limitVersion, TimeType timeType) {\n     this.timeType = timeType;\n-    settings = IteratorUtil.generateInitialTableProperties();\n+    settings = IteratorUtil.generateInitialTableProperties(limitVersion);\n     for (Entry<String,String> entry : AccumuloConfiguration.getDefaultConfiguration()) {\n       String key = entry.getKey();\n       if (key.startsWith(Property.TABLE_PREFIX.getKey()))\ndiff --git a/core/src/main/java/org/apache/accumulo/core/iterators/IteratorUtil.java b/core/src/main/java/org/apache/accumulo/core/iterators/IteratorUtil.java\nindex 172fa63ed..9b1ca690e 100644\n--- a/core/src/main/java/org/apache/accumulo/core/iterators/IteratorUtil.java\n+++ b/core/src/main/java/org/apache/accumulo/core/iterators/IteratorUtil.java\n@@ -63,13 +63,22 @@ public int compare(IterInfo o1, IterInfo o2) {\n     \n   }\n   \n-  public static Map<String,String> generateInitialTableProperties() {\n+  /**\n+   * Generate the initial (default) properties for a table\n+   * @param limitVersion\n+   *   include a VersioningIterator at priority 20 that retains a single version of a given K/V pair.\n+   * @return A map of Table properties\n+   */\n+  public static Map<String,String> generateInitialTableProperties(boolean limitVersion) {\n     TreeMap<String,String> props = new TreeMap<String,String>();\n     \n+    if (limitVersion) {\n         for (IteratorScope iterScope : IteratorScope.values()) {\n           props.put(Property.TABLE_ITERATOR_PREFIX + iterScope.name() + \".vers\", \"20,\" + VersioningIterator.class.getName());\n           props.put(Property.TABLE_ITERATOR_PREFIX + iterScope.name() + \".vers.opt.maxVersions\", \"1\");\n         }\n+    }\n+    \n     return props;\n   }\n   \ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/CreateTableCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/CreateTableCommand.java\nindex 83829a949..f2495cc56 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/CreateTableCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/CreateTableCommand.java\n@@ -110,7 +110,7 @@ public int execute(final String fullCommand, final CommandLine cl, final Shell s\n     // context\n     \n     if (cl.hasOption(createTableNoDefaultIters.getOpt())) {\n-      for (String key : IteratorUtil.generateInitialTableProperties().keySet()) {\n+      for (String key : IteratorUtil.generateInitialTableProperties(true).keySet()) {\n         shellState.getConnector().tableOperations().removeProperty(tableName, key);\n       }\n     }\n",
        "project": "accumulo",
        "linesAdd": 8,
        "jira_id": "795",
        "nb_skipped": 0,
        "commit": "9453bcfa",
        "nb_failure": 1,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 421,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mapred.RangeInputSplitTest",
            "org.apache.accumulo.core.client.mapreduce.RangeInputSplitTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\nindex 73c9b59f3..05316a1ae 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\n@@ -204,6 +204,14 @@ public void readFields(DataInput in) throws IOException {\n       zooKeepers = in.readUTF();\n     }\n \n+    if (in.readBoolean()) {\n+      int numIterators = in.readInt();\n+      iterators = new ArrayList<IteratorSetting>(numIterators);\n+      for (int i = 0; i < numIterators; i++) {\n+        iterators.add(new IteratorSetting(in));\n+      }\n+    }\n+\n     if (in.readBoolean()) {\n       level = Level.toLevel(in.readInt());\n     }\n@@ -275,6 +283,14 @@ public void write(DataOutput out) throws IOException {\n       out.writeUTF(zooKeepers);\n     }\n \n+    out.writeBoolean(null != iterators);\n+    if (null != iterators) {\n+      out.writeInt(iterators.size());\n+      for (IteratorSetting iterator : iterators) {\n+        iterator.write(out);\n+      }\n+    }\n+\n     out.writeBoolean(null != level);\n     if (null != level) {\n       out.writeInt(level.toInt());\n",
        "project": "accumulo",
        "linesAdd": 16,
        "jira_id": "2962",
        "nb_skipped": 0,
        "commit": "2fd7633f",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 6,
        "nb_test": 79,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.server.client.BulkImporterTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java b/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java\nindex 4f95e1a6c..83283ac18 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java\n@@ -65,7 +65,6 @@\n   MASTER_RECOVERY_POOL(\"master.recovery.pool\", \"recovery\", PropertyType.STRING, \"Priority queue to use for log recovery map/reduce jobs.\"),\n   MASTER_RECOVERY_SORT_MAPREDUCE(\"master.recovery.sort.mapreduce\", \"false\", PropertyType.BOOLEAN,\n       \"If true, use map/reduce to sort write-ahead logs during recovery\"),\n-  MASTER_BULK_SERVERS(\"master.bulk.server.max\", \"4\", PropertyType.COUNT, \"The number of servers to use during a bulk load\"),\n   MASTER_BULK_RETRIES(\"master.bulk.retries\", \"3\", PropertyType.COUNT, \"The number of attempts to bulk-load a file before giving up.\"),\n   MASTER_BULK_THREADPOOL_SIZE(\"master.bulk.threadpool.size\", \"5\", PropertyType.COUNT, \"The number of threads to use when coordinating a bulk-import.\"),\n   MASTER_MINTHREADS(\"master.server.threads.minimum\", \"2\", PropertyType.COUNT, \"The minimum number of threads to use to handle incoming requests.\"),\ndiff --git a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java\nindex 5e82a7d1e..bb4ae64e3 100644\n--- a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java\n+++ b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java\n@@ -42,14 +42,13 @@\n import org.apache.hadoop.conf.Configuration;\n import org.apache.hadoop.io.Text;\n import org.apache.hadoop.mapreduce.Mapper;\n-import org.apache.log4j.Logger;\n \n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Multimap;\n \n public class WikipediaPartitionedMapper extends Mapper<Text,Article,Text,Mutation> {\n   \n-  private static final Logger log = Logger.getLogger(WikipediaPartitionedMapper.class);\n+  // private static final Logger log = Logger.getLogger(WikipediaPartitionedMapper.class);\n   \n   public final static Charset UTF8 = Charset.forName(\"UTF-8\");\n   public static final String DOCUMENT_COLUMN_FAMILY = \"d\";\ndiff --git a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java\nindex 82af9fd52..3507108b3 100644\n--- a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java\n+++ b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java\n@@ -23,40 +23,21 @@\n import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStreamReader;\n-import java.io.StringReader;\n import java.nio.charset.Charset;\n-import java.util.HashSet;\n-import java.util.IllegalFormatException;\n-import java.util.Map.Entry;\n-import java.util.Set;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-import org.apache.accumulo.core.data.Mutation;\n-import org.apache.accumulo.core.data.Value;\n-import org.apache.accumulo.core.security.ColumnVisibility;\n import org.apache.accumulo.examples.wikisearch.ingest.ArticleExtractor.Article;\n import org.apache.accumulo.examples.wikisearch.ingest.WikipediaInputFormat.WikipediaInputSplit;\n-import org.apache.accumulo.examples.wikisearch.normalizer.LcNoDiacriticsNormalizer;\n-import org.apache.accumulo.examples.wikisearch.protobuf.Uid;\n-import org.apache.accumulo.examples.wikisearch.protobuf.Uid.List.Builder;\n-import org.apache.commons.codec.binary.Base64;\n-import org.apache.commons.lang.StringUtils;\n import org.apache.hadoop.conf.Configuration;\n import org.apache.hadoop.io.LongWritable;\n import org.apache.hadoop.io.Text;\n import org.apache.hadoop.mapreduce.Mapper;\n import org.apache.hadoop.mapreduce.lib.input.FileSplit;\n-import org.apache.log4j.Logger;\n-import org.apache.lucene.analysis.tokenattributes.TermAttribute;\n-import org.apache.lucene.wikipedia.analysis.WikipediaTokenizer;\n-\n-import com.google.common.collect.HashMultimap;\n-import com.google.common.collect.Multimap;\n \n public class WikipediaPartitioner extends Mapper<LongWritable,Text,Text,Article> {\n   \n-  private static final Logger log = Logger.getLogger(WikipediaPartitioner.class);\n+  // private static final Logger log = Logger.getLogger(WikipediaPartitioner.class);\n   \n   public final static Charset UTF8 = Charset.forName(\"UTF-8\");\n   public static final String DOCUMENT_COLUMN_FAMILY = \"d\";\ndiff --git a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java\nindex d8c57c2f9..2738e2c0b 100644\n--- a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java\n+++ b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java\n@@ -4,20 +4,18 @@\n \n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n import org.apache.accumulo.core.data.Mutation;\n-import org.apache.accumulo.examples.wikisearch.ingest.WikipediaMapper;\n import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.io.Text;\n import org.apache.hadoop.mapreduce.JobContext;\n import org.apache.hadoop.mapreduce.OutputCommitter;\n import org.apache.hadoop.mapreduce.OutputFormat;\n import org.apache.hadoop.mapreduce.RecordWriter;\n import org.apache.hadoop.mapreduce.TaskAttemptContext;\n-import org.apache.hadoop.fs.FileSystem;\n-import org.apache.hadoop.io.Text;\n-import org.apache.log4j.Logger;\n \n public class SortingRFileOutputFormat extends OutputFormat<Text,Mutation> {\n \n-  private static final Logger log = Logger.getLogger(SortingRFileOutputFormat.class);\n+  // private static final Logger log = Logger.getLogger(SortingRFileOutputFormat.class);\n \n   public static final String PATH_NAME = \"sortingrfileoutputformat.path\";\n   public static final String MAX_BUFFER_SIZE = \"sortingrfileoutputformat.max.buffer.size\";\ndiff --git a/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java b/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java\nindex 071b8bd26..4ee5371f2 100644\n--- a/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java\n+++ b/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java\n@@ -38,8 +38,8 @@\n import org.apache.accumulo.core.client.Instance;\n import org.apache.accumulo.core.client.impl.ServerClient;\n import org.apache.accumulo.core.client.impl.TabletLocator;\n-import org.apache.accumulo.core.client.impl.Translator;\n import org.apache.accumulo.core.client.impl.TabletLocator.TabletLocation;\n+import org.apache.accumulo.core.client.impl.Translator;\n import org.apache.accumulo.core.client.impl.thrift.ClientService;\n import org.apache.accumulo.core.client.impl.thrift.ThriftTableOperationException;\n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n@@ -150,7 +150,7 @@ public void run() {\n             } catch (Exception ex) {\n               log.warn(\"Unable to find tablets that overlap file \" + mapFile.toString());\n             }\n-            \n+            log.debug(\"Map file \" + mapFile + \" found to overlap \" + tabletsToAssignMapFileTo.size() + \" tablets\");\n             if (tabletsToAssignMapFileTo.size() == 0) {\n               List<KeyExtent> empty = Collections.emptyList();\n               completeFailures.put(mapFile, empty);\n@@ -652,33 +652,41 @@ public String toString() {\n     return findOverlappingTablets(acuConf, fs, locator, file, start, failed.getEndRow());\n   }\n   \n+  final static byte[] byte0 = {0};\n+\n   public static List<TabletLocation> findOverlappingTablets(AccumuloConfiguration acuConf, FileSystem fs, TabletLocator locator, Path file, Text startRow,\n       Text endRow) throws Exception {\n     List<TabletLocation> result = new ArrayList<TabletLocation>();\n-    \n     Collection<ByteSequence> columnFamilies = Collections.emptyList();\n-    \n-    FileSKVIterator reader = FileOperations.getInstance().openReader(file.toString(), true, fs, fs.getConf(), acuConf);\n+    String filename = file.toString();\n+    // log.debug(filename + \" finding overlapping tablets \" + startRow + \" -> \" + endRow);\n+    FileSKVIterator reader = FileOperations.getInstance().openReader(filename, true, fs, fs.getConf(), acuConf);\n     try {\n       Text row = startRow;\n       if (row == null)\n         row = new Text();\n       while (true) {\n+        // log.debug(filename + \" Seeking to row \" + row);\n         reader.seek(new Range(row, null), columnFamilies, false);\n-        if (!reader.hasTop())\n+        if (!reader.hasTop()) {\n+          // log.debug(filename + \" not found\");\n           break;\n+        }\n         row = reader.getTopKey().getRow();\n         TabletLocation tabletLocation = locator.locateTablet(row, false, true);\n+        // log.debug(filename + \" found row \" + row + \" at location \" + tabletLocation);\n         result.add(tabletLocation);\n         row = tabletLocation.tablet_extent.getEndRow();\n-        if (row != null && (endRow == null || row.compareTo(endRow) < 0))\n-          row = Range.followingPrefix(row);\n-        else\n+        if (row != null && (endRow == null || row.compareTo(endRow) < 0)) {\n+          row = new Text(row);\n+          row.append(byte0, 0, byte0.length);\n+        } else\n           break;\n       }\n     } finally {\n       reader.close();\n     }\n+    // log.debug(filename + \" to be sent to \" + result);\n     return result;\n   }\n   \ndiff --git a/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java b/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java\nindex c4a3f5091..05c353dae 100644\n--- a/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java\n+++ b/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java\n@@ -19,11 +19,15 @@\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n import java.util.concurrent.LinkedBlockingQueue;\n@@ -41,12 +45,13 @@\n import org.apache.accumulo.core.client.impl.thrift.TableOperationExceptionType;\n import org.apache.accumulo.core.client.impl.thrift.ThriftTableOperationException;\n import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.conf.SiteConfiguration;\n import org.apache.accumulo.core.file.FileOperations;\n import org.apache.accumulo.core.master.state.tables.TableState;\n import org.apache.accumulo.core.security.thrift.AuthInfo;\n import org.apache.accumulo.core.util.CachedConfiguration;\n import org.apache.accumulo.core.util.Daemon;\n-import org.apache.accumulo.core.util.LoggingRunnable;\n+import org.apache.accumulo.core.util.ThriftUtil;\n import org.apache.accumulo.core.util.UtilWaitThread;\n import org.apache.accumulo.server.ServerConstants;\n import org.apache.accumulo.server.client.HdfsZooInstance;\n@@ -370,7 +375,7 @@ public LoadFiles(String tableId, String source, String bulk, String errorDir, bo\n   \n   @Override\n   public Repo<Master> call(final long tid, Master master) throws Exception {\n-    \n+    final SiteConfiguration conf = ServerConfiguration.getSiteConfiguration();\n     FileSystem fs = TraceFileSystem.wrap(org.apache.accumulo.core.file.FileUtil.getFileSystem(CachedConfiguration.getInstance(),\n         ServerConfiguration.getSiteConfiguration()));\n     List<FileStatus> files = new ArrayList<FileStatus>();\n@@ -389,42 +394,68 @@ public LoadFiles(String tableId, String source, String bulk, String errorDir, bo\n     }\n     fs.delete(writable, false);\n     \n-    // group files into N-sized chunks, send the chunks to random servers\n-    final int SERVERS_TO_USE = Math.min(ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_SERVERS), master.onlineTabletServers()\n-        .size());\n-    \n-    log.debug(\"tid \" + tid + \" using \" + SERVERS_TO_USE + \" servers\");\n-    // wait for success, repeat failures R times\n     final List<String> filesToLoad = Collections.synchronizedList(new ArrayList<String>());\n     for (FileStatus f : files)\n       filesToLoad.add(f.getPath().toString());\n     \n-    final int RETRIES = Math.max(1, ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_RETRIES));\n-    for (int i = 0; i < RETRIES && filesToLoad.size() > 0; i++) {\n-      List<Future<?>> results = new ArrayList<Future<?>>();\n-      for (List<String> chunk : groupFiles(filesToLoad, SERVERS_TO_USE)) {\n-        final List<String> attempt = chunk;\n-        results.add(threadPool.submit(new LoggingRunnable(log, new Runnable() {\n+\n+    final int RETRIES = Math.max(1, conf.getCount(Property.MASTER_BULK_RETRIES));\n+    for (int attempt = 0; attempt < RETRIES && filesToLoad.size() > 0; attempt++) {\n+      List<Future<List<String>>> results = new ArrayList<Future<List<String>>>();\n+      \n+      // Figure out which files will be sent to which server\n+      Set<TServerInstance> currentServers = Collections.synchronizedSet(new HashSet<TServerInstance>(master.onlineTabletServers()));\n+      Map<String,List<String>> loadAssignments = new HashMap<String,List<String>>();\n+      for (TServerInstance server : currentServers) {\n+        loadAssignments.put(server.hostPort(), new ArrayList<String>());\n+      }\n+      int i = 0;\n+      List<Entry<String,List<String>>> entries = new ArrayList<Entry<String,List<String>>>(loadAssignments.entrySet());\n+      for (String file : filesToLoad) {\n+        entries.get(i % entries.size()).getValue().add(file);\n+        i++;\n+      }\n+      \n+      // Use the threadpool to assign files one-at-a-time to the server\n+      for (Entry<String,List<String>> entry : entries) {\n+        if (entry.getValue().isEmpty()) {\n+          continue;\n+        }\n+        final Entry<String,List<String>> finalEntry = entry;\n+        results.add(threadPool.submit(new Callable<List<String>>() {\n           @Override\n-          public void run() {\n+          public List<String> call() {\n+            if (log.isDebugEnabled()) {\n+              log.debug(\"Asking \" + finalEntry.getKey() + \" to load \" + sampleList(finalEntry.getValue(), 10));\n+            }\n+            List<String> failures = new ArrayList<String>();\n             ClientService.Iface client = null;\n             try {\n-              client = ServerClient.getConnection(HdfsZooInstance.getInstance());\n+              client = ThriftUtil.getTServerClient(finalEntry.getKey(), conf);\n+              for (String file : finalEntry.getValue()) {\n+                List<String> attempt = Collections.singletonList(file);\n+                log.debug(\"Asking \" + finalEntry.getKey() + \" to bulk import \" + file);\n                 List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);\n-              attempt.removeAll(fail);\n-              filesToLoad.removeAll(attempt);\n+                if (fail.isEmpty()) {\n+                  filesToLoad.remove(file);\n+                } else {\n+                  failures.addAll(fail);\n+                }\n+              }\n             } catch (Exception ex) {\n               log.error(ex, ex);\n             } finally {\n               ServerClient.close(client);\n             }\n+            return failures;\n           }\n-        })));\n+        }));\n       }\n-      for (Future<?> f : results)\n-        f.get();\n+      Set<String> failures = new HashSet<String>();\n+      for (Future<List<String>> f : results)\n+        failures.addAll(f.get());\n       if (filesToLoad.size() > 0) {\n-        log.debug(\"tid \" + tid + \" attempt \" + (i + 1) + \" \" + filesToLoad + \" failed\");\n+        log.debug(\"tid \" + tid + \" attempt \" + (i + 1) + \" \" + sampleList(filesToLoad, 10) + \" failed\");\n         UtilWaitThread.sleep(100);\n       }\n     }\n@@ -449,16 +480,24 @@ public void run() {\n     return new CompleteBulkImport(tableId, source, bulk, errorDir);\n   }\n   \n-  private List<List<String>> groupFiles(List<String> files, int groups) {\n-    List<List<String>> result = new ArrayList<List<String>>();\n-    Iterator<String> iter = files.iterator();\n-    for (int i = 0; i < groups && iter.hasNext(); i++) {\n-      List<String> group = new ArrayList<String>();\n-      for (int j = 0; j < Math.ceil(files.size() / (double) groups) && iter.hasNext(); j++) {\n-        group.add(iter.next());\n+  static String sampleList(Collection<?> potentiallyLongList, int max) {\n+    StringBuffer result = new StringBuffer();\n+    result.append(\"[\");\n+    int i = 0;\n+    for (Object obj : potentiallyLongList) {\n+      result.append(obj);\n+      if (i >= max) {\n+        result.append(\"...\");\n+        break;\n+      } else {\n+        result.append(\", \");\n       }\n-      result.add(group);\n+      i++;\n     }\n-    return result;\n+    if (i < max)\n+      result.delete(result.length() - 2, result.length());\n+    result.append(\"]\");\n+    return result.toString();\n   }\n+\n }\n",
        "project": "accumulo",
        "linesAdd": 83,
        "jira_id": "412",
        "nb_skipped": 0,
        "commit": "5594b2e0",
        "nb_failure": 1,
        "linesRem": 67,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 25,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.proxy.SimpleTest"
        ],
        "patch": "diff --git a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\nindex ed8c71f4b..859b94851 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n@@ -104,11 +104,19 @@\n     public Iterator<Map.Entry<Key,Value>> iterator;\n   }\n   \n-  static class CloseWriter implements RemovalListener<UUID,BatchWriter> {\n+  static protected class BatchWriterPlusException {\n+    public BatchWriter writer;\n+    public MutationsRejectedException exception = null;\n+  }\n+  \n+  static class CloseWriter implements RemovalListener<UUID,BatchWriterPlusException> {\n     @Override\n-    public void onRemoval(RemovalNotification<UUID,BatchWriter> notification) {\n+    public void onRemoval(RemovalNotification<UUID,BatchWriterPlusException> notification) {\n       try {\n-        notification.getValue().close();\n+        BatchWriterPlusException value = notification.getValue();\n+        if (value.exception != null)\n+          throw value.exception;\n+        notification.getValue().writer.close();\n       } catch (MutationsRejectedException e) {\n         logger.warn(e, e);\n       }\n@@ -131,7 +139,7 @@ public CloseScanner() {}\n   }\n   \n   protected Cache<UUID,ScannerPlusIterator> scannerCache;\n-  protected Cache<UUID,BatchWriter> writerCache;\n+  protected Cache<UUID,BatchWriterPlusException> writerCache;\n   \n   public ProxyServer(Properties props) {\n \n@@ -904,10 +912,12 @@ public void closeScanner(String uuid) throws TException {\n   @Override\n   public void updateAndFlush(ByteBuffer login, String tableName, Map<ByteBuffer,List<ColumnUpdate>> cells) throws TException {\n     try {\n-      BatchWriter writer = getWriter(login, tableName, null);\n-      addCellsToWriter(cells, writer);\n-      writer.flush();\n-      writer.close();\n+      BatchWriterPlusException bwpe = getWriter(login, tableName, null);\n+      addCellsToWriter(cells, bwpe);\n+      if (bwpe.exception != null)\n+        throw bwpe.exception;\n+      bwpe.writer.flush();\n+      bwpe.writer.close();\n     } catch (Exception e) {\n       throw translateException(e);\n     }\n@@ -915,7 +925,10 @@ public void updateAndFlush(ByteBuffer login, String tableName, Map<ByteBuffer,Li\n   \n   private static final ColumnVisibility EMPTY_VIS = new ColumnVisibility();\n   \n-  private void addCellsToWriter(Map<ByteBuffer,List<ColumnUpdate>> cells, BatchWriter writer) throws MutationsRejectedException {\n+  private void addCellsToWriter(Map<ByteBuffer,List<ColumnUpdate>> cells, BatchWriterPlusException bwpe) throws MutationsRejectedException {\n+    if (bwpe.exception != null)\n+      return;\n+    \n     HashMap<Text,ColumnVisibility> vizMap = new HashMap<Text,ColumnVisibility>();\n     \n     for (Entry<ByteBuffer,List<ColumnUpdate>> entry : cells.entrySet()) {\n@@ -947,14 +960,18 @@ private void addCellsToWriter(Map<ByteBuffer,List<ColumnUpdate>> cells, BatchWri\n           m.put(update.getColFamily(), update.getColQualifier(), viz, value);\n         }\n       }\n-      writer.addMutation(m);\n+      try {\n+        bwpe.writer.addMutation(m);\n+      } catch (MutationsRejectedException mre) {\n+        bwpe.exception = mre;\n+      }\n     }\n   }\n   \n   @Override\n   public String createWriter(ByteBuffer login, String tableName, WriterOptions opts) throws TException {\n     try {\n-      BatchWriter writer = getWriter(login, tableName, opts);\n+      BatchWriterPlusException writer = getWriter(login, tableName, opts);\n       UUID uuid = UUID.randomUUID();\n       writerCache.put(uuid, writer);\n       return uuid.toString();\n@@ -966,11 +983,11 @@ public String createWriter(ByteBuffer login, String tableName, WriterOptions opt\n   @Override\n   public void update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells) throws TException {\n     try {\n-      BatchWriter batchwriter = writerCache.getIfPresent(UUID.fromString(writer));\n-      if (batchwriter == null) {\n+      BatchWriterPlusException bwpe = writerCache.getIfPresent(UUID.fromString(writer));\n+      if (bwpe == null) {\n         throw new UnknownWriter(\"Writer never existed or no longer exists\");\n       }\n-      addCellsToWriter(cells, batchwriter);\n+      addCellsToWriter(cells, bwpe);\n     } catch (Exception e) {\n       throw translateException(e);\n     }\n@@ -979,11 +996,13 @@ public void update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells) thro\n   @Override\n   public void flush(String writer) throws TException {\n     try {\n-      BatchWriter batchwriter = writerCache.getIfPresent(UUID.fromString(writer));\n-      if (batchwriter == null) {\n+      BatchWriterPlusException bwpe = writerCache.getIfPresent(UUID.fromString(writer));\n+      if (bwpe == null) {\n         throw new UnknownWriter(\"Writer never existed or no longer exists\");\n       }\n-      batchwriter.flush();\n+      if (bwpe.exception != null)\n+        throw bwpe.exception;\n+      bwpe.writer.flush();\n     } catch (Exception e) {\n       throw translateException(e);\n     }\n@@ -992,18 +1011,20 @@ public void flush(String writer) throws TException {\n   @Override\n   public void closeWriter(String writer) throws TException {\n     try {\n-      BatchWriter batchwriter = writerCache.getIfPresent(UUID.fromString(writer));\n-      if (batchwriter == null) {\n+      BatchWriterPlusException bwpe = writerCache.getIfPresent(UUID.fromString(writer));\n+      if (bwpe == null) {\n         throw new UnknownWriter(\"Writer never existed or no longer exists\");\n       }\n-      batchwriter.close();\n+      if (bwpe.exception != null)\n+        throw bwpe.exception;\n+      bwpe.writer.close();\n       writerCache.invalidate(UUID.fromString(writer));\n     } catch (Exception e) {\n       throw translateException(e);\n     }\n   }\n   \n-  private BatchWriter getWriter(ByteBuffer login, String tableName, WriterOptions opts) throws Exception {\n+  private BatchWriterPlusException getWriter(ByteBuffer login, String tableName, WriterOptions opts) throws Exception {\n     BatchWriterConfig cfg = new BatchWriterConfig();\n     if (opts != null) {\n       if (opts.maxMemory != 0)\n@@ -1015,7 +1036,9 @@ private BatchWriter getWriter(ByteBuffer login, String tableName, WriterOptions\n       if (opts.latencyMs != 0)\n         cfg.setMaxLatency(opts.latencyMs, TimeUnit.MILLISECONDS);\n     }\n-    return getConnector(login).createBatchWriter(tableName, cfg);\n+    BatchWriterPlusException result = new BatchWriterPlusException();\n+    result.writer = getConnector(login).createBatchWriter(tableName, cfg);\n+    return result;\n   }\n   \n   private IteratorSetting getIteratorSetting(org.apache.accumulo.proxy.thrift.IteratorSetting setting) {\ndiff --git a/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java b/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java\nindex 28d7e025e..cc244f3a7 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java\n@@ -182,7 +182,7 @@\n \n     public String createWriter(ByteBuffer login, String tableName, WriterOptions opts) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException;\n \n-    public void update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells) throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException;\n+    public void update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells) throws org.apache.thrift.TException;\n \n     public void flush(String writer) throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException;\n \n@@ -2358,10 +2358,9 @@ public String recv_createWriter() throws AccumuloException, AccumuloSecurityExce\n       throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, \"createWriter failed: unknown result\");\n     }\n \n-    public void update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells) throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException\n+    public void update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells) throws org.apache.thrift.TException\n     {\n       send_update(writer, cells);\n-      recv_update();\n     }\n \n     public void send_update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells) throws org.apache.thrift.TException\n@@ -2372,19 +2371,6 @@ public void send_update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells)\n       sendBase(\"update\", args);\n     }\n \n-    public void recv_update() throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException\n-    {\n-      update_result result = new update_result();\n-      receiveBase(result, \"update\");\n-      if (result.ouch1 != null) {\n-        throw result.ouch1;\n-      }\n-      if (result.ouch2 != null) {\n-        throw result.ouch2;\n-      }\n-      return;\n-    }\n-\n     public void flush(String writer) throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException\n     {\n       send_flush(writer);\n@@ -4994,7 +4980,7 @@ public void update(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells, org.\n       private String writer;\n       private Map<ByteBuffer,List<ColumnUpdate>> cells;\n       public update_call(String writer, Map<ByteBuffer,List<ColumnUpdate>> cells, org.apache.thrift.async.AsyncMethodCallback<update_call> resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {\n-        super(client, protocolFactory, transport, resultHandler, false);\n+        super(client, protocolFactory, transport, resultHandler, true);\n         this.writer = writer;\n         this.cells = cells;\n       }\n@@ -5008,13 +4994,12 @@ public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apa\n         prot.writeMessageEnd();\n       }\n \n-      public void getResult() throws UnknownWriter, MutationsRejectedException, org.apache.thrift.TException {\n+      public void getResult() throws org.apache.thrift.TException {\n         if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n           throw new IllegalStateException(\"Method call not finished!\");\n         }\n         org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());\n         org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);\n-        (new Client(prot)).recv_update();\n       }\n     }\n \n@@ -7007,19 +6992,12 @@ public update_args getEmptyArgsInstance() {\n       }\n \n       protected boolean isOneway() {\n-        return false;\n+        return true;\n       }\n \n-      public update_result getResult(I iface, update_args args) throws org.apache.thrift.TException {\n-        update_result result = new update_result();\n-        try {\n+      public org.apache.thrift.TBase getResult(I iface, update_args args) throws org.apache.thrift.TException {\n         iface.update(args.writer, args.cells);\n-        } catch (UnknownWriter ouch1) {\n-          result.ouch1 = ouch1;\n-        } catch (MutationsRejectedException ouch2) {\n-          result.ouch2 = ouch2;\n-        }\n-        return result;\n+        return null;\n       }\n     }\n \n@@ -81630,464 +81608,6 @@ public void read(org.apache.thrift.protocol.TProtocol prot, update_args struct)\n \n   }\n \n-  public static class update_result implements org.apache.thrift.TBase<update_result, update_result._Fields>, java.io.Serializable, Cloneable   {\n-    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct(\"update_result\");\n-\n-    private static final org.apache.thrift.protocol.TField OUCH1_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch1\", org.apache.thrift.protocol.TType.STRUCT, (short)1);\n-    private static final org.apache.thrift.protocol.TField OUCH2_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch2\", org.apache.thrift.protocol.TType.STRUCT, (short)2);\n-\n-    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();\n-    static {\n-      schemes.put(StandardScheme.class, new update_resultStandardSchemeFactory());\n-      schemes.put(TupleScheme.class, new update_resultTupleSchemeFactory());\n-    }\n-\n-    public UnknownWriter ouch1; // required\n-    public MutationsRejectedException ouch2; // required\n-\n-    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */\n-    @SuppressWarnings(\"all\") public enum _Fields implements org.apache.thrift.TFieldIdEnum {\n-      OUCH1((short)1, \"ouch1\"),\n-      OUCH2((short)2, \"ouch2\");\n-\n-      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();\n-\n-      static {\n-        for (_Fields field : EnumSet.allOf(_Fields.class)) {\n-          byName.put(field.getFieldName(), field);\n-        }\n-      }\n-\n-      /**\n-       * Find the _Fields constant that matches fieldId, or null if its not found.\n-       */\n-      public static _Fields findByThriftId(int fieldId) {\n-        switch(fieldId) {\n-          case 1: // OUCH1\n-            return OUCH1;\n-          case 2: // OUCH2\n-            return OUCH2;\n-          default:\n-            return null;\n-        }\n-      }\n-\n-      /**\n-       * Find the _Fields constant that matches fieldId, throwing an exception\n-       * if it is not found.\n-       */\n-      public static _Fields findByThriftIdOrThrow(int fieldId) {\n-        _Fields fields = findByThriftId(fieldId);\n-        if (fields == null) throw new IllegalArgumentException(\"Field \" + fieldId + \" doesn't exist!\");\n-        return fields;\n-      }\n-\n-      /**\n-       * Find the _Fields constant that matches name, or null if its not found.\n-       */\n-      public static _Fields findByName(String name) {\n-        return byName.get(name);\n-      }\n-\n-      private final short _thriftId;\n-      private final String _fieldName;\n-\n-      _Fields(short thriftId, String fieldName) {\n-        _thriftId = thriftId;\n-        _fieldName = fieldName;\n-      }\n-\n-      public short getThriftFieldId() {\n-        return _thriftId;\n-      }\n-\n-      public String getFieldName() {\n-        return _fieldName;\n-      }\n-    }\n-\n-    // isset id assignments\n-    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;\n-    static {\n-      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);\n-      tmpMap.put(_Fields.OUCH1, new org.apache.thrift.meta_data.FieldMetaData(\"ouch1\", org.apache.thrift.TFieldRequirementType.DEFAULT, \n-          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n-      tmpMap.put(_Fields.OUCH2, new org.apache.thrift.meta_data.FieldMetaData(\"ouch2\", org.apache.thrift.TFieldRequirementType.DEFAULT, \n-          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n-      metaDataMap = Collections.unmodifiableMap(tmpMap);\n-      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(update_result.class, metaDataMap);\n-    }\n-\n-    public update_result() {\n-    }\n-\n-    public update_result(\n-      UnknownWriter ouch1,\n-      MutationsRejectedException ouch2)\n-    {\n-      this();\n-      this.ouch1 = ouch1;\n-      this.ouch2 = ouch2;\n-    }\n-\n-    /**\n-     * Performs a deep copy on <i>other</i>.\n-     */\n-    public update_result(update_result other) {\n-      if (other.isSetOuch1()) {\n-        this.ouch1 = new UnknownWriter(other.ouch1);\n-      }\n-      if (other.isSetOuch2()) {\n-        this.ouch2 = new MutationsRejectedException(other.ouch2);\n-      }\n-    }\n-\n-    public update_result deepCopy() {\n-      return new update_result(this);\n-    }\n-\n-    @Override\n-    public void clear() {\n-      this.ouch1 = null;\n-      this.ouch2 = null;\n-    }\n-\n-    public UnknownWriter getOuch1() {\n-      return this.ouch1;\n-    }\n-\n-    public update_result setOuch1(UnknownWriter ouch1) {\n-      this.ouch1 = ouch1;\n-      return this;\n-    }\n-\n-    public void unsetOuch1() {\n-      this.ouch1 = null;\n-    }\n-\n-    /** Returns true if field ouch1 is set (has been assigned a value) and false otherwise */\n-    public boolean isSetOuch1() {\n-      return this.ouch1 != null;\n-    }\n-\n-    public void setOuch1IsSet(boolean value) {\n-      if (!value) {\n-        this.ouch1 = null;\n-      }\n-    }\n-\n-    public MutationsRejectedException getOuch2() {\n-      return this.ouch2;\n-    }\n-\n-    public update_result setOuch2(MutationsRejectedException ouch2) {\n-      this.ouch2 = ouch2;\n-      return this;\n-    }\n-\n-    public void unsetOuch2() {\n-      this.ouch2 = null;\n-    }\n-\n-    /** Returns true if field ouch2 is set (has been assigned a value) and false otherwise */\n-    public boolean isSetOuch2() {\n-      return this.ouch2 != null;\n-    }\n-\n-    public void setOuch2IsSet(boolean value) {\n-      if (!value) {\n-        this.ouch2 = null;\n-      }\n-    }\n-\n-    public void setFieldValue(_Fields field, Object value) {\n-      switch (field) {\n-      case OUCH1:\n-        if (value == null) {\n-          unsetOuch1();\n-        } else {\n-          setOuch1((UnknownWriter)value);\n-        }\n-        break;\n-\n-      case OUCH2:\n-        if (value == null) {\n-          unsetOuch2();\n-        } else {\n-          setOuch2((MutationsRejectedException)value);\n-        }\n-        break;\n-\n-      }\n-    }\n-\n-    public Object getFieldValue(_Fields field) {\n-      switch (field) {\n-      case OUCH1:\n-        return getOuch1();\n-\n-      case OUCH2:\n-        return getOuch2();\n-\n-      }\n-      throw new IllegalStateException();\n-    }\n-\n-    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */\n-    public boolean isSet(_Fields field) {\n-      if (field == null) {\n-        throw new IllegalArgumentException();\n-      }\n-\n-      switch (field) {\n-      case OUCH1:\n-        return isSetOuch1();\n-      case OUCH2:\n-        return isSetOuch2();\n-      }\n-      throw new IllegalStateException();\n-    }\n-\n-    @Override\n-    public boolean equals(Object that) {\n-      if (that == null)\n-        return false;\n-      if (that instanceof update_result)\n-        return this.equals((update_result)that);\n-      return false;\n-    }\n-\n-    public boolean equals(update_result that) {\n-      if (that == null)\n-        return false;\n-\n-      boolean this_present_ouch1 = true && this.isSetOuch1();\n-      boolean that_present_ouch1 = true && that.isSetOuch1();\n-      if (this_present_ouch1 || that_present_ouch1) {\n-        if (!(this_present_ouch1 && that_present_ouch1))\n-          return false;\n-        if (!this.ouch1.equals(that.ouch1))\n-          return false;\n-      }\n-\n-      boolean this_present_ouch2 = true && this.isSetOuch2();\n-      boolean that_present_ouch2 = true && that.isSetOuch2();\n-      if (this_present_ouch2 || that_present_ouch2) {\n-        if (!(this_present_ouch2 && that_present_ouch2))\n-          return false;\n-        if (!this.ouch2.equals(that.ouch2))\n-          return false;\n-      }\n-\n-      return true;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      return 0;\n-    }\n-\n-    public int compareTo(update_result other) {\n-      if (!getClass().equals(other.getClass())) {\n-        return getClass().getName().compareTo(other.getClass().getName());\n-      }\n-\n-      int lastComparison = 0;\n-      update_result typedOther = (update_result)other;\n-\n-      lastComparison = Boolean.valueOf(isSetOuch1()).compareTo(typedOther.isSetOuch1());\n-      if (lastComparison != 0) {\n-        return lastComparison;\n-      }\n-      if (isSetOuch1()) {\n-        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch1, typedOther.ouch1);\n-        if (lastComparison != 0) {\n-          return lastComparison;\n-        }\n-      }\n-      lastComparison = Boolean.valueOf(isSetOuch2()).compareTo(typedOther.isSetOuch2());\n-      if (lastComparison != 0) {\n-        return lastComparison;\n-      }\n-      if (isSetOuch2()) {\n-        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch2, typedOther.ouch2);\n-        if (lastComparison != 0) {\n-          return lastComparison;\n-        }\n-      }\n-      return 0;\n-    }\n-\n-    public _Fields fieldForId(int fieldId) {\n-      return _Fields.findByThriftId(fieldId);\n-    }\n-\n-    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {\n-      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);\n-    }\n-\n-    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {\n-      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);\n-      }\n-\n-    @Override\n-    public String toString() {\n-      StringBuilder sb = new StringBuilder(\"update_result(\");\n-      boolean first = true;\n-\n-      sb.append(\"ouch1:\");\n-      if (this.ouch1 == null) {\n-        sb.append(\"null\");\n-      } else {\n-        sb.append(this.ouch1);\n-      }\n-      first = false;\n-      if (!first) sb.append(\", \");\n-      sb.append(\"ouch2:\");\n-      if (this.ouch2 == null) {\n-        sb.append(\"null\");\n-      } else {\n-        sb.append(this.ouch2);\n-      }\n-      first = false;\n-      sb.append(\")\");\n-      return sb.toString();\n-    }\n-\n-    public void validate() throws org.apache.thrift.TException {\n-      // check for required fields\n-      // check for sub-struct validity\n-    }\n-\n-    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {\n-      try {\n-        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));\n-      } catch (org.apache.thrift.TException te) {\n-        throw new java.io.IOException(te);\n-      }\n-    }\n-\n-    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {\n-      try {\n-        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));\n-      } catch (org.apache.thrift.TException te) {\n-        throw new java.io.IOException(te);\n-      }\n-    }\n-\n-    private static class update_resultStandardSchemeFactory implements SchemeFactory {\n-      public update_resultStandardScheme getScheme() {\n-        return new update_resultStandardScheme();\n-      }\n-    }\n-\n-    private static class update_resultStandardScheme extends StandardScheme<update_result> {\n-\n-      public void read(org.apache.thrift.protocol.TProtocol iprot, update_result struct) throws org.apache.thrift.TException {\n-        org.apache.thrift.protocol.TField schemeField;\n-        iprot.readStructBegin();\n-        while (true)\n-        {\n-          schemeField = iprot.readFieldBegin();\n-          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { \n-            break;\n-          }\n-          switch (schemeField.id) {\n-            case 1: // OUCH1\n-              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\n-                struct.ouch1 = new UnknownWriter();\n-                struct.ouch1.read(iprot);\n-                struct.setOuch1IsSet(true);\n-              } else { \n-                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n-              }\n-              break;\n-            case 2: // OUCH2\n-              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\n-                struct.ouch2 = new MutationsRejectedException();\n-                struct.ouch2.read(iprot);\n-                struct.setOuch2IsSet(true);\n-              } else { \n-                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n-              }\n-              break;\n-            default:\n-              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n-          }\n-          iprot.readFieldEnd();\n-        }\n-        iprot.readStructEnd();\n-\n-        // check for required fields of primitive type, which can't be checked in the validate method\n-        struct.validate();\n-      }\n-\n-      public void write(org.apache.thrift.protocol.TProtocol oprot, update_result struct) throws org.apache.thrift.TException {\n-        struct.validate();\n-\n-        oprot.writeStructBegin(STRUCT_DESC);\n-        if (struct.ouch1 != null) {\n-          oprot.writeFieldBegin(OUCH1_FIELD_DESC);\n-          struct.ouch1.write(oprot);\n-          oprot.writeFieldEnd();\n-        }\n-        if (struct.ouch2 != null) {\n-          oprot.writeFieldBegin(OUCH2_FIELD_DESC);\n-          struct.ouch2.write(oprot);\n-          oprot.writeFieldEnd();\n-        }\n-        oprot.writeFieldStop();\n-        oprot.writeStructEnd();\n-      }\n-\n-    }\n-\n-    private static class update_resultTupleSchemeFactory implements SchemeFactory {\n-      public update_resultTupleScheme getScheme() {\n-        return new update_resultTupleScheme();\n-      }\n-    }\n-\n-    private static class update_resultTupleScheme extends TupleScheme<update_result> {\n-\n-      @Override\n-      public void write(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {\n-        TTupleProtocol oprot = (TTupleProtocol) prot;\n-        BitSet optionals = new BitSet();\n-        if (struct.isSetOuch1()) {\n-          optionals.set(0);\n-        }\n-        if (struct.isSetOuch2()) {\n-          optionals.set(1);\n-        }\n-        oprot.writeBitSet(optionals, 2);\n-        if (struct.isSetOuch1()) {\n-          struct.ouch1.write(oprot);\n-        }\n-        if (struct.isSetOuch2()) {\n-          struct.ouch2.write(oprot);\n-        }\n-      }\n-\n-      @Override\n-      public void read(org.apache.thrift.protocol.TProtocol prot, update_result struct) throws org.apache.thrift.TException {\n-        TTupleProtocol iprot = (TTupleProtocol) prot;\n-        BitSet incoming = iprot.readBitSet(2);\n-        if (incoming.get(0)) {\n-          struct.ouch1 = new UnknownWriter();\n-          struct.ouch1.read(iprot);\n-          struct.setOuch1IsSet(true);\n-        }\n-        if (incoming.get(1)) {\n-          struct.ouch2 = new MutationsRejectedException();\n-          struct.ouch2.read(iprot);\n-          struct.setOuch2IsSet(true);\n-        }\n-      }\n-    }\n-\n-  }\n-\n   public static class flush_args implements org.apache.thrift.TBase<flush_args, flush_args._Fields>, java.io.Serializable, Cloneable   {\n     private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct(\"flush_args\");\n \n",
        "project": "accumulo",
        "linesAdd": 52,
        "jira_id": "1190",
        "nb_skipped": 0,
        "commit": "e29dc4f5",
        "nb_failure": 0,
        "linesRem": 488,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 366,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.util.shell.ShellTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/TableDiskUsage.java b/core/src/main/java/org/apache/accumulo/core/util/TableDiskUsage.java\nindex 64d5970e7..6a61c50f4 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/TableDiskUsage.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/TableDiskUsage.java\n@@ -144,12 +144,17 @@ public static void printDiskUsage(AccumuloConfiguration acuConf, Collection<Stri\n       tdu.addTable(tableId);\n     \n     HashSet<String> tablesReferenced = new HashSet<String>(tableIds);\n+    HashSet<String> emptyTableIds = new HashSet<String>();\n     \n     for (String tableId : tableIds) {\n       Scanner mdScanner = conn.createScanner(Constants.METADATA_TABLE_NAME, Constants.NO_AUTHS);\n       mdScanner.fetchColumnFamily(Constants.METADATA_DATAFILE_COLUMN_FAMILY);\n       mdScanner.setRange(new KeyExtent(new Text(tableId), null, null).toMetadataRange());\n       \n+      if(!mdScanner.iterator().hasNext()) {\n+        emptyTableIds.add(tableId);\n+      }\n+      \n       for (Entry<Key,Value> entry : mdScanner) {\n         String file = entry.getKey().getColumnQualifier().toString();\n         if (file.startsWith(\"../\")) {\n@@ -216,6 +221,14 @@ public int compare(TreeSet<String> o1, TreeSet<String> o2) {\n       usage.put(tableNames, entry.getValue());\n     }\n \n+    if(!emptyTableIds.isEmpty()) {\n+      TreeSet<String> emptyTables = new TreeSet<String>();\n+      for (String tableId : emptyTableIds) {\n+        emptyTables.add(reverseTableIdMap.get(tableId));\n+      }\n+      usage.put(emptyTables, 0L);\n+    }\n+    \n     for (Entry<TreeSet<String>,Long> entry : usage.entrySet())\n       printer.print(String.format(\"%,24d %s\", entry.getValue(), entry.getKey()));\n     \n",
        "project": "accumulo",
        "linesAdd": 13,
        "jira_id": "1192",
        "nb_skipped": 0,
        "commit": "9476b877",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 711,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.util.UnsynchronizedBufferTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/UnsynchronizedBuffer.java b/core/src/main/java/org/apache/accumulo/core/util/UnsynchronizedBuffer.java\nindex 6947d64f6..f35361384 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/UnsynchronizedBuffer.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/UnsynchronizedBuffer.java\n@@ -118,8 +118,8 @@ public Reader(byte b[]) {\n     }\n \n     public Reader(ByteBuffer buffer) {\n-      if (buffer.hasArray()) {\n-        offset = buffer.arrayOffset();\n+      if (buffer.hasArray() && buffer.array().length == buffer.arrayOffset() + buffer.limit()) {\n+        offset = buffer.arrayOffset() + buffer.position();\n         data = buffer.array();\n       } else {\n         data = new byte[buffer.remaining()];\n",
        "project": "accumulo",
        "linesAdd": 2,
        "jira_id": "4098",
        "nb_skipped": 2,
        "commit": "a2c2d38a",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 305,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.iterators.user.CombinerTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java b/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\nindex 6e7207363..584eb1468 100644\n--- a/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\n+++ b/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\n@@ -63,7 +63,7 @@\n      */\n     public ValueIterator(SortedKeyValueIterator<Key,Value> source) {\n       this.source = source;\n-      topKey = source.getTopKey();\n+      topKey = new Key(source.getTopKey());\n       hasNext = _hasNext();\n     }\n     \n",
        "project": "accumulo",
        "linesAdd": 1,
        "jira_id": "907",
        "nb_skipped": 0,
        "commit": "4aeaeb2a",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 33,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.proxy.SimpleTest"
        ],
        "patch": "diff --git a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\nindex 3c5c88a43..c6e74f15c 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n@@ -1125,16 +1125,16 @@ private void addCellsToWriter(Map<ByteBuffer,List<ColumnUpdate>> cells, BatchWri\n         if (update.isSetTimestamp()) {\n           if (update.isSetDeleteCell()) {\n             m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\n+          } else {\n+            m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, update.getTimestamp(), new Value(value));\n+            }\n         } else {\n           if (update.isSetDeleteCell()) {\n-              m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\n+            m.putDelete(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz);\n           } else {\n-              m.put(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp(), value);\n+            m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, new Value(value));\n           }\n         }\n-        } else {\n-          m.put(update.getColFamily(), update.getColQualifier(), viz, value);\n-        }\n       }\n       try {\n         bwpe.writer.addMutation(m);\n",
        "project": "accumulo",
        "linesAdd": 5,
        "jira_id": "1800",
        "nb_skipped": 0,
        "commit": "3143b9c5",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 341,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.data.MutationTest",
            "org.apache.accumulo.core.data.KeyTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/data/Key.java b/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\nindex cfb0b5cbe..b6cfad75a 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\n@@ -291,6 +291,19 @@ public Key(TKey tkey) {\n     this.colVisibility = toBytes(tkey.colVisibility);\n     this.timestamp = tkey.timestamp;\n     this.deleted = false;\n+\n+    if (row == null) {\n+      throw new IllegalArgumentException(\"null row\");\n+    }\n+    if (colFamily == null) {\n+      throw new IllegalArgumentException(\"null column family\");\n+    }\n+    if (colQualifier == null) {\n+      throw new IllegalArgumentException(\"null column qualifier\");\n+    }\n+    if (colVisibility == null) {\n+      throw new IllegalArgumentException(\"null column visibility\");\n+    }\n   }\n   \n   /**\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/data/Mutation.java b/src/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\nindex 3979da90b..6b2c09f18 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\n@@ -187,6 +187,13 @@ public Mutation(TMutation tmutation) {\n     this.data = ByteBufferUtil.toBytes(tmutation.data);\n     this.entries = tmutation.entries;\n     this.values = ByteBufferUtil.toBytesList(tmutation.values);\n+\n+    if (this.row == null) {\n+      throw new IllegalArgumentException(\"null row\");\n+    }\n+    if (this.data == null) {\n+      throw new IllegalArgumentException(\"null serialized data\");\n+    }\n   }\n   \n   public Mutation(Mutation m) {\n",
        "project": "accumulo",
        "linesAdd": 20,
        "jira_id": "1986",
        "nb_skipped": 0,
        "commit": "adee0f12",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 291,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.iterators.user.FilterTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/Filter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/Filter.java\nindex 94daf03bf..a9ed76c19 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/Filter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/Filter.java\n@@ -69,7 +69,7 @@ public void seek(Range range, Collection<ByteSequence> columnFamilies, boolean i\n    * Iterates over the source until an acceptable key/value pair is found.\n    */\n   protected void findTop() {\n-    while (getSource().hasTop() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {\n+    while (getSource().hasTop() && !getSource().getTopKey().isDeleted() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {\n       try {\n         getSource().next();\n       } catch (IOException e) {\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/SortedKeyValueIterator.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/SortedKeyValueIterator.java\nindex 8bbf18af7..edeaa1d2a 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/SortedKeyValueIterator.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/SortedKeyValueIterator.java\n@@ -59,7 +59,9 @@\n   boolean hasTop();\n   \n   /**\n-   * Advances to the next K,V pair.\n+   * Advances to the next K,V pair. Note that in minor compaction scope and in non-full major compaction scopes the iterator may see deletion entries. These\n+   * entries should be preserved by all iterators except ones that are strictly scan-time iterators that will never be configured for the minc or majc scopes.\n+   * Deletion entries are only removed during full major compactions.\n    * \n    * @throws IOException\n    *           if an I/O error occurs.\n@@ -88,7 +90,9 @@\n   void seek(Range range, Collection<ByteSequence> columnFamilies, boolean inclusive) throws IOException;\n   \n   /**\n-   * Returns top key. Can be called 0 or more times without affecting behavior of next() or hasTop().\n+   * Returns top key. Can be called 0 or more times without affecting behavior of next() or hasTop(). Note that in minor compaction scope and in non-full major\n+   * compaction scopes the iterator may see deletion entries. These entries should be preserved by all iterators except ones that are strictly scan-time\n+   * iterators that will never be configured for the minc or majc scopes. Deletion entries are only removed during full major compactions.\n    * \n    * @return <tt>K</tt>\n    * @exception IllegalStateException\n",
        "project": "accumulo",
        "linesAdd": 1,
        "jira_id": "414",
        "nb_skipped": 0,
        "commit": "ebf22df0",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 276,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.iterators.user.GrepIteratorTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/GrepIterator.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/GrepIterator.java\nindex e768bff54..ab8ca84db 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/GrepIterator.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/GrepIterator.java\n@@ -17,35 +17,27 @@\n package org.apache.accumulo.core.iterators.user;\n \n import java.io.IOException;\n+import java.util.Arrays;\n import java.util.Map;\n \n import org.apache.accumulo.core.client.IteratorSetting;\n import org.apache.accumulo.core.data.ByteSequence;\n import org.apache.accumulo.core.data.Key;\n import org.apache.accumulo.core.data.Value;\n+import org.apache.accumulo.core.iterators.Filter;\n import org.apache.accumulo.core.iterators.IteratorEnvironment;\n-import org.apache.accumulo.core.iterators.SkippingIterator;\n import org.apache.accumulo.core.iterators.SortedKeyValueIterator;\n \n /**\n  * This iterator provides exact string matching. It searches both the Key and Value for the string. The string to match is specified by the \"term\" option.\n  */\n-public class GrepIterator extends SkippingIterator {\n+public class GrepIterator extends Filter {\n   \n   private byte term[];\n   \n   @Override\n-  protected void consume() throws IOException {\n-    while (getSource().hasTop()) {\n-      Key k = getSource().getTopKey();\n-      Value v = getSource().getTopValue();\n-      \n-      if (match(v.get()) || match(k.getRowData()) || match(k.getColumnFamilyData()) || match(k.getColumnQualifierData())) {\n-        break;\n-      }\n-      \n-      getSource().next();\n-    }\n+  public boolean accept(Key k, Value v) {\n+    return match(v.get()) || match(k.getRowData()) || match(k.getColumnFamilyData()) || match(k.getColumnQualifierData());\n   }\n   \n   private boolean match(ByteSequence bs) {\n@@ -88,7 +80,9 @@ private static int indexOf(byte[] source, int sourceOffset, int sourceCount, byt\n   \n   @Override\n   public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n-    throw new UnsupportedOperationException();\n+    GrepIterator copy = (GrepIterator) super.deepCopy(env);\n+    copy.term = Arrays.copyOf(term, term.length);\n+    return copy;\n   }\n   \n   @Override\n",
        "project": "accumulo",
        "linesAdd": 8,
        "jira_id": "414",
        "nb_skipped": 0,
        "commit": "116d5928",
        "nb_failure": 1,
        "linesRem": 14,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 422,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mapreduce.RangeInputSplitTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\nindex 05316a1ae..15c6185d3 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\n@@ -144,6 +144,9 @@ public long getLength() throws IOException {\n   @Override\n   public void readFields(DataInput in) throws IOException {\n     range.readFields(in);\n+    if (in.readBoolean()) {\n+      table = in.readUTF();\n+    }\n     int numLocs = in.readInt();\n     locations = new String[numLocs];\n     for (int i = 0; i < numLocs; ++i)\n@@ -220,6 +223,12 @@ public void readFields(DataInput in) throws IOException {\n   @Override\n   public void write(DataOutput out) throws IOException {\n     range.write(out);\n+\n+    out.writeBoolean(null != table);\n+    if (null != table) {\n+      out.writeUTF(table);\n+    }\n+\n     out.writeInt(locations.length);\n     for (int i = 0; i < locations.length; ++i)\n       out.writeUTF(locations[i]);\n",
        "project": "accumulo",
        "linesAdd": 9,
        "jira_id": "3015",
        "nb_skipped": 0,
        "commit": "f848178e",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 295,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.iterators.user.FilterTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java b/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java\nindex 2dbfe66fd..49f0146e4 100644\n--- a/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java\n@@ -17,8 +17,8 @@\n package org.apache.accumulo.core.iterators.user;\n \n import java.io.IOException;\n+import java.text.ParseException;\n import java.text.SimpleDateFormat;\n-import java.util.Date;\n import java.util.Map;\n import java.util.TimeZone;\n \n@@ -33,6 +33,7 @@\n  * A Filter that matches entries whose timestamps fall within a range.\n  */\n public class TimestampFilter extends Filter {\n+  private static final String LONG_PREFIX = \"LONG\";\n   private final SimpleDateFormat dateParser = initDateParser();\n   \n   private static SimpleDateFormat initDateParser() {\n@@ -86,10 +87,20 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n       throw new IllegalArgumentException(\"must have either start or end for \" + TimestampFilter.class.getName());\n     \n     try {\n-      if (hasStart)\n-        start = dateParser.parse(options.get(START)).getTime();\n-      if (hasEnd)\n-        end = dateParser.parse(options.get(END)).getTime();\n+      if (hasStart) {\n+        String s = options.get(START);\n+        if (s.startsWith(LONG_PREFIX))\n+          start = Long.valueOf(s.substring(LONG_PREFIX.length()));\n+        else\n+          start = dateParser.parse(s).getTime();\n+      }\n+      if (hasEnd) {\n+        String s = options.get(END);\n+        if (s.startsWith(LONG_PREFIX))\n+          end = Long.valueOf(s.substring(LONG_PREFIX.length()));\n+        else\n+          end = dateParser.parse(s).getTime();\n+      }\n     } catch (Exception e) {\n       throw new IllegalArgumentException(e);\n     }\n@@ -116,8 +127,8 @@ public IteratorOptions describeOptions() {\n     IteratorOptions io = super.describeOptions();\n     io.setName(\"tsfilter\");\n     io.setDescription(\"TimestampFilter displays entries with timestamps between specified values\");\n-    io.addNamedOption(\"start\", \"start timestamp (yyyyMMddHHmmssz)\");\n-    io.addNamedOption(\"end\", \"end timestamp (yyyyMMddHHmmssz)\");\n+    io.addNamedOption(\"start\", \"start timestamp (yyyyMMddHHmmssz or LONG<longstring>)\");\n+    io.addNamedOption(\"end\", \"end timestamp (yyyyMMddHHmmssz or LONG<longstring>)\");\n     io.addNamedOption(\"startInclusive\", \"true or false\");\n     io.addNamedOption(\"endInclusive\", \"true or false\");\n     return io;\n@@ -126,11 +137,27 @@ public IteratorOptions describeOptions() {\n   @Override\n   public boolean validateOptions(Map<String,String> options) {\n     super.validateOptions(options);\n+    boolean hasStart = false;\n+    boolean hasEnd = false;\n     try {\n-      if (options.containsKey(START))\n-        dateParser.parse(options.get(START));\n-      if (options.containsKey(END))\n-        dateParser.parse(options.get(END));\n+      if (options.containsKey(START)) {\n+        hasStart = true;\n+        String s = options.get(START);\n+        if (s.startsWith(LONG_PREFIX))\n+          Long.valueOf(s.substring(LONG_PREFIX.length()));\n+        else\n+          dateParser.parse(s);\n+      }\n+      if (options.containsKey(END)) {\n+        hasEnd = true;\n+        String s = options.get(END);\n+        if (s.startsWith(LONG_PREFIX))\n+          Long.valueOf(s.substring(LONG_PREFIX.length()));\n+        else\n+          dateParser.parse(s);\n+      }\n+      if (!hasStart && !hasEnd)\n+        return false;\n       if (options.get(START_INCL) != null)\n         Boolean.parseBoolean(options.get(START_INCL));\n       if (options.get(END_INCL) != null)\n@@ -185,8 +212,13 @@ public static void setRange(IteratorSetting is, String start, boolean startInclu\n    *          boolean indicating whether the start is inclusive\n    */\n   public static void setStart(IteratorSetting is, String start, boolean startInclusive) {\n-    is.addOption(START, start);\n-    is.addOption(START_INCL, Boolean.toString(startInclusive));\n+    SimpleDateFormat dateParser = initDateParser();\n+    try {\n+      long startTS = dateParser.parse(start).getTime();\n+      setStart(is, startTS, startInclusive);\n+    } catch (ParseException e) {\n+      throw new IllegalArgumentException(\"couldn't parse \" + start);\n+    }\n   }\n   \n   /**\n@@ -200,8 +232,13 @@ public static void setStart(IteratorSetting is, String start, boolean startInclu\n    *          boolean indicating whether the end is inclusive\n    */\n   public static void setEnd(IteratorSetting is, String end, boolean endInclusive) {\n-    is.addOption(END, end);\n-    is.addOption(END_INCL, Boolean.toString(endInclusive));\n+    SimpleDateFormat dateParser = initDateParser();\n+    try {\n+      long endTS = dateParser.parse(end).getTime();\n+      setEnd(is, endTS, endInclusive);\n+    } catch (ParseException e) {\n+      throw new IllegalArgumentException(\"couldn't parse \" + end);\n+    }\n   }\n   \n   /**\n@@ -248,8 +285,7 @@ public static void setRange(IteratorSetting is, long start, boolean startInclusi\n    *          boolean indicating whether the start is inclusive\n    */\n   public static void setStart(IteratorSetting is, long start, boolean startInclusive) {\n-    SimpleDateFormat dateParser = initDateParser();\n-    is.addOption(START, dateParser.format(new Date(start)));\n+    is.addOption(START, LONG_PREFIX + Long.toString(start));\n     is.addOption(START_INCL, Boolean.toString(startInclusive));\n   }\n   \n@@ -264,8 +300,7 @@ public static void setStart(IteratorSetting is, long start, boolean startInclusi\n    *          boolean indicating whether the end is inclusive\n    */\n   public static void setEnd(IteratorSetting is, long end, boolean endInclusive) {\n-    SimpleDateFormat dateParser = initDateParser();\n-    is.addOption(END, dateParser.format(new Date(end)));\n+    is.addOption(END, LONG_PREFIX + Long.toString(end));\n     is.addOption(END_INCL, Boolean.toString(endInclusive));\n   }\n }\n",
        "project": "accumulo",
        "linesAdd": 54,
        "jira_id": "776",
        "nb_skipped": 0,
        "commit": "dc9f23d9",
        "nb_failure": 0,
        "linesRem": 19,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 709,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.data.MutationTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/data/Mutation.java b/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\nindex 5b052c3e2..e4e229c71 100644\n--- a/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\n+++ b/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\n@@ -598,7 +598,7 @@ public boolean equals(Object o) {\n \n   @Override\n   public int hashCode() {\n-    return toThrift(false).hashCode();\n+    return serializedSnapshot().hashCode();\n   }\n \n   /**\n",
        "project": "accumulo",
        "linesAdd": 1,
        "jira_id": "4029",
        "nb_skipped": 2,
        "commit": "5ca779a0",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 367,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.file.FileOperationsTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/file/FileOperations.java b/core/src/main/java/org/apache/accumulo/core/file/FileOperations.java\nindex 9f6072563..17e540b70 100644\n--- a/core/src/main/java/org/apache/accumulo/core/file/FileOperations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/file/FileOperations.java\n@@ -44,14 +44,13 @@ private FileOperations findFileFactory(String file) {\n     if (name.startsWith(Constants.MAPFILE_EXTENSION + \"_\")) {\n       return new MapFileOperations();\n     }\n-    \n     String[] sp = name.split(\"\\\\.\");\n     \n-    if (sp.length != 2) {\n+    if (sp.length < 2) {\n       throw new IllegalArgumentException(\"File name \" + name + \" has no extension\");\n     }\n     \n-    String extension = sp[1];\n+    String extension = sp[sp.length - 1];\n     \n     if (extension.equals(Constants.MAPFILE_EXTENSION) || extension.equals(Constants.MAPFILE_EXTENSION + \"_tmp\")) {\n       return new MapFileOperations();\n",
        "project": "accumulo",
        "linesAdd": 2,
        "jira_id": "1518",
        "nb_skipped": 0,
        "commit": "dc95cb69",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 367,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.util.shell.ShellTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\nindex 1a3c51887..4469d5c3d 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\n@@ -78,8 +78,13 @@ public int start() throws IOException {\n     \n     if (execFile != null) {\n       java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n-      while (scanner.hasNextLine())\n+      try {\n+        while (scanner.hasNextLine() && !hasExited()) {\n           execCommand(scanner.nextLine(), true, isVerbose());\n+        }\n+      } finally {\n+        scanner.close();\n+      }\n     } else if (execCommand != null) {\n       for (String command : execCommand.split(\"\\n\")) {\n         execCommand(command, true, isVerbose());\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\nindex ab08c3230..75f7bd00f 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n@@ -447,8 +447,9 @@ public int start() throws IOException {\n     if (execFile != null) {\n       java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n       try {\n-        while (scanner.hasNextLine())\n+        while (scanner.hasNextLine() && !hasExited()) {\n           execCommand(scanner.nextLine(), true, isVerbose());\n+        }\n       } finally {\n         scanner.close();\n       }\n",
        "project": "accumulo",
        "linesAdd": 8,
        "jira_id": "1348",
        "nb_skipped": 0,
        "commit": "6ff92b12",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 49,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.shell.ShellOptionsJCTest"
        ],
        "patch": "diff --git a/shell/src/main/java/org/apache/accumulo/shell/ShellOptionsJC.java b/shell/src/main/java/org/apache/accumulo/shell/ShellOptionsJC.java\nindex 92ea1a5e0..01b7ce385 100644\n--- a/shell/src/main/java/org/apache/accumulo/shell/ShellOptionsJC.java\n+++ b/shell/src/main/java/org/apache/accumulo/shell/ShellOptionsJC.java\n@@ -315,6 +315,11 @@ public ClientConfiguration getClientConfiguration() throws ConfigurationExceptio\n       clientConfig.withZkHosts(siteConf.get(Property.INSTANCE_ZK_HOST));\n     }\n \n+    // If the user provided the hosts, set the ZK for tracing too\n+    if (null != zooKeeperHosts) {\n+      clientConfig.setProperty(ClientProperty.INSTANCE_ZK_HOST, zooKeeperHosts);\n+    }\n+\n     return clientConfig;\n   }\n \n",
        "project": "accumulo",
        "linesAdd": 4,
        "jira_id": "3945",
        "nb_skipped": 0,
        "commit": "36225565",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 6,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.cloudtrace.instrument.TracerTest"
        ],
        "patch": "diff --git a/src/trace/src/main/java/org/apache/accumulo/cloudtrace/instrument/TraceProxy.java b/src/trace/src/main/java/org/apache/accumulo/cloudtrace/instrument/TraceProxy.java\nindex 67c446342..6b71361f9 100644\n--- a/src/trace/src/main/java/org/apache/accumulo/cloudtrace/instrument/TraceProxy.java\n+++ b/src/trace/src/main/java/org/apache/accumulo/cloudtrace/instrument/TraceProxy.java\n@@ -17,11 +17,14 @@\n package org.apache.accumulo.cloudtrace.instrument;\n \n import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.Proxy;\n \n+import org.apache.log4j.Logger;\n+\n public class TraceProxy {\n-  // private static final Logger log = Logger.getLogger(TraceProxy.class);\n+  private static final Logger log = Logger.getLogger(TraceProxy.class);\n \n   static final Sampler ALWAYS = new Sampler() {\n     @Override\n@@ -39,19 +42,29 @@ public boolean next() {\n     InvocationHandler handler = new InvocationHandler() {\n       @Override\n       public Object invoke(Object obj, Method method, Object[] args) throws Throwable {\n-        if (!sampler.next()) {\n-          return method.invoke(instance, args);\n+        Span span = null;\n+        if (sampler.next()) {\n+          span = Trace.on(method.getName());\n         }\n-        Span span = Trace.on(method.getName());\n         try {\n           return method.invoke(instance, args);\n-        } catch (Throwable ex) {\n-          ex.printStackTrace();\n-          throw ex;\n+          // Can throw RuntimeException, Error, or any checked exceptions of the method.\n+        } catch (InvocationTargetException ite) {\n+          Throwable cause = ite.getCause();\n+          if (cause == null) {\n+            // This should never happen, but account for it anyway\n+            log.error(\"Invocation exception during trace with null cause: \", ite);\n+            throw new RuntimeException(ite);\n+          }\n+          throw cause;\n+        } catch (IllegalAccessException e) {\n+          throw new RuntimeException(e);\n         } finally {\n+          if (span != null) {\n             span.stop();\n           }\n         }\n+      }\n     };\n     return (T) Proxy.newProxyInstance(instance.getClass().getClassLoader(), instance.getClass().getInterfaces(), handler);\n   }\n",
        "project": "accumulo",
        "linesAdd": 18,
        "jira_id": "2390",
        "nb_skipped": 0,
        "commit": "28294266",
        "nb_failure": 0,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 24,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.proxy.TestProxyReadWrite"
        ],
        "patch": "diff --git a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\nindex 911d18740..167cecc54 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n@@ -819,7 +819,17 @@ public String createBatchScanner(ByteBuffer login, String tableName, BatchScanOp\n           }\n         }\n         scanner.setRanges(ranges);\n+\n+        if (opts.columns != null) {\n+          for (ScanColumn col : opts.columns) {\n+            if (col.isSetColQualifier())\n+              scanner.fetchColumn(ByteBufferUtil.toText(col.colFamily), ByteBufferUtil.toText(col.colQualifier));\n+            else\n+              scanner.fetchColumnFamily(ByteBufferUtil.toText(col.colFamily));\n+          }\n         }\n+      }\n+\n       UUID uuid = UUID.randomUUID();\n       \n       ScannerPlusIterator spi = new ScannerPlusIterator();\n",
        "project": "accumulo",
        "linesAdd": 10,
        "jira_id": "1183",
        "nb_skipped": 0,
        "commit": "742960f1",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 715,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.util.ByteBufferUtilTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/data/ArrayByteSequence.java b/core/src/main/java/org/apache/accumulo/core/data/ArrayByteSequence.java\nindex d9ddc6702..d04013941 100644\n--- a/core/src/main/java/org/apache/accumulo/core/data/ArrayByteSequence.java\n+++ b/core/src/main/java/org/apache/accumulo/core/data/ArrayByteSequence.java\n@@ -21,6 +21,8 @@\n import java.io.Serializable;\n import java.nio.ByteBuffer;\n \n+import org.apache.accumulo.core.util.ByteBufferUtil;\n+\n public class ArrayByteSequence extends ByteSequence implements Serializable {\n \n   private static final long serialVersionUID = 1L;\n@@ -52,15 +54,14 @@ public ArrayByteSequence(String s) {\n   }\n \n   public ArrayByteSequence(ByteBuffer buffer) {\n-    this.length = buffer.remaining();\n-\n     if (buffer.hasArray()) {\n       this.data = buffer.array();\n-      this.offset = buffer.position();\n+      this.offset = buffer.position() + buffer.arrayOffset();\n+      this.length = buffer.remaining();\n     } else {\n-      this.data = new byte[length];\n       this.offset = 0;\n-      buffer.get(data);\n+      this.data = ByteBufferUtil.toBytes(buffer);\n+      this.length = data.length;\n     }\n   }\n \n@@ -118,6 +119,7 @@ public ByteSequence subSequence(int start, int end) {\n     return copy;\n   }\n \n+  @Override\n   public String toString() {\n     return new String(data, offset, length, UTF_8);\n   }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/ByteBufferUtil.java b/core/src/main/java/org/apache/accumulo/core/util/ByteBufferUtil.java\nindex be5cddf9d..cdde05cda 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/ByteBufferUtil.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/ByteBufferUtil.java\n@@ -31,7 +31,15 @@\n   public static byte[] toBytes(ByteBuffer buffer) {\n     if (buffer == null)\n       return null;\n-    return Arrays.copyOfRange(buffer.array(), buffer.position(), buffer.limit());\n+    if (buffer.hasArray()) {\n+      // did not use buffer.get() because it changes the position\n+      return Arrays.copyOfRange(buffer.array(), buffer.position() + buffer.arrayOffset(), buffer.limit() + buffer.arrayOffset());\n+    } else {\n+      byte[] data = new byte[buffer.remaining()];\n+      // duplicate inorder to avoid changing position\n+      buffer.duplicate().get(data);\n+      return data;\n+    }\n   }\n \n   public static List<ByteBuffer> toByteBuffers(Collection<byte[]> bytesList) {\n@@ -47,23 +55,32 @@\n   public static List<byte[]> toBytesList(Collection<ByteBuffer> bytesList) {\n     if (bytesList == null)\n       return null;\n-    ArrayList<byte[]> result = new ArrayList<byte[]>();\n+    ArrayList<byte[]> result = new ArrayList<byte[]>(bytesList.size());\n     for (ByteBuffer bytes : bytesList) {\n       result.add(toBytes(bytes));\n     }\n     return result;\n   }\n \n-  public static Text toText(ByteBuffer bytes) {\n-    if (bytes == null)\n+  public static Text toText(ByteBuffer byteBuffer) {\n+    if (byteBuffer == null)\n       return null;\n+\n+    if (byteBuffer.hasArray()) {\n       Text result = new Text();\n-    result.set(bytes.array(), bytes.position(), bytes.remaining());\n+      result.set(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining());\n       return result;\n+    } else {\n+      return new Text(toBytes(byteBuffer));\n+    }\n   }\n \n   public static String toString(ByteBuffer bytes) {\n-    return new String(bytes.array(), bytes.position(), bytes.remaining(), UTF_8);\n+    if (bytes.hasArray()) {\n+      return new String(bytes.array(), bytes.arrayOffset() + bytes.position(), bytes.remaining(), UTF_8);\n+    } else {\n+      return new String(toBytes(bytes), UTF_8);\n+    }\n   }\n \n   public static ByteBuffer toByteBuffers(ByteSequence bs) {\n@@ -73,7 +90,6 @@ public static ByteBuffer toByteBuffers(ByteSequence bs) {\n     if (bs.isBackedByArray()) {\n       return ByteBuffer.wrap(bs.getBackingArray(), bs.offset(), bs.length());\n     } else {\n-      // TODO create more efficient impl\n       return ByteBuffer.wrap(bs.toArray());\n     }\n   }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/UnsynchronizedBuffer.java b/core/src/main/java/org/apache/accumulo/core/util/UnsynchronizedBuffer.java\nindex f35361384..b77655306 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/UnsynchronizedBuffer.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/UnsynchronizedBuffer.java\n@@ -122,8 +122,8 @@ public Reader(ByteBuffer buffer) {\n         offset = buffer.arrayOffset() + buffer.position();\n         data = buffer.array();\n       } else {\n-        data = new byte[buffer.remaining()];\n-        buffer.get(data);\n+        offset = 0;\n+        data = ByteBufferUtil.toBytes(buffer);\n       }\n     }\n \n",
        "project": "accumulo",
        "linesAdd": 30,
        "jira_id": "4113",
        "nb_skipped": 2,
        "commit": "27300d81",
        "nb_failure": 1,
        "linesRem": 13,
        "singleLine": false
    },
    {
        "files": 6,
        "nb_test": 79,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.server.client.BulkImporterTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java b/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java\nindex 4f95e1a6c..83283ac18 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java\n@@ -65,7 +65,6 @@\n   MASTER_RECOVERY_POOL(\"master.recovery.pool\", \"recovery\", PropertyType.STRING, \"Priority queue to use for log recovery map/reduce jobs.\"),\n   MASTER_RECOVERY_SORT_MAPREDUCE(\"master.recovery.sort.mapreduce\", \"false\", PropertyType.BOOLEAN,\n       \"If true, use map/reduce to sort write-ahead logs during recovery\"),\n-  MASTER_BULK_SERVERS(\"master.bulk.server.max\", \"4\", PropertyType.COUNT, \"The number of servers to use during a bulk load\"),\n   MASTER_BULK_RETRIES(\"master.bulk.retries\", \"3\", PropertyType.COUNT, \"The number of attempts to bulk-load a file before giving up.\"),\n   MASTER_BULK_THREADPOOL_SIZE(\"master.bulk.threadpool.size\", \"5\", PropertyType.COUNT, \"The number of threads to use when coordinating a bulk-import.\"),\n   MASTER_MINTHREADS(\"master.server.threads.minimum\", \"2\", PropertyType.COUNT, \"The minimum number of threads to use to handle incoming requests.\"),\ndiff --git a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java\nindex 5e82a7d1e..bb4ae64e3 100644\n--- a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java\n+++ b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java\n@@ -42,14 +42,13 @@\n import org.apache.hadoop.conf.Configuration;\n import org.apache.hadoop.io.Text;\n import org.apache.hadoop.mapreduce.Mapper;\n-import org.apache.log4j.Logger;\n \n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Multimap;\n \n public class WikipediaPartitionedMapper extends Mapper<Text,Article,Text,Mutation> {\n   \n-  private static final Logger log = Logger.getLogger(WikipediaPartitionedMapper.class);\n+  // private static final Logger log = Logger.getLogger(WikipediaPartitionedMapper.class);\n   \n   public final static Charset UTF8 = Charset.forName(\"UTF-8\");\n   public static final String DOCUMENT_COLUMN_FAMILY = \"d\";\ndiff --git a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java\nindex 82af9fd52..3507108b3 100644\n--- a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java\n+++ b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java\n@@ -23,40 +23,21 @@\n import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStreamReader;\n-import java.io.StringReader;\n import java.nio.charset.Charset;\n-import java.util.HashSet;\n-import java.util.IllegalFormatException;\n-import java.util.Map.Entry;\n-import java.util.Set;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-import org.apache.accumulo.core.data.Mutation;\n-import org.apache.accumulo.core.data.Value;\n-import org.apache.accumulo.core.security.ColumnVisibility;\n import org.apache.accumulo.examples.wikisearch.ingest.ArticleExtractor.Article;\n import org.apache.accumulo.examples.wikisearch.ingest.WikipediaInputFormat.WikipediaInputSplit;\n-import org.apache.accumulo.examples.wikisearch.normalizer.LcNoDiacriticsNormalizer;\n-import org.apache.accumulo.examples.wikisearch.protobuf.Uid;\n-import org.apache.accumulo.examples.wikisearch.protobuf.Uid.List.Builder;\n-import org.apache.commons.codec.binary.Base64;\n-import org.apache.commons.lang.StringUtils;\n import org.apache.hadoop.conf.Configuration;\n import org.apache.hadoop.io.LongWritable;\n import org.apache.hadoop.io.Text;\n import org.apache.hadoop.mapreduce.Mapper;\n import org.apache.hadoop.mapreduce.lib.input.FileSplit;\n-import org.apache.log4j.Logger;\n-import org.apache.lucene.analysis.tokenattributes.TermAttribute;\n-import org.apache.lucene.wikipedia.analysis.WikipediaTokenizer;\n-\n-import com.google.common.collect.HashMultimap;\n-import com.google.common.collect.Multimap;\n \n public class WikipediaPartitioner extends Mapper<LongWritable,Text,Text,Article> {\n   \n-  private static final Logger log = Logger.getLogger(WikipediaPartitioner.class);\n+  // private static final Logger log = Logger.getLogger(WikipediaPartitioner.class);\n   \n   public final static Charset UTF8 = Charset.forName(\"UTF-8\");\n   public static final String DOCUMENT_COLUMN_FAMILY = \"d\";\ndiff --git a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java\nindex d8c57c2f9..2738e2c0b 100644\n--- a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java\n+++ b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java\n@@ -4,20 +4,18 @@\n \n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n import org.apache.accumulo.core.data.Mutation;\n-import org.apache.accumulo.examples.wikisearch.ingest.WikipediaMapper;\n import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.io.Text;\n import org.apache.hadoop.mapreduce.JobContext;\n import org.apache.hadoop.mapreduce.OutputCommitter;\n import org.apache.hadoop.mapreduce.OutputFormat;\n import org.apache.hadoop.mapreduce.RecordWriter;\n import org.apache.hadoop.mapreduce.TaskAttemptContext;\n-import org.apache.hadoop.fs.FileSystem;\n-import org.apache.hadoop.io.Text;\n-import org.apache.log4j.Logger;\n \n public class SortingRFileOutputFormat extends OutputFormat<Text,Mutation> {\n \n-  private static final Logger log = Logger.getLogger(SortingRFileOutputFormat.class);\n+  // private static final Logger log = Logger.getLogger(SortingRFileOutputFormat.class);\n \n   public static final String PATH_NAME = \"sortingrfileoutputformat.path\";\n   public static final String MAX_BUFFER_SIZE = \"sortingrfileoutputformat.max.buffer.size\";\ndiff --git a/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java b/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java\nindex 071b8bd26..4ee5371f2 100644\n--- a/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java\n+++ b/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java\n@@ -38,8 +38,8 @@\n import org.apache.accumulo.core.client.Instance;\n import org.apache.accumulo.core.client.impl.ServerClient;\n import org.apache.accumulo.core.client.impl.TabletLocator;\n-import org.apache.accumulo.core.client.impl.Translator;\n import org.apache.accumulo.core.client.impl.TabletLocator.TabletLocation;\n+import org.apache.accumulo.core.client.impl.Translator;\n import org.apache.accumulo.core.client.impl.thrift.ClientService;\n import org.apache.accumulo.core.client.impl.thrift.ThriftTableOperationException;\n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n@@ -150,7 +150,7 @@ public void run() {\n             } catch (Exception ex) {\n               log.warn(\"Unable to find tablets that overlap file \" + mapFile.toString());\n             }\n-            \n+            log.debug(\"Map file \" + mapFile + \" found to overlap \" + tabletsToAssignMapFileTo.size() + \" tablets\");\n             if (tabletsToAssignMapFileTo.size() == 0) {\n               List<KeyExtent> empty = Collections.emptyList();\n               completeFailures.put(mapFile, empty);\n@@ -652,33 +652,41 @@ public String toString() {\n     return findOverlappingTablets(acuConf, fs, locator, file, start, failed.getEndRow());\n   }\n   \n+  final static byte[] byte0 = {0};\n+\n   public static List<TabletLocation> findOverlappingTablets(AccumuloConfiguration acuConf, FileSystem fs, TabletLocator locator, Path file, Text startRow,\n       Text endRow) throws Exception {\n     List<TabletLocation> result = new ArrayList<TabletLocation>();\n-    \n     Collection<ByteSequence> columnFamilies = Collections.emptyList();\n-    \n-    FileSKVIterator reader = FileOperations.getInstance().openReader(file.toString(), true, fs, fs.getConf(), acuConf);\n+    String filename = file.toString();\n+    // log.debug(filename + \" finding overlapping tablets \" + startRow + \" -> \" + endRow);\n+    FileSKVIterator reader = FileOperations.getInstance().openReader(filename, true, fs, fs.getConf(), acuConf);\n     try {\n       Text row = startRow;\n       if (row == null)\n         row = new Text();\n       while (true) {\n+        // log.debug(filename + \" Seeking to row \" + row);\n         reader.seek(new Range(row, null), columnFamilies, false);\n-        if (!reader.hasTop())\n+        if (!reader.hasTop()) {\n+          // log.debug(filename + \" not found\");\n           break;\n+        }\n         row = reader.getTopKey().getRow();\n         TabletLocation tabletLocation = locator.locateTablet(row, false, true);\n+        // log.debug(filename + \" found row \" + row + \" at location \" + tabletLocation);\n         result.add(tabletLocation);\n         row = tabletLocation.tablet_extent.getEndRow();\n-        if (row != null && (endRow == null || row.compareTo(endRow) < 0))\n-          row = Range.followingPrefix(row);\n-        else\n+        if (row != null && (endRow == null || row.compareTo(endRow) < 0)) {\n+          row = new Text(row);\n+          row.append(byte0, 0, byte0.length);\n+        } else\n           break;\n       }\n     } finally {\n       reader.close();\n     }\n+    // log.debug(filename + \" to be sent to \" + result);\n     return result;\n   }\n   \ndiff --git a/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java b/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java\nindex c4a3f5091..05c353dae 100644\n--- a/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java\n+++ b/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java\n@@ -19,11 +19,15 @@\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n import java.util.concurrent.LinkedBlockingQueue;\n@@ -41,12 +45,13 @@\n import org.apache.accumulo.core.client.impl.thrift.TableOperationExceptionType;\n import org.apache.accumulo.core.client.impl.thrift.ThriftTableOperationException;\n import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.conf.SiteConfiguration;\n import org.apache.accumulo.core.file.FileOperations;\n import org.apache.accumulo.core.master.state.tables.TableState;\n import org.apache.accumulo.core.security.thrift.AuthInfo;\n import org.apache.accumulo.core.util.CachedConfiguration;\n import org.apache.accumulo.core.util.Daemon;\n-import org.apache.accumulo.core.util.LoggingRunnable;\n+import org.apache.accumulo.core.util.ThriftUtil;\n import org.apache.accumulo.core.util.UtilWaitThread;\n import org.apache.accumulo.server.ServerConstants;\n import org.apache.accumulo.server.client.HdfsZooInstance;\n@@ -370,7 +375,7 @@ public LoadFiles(String tableId, String source, String bulk, String errorDir, bo\n   \n   @Override\n   public Repo<Master> call(final long tid, Master master) throws Exception {\n-    \n+    final SiteConfiguration conf = ServerConfiguration.getSiteConfiguration();\n     FileSystem fs = TraceFileSystem.wrap(org.apache.accumulo.core.file.FileUtil.getFileSystem(CachedConfiguration.getInstance(),\n         ServerConfiguration.getSiteConfiguration()));\n     List<FileStatus> files = new ArrayList<FileStatus>();\n@@ -389,42 +394,68 @@ public LoadFiles(String tableId, String source, String bulk, String errorDir, bo\n     }\n     fs.delete(writable, false);\n     \n-    // group files into N-sized chunks, send the chunks to random servers\n-    final int SERVERS_TO_USE = Math.min(ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_SERVERS), master.onlineTabletServers()\n-        .size());\n-    \n-    log.debug(\"tid \" + tid + \" using \" + SERVERS_TO_USE + \" servers\");\n-    // wait for success, repeat failures R times\n     final List<String> filesToLoad = Collections.synchronizedList(new ArrayList<String>());\n     for (FileStatus f : files)\n       filesToLoad.add(f.getPath().toString());\n     \n-    final int RETRIES = Math.max(1, ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_RETRIES));\n-    for (int i = 0; i < RETRIES && filesToLoad.size() > 0; i++) {\n-      List<Future<?>> results = new ArrayList<Future<?>>();\n-      for (List<String> chunk : groupFiles(filesToLoad, SERVERS_TO_USE)) {\n-        final List<String> attempt = chunk;\n-        results.add(threadPool.submit(new LoggingRunnable(log, new Runnable() {\n+\n+    final int RETRIES = Math.max(1, conf.getCount(Property.MASTER_BULK_RETRIES));\n+    for (int attempt = 0; attempt < RETRIES && filesToLoad.size() > 0; attempt++) {\n+      List<Future<List<String>>> results = new ArrayList<Future<List<String>>>();\n+      \n+      // Figure out which files will be sent to which server\n+      Set<TServerInstance> currentServers = Collections.synchronizedSet(new HashSet<TServerInstance>(master.onlineTabletServers()));\n+      Map<String,List<String>> loadAssignments = new HashMap<String,List<String>>();\n+      for (TServerInstance server : currentServers) {\n+        loadAssignments.put(server.hostPort(), new ArrayList<String>());\n+      }\n+      int i = 0;\n+      List<Entry<String,List<String>>> entries = new ArrayList<Entry<String,List<String>>>(loadAssignments.entrySet());\n+      for (String file : filesToLoad) {\n+        entries.get(i % entries.size()).getValue().add(file);\n+        i++;\n+      }\n+      \n+      // Use the threadpool to assign files one-at-a-time to the server\n+      for (Entry<String,List<String>> entry : entries) {\n+        if (entry.getValue().isEmpty()) {\n+          continue;\n+        }\n+        final Entry<String,List<String>> finalEntry = entry;\n+        results.add(threadPool.submit(new Callable<List<String>>() {\n           @Override\n-          public void run() {\n+          public List<String> call() {\n+            if (log.isDebugEnabled()) {\n+              log.debug(\"Asking \" + finalEntry.getKey() + \" to load \" + sampleList(finalEntry.getValue(), 10));\n+            }\n+            List<String> failures = new ArrayList<String>();\n             ClientService.Iface client = null;\n             try {\n-              client = ServerClient.getConnection(HdfsZooInstance.getInstance());\n+              client = ThriftUtil.getTServerClient(finalEntry.getKey(), conf);\n+              for (String file : finalEntry.getValue()) {\n+                List<String> attempt = Collections.singletonList(file);\n+                log.debug(\"Asking \" + finalEntry.getKey() + \" to bulk import \" + file);\n                 List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);\n-              attempt.removeAll(fail);\n-              filesToLoad.removeAll(attempt);\n+                if (fail.isEmpty()) {\n+                  filesToLoad.remove(file);\n+                } else {\n+                  failures.addAll(fail);\n+                }\n+              }\n             } catch (Exception ex) {\n               log.error(ex, ex);\n             } finally {\n               ServerClient.close(client);\n             }\n+            return failures;\n           }\n-        })));\n+        }));\n       }\n-      for (Future<?> f : results)\n-        f.get();\n+      Set<String> failures = new HashSet<String>();\n+      for (Future<List<String>> f : results)\n+        failures.addAll(f.get());\n       if (filesToLoad.size() > 0) {\n-        log.debug(\"tid \" + tid + \" attempt \" + (i + 1) + \" \" + filesToLoad + \" failed\");\n+        log.debug(\"tid \" + tid + \" attempt \" + (i + 1) + \" \" + sampleList(filesToLoad, 10) + \" failed\");\n         UtilWaitThread.sleep(100);\n       }\n     }\n@@ -449,16 +480,24 @@ public void run() {\n     return new CompleteBulkImport(tableId, source, bulk, errorDir);\n   }\n   \n-  private List<List<String>> groupFiles(List<String> files, int groups) {\n-    List<List<String>> result = new ArrayList<List<String>>();\n-    Iterator<String> iter = files.iterator();\n-    for (int i = 0; i < groups && iter.hasNext(); i++) {\n-      List<String> group = new ArrayList<String>();\n-      for (int j = 0; j < Math.ceil(files.size() / (double) groups) && iter.hasNext(); j++) {\n-        group.add(iter.next());\n+  static String sampleList(Collection<?> potentiallyLongList, int max) {\n+    StringBuffer result = new StringBuffer();\n+    result.append(\"[\");\n+    int i = 0;\n+    for (Object obj : potentiallyLongList) {\n+      result.append(obj);\n+      if (i >= max) {\n+        result.append(\"...\");\n+        break;\n+      } else {\n+        result.append(\", \");\n       }\n-      result.add(group);\n+      i++;\n     }\n-    return result;\n+    if (i < max)\n+      result.delete(result.length() - 2, result.length());\n+    result.append(\"]\");\n+    return result.toString();\n   }\n+\n }\n",
        "project": "accumulo",
        "linesAdd": 83,
        "jira_id": "412",
        "nb_skipped": 0,
        "commit": "5594b2e0",
        "nb_failure": 1,
        "linesRem": 67,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 634,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.security.crypto.BlockedIOStreamTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/security/crypto/BlockedOutputStream.java b/core/src/main/java/org/apache/accumulo/core/security/crypto/BlockedOutputStream.java\nindex ca72055cc..3ce648e86 100644\n--- a/core/src/main/java/org/apache/accumulo/core/security/crypto/BlockedOutputStream.java\n+++ b/core/src/main/java/org/apache/accumulo/core/security/crypto/BlockedOutputStream.java\n@@ -72,15 +72,18 @@ public void write(int b) throws IOException {\n \n   @Override\n   public void write(byte b[], int off, int len) throws IOException {\n-    if (bb.remaining() >= len) {\n-      bb.put(b, off, len);\n-      if (bb.remaining() == 0)\n-        flush();\n-    } else {\n+    // Can't recurse here in case the len is large and the blocksize is small (and the stack is small)\n+    // So we'll just fill up the buffer over and over\n+    while (len >= bb.remaining()) {\n       int remaining = bb.remaining();\n-      write(b, off, remaining);\n-      write(b, off + remaining, len - remaining);\n+      bb.put(b, off, remaining);\n+      // This is guaranteed to have the buffer filled, so we'll just flush it. No check needed\n+      flush();\n+      off += remaining;\n+      len -= remaining;\n     }\n+    // And then write the remainder (and this is guaranteed to not fill the buffer, so we won't flush afteward\n+    bb.put(b, off, len);\n   }\n \n   @Override\n",
        "project": "accumulo",
        "linesAdd": 6,
        "jira_id": "2671",
        "nb_skipped": 1,
        "commit": "17344890",
        "nb_failure": 0,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 635,
        "nb_error": 0,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.accumulo.core.file.rfile.RFileTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/security/crypto/CryptoModuleFactory.java b/core/src/main/java/org/apache/accumulo/core/security/crypto/CryptoModuleFactory.java\nindex 649bfc80a..4d04125a5 100644\n--- a/core/src/main/java/org/apache/accumulo/core/security/crypto/CryptoModuleFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/security/crypto/CryptoModuleFactory.java\n@@ -258,6 +258,7 @@ public static CryptoModuleParameters fillParamsObjectFromConfiguration(CryptoMod\n     // Get all the options from the configuration\n     Map<String,String> cryptoOpts = conf.getAllPropertiesWithPrefix(Property.CRYPTO_PREFIX);\n     cryptoOpts.putAll(conf.getAllPropertiesWithPrefix(Property.INSTANCE_PREFIX));\n+    cryptoOpts.remove(Property.INSTANCE_SECRET.getKey());\n     cryptoOpts.put(Property.CRYPTO_BLOCK_STREAM_SIZE.getKey(), Integer.toString((int) conf.getMemoryInBytes(Property.CRYPTO_BLOCK_STREAM_SIZE)));\n \n     return fillParamsObjectFromStringMap(params, cryptoOpts);\n",
        "project": "accumulo",
        "linesAdd": 1,
        "jira_id": "2713",
        "nb_skipped": 1,
        "commit": "6138a80f",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 2,
        "nb_test": 362,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.util.shell.ShellTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\nindex 1a3c51887..4469d5c3d 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\n@@ -78,8 +78,13 @@ public int start() throws IOException {\n     \n     if (execFile != null) {\n       java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n-      while (scanner.hasNextLine())\n+      try {\n+        while (scanner.hasNextLine() && !hasExited()) {\n           execCommand(scanner.nextLine(), true, isVerbose());\n+        }\n+      } finally {\n+        scanner.close();\n+      }\n     } else if (execCommand != null) {\n       for (String command : execCommand.split(\"\\n\")) {\n         execCommand(command, true, isVerbose());\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\nindex abb324ee1..7efe5e607 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n@@ -438,8 +438,13 @@ public int start() throws IOException {\n     \n     if (execFile != null) {\n       java.util.Scanner scanner = new java.util.Scanner(new File(execFile));\n-      while (scanner.hasNextLine())\n+      try {\n+        while (scanner.hasNextLine() && !hasExited()) {\n           execCommand(scanner.nextLine(), true, isVerbose());\n+        }\n+      } finally {\n+        scanner.close();\n+      }\n     } else if (execCommand != null) {\n       for (String command : execCommand.split(\"\\n\")) {\n         execCommand(command, true, isVerbose());\n",
        "project": "accumulo",
        "linesAdd": 12,
        "jira_id": "1348",
        "nb_skipped": 0,
        "commit": "ef0f6ddc",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 5,
        "nb_test": 722,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.util.shell.commands.CompactCommandTest",
            "org.apache.accumulo.core.util.shell.commands.MergeCommandTest",
            "org.apache.accumulo.core.util.shell.commands.DeleteRowsCommandTest",
            "org.apache.accumulo.core.util.shell.commands.FlushCommandTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperations.java b/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperations.java\nindex 536d6e667..bcad3a30f 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperations.java\n@@ -260,7 +260,7 @@ Text getMaxRow(String tableName, Authorizations auths, Text startRow, boolean st\n    * @param start\n    *          first tablet to be compacted contains the row after this row, null means the first tablet in table\n    * @param end\n-   *          last tablet to be merged contains this row, null means the last tablet in table\n+   *          last tablet to be compacted contains this row, null means the last tablet in table\n    * @param flush\n    *          when true, table memory is flushed before compaction starts\n    * @param wait\n@@ -276,7 +276,7 @@ Text getMaxRow(String tableName, Authorizations auths, Text startRow, boolean st\n    * @param start\n    *          first tablet to be compacted contains the row after this row, null means the first tablet in table\n    * @param end\n-   *          last tablet to be merged contains this row, null means the last tablet in table\n+   *          last tablet to be compacted contains this row, null means the last tablet in table\n    * @param iterators\n    *          A set of iterators that will be applied to each tablet compacted\n    * @param flush\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/DeleteRowsCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/DeleteRowsCommand.java\nindex 64968f05e..6ffa3f40e 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/DeleteRowsCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/DeleteRowsCommand.java\n@@ -54,9 +54,7 @@ public int numArgs() {\n   public Options getOptions() {\n     final Options o = new Options();\n     forceOpt = new Option(\"f\", \"force\", false, \"delete data even if start or end are not specified\");\n-    startRowOptExclusive = new Option(OptUtil.START_ROW_OPT, \"begin-row\", true, \"begin row (exclusive)\");\n-    startRowOptExclusive.setArgName(\"begin-row\");\n-    o.addOption(startRowOptExclusive);\n+    o.addOption(OptUtil.startRowOpt());\n     o.addOption(OptUtil.endRowOpt());\n     o.addOption(OptUtil.tableOpt(\"table to delete a row range from\"));\n     o.addOption(forceOpt);\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/MergeCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/MergeCommand.java\nindex 9213a06c8..18d519d36 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/MergeCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/MergeCommand.java\n@@ -96,9 +96,7 @@ public Options getOptions() {\n     sizeOpt = new Option(\"s\", \"size\", true, \"merge tablets to the given size over the entire table\");\n     forceOpt = new Option(\"f\", \"force\", false, \"merge small tablets to large tablets, even if it goes over the given size\");\n     allOpt = new Option(\"\", \"all\", false, \"allow an entire table to be merged into one tablet without prompting the user for confirmation\");\n-    Option startRowOpt = OptUtil.startRowOpt();\n-    startRowOpt.setDescription(\"begin row (NOT inclusive)\");\n-    o.addOption(startRowOpt);\n+    o.addOption(OptUtil.startRowOpt());\n     o.addOption(OptUtil.endRowOpt());\n     o.addOption(OptUtil.tableOpt(\"table to be merged\"));\n     o.addOption(verboseOpt);\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\nindex 9915bdf57..432f17a38 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\n@@ -117,7 +117,7 @@ public static OptionGroup addListDeleteGroup(final String name) {\n   }\n \n   public static Option startRowOpt() {\n-    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (inclusive)\");\n+    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (NOT) inclusive\");\n     o.setArgName(\"begin-row\");\n     return o;\n   }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/ScanCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/ScanCommand.java\nindex 9a0026af1..60ae0a7cc 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/ScanCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/ScanCommand.java\n@@ -57,6 +57,7 @@\n \n   protected Option timestampOpt;\n   private Option optStartRowExclusive;\n+  private Option optStartRowInclusive;\n   private Option optEndRowExclusive;\n   private Option timeoutOption;\n   private Option profileOpt;\n@@ -318,7 +319,9 @@ public Options getOptions() {\n \n     o.addOption(scanOptAuths);\n     o.addOption(scanOptRow);\n-    o.addOption(OptUtil.startRowOpt());\n+    optStartRowInclusive = new Option(OptUtil.START_ROW_OPT, \"begin-row\", true, \"begin row (inclusive)\");\n+    optStartRowInclusive.setArgName(\"begin-row\");\n+    o.addOption(optStartRowInclusive);\n     o.addOption(OptUtil.endRowOpt());\n     o.addOption(optStartRowExclusive);\n     o.addOption(optEndRowExclusive);\n",
        "project": "accumulo",
        "linesAdd": 7,
        "jira_id": "4138",
        "nb_skipped": 2,
        "commit": "50db442b",
        "nb_failure": 4,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 367,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.util.shell.ShellTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/TableDiskUsage.java b/core/src/main/java/org/apache/accumulo/core/util/TableDiskUsage.java\nindex 64d5970e7..6a61c50f4 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/TableDiskUsage.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/TableDiskUsage.java\n@@ -144,12 +144,17 @@ public static void printDiskUsage(AccumuloConfiguration acuConf, Collection<Stri\n       tdu.addTable(tableId);\n     \n     HashSet<String> tablesReferenced = new HashSet<String>(tableIds);\n+    HashSet<String> emptyTableIds = new HashSet<String>();\n     \n     for (String tableId : tableIds) {\n       Scanner mdScanner = conn.createScanner(Constants.METADATA_TABLE_NAME, Constants.NO_AUTHS);\n       mdScanner.fetchColumnFamily(Constants.METADATA_DATAFILE_COLUMN_FAMILY);\n       mdScanner.setRange(new KeyExtent(new Text(tableId), null, null).toMetadataRange());\n       \n+      if(!mdScanner.iterator().hasNext()) {\n+        emptyTableIds.add(tableId);\n+      }\n+      \n       for (Entry<Key,Value> entry : mdScanner) {\n         String file = entry.getKey().getColumnQualifier().toString();\n         if (file.startsWith(\"../\")) {\n@@ -216,6 +221,14 @@ public int compare(TreeSet<String> o1, TreeSet<String> o2) {\n       usage.put(tableNames, entry.getValue());\n     }\n \n+    if(!emptyTableIds.isEmpty()) {\n+      TreeSet<String> emptyTables = new TreeSet<String>();\n+      for (String tableId : emptyTableIds) {\n+        emptyTables.add(reverseTableIdMap.get(tableId));\n+      }\n+      usage.put(emptyTables, 0L);\n+    }\n+    \n     for (Entry<TreeSet<String>,Long> entry : usage.entrySet())\n       printer.print(String.format(\"%,24d %s\", entry.getValue(), entry.getKey()));\n     \n",
        "project": "accumulo",
        "linesAdd": 13,
        "jira_id": "1192",
        "nb_skipped": 0,
        "commit": "c489d866",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 391,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mock.MockConnectorTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchWriter.java\nindex b33ebcb74..d89a2631c 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchWriter.java\n@@ -19,6 +19,7 @@\n import org.apache.accumulo.core.client.BatchWriter;\n import org.apache.accumulo.core.client.MutationsRejectedException;\n import org.apache.accumulo.core.data.Mutation;\n+import org.apache.accumulo.core.util.ArgumentChecker;\n \n public class MockBatchWriter implements BatchWriter {\n   \n@@ -32,11 +33,13 @@\n   \n   @Override\n   public void addMutation(Mutation m) throws MutationsRejectedException {\n+    ArgumentChecker.notNull(m);\n     acu.addMutation(tablename, m);\n   }\n   \n   @Override\n   public void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {\n+    ArgumentChecker.notNull(iterable);\n     for (Mutation m : iterable) {\n       acu.addMutation(tablename, m);\n     }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\nindex 6d6d53495..3dcab11bd 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n@@ -101,6 +101,8 @@ public int compareTo(Key o) {\n   }\n   \n   synchronized void addMutation(Mutation m) {\n+    if (m.size() == 0)\n+      throw new IllegalArgumentException(\"Can not add empty mutations\");\n     long now = System.currentTimeMillis();\n     mutationCount++;\n     for (ColumnUpdate u : m.getUpdates()) {\n",
        "project": "accumulo",
        "linesAdd": 5,
        "jira_id": "1505",
        "nb_skipped": 0,
        "commit": "994df698",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 702,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.ZooKeeperInstanceTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/ClientConfiguration.java b/core/src/main/java/org/apache/accumulo/core/client/ClientConfiguration.java\nindex b64fab4b7..17ad10b8f 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/ClientConfiguration.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/ClientConfiguration.java\n@@ -107,6 +107,8 @@ public static ClientProperty getPropertyByKey(String key) {\n \n   public ClientConfiguration(List<? extends Configuration> configs) {\n     super(configs);\n+    // Don't do list interpolation\n+    this.setListDelimiter('\\0');\n   }\n \n   /**\n",
        "project": "accumulo",
        "linesAdd": 1,
        "jira_id": "3218",
        "nb_skipped": 1,
        "commit": "1b35d263",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 2,
        "nb_test": 285,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mock.MockTableOperationsTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsHelper.java b/src/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsHelper.java\nindex b533beb04..dfb75baa2 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsHelper.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsHelper.java\n@@ -48,6 +48,8 @@ public void attachIterator(String tableName, IteratorSetting setting) throws Acc\n   @Override\n   public void removeIterator(String tableName, String name, EnumSet<IteratorScope> scopes) throws AccumuloSecurityException, AccumuloException,\n       TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(null, tableName, null);\n     Map<String,String> copy = new HashMap<String,String>();\n     for (Entry<String,String> property : this.getProperties(tableName)) {\n       copy.put(property.getKey(), property.getValue());\n@@ -64,6 +66,8 @@ public void removeIterator(String tableName, String name, EnumSet<IteratorScope>\n   @Override\n   public IteratorSetting getIteratorSetting(String tableName, String name, IteratorScope scope) throws AccumuloSecurityException, AccumuloException,\n       TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(null, tableName, null);\n     int priority = -1;\n     String classname = null;\n     Map<String,String> settings = new HashMap<String,String>();\n@@ -90,6 +94,8 @@ public IteratorSetting getIteratorSetting(String tableName, String name, Iterato\n   \n   @Override\n   public Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(null, tableName, null);\n     Set<String> result = new HashSet<String>();\n     Set<String> lifecycles = new HashSet<String>();\n     for (IteratorScope scope : IteratorScope.values())\n@@ -107,6 +113,8 @@ public IteratorSetting getIteratorSetting(String tableName, String name, Iterato\n   \n   @Override\n   public void checkIteratorConflicts(String tableName, IteratorSetting setting) throws AccumuloException, TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(null, tableName, null);\n     for (IteratorScope scope : setting.getScopes()) {\n       String scopeStr = String.format(\"%s%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase());\n       String nameStr = String.format(\"%s.%s\", scopeStr, setting.getName());\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java b/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\nindex 4353ab17d..f2f32dfe5 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n@@ -82,6 +82,8 @@ public void create(String tableName, boolean versioningIter, TimeType timeType)\n     if (!tableName.matches(Constants.VALID_TABLE_NAME_REGEX)) {\n       throw new IllegalArgumentException();\n     }\n+    if (exists(tableName))\n+      throw new TableExistsException(tableName, tableName, \"\");\n     acu.createTable(username, tableName, versioningIter, timeType);\n   }\n   \n@@ -91,30 +93,42 @@ public void create(String tableName, boolean versioningIter, TimeType timeType)\n   @Override\n   public void addAggregators(String tableName, List<? extends PerColumnIteratorConfig> aggregators) throws AccumuloSecurityException, TableNotFoundException,\n       AccumuloException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     acu.addAggregators(tableName, aggregators);\n   }\n   \n   @Override\n-  public void addSplits(String tableName, SortedSet<Text> partitionKeys) throws TableNotFoundException, AccumuloException, AccumuloSecurityException {}\n+  public void addSplits(String tableName, SortedSet<Text> partitionKeys) throws TableNotFoundException, AccumuloException, AccumuloSecurityException {\n+    throw new NotImplementedException();\n+  }\n   \n   @Override\n-  public Collection<Text> getSplits(String tableName) {\n+  public Collection<Text> getSplits(String tableName) throws TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     return Collections.emptyList();\n   }\n   \n   @Override\n-  public Collection<Text> getSplits(String tableName, int maxSplits) {\n-    return Collections.emptyList();\n+  public Collection<Text> getSplits(String tableName, int maxSplits) throws TableNotFoundException {\n+    return getSplits(tableName);\n   }\n   \n   @Override\n   public void delete(String tableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     acu.tables.remove(tableName);\n   }\n   \n   @Override\n   public void rename(String oldTableName, String newTableName) throws AccumuloSecurityException, TableNotFoundException, AccumuloException,\n       TableExistsException {\n+    if (!exists(oldTableName))\n+      throw new TableNotFoundException(oldTableName, oldTableName, \"\");\n+    if (exists(newTableName))\n+      throw new TableExistsException(newTableName, newTableName, \"\");\n     MockTable t = acu.tables.remove(oldTableName);\n     acu.tables.put(newTableName, t);\n   }\n@@ -134,15 +148,19 @@ public void removeProperty(String tableName, String property) throws AccumuloExc\n   \n   @Override\n   public Iterable<Entry<String,String>> getProperties(String tableName) throws TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     return acu.tables.get(tableName).settings.entrySet();\n   }\n   \n   @Override\n-  public void setLocalityGroups(String tableName, Map<String,Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {}\n+  public void setLocalityGroups(String tableName, Map<String,Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n+    throw new NotImplementedException();\n+  }\n   \n   @Override\n   public Map<String,Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {\n-    return null;\n+    throw new NotImplementedException();\n   }\n   \n   @Override\n@@ -164,13 +182,17 @@ public void importDirectory(String tableName, String dir, String failureDir, boo\n   }\n   \n   @Override\n-  public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {}\n+  public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {\n+    throw new NotImplementedException();\n+  }\n   \n   @Override\n   public void online(String tableName) throws AccumuloSecurityException, AccumuloException {}\n   \n   @Override\n-  public void clearLocatorCache(String tableName) throws TableNotFoundException {}\n+  public void clearLocatorCache(String tableName) throws TableNotFoundException {\n+    throw new NotImplementedException();\n+  }\n   \n   @Override\n   public Map<String,String> tableIdMap() {\n",
        "project": "accumulo",
        "linesAdd": 38,
        "jira_id": "217",
        "nb_skipped": 0,
        "commit": "add180fb",
        "nb_failure": 0,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 510,
        "nb_error": 16,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mapred.AccumuloFileOutputFormatTest",
            "org.apache.accumulo.core.client.mapreduce.AccumuloOutputFormatTest",
            "org.apache.accumulo.core.client.mapred.AccumuloRowInputFormatTest",
            "org.apache.accumulo.core.client.mapreduce.AccumuloMultiTableInputFormatTest",
            "org.apache.accumulo.core.client.mapred.AccumuloInputFormatTest",
            "org.apache.accumulo.core.client.mapred.TokenFileTest",
            "org.apache.accumulo.core.client.mapred.AccumuloOutputFormatTest",
            "org.apache.accumulo.core.client.mapreduce.TokenFileTest",
            "org.apache.accumulo.core.client.mapreduce.AccumuloFileOutputFormatTest",
            "org.apache.accumulo.core.client.mapreduce.AccumuloInputFormatTest",
            "org.apache.accumulo.core.client.mapreduce.AccumuloRowInputFormatTest",
            "org.apache.accumulo.core.client.mapred.AccumuloMultiTableInputFormatTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mapred/AbstractInputFormat.java b/core/src/main/java/org/apache/accumulo/core/client/mapred/AbstractInputFormat.java\nindex c89c5d735..eaf99cbea 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mapred/AbstractInputFormat.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mapred/AbstractInputFormat.java\n@@ -371,6 +371,8 @@ public void initialize(InputSplit inSplit, JobConf job) throws IOException {\n         log.debug(\"Authorizations are: \" + authorizations);\n         if (tableConfig.isOfflineScan()) {\n           scanner = new OfflineScanner(instance, new Credentials(principal, token), split.getTableId(), authorizations);\n+        } else if (instance instanceof MockInstance) {\n+          scanner = instance.getConnector(principal, token).createScanner(split.getTableName(), authorizations);\n         } else {\n           scanner = new ScannerImpl(instance, new Credentials(principal, token), split.getTableId(), authorizations);\n         }\n@@ -382,7 +384,7 @@ public void initialize(InputSplit inSplit, JobConf job) throws IOException {\n           log.info(\"Using local iterators\");\n           scanner = new ClientSideIteratorScanner(scanner);\n         }\n-        setupIterators(job, scanner, split.getTableId());\n+        setupIterators(job, scanner, split.getTableName());\n       } catch (Exception e) {\n         throw new IOException(e);\n       }\n@@ -460,7 +462,11 @@ public float getProgress() throws IOException {\n       TabletLocator tl;\n       try {\n         // resolve table name to id once, and use id from this point forward\n-        tableId = Tables.getTableId(getInstance(job), tableName);\n+        Instance instance = getInstance(job);\n+        if (instance instanceof MockInstance)\n+          tableId = \"\";\n+        else\n+          tableId = Tables.getTableId(instance, tableName);\n         if (tableConfig.isOfflineScan()) {\n           binnedRanges = binOfflineTable(job, tableId, ranges);\n           while (binnedRanges == null) {\n@@ -469,7 +475,6 @@ public float getProgress() throws IOException {\n             binnedRanges = binOfflineTable(job, tableId, ranges);\n           }\n         } else {\n-          Instance instance = getInstance(job);\n           tl = getTabletLocator(job, tableId);\n           // its possible that the cache could contain complete, but old information about a tables tablets... so clear it\n           tl.invalidateCache();\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/AbstractInputFormat.java b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/AbstractInputFormat.java\nindex 74f8f8b7a..d426caf34 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/AbstractInputFormat.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/AbstractInputFormat.java\n@@ -386,6 +386,8 @@ public void initialize(InputSplit inSplit, TaskAttemptContext attempt) throws IO\n         log.debug(\"Authorizations are: \" + authorizations);\n         if (tableConfig.isOfflineScan()) {\n           scanner = new OfflineScanner(instance, new Credentials(principal, token), split.getTableId(), authorizations);\n+        } else if (instance instanceof MockInstance) {\n+          scanner = instance.getConnector(principal, token).createScanner(split.getTableName(), authorizations);\n         } else {\n           scanner = new ScannerImpl(instance, new Credentials(principal, token), split.getTableId(), authorizations);\n         }\n@@ -397,7 +399,7 @@ public void initialize(InputSplit inSplit, TaskAttemptContext attempt) throws IO\n           log.info(\"Using local iterators\");\n           scanner = new ClientSideIteratorScanner(scanner);\n         }\n-        setupIterators(attempt, scanner, split.getTableId());\n+        setupIterators(attempt, scanner, split.getTableName());\n       } catch (Exception e) {\n         throw new IOException(e);\n       }\n@@ -488,7 +490,11 @@ public V getCurrentValue() throws IOException, InterruptedException {\n       TabletLocator tl;\n       try {\n         // resolve table name to id once, and use id from this point forward\n-        tableId = Tables.getTableId(getInstance(context), tableName);\n+        Instance instance = getInstance(context);\n+        if (instance instanceof MockInstance)\n+          tableId = \"\";\n+        else\n+          tableId = Tables.getTableId(instance, tableName);\n         if (tableConfig.isOfflineScan()) {\n           binnedRanges = binOfflineTable(context, tableId, ranges);\n           while (binnedRanges == null) {\n@@ -498,7 +504,6 @@ public V getCurrentValue() throws IOException, InterruptedException {\n \n           }\n         } else {\n-          Instance instance = getInstance(context);\n           tl = getTabletLocator(context, tableId);\n           // its possible that the cache could contain complete, but old information about a tables tablets... so clear it\n           tl.invalidateCache();\n",
        "project": "accumulo",
        "linesAdd": 16,
        "jira_id": "1732",
        "nb_skipped": 0,
        "commit": "941e3cb1",
        "nb_failure": 0,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 265,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.data.KeyTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/data/Key.java b/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\nindex 3d1f92db7..afab88733 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\n@@ -22,6 +22,8 @@\n  * \n  */\n \n+import static org.apache.accumulo.core.util.ByteBufferUtil.toBytes;\n+\n import java.io.DataInput;\n import java.io.DataOutput;\n import java.io.IOException;\n@@ -38,8 +40,6 @@\n import org.apache.hadoop.io.WritableComparator;\n import org.apache.hadoop.io.WritableUtils;\n \n-import static org.apache.accumulo.core.util.ByteBufferUtil.toBytes;\n-\n public class Key implements WritableComparable<Key>, Cloneable {\n   \n   protected byte[] row;\n@@ -444,8 +444,10 @@ public int hashCode() {\n   }\n   \n   public static String toPrintableString(byte ba[], int offset, int len, int maxLen) {\n-    StringBuilder sb = new StringBuilder();\n+    return appendPrintableString(ba, offset, len, maxLen, new StringBuilder()).toString();\n+  }\n   \n+  public static StringBuilder appendPrintableString(byte ba[], int offset, int len, int maxLen, StringBuilder sb) {\n     int plen = Math.min(len, maxLen);\n     \n     for (int i = 0; i < plen; i++) {\n@@ -460,26 +462,33 @@ public static String toPrintableString(byte ba[], int offset, int len, int maxLe\n       sb.append(\"... TRUNCATED\");\n     }\n     \n-    return sb.toString();\n+    return sb;\n   }\n   \n-  public String toString() {\n-    String labelString = new ColumnVisibility(colVisibility).toString();\n+  private StringBuilder rowColumnStringBuilder() {\n+    StringBuilder sb = new StringBuilder();\n+    appendPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT, sb);\n+    sb.append(\" \");\n+    appendPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT, sb);\n+    sb.append(\":\");\n+    appendPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT, sb);\n+    sb.append(\" [\");\n+    appendPrintableString(colVisibility, 0, colVisibility.length, Constants.MAX_DATA_TO_PRINT, sb);\n+    sb.append(\"]\");\n+    return sb;\n+  }\n   \n-    String s = toPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT) + \" \"\n-        + toPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT) + \":\"\n-        + toPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT) + \" \" + labelString + \" \" + Long.toString(timestamp) + \" \"\n-        + deleted;\n-    return s;\n+  public String toString() {\n+    StringBuilder sb = rowColumnStringBuilder();\n+    sb.append(\" \");\n+    sb.append(Long.toString(timestamp));\n+    sb.append(\" \");\n+    sb.append(deleted);\n+    return sb.toString();\n   }\n   \n   public String toStringNoTime() {\n-    \n-    String labelString = new ColumnVisibility(colVisibility).toString();\n-    \n-    String s = new String(row, 0, row.length) + \" \" + new String(colFamily, 0, colFamily.length) + \":\" + new String(colQualifier, 0, colQualifier.length) + \" \"\n-        + labelString;\n-    return s;\n+    return rowColumnStringBuilder().toString();\n   }\n   \n   public int getLength() {\n",
        "project": "accumulo",
        "linesAdd": 26,
        "jira_id": "193",
        "nb_skipped": 0,
        "commit": "c831e44d",
        "nb_failure": 0,
        "linesRem": 17,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 270,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mock.MockConnectorTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java b/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\nindex ae167096b..2fe637afb 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n@@ -69,9 +69,9 @@ public int compareTo(Key o) {\n       if (o instanceof MockMemKey) {\n         MockMemKey other = (MockMemKey) o;\n         if (count < other.count)\n-          return -1;\n-        if (count > other.count)\n           return 1;\n+        if (count > other.count)\n+          return -1;\n       } else {\n         return 1;\n       }\n",
        "project": "accumulo",
        "linesAdd": 2,
        "jira_id": "218",
        "nb_skipped": 0,
        "commit": "3d55560a",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 366,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mock.MockConnectorTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchWriter.java\nindex b33ebcb74..d89a2631c 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchWriter.java\n@@ -19,6 +19,7 @@\n import org.apache.accumulo.core.client.BatchWriter;\n import org.apache.accumulo.core.client.MutationsRejectedException;\n import org.apache.accumulo.core.data.Mutation;\n+import org.apache.accumulo.core.util.ArgumentChecker;\n \n public class MockBatchWriter implements BatchWriter {\n   \n@@ -32,11 +33,13 @@\n   \n   @Override\n   public void addMutation(Mutation m) throws MutationsRejectedException {\n+    ArgumentChecker.notNull(m);\n     acu.addMutation(tablename, m);\n   }\n   \n   @Override\n   public void addMutations(Iterable<Mutation> iterable) throws MutationsRejectedException {\n+    ArgumentChecker.notNull(iterable);\n     for (Mutation m : iterable) {\n       acu.addMutation(tablename, m);\n     }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\nindex 6d6d53495..3dcab11bd 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n@@ -101,6 +101,8 @@ public int compareTo(Key o) {\n   }\n   \n   synchronized void addMutation(Mutation m) {\n+    if (m.size() == 0)\n+      throw new IllegalArgumentException(\"Can not add empty mutations\");\n     long now = System.currentTimeMillis();\n     mutationCount++;\n     for (ColumnUpdate u : m.getUpdates()) {\n",
        "project": "accumulo",
        "linesAdd": 5,
        "jira_id": "1505",
        "nb_skipped": 0,
        "commit": "b082fc1e",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 34,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.proxy.SimpleTest"
        ],
        "patch": "diff --git a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\nindex 0fedb1d57..f873010fa 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n@@ -1124,13 +1124,13 @@ private void addCellsToWriter(Map<ByteBuffer,List<ColumnUpdate>> cells, BatchWri\n         if (update.isSetValue())\n           value = update.getValue();\n         if (update.isSetTimestamp()) {\n-          if (update.isSetDeleteCell()) {\n+          if (update.isSetDeleteCell() && update.isDeleteCell()) {\n             m.putDelete(update.getColFamily(), update.getColQualifier(), viz, update.getTimestamp());\n           } else {\n             m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, update.getTimestamp(), new Value(value));\n           }\n         } else {\n-          if (update.isSetDeleteCell()) {\n+          if (update.isSetDeleteCell() && update.isDeleteCell()) {\n             m.putDelete(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz);\n           } else {\n             m.put(new Text(update.getColFamily()), new Text(update.getColQualifier()), viz, new Value(value));\n",
        "project": "accumulo",
        "linesAdd": 2,
        "jira_id": "3474",
        "nb_skipped": 0,
        "commit": "cfb832a1",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 363,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.util.shell.ShellTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/SetIterCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/SetIterCommand.java\nindex 4c6d2d293..26e38e649 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/SetIterCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/SetIterCommand.java\n@@ -175,14 +175,23 @@ private static String setUpOptions(ClassLoader classloader, final ConsoleReader\n       clazz = classloader.loadClass(className).asSubclass(OptionDescriber.class);\n       skvi = clazz.newInstance();\n     } catch (ClassNotFoundException e) {\n-      throw new IllegalArgumentException(e.getMessage());\n+      StringBuilder msg = new StringBuilder(\"Unable to load \").append(className);\n+      if (className.indexOf('.') < 0) {\n+        msg.append(\"; did you use a fully qualified package name?\");\n+      } else {\n+        msg.append(\"; class not found.\");\n+      }\n+      throw new ShellCommandException(ErrorCode.INITIALIZATION_FAILURE, msg.toString());\n     } catch (InstantiationException e) {\n       throw new IllegalArgumentException(e.getMessage());\n     } catch (IllegalAccessException e) {\n       throw new IllegalArgumentException(e.getMessage());\n     } catch (ClassCastException e) {\n-      throw new ShellCommandException(ErrorCode.INITIALIZATION_FAILURE, \"Unable to load \" + className + \" as type \" + OptionDescriber.class.getName()\n-          + \"; configure with 'config' instead\");\n+      StringBuilder msg = new StringBuilder(\"Loaded \");\n+      msg.append(className).append(\" but it does not implement \");\n+      msg.append(OptionDescriber.class.getSimpleName());\n+      msg.append(\"; use 'config -s' instead.\");\n+      throw new ShellCommandException(ErrorCode.INITIALIZATION_FAILURE, msg.toString());\n     }\n     \n     final IteratorOptions itopts = skvi.describeOptions();\n",
        "project": "accumulo",
        "linesAdd": 12,
        "jira_id": "1358",
        "nb_skipped": 0,
        "commit": "4d10c92f",
        "nb_failure": 2,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 259,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.iterators.FamilyIntersectingIteratorTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/FamilyIntersectingIterator.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/FamilyIntersectingIterator.java\nindex 6df0e809e..f870b307e 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/FamilyIntersectingIterator.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/FamilyIntersectingIterator.java\n@@ -151,7 +151,7 @@ protected Key buildDocKey() {\n     if (log.isTraceEnabled())\n       log.trace(zeroIndex + \" \" + currentDocID.getLength());\n     Text colq = new Text();\n-    colq.set(currentDocID.getBytes(), zeroIndex + 1, currentDocID.getLength() - zeroIndex - 2);\n+    colq.set(currentDocID.getBytes(), zeroIndex + 1, currentDocID.getLength() - zeroIndex - 1);\n     Key k = new Key(currentPartition, colf, colq);\n     if (log.isTraceEnabled())\n       log.trace(\"built doc key for seek: \" + k.toString());\n",
        "project": "accumulo",
        "linesAdd": 1,
        "jira_id": "178",
        "nb_skipped": 0,
        "commit": "2f0643a9",
        "nb_failure": 3,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 413,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mock.MockTableOperationsTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockAccumulo.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockAccumulo.java\nindex 5977d1da7..272d1afaa 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockAccumulo.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockAccumulo.java\n@@ -21,6 +21,7 @@\n import java.util.HashMap;\n import java.util.Map;\n import java.util.SortedSet;\n+import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.accumulo.core.Constants;\n import org.apache.accumulo.core.client.BatchScanner;\n@@ -38,6 +39,7 @@\n   final Map<String,String> systemProperties = new HashMap<String,String>();\n   Map<String,MockUser> users = new HashMap<String,MockUser>();\n   final FileSystem fs;\n+  final AtomicInteger tableIdCounter = new AtomicInteger(0);\n   \n   MockAccumulo(FileSystem fs) {\n     this.fs = fs;\n@@ -76,7 +78,7 @@ public BatchScanner createBatchScanner(String tableName, Authorizations authoriz\n   }\n   \n   public void createTable(String username, String tableName, boolean useVersions, TimeType timeType) {\n-    MockTable t = new MockTable(useVersions, timeType);\n+    MockTable t = new MockTable(useVersions, timeType, Integer.toString(tableIdCounter.incrementAndGet()));\n     t.userPermissions.put(username, EnumSet.allOf(TablePermission.class));\n     tables.put(tableName, t);\n   }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\nindex 3dcab11bd..2e13d842e 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n@@ -89,9 +89,11 @@ public int compareTo(Key o) {\n   private TimeType timeType;\n   SortedSet<Text> splits = new ConcurrentSkipListSet<Text>();\n   Map<String,Set<Text>> localityGroups = new TreeMap<String, Set<Text>>();\n+  private String tableId;\n   \n-  MockTable(boolean limitVersion, TimeType timeType) {\n+  MockTable(boolean limitVersion, TimeType timeType, String tableId) {\n     this.timeType = timeType;\n+    this.tableId = tableId;\n     settings = IteratorUtil.generateInitialTableProperties(limitVersion);\n     for (Entry<String,String> entry : AccumuloConfiguration.getDefaultConfiguration()) {\n       String key = entry.getKey();\n@@ -143,4 +145,8 @@ public void merge(Text start, Text end) {\n     if (reAdd)\n       splits.add(start);\n   }\n+\n+  public String getTableId() {\n+    return this.tableId;\n+  }\n }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\nindex 64f8225fc..5b1535127 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n@@ -296,8 +296,8 @@ public void clearLocatorCache(String tableName) throws TableNotFoundException {\n   @Override\n   public Map<String,String> tableIdMap() {\n     Map<String,String> result = new HashMap<String,String>();\n-    for (String table : acu.tables.keySet()) {\n-      result.put(table, table);\n+    for (Entry<String,MockTable> entry : acu.tables.entrySet()) {\n+      result.put(entry.getKey(), entry.getValue().getTableId());\n     }\n     return result;\n   }\n",
        "project": "accumulo",
        "linesAdd": 12,
        "jira_id": "2857",
        "nb_skipped": 0,
        "commit": "9fcca2ed",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 272,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.iterators.FamilyIntersectingIteratorTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/FamilyIntersectingIterator.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/FamilyIntersectingIterator.java\nindex 6df0e809e..f870b307e 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/FamilyIntersectingIterator.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/FamilyIntersectingIterator.java\n@@ -151,7 +151,7 @@ protected Key buildDocKey() {\n     if (log.isTraceEnabled())\n       log.trace(zeroIndex + \" \" + currentDocID.getLength());\n     Text colq = new Text();\n-    colq.set(currentDocID.getBytes(), zeroIndex + 1, currentDocID.getLength() - zeroIndex - 2);\n+    colq.set(currentDocID.getBytes(), zeroIndex + 1, currentDocID.getLength() - zeroIndex - 1);\n     Key k = new Key(currentPartition, colf, colq);\n     if (log.isTraceEnabled())\n       log.trace(\"built doc key for seek: \" + k.toString());\n",
        "project": "accumulo",
        "linesAdd": 1,
        "jira_id": "178",
        "nb_skipped": 0,
        "commit": "efef09b0",
        "nb_failure": 3,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 296,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mock.TestBatchScanner821"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchScanner.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchScanner.java\nindex c33599b50..351fdf971 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchScanner.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockBatchScanner.java\n@@ -24,10 +24,12 @@\n import java.util.Map.Entry;\n \n import org.apache.accumulo.core.client.BatchScanner;\n+import org.apache.accumulo.core.client.mock.MockScanner.RangeFilter;\n import org.apache.accumulo.core.data.Key;\n import org.apache.accumulo.core.data.Range;\n import org.apache.accumulo.core.data.Value;\n import org.apache.accumulo.core.iterators.Filter;\n+import org.apache.accumulo.core.iterators.IteratorEnvironment;\n import org.apache.accumulo.core.iterators.SortedKeyValueIterator;\n import org.apache.accumulo.core.iterators.SortedMapIterator;\n import org.apache.accumulo.core.security.Authorizations;\n@@ -53,7 +55,11 @@ public void setRanges(Collection<Range> ranges) {\n   static class RangesFilter extends Filter {\n     List<Range> ranges;\n     \n-    RangesFilter(SortedKeyValueIterator<Key,Value> iterator, List<Range> ranges) {\n+    public RangesFilter deepCopy(IteratorEnvironment env) {\n+      return new RangesFilter(getSource().deepCopy(env), ranges);\n+    }\n+    \n+    public RangesFilter(SortedKeyValueIterator<Key,Value> iterator, List<Range> ranges) {\n       setSource(iterator);\n       this.ranges = ranges;\n     }\n@@ -77,9 +83,9 @@ public boolean accept(Key k, Value v) {\n \n     IteratorChain chain = new IteratorChain();\n     for (Range range : ranges) {\n-      SortedKeyValueIterator<Key,Value> i = new SortedMapIterator(table.table);\n+      SortedKeyValueIterator<Key,Value> i = new RangesFilter(new SortedMapIterator(table.table), ranges);\n       try {\n-        i = new RangesFilter(createFilter(i), ranges);\n+        i = createFilter(i);\n         i.seek(range, createColumnBSS(fetchedColumns), !fetchedColumns.isEmpty());\n         chain.addIterator(new IteratorAdapter(i));\n       } catch (IOException e) {\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockScanner.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockScanner.java\nindex 82b9b198e..2d78bbf38 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockScanner.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockScanner.java\n@@ -26,8 +26,10 @@\n import org.apache.accumulo.core.data.Range;\n import org.apache.accumulo.core.data.Value;\n import org.apache.accumulo.core.iterators.Filter;\n+import org.apache.accumulo.core.iterators.IteratorEnvironment;\n import org.apache.accumulo.core.iterators.SortedKeyValueIterator;\n import org.apache.accumulo.core.iterators.SortedMapIterator;\n+import org.apache.accumulo.core.iterators.system.DeletingIterator;\n import org.apache.accumulo.core.security.Authorizations;\n \n public class MockScanner extends MockScannerBase implements Scanner {\n",
        "project": "accumulo",
        "linesAdd": 11,
        "jira_id": "821",
        "nb_skipped": 0,
        "commit": "a450ac2f",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 5,
        "nb_test": 30,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.gc.GarbageCollectWriteAheadLogsTest"
        ],
        "patch": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java b/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\nindex 5c1194a18..d4a2d4f8e 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\n@@ -529,8 +529,15 @@ else if (path.startsWith(\"/\"))\n \n   @Override\n   public Path getFullPath(FileType fileType, String path) {\n-    if (path.contains(\":\"))\n+    int colon = path.indexOf(':');\n+    if (colon > -1) {\n+      // Check if this is really an absolute path or if this is a 1.4 style relative path for a WAL\n+      if (fileType == FileType.WAL && path.charAt(colon + 1) != '/') {\n+        path = path.substring(path.indexOf('/'));\n+      } else {\n         return new Path(path);\n+      }\n+    }\n \n     // normalize the path\n     Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());\ndiff --git a/server/base/src/main/java/org/apache/accumulo/server/master/recovery/RecoveryPath.java b/server/base/src/main/java/org/apache/accumulo/server/master/recovery/RecoveryPath.java\nindex 1da945d21..4a6638aee 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/master/recovery/RecoveryPath.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/master/recovery/RecoveryPath.java\n@@ -34,8 +34,11 @@ public static Path getRecoveryPath(VolumeManager fs, Path walPath) throws IOExce\n       String uuid = walPath.getName();\n       // drop uuid\n       walPath = walPath.getParent();\n+      // recovered 1.4 WALs won't have a server component\n+      if (!walPath.getName().equals(FileType.WAL.getDirectory())) {\n         // drop server\n         walPath = walPath.getParent();\n+      }\n   \n       if (!walPath.getName().equals(FileType.WAL.getDirectory()))\n         throw new IllegalArgumentException(\"Bad path \" + walPath);\ndiff --git a/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectWriteAheadLogs.java b/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectWriteAheadLogs.java\nindex ae850af12..56a0fd5e0 100644\n--- a/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectWriteAheadLogs.java\n+++ b/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectWriteAheadLogs.java\n@@ -281,7 +281,9 @@ private int removeMetadataEntries(Map<String,Path>  nameToFileMap, Map<String, P\n \n     while (iterator.hasNext()) {\n       for (String entry : iterator.next().logSet) {\n-        String uuid = new Path(entry).getName();\n+        // old style WALs will have the IP:Port of their logger and new style will either be a Path either absolute or relative, in all cases\n+        // the last \"/\" will mark a UUID file name.\n+        String uuid = entry.substring(entry.lastIndexOf(\"/\") + 1);\n         if (!isUUID(uuid)) {\n           // fully expect this to be a uuid, if its not then something is wrong and walog GC should not proceed!\n           throw new IllegalArgumentException(\"Expected uuid, but got \" + uuid + \" from \" + entry);\n@@ -327,8 +329,8 @@ int scanServers(String[] walDirs, Map<Path,String> fileToServerMap, Map<String,P\n         continue;\n       for (FileStatus status : listing) {\n         String server = status.getPath().getName();\n-        servers.add(server);\n         if (status.isDir()) {\n+          servers.add(server);\n           for (FileStatus file : fs.listStatus(new Path(walRoot, server))) {\n             if (isUUID(file.getPath().getName())) {\n               fileToServerMap.put(file.getPath(), server);\n@@ -339,7 +341,9 @@ int scanServers(String[] walDirs, Map<Path,String> fileToServerMap, Map<String,P\n           }\n         } else if (isUUID(server)) {\n           // old-style WAL are not under a directory\n+          servers.add(\"\");\n           fileToServerMap.put(status.getPath(), \"\");\n+          nameToFileMap.put(server, status.getPath());\n         } else {\n           log.info(\"Ignoring file \" + status.getPath() + \" because it doesn't look like a uuid\");\n         }\ndiff --git a/server/tserver/src/main/java/org/apache/accumulo/tserver/Tablet.java b/server/tserver/src/main/java/org/apache/accumulo/tserver/Tablet.java\nindex f73d4ca87..36b22892a 100644\n--- a/server/tserver/src/main/java/org/apache/accumulo/tserver/Tablet.java\n+++ b/server/tserver/src/main/java/org/apache/accumulo/tserver/Tablet.java\n@@ -1357,6 +1357,8 @@ public void sessionExpired() {\n     tabletResources.setTablet(this, acuTableConf);\n     if (!logEntries.isEmpty()) {\n       log.info(\"Starting Write-Ahead Log recovery for \" + this.extent);\n+      // count[0] = entries used on tablet\n+      // count[1] = track max time from walog entries wihtout timestamps\n       final long[] count = new long[2];\n       final CommitSession commitSession = tabletMemory.getCommitSession();\n       count[1] = Long.MIN_VALUE;\n@@ -1388,6 +1390,7 @@ public void receive(Mutation m) {\n         commitSession.updateMaxCommittedTime(tabletTime.getTime());\n \n         if (count[0] == 0) {\n+          log.debug(\"No replayed mutations applied, removing unused entries for \" + extent);\n           MetadataTableUtil.removeUnusedWALEntries(extent, logEntries, tabletServer.getLock());\n           logEntries.clear();\n         }\n@@ -1403,7 +1406,7 @@ public void receive(Mutation m) {\n       currentLogs = new HashSet<DfsLogger>();\n       for (LogEntry logEntry : logEntries) {\n         for (String log : logEntry.logSet) {\n-          currentLogs.add(new DfsLogger(tabletServer.getServerConfig(), log));\n+          currentLogs.add(new DfsLogger(tabletServer.getServerConfig(), log, logEntry.getColumnQualifier().toString()));\n         }\n       }\n \n@@ -3661,12 +3664,12 @@ public void importMapFiles(long tid, Map<FileRef,MapFileInfo> fileMap, boolean s\n \n       for (DfsLogger logger : otherLogs) {\n         otherLogsCopy.add(logger.toString());\n-        doomed.add(logger.toString());\n+        doomed.add(logger.getMeta());\n       }\n \n       for (DfsLogger logger : currentLogs) {\n         currentLogsCopy.add(logger.toString());\n-        doomed.remove(logger.toString());\n+        doomed.remove(logger.getMeta());\n       }\n \n       otherLogs = Collections.emptySet();\n@@ -3684,6 +3687,10 @@ public void importMapFiles(long tid, Map<FileRef,MapFileInfo> fileMap, boolean s\n       log.debug(\"Logs for current memory: \" + getExtent() + \" \" + logger);\n     }\n \n+    for (String logger : doomed) {\n+      log.debug(\"Logs to be destroyed: \" + getExtent() + \" \" + logger);\n+    }\n+\n     return doomed;\n   }\n \ndiff --git a/server/tserver/src/main/java/org/apache/accumulo/tserver/log/DfsLogger.java b/server/tserver/src/main/java/org/apache/accumulo/tserver/log/DfsLogger.java\nindex cca295343..b152380e3 100644\n--- a/server/tserver/src/main/java/org/apache/accumulo/tserver/log/DfsLogger.java\n+++ b/server/tserver/src/main/java/org/apache/accumulo/tserver/log/DfsLogger.java\n@@ -220,13 +220,21 @@ public int hashCode() {\n   private String logPath;\n   private Daemon syncThread;\n \n+  /* Track what's actually in +r/!0 for this logger ref */\n+  private String metaReference;\n+\n   public DfsLogger(ServerResources conf) throws IOException {\n     this.conf = conf;\n   }\n \n-  public DfsLogger(ServerResources conf, String filename) throws IOException {\n+  /**\n+   * Refernce a pre-existing log file.\n+   * @param meta the cq for the \"log\" entry in +r/!0\n+   */\n+  public DfsLogger(ServerResources conf, String filename, String meta) throws IOException {\n     this.conf = conf;\n     this.logPath = filename;\n+    metaReference = meta;\n   }\n \n   public static DFSLoggerInputStreams readHeaderAndReturnStream(VolumeManager fs, Path path, AccumuloConfiguration conf) throws IOException {\n@@ -315,6 +323,7 @@ public synchronized void open(String address) throws IOException {\n     VolumeManager fs = conf.getFileSystem();\n \n     logPath = fs.choose(ServerConstants.getWalDirs()) + \"/\" + logger + \"/\" + filename;\n+    metaReference = toString();\n     try {\n       short replication = (short) conf.getConfiguration().getCount(Property.TSERV_WAL_REPLICATION);\n       if (replication == 0)\n@@ -400,6 +409,16 @@ public String toString() {\n     return fileName;\n   }\n \n+  /**\n+   * get the cq needed to reference this logger's entry in +r/!0\n+   */\n+  public String getMeta() {\n+    if (null == metaReference) {\n+      throw new IllegalStateException(\"logger doesn't have meta reference. \" + this);\n+    }\n+    return metaReference;\n+  }\n+\n   public String getFileName() {\n     return logPath.toString();\n   }\n",
        "project": "accumulo",
        "linesAdd": 33,
        "jira_id": "2899",
        "nb_skipped": 0,
        "commit": "31aea2ad",
        "nb_failure": 1,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 27,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.proxy.SimpleTest"
        ],
        "patch": "diff --git a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\nindex 926c41329..c0dee9a50 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n@@ -50,6 +50,8 @@\n import org.apache.accumulo.core.client.admin.ActiveCompaction;\n import org.apache.accumulo.core.client.admin.ActiveScan;\n import org.apache.accumulo.core.client.admin.TimeType;\n+import org.apache.accumulo.core.client.impl.thrift.TableOperationExceptionType;\n+import org.apache.accumulo.core.client.impl.thrift.ThriftTableOperationException;\n import org.apache.accumulo.core.client.mock.MockInstance;\n import org.apache.accumulo.core.client.security.SecurityErrorCode;\n import org.apache.accumulo.core.client.security.tokens.AuthenticationToken;\n@@ -178,6 +180,12 @@ private TException translateException(Exception ex) {\n       logger.debug(e, e);\n       return new org.apache.accumulo.proxy.thrift.MutationsRejectedException(e.toString());\n     } catch (AccumuloException e) {\n+      if (e.getCause() instanceof ThriftTableOperationException) {\n+        ThriftTableOperationException ttoe = (ThriftTableOperationException) e.getCause();\n+        if (ttoe.type == TableOperationExceptionType.NOTFOUND) {\n+          return new org.apache.accumulo.proxy.thrift.TableNotFoundException(e.toString());\n+        }\n+      }\n       logger.debug(e, e);\n       return new org.apache.accumulo.proxy.thrift.AccumuloException(e.toString());\n     } catch (AccumuloSecurityException e) {\ndiff --git a/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java b/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java\nindex 857320a44..f53b6acfd 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/thrift/AccumuloProxy.java\n@@ -104,17 +104,17 @@\n \n     public void onlineTable(ByteBuffer login, String tableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException;\n \n-    public void removeConstraint(ByteBuffer login, String tableName, int constraint) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException;\n+    public void removeConstraint(ByteBuffer login, String tableName, int constraint) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException;\n \n     public void removeIterator(ByteBuffer login, String tableName, String iterName, Set<IteratorScope> scopes) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException;\n \n-    public void removeTableProperty(ByteBuffer login, String tableName, String property) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException;\n+    public void removeTableProperty(ByteBuffer login, String tableName, String property) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException;\n \n     public void renameTable(ByteBuffer login, String oldTableName, String newTableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, TableExistsException, org.apache.thrift.TException;\n \n     public void setLocalityGroups(ByteBuffer login, String tableName, Map<String,Set<String>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException;\n \n-    public void setTableProperty(ByteBuffer login, String tableName, String property, String value) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException;\n+    public void setTableProperty(ByteBuffer login, String tableName, String property, String value) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException;\n \n     public Set<Range> splitRangeByTablets(ByteBuffer login, String tableName, Range range, int maxSplits) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException;\n \n@@ -1206,7 +1206,7 @@ public void recv_onlineTable() throws AccumuloException, AccumuloSecurityExcepti\n       return;\n     }\n \n-    public void removeConstraint(ByteBuffer login, String tableName, int constraint) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException\n+    public void removeConstraint(ByteBuffer login, String tableName, int constraint) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException\n     {\n       send_removeConstraint(login, tableName, constraint);\n       recv_removeConstraint();\n@@ -1221,7 +1221,7 @@ public void send_removeConstraint(ByteBuffer login, String tableName, int constr\n       sendBase(\"removeConstraint\", args);\n     }\n \n-    public void recv_removeConstraint() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException\n+    public void recv_removeConstraint() throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException\n     {\n       removeConstraint_result result = new removeConstraint_result();\n       receiveBase(result, \"removeConstraint\");\n@@ -1231,6 +1231,9 @@ public void recv_removeConstraint() throws AccumuloException, AccumuloSecurityEx\n       if (result.ouch2 != null) {\n         throw result.ouch2;\n       }\n+      if (result.ouch3 != null) {\n+        throw result.ouch3;\n+      }\n       return;\n     }\n \n@@ -1266,7 +1269,7 @@ public void recv_removeIterator() throws AccumuloException, AccumuloSecurityExce\n       return;\n     }\n \n-    public void removeTableProperty(ByteBuffer login, String tableName, String property) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException\n+    public void removeTableProperty(ByteBuffer login, String tableName, String property) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException\n     {\n       send_removeTableProperty(login, tableName, property);\n       recv_removeTableProperty();\n@@ -1281,7 +1284,7 @@ public void send_removeTableProperty(ByteBuffer login, String tableName, String\n       sendBase(\"removeTableProperty\", args);\n     }\n \n-    public void recv_removeTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException\n+    public void recv_removeTableProperty() throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException\n     {\n       removeTableProperty_result result = new removeTableProperty_result();\n       receiveBase(result, \"removeTableProperty\");\n@@ -1291,6 +1294,9 @@ public void recv_removeTableProperty() throws AccumuloException, AccumuloSecurit\n       if (result.ouch2 != null) {\n         throw result.ouch2;\n       }\n+      if (result.ouch3 != null) {\n+        throw result.ouch3;\n+      }\n       return;\n     }\n \n@@ -1359,7 +1365,7 @@ public void recv_setLocalityGroups() throws AccumuloException, AccumuloSecurityE\n       return;\n     }\n \n-    public void setTableProperty(ByteBuffer login, String tableName, String property, String value) throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException\n+    public void setTableProperty(ByteBuffer login, String tableName, String property, String value) throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException\n     {\n       send_setTableProperty(login, tableName, property, value);\n       recv_setTableProperty();\n@@ -1375,7 +1381,7 @@ public void send_setTableProperty(ByteBuffer login, String tableName, String pro\n       sendBase(\"setTableProperty\", args);\n     }\n \n-    public void recv_setTableProperty() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException\n+    public void recv_setTableProperty() throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException\n     {\n       setTableProperty_result result = new setTableProperty_result();\n       receiveBase(result, \"setTableProperty\");\n@@ -1385,6 +1391,9 @@ public void recv_setTableProperty() throws AccumuloException, AccumuloSecurityEx\n       if (result.ouch2 != null) {\n         throw result.ouch2;\n       }\n+      if (result.ouch3 != null) {\n+        throw result.ouch3;\n+      }\n       return;\n     }\n \n@@ -3575,7 +3584,7 @@ public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apa\n         prot.writeMessageEnd();\n       }\n \n-      public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n+      public void getResult() throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException {\n         if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n           throw new IllegalStateException(\"Method call not finished!\");\n         }\n@@ -3654,7 +3663,7 @@ public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apa\n         prot.writeMessageEnd();\n       }\n \n-      public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n+      public void getResult() throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException {\n         if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n           throw new IllegalStateException(\"Method call not finished!\");\n         }\n@@ -3771,7 +3780,7 @@ public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apa\n         prot.writeMessageEnd();\n       }\n \n-      public void getResult() throws AccumuloException, AccumuloSecurityException, org.apache.thrift.TException {\n+      public void getResult() throws AccumuloException, AccumuloSecurityException, TableNotFoundException, org.apache.thrift.TException {\n         if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {\n           throw new IllegalStateException(\"Method call not finished!\");\n         }\n@@ -5983,6 +5992,8 @@ public removeConstraint_result getResult(I iface, removeConstraint_args args) th\n           result.ouch1 = ouch1;\n         } catch (AccumuloSecurityException ouch2) {\n           result.ouch2 = ouch2;\n+        } catch (TableNotFoundException ouch3) {\n+          result.ouch3 = ouch3;\n         }\n         return result;\n       }\n@@ -6037,6 +6048,8 @@ public removeTableProperty_result getResult(I iface, removeTableProperty_args ar\n           result.ouch1 = ouch1;\n         } catch (AccumuloSecurityException ouch2) {\n           result.ouch2 = ouch2;\n+        } catch (TableNotFoundException ouch3) {\n+          result.ouch3 = ouch3;\n         }\n         return result;\n       }\n@@ -6121,6 +6134,8 @@ public setTableProperty_result getResult(I iface, setTableProperty_args args) th\n           result.ouch1 = ouch1;\n         } catch (AccumuloSecurityException ouch2) {\n           result.ouch2 = ouch2;\n+        } catch (TableNotFoundException ouch3) {\n+          result.ouch3 = ouch3;\n         }\n         return result;\n       }\n@@ -39944,6 +39959,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, removeConstraint_arg\n \n     private static final org.apache.thrift.protocol.TField OUCH1_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch1\", org.apache.thrift.protocol.TType.STRUCT, (short)1);\n     private static final org.apache.thrift.protocol.TField OUCH2_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch2\", org.apache.thrift.protocol.TType.STRUCT, (short)2);\n+    private static final org.apache.thrift.protocol.TField OUCH3_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch3\", org.apache.thrift.protocol.TType.STRUCT, (short)3);\n \n     private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();\n     static {\n@@ -39953,11 +39969,13 @@ public void read(org.apache.thrift.protocol.TProtocol prot, removeConstraint_arg\n \n     public AccumuloException ouch1; // required\n     public AccumuloSecurityException ouch2; // required\n+    public TableNotFoundException ouch3; // required\n \n     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */\n     @SuppressWarnings(\"all\") public enum _Fields implements org.apache.thrift.TFieldIdEnum {\n       OUCH1((short)1, \"ouch1\"),\n-      OUCH2((short)2, \"ouch2\");\n+      OUCH2((short)2, \"ouch2\"),\n+      OUCH3((short)3, \"ouch3\");\n \n       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();\n \n@@ -39976,6 +39994,8 @@ public static _Fields findByThriftId(int fieldId) {\n             return OUCH1;\n           case 2: // OUCH2\n             return OUCH2;\n+          case 3: // OUCH3\n+            return OUCH3;\n           default:\n             return null;\n         }\n@@ -40023,6 +40043,8 @@ public String getFieldName() {\n           new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n       tmpMap.put(_Fields.OUCH2, new org.apache.thrift.meta_data.FieldMetaData(\"ouch2\", org.apache.thrift.TFieldRequirementType.DEFAULT, \n           new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n+      tmpMap.put(_Fields.OUCH3, new org.apache.thrift.meta_data.FieldMetaData(\"ouch3\", org.apache.thrift.TFieldRequirementType.DEFAULT, \n+          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n       metaDataMap = Collections.unmodifiableMap(tmpMap);\n       org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(removeConstraint_result.class, metaDataMap);\n     }\n@@ -40032,11 +40054,13 @@ public removeConstraint_result() {\n \n     public removeConstraint_result(\n       AccumuloException ouch1,\n-      AccumuloSecurityException ouch2)\n+      AccumuloSecurityException ouch2,\n+      TableNotFoundException ouch3)\n     {\n       this();\n       this.ouch1 = ouch1;\n       this.ouch2 = ouch2;\n+      this.ouch3 = ouch3;\n     }\n \n     /**\n@@ -40049,6 +40073,9 @@ public removeConstraint_result(removeConstraint_result other) {\n       if (other.isSetOuch2()) {\n         this.ouch2 = new AccumuloSecurityException(other.ouch2);\n       }\n+      if (other.isSetOuch3()) {\n+        this.ouch3 = new TableNotFoundException(other.ouch3);\n+      }\n     }\n \n     public removeConstraint_result deepCopy() {\n@@ -40059,6 +40086,7 @@ public removeConstraint_result deepCopy() {\n     public void clear() {\n       this.ouch1 = null;\n       this.ouch2 = null;\n+      this.ouch3 = null;\n     }\n \n     public AccumuloException getOuch1() {\n@@ -40109,6 +40137,30 @@ public void setOuch2IsSet(boolean value) {\n       }\n     }\n \n+    public TableNotFoundException getOuch3() {\n+      return this.ouch3;\n+    }\n+\n+    public removeConstraint_result setOuch3(TableNotFoundException ouch3) {\n+      this.ouch3 = ouch3;\n+      return this;\n+    }\n+\n+    public void unsetOuch3() {\n+      this.ouch3 = null;\n+    }\n+\n+    /** Returns true if field ouch3 is set (has been assigned a value) and false otherwise */\n+    public boolean isSetOuch3() {\n+      return this.ouch3 != null;\n+    }\n+\n+    public void setOuch3IsSet(boolean value) {\n+      if (!value) {\n+        this.ouch3 = null;\n+      }\n+    }\n+\n     public void setFieldValue(_Fields field, Object value) {\n       switch (field) {\n       case OUCH1:\n@@ -40127,6 +40179,14 @@ public void setFieldValue(_Fields field, Object value) {\n         }\n         break;\n \n+      case OUCH3:\n+        if (value == null) {\n+          unsetOuch3();\n+        } else {\n+          setOuch3((TableNotFoundException)value);\n+        }\n+        break;\n+\n       }\n     }\n \n@@ -40138,6 +40198,9 @@ public Object getFieldValue(_Fields field) {\n       case OUCH2:\n         return getOuch2();\n \n+      case OUCH3:\n+        return getOuch3();\n+\n       }\n       throw new IllegalStateException();\n     }\n@@ -40153,6 +40216,8 @@ public boolean isSet(_Fields field) {\n         return isSetOuch1();\n       case OUCH2:\n         return isSetOuch2();\n+      case OUCH3:\n+        return isSetOuch3();\n       }\n       throw new IllegalStateException();\n     }\n@@ -40188,6 +40253,15 @@ public boolean equals(removeConstraint_result that) {\n           return false;\n       }\n \n+      boolean this_present_ouch3 = true && this.isSetOuch3();\n+      boolean that_present_ouch3 = true && that.isSetOuch3();\n+      if (this_present_ouch3 || that_present_ouch3) {\n+        if (!(this_present_ouch3 && that_present_ouch3))\n+          return false;\n+        if (!this.ouch3.equals(that.ouch3))\n+          return false;\n+      }\n+\n       return true;\n     }\n \n@@ -40224,6 +40298,16 @@ public int compareTo(removeConstraint_result other) {\n           return lastComparison;\n         }\n       }\n+      lastComparison = Boolean.valueOf(isSetOuch3()).compareTo(typedOther.isSetOuch3());\n+      if (lastComparison != 0) {\n+        return lastComparison;\n+      }\n+      if (isSetOuch3()) {\n+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch3, typedOther.ouch3);\n+        if (lastComparison != 0) {\n+          return lastComparison;\n+        }\n+      }\n       return 0;\n     }\n \n@@ -40259,6 +40343,14 @@ public String toString() {\n         sb.append(this.ouch2);\n       }\n       first = false;\n+      if (!first) sb.append(\", \");\n+      sb.append(\"ouch3:\");\n+      if (this.ouch3 == null) {\n+        sb.append(\"null\");\n+      } else {\n+        sb.append(this.ouch3);\n+      }\n+      first = false;\n       sb.append(\")\");\n       return sb.toString();\n     }\n@@ -40320,6 +40412,15 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, removeConstraint_re\n                 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n               }\n               break;\n+            case 3: // OUCH3\n+              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\n+                struct.ouch3 = new TableNotFoundException();\n+                struct.ouch3.read(iprot);\n+                struct.setOuch3IsSet(true);\n+              } else { \n+                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n+              }\n+              break;\n             default:\n               org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n           }\n@@ -40345,6 +40446,11 @@ public void write(org.apache.thrift.protocol.TProtocol oprot, removeConstraint_r\n           struct.ouch2.write(oprot);\n           oprot.writeFieldEnd();\n         }\n+        if (struct.ouch3 != null) {\n+          oprot.writeFieldBegin(OUCH3_FIELD_DESC);\n+          struct.ouch3.write(oprot);\n+          oprot.writeFieldEnd();\n+        }\n         oprot.writeFieldStop();\n         oprot.writeStructEnd();\n       }\n@@ -40369,19 +40475,25 @@ public void write(org.apache.thrift.protocol.TProtocol prot, removeConstraint_re\n         if (struct.isSetOuch2()) {\n           optionals.set(1);\n         }\n-        oprot.writeBitSet(optionals, 2);\n+        if (struct.isSetOuch3()) {\n+          optionals.set(2);\n+        }\n+        oprot.writeBitSet(optionals, 3);\n         if (struct.isSetOuch1()) {\n           struct.ouch1.write(oprot);\n         }\n         if (struct.isSetOuch2()) {\n           struct.ouch2.write(oprot);\n         }\n+        if (struct.isSetOuch3()) {\n+          struct.ouch3.write(oprot);\n+        }\n       }\n \n       @Override\n       public void read(org.apache.thrift.protocol.TProtocol prot, removeConstraint_result struct) throws org.apache.thrift.TException {\n         TTupleProtocol iprot = (TTupleProtocol) prot;\n-        BitSet incoming = iprot.readBitSet(2);\n+        BitSet incoming = iprot.readBitSet(3);\n         if (incoming.get(0)) {\n           struct.ouch1 = new AccumuloException();\n           struct.ouch1.read(iprot);\n@@ -40392,6 +40504,11 @@ public void read(org.apache.thrift.protocol.TProtocol prot, removeConstraint_res\n           struct.ouch2.read(iprot);\n           struct.setOuch2IsSet(true);\n         }\n+        if (incoming.get(2)) {\n+          struct.ouch3 = new TableNotFoundException();\n+          struct.ouch3.read(iprot);\n+          struct.setOuch3IsSet(true);\n+        }\n       }\n     }\n \n@@ -42244,6 +42361,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, removeTableProperty_\n \n     private static final org.apache.thrift.protocol.TField OUCH1_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch1\", org.apache.thrift.protocol.TType.STRUCT, (short)1);\n     private static final org.apache.thrift.protocol.TField OUCH2_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch2\", org.apache.thrift.protocol.TType.STRUCT, (short)2);\n+    private static final org.apache.thrift.protocol.TField OUCH3_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch3\", org.apache.thrift.protocol.TType.STRUCT, (short)3);\n \n     private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();\n     static {\n@@ -42253,11 +42371,13 @@ public void read(org.apache.thrift.protocol.TProtocol prot, removeTableProperty_\n \n     public AccumuloException ouch1; // required\n     public AccumuloSecurityException ouch2; // required\n+    public TableNotFoundException ouch3; // required\n \n     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */\n     @SuppressWarnings(\"all\") public enum _Fields implements org.apache.thrift.TFieldIdEnum {\n       OUCH1((short)1, \"ouch1\"),\n-      OUCH2((short)2, \"ouch2\");\n+      OUCH2((short)2, \"ouch2\"),\n+      OUCH3((short)3, \"ouch3\");\n \n       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();\n \n@@ -42276,6 +42396,8 @@ public static _Fields findByThriftId(int fieldId) {\n             return OUCH1;\n           case 2: // OUCH2\n             return OUCH2;\n+          case 3: // OUCH3\n+            return OUCH3;\n           default:\n             return null;\n         }\n@@ -42323,6 +42445,8 @@ public String getFieldName() {\n           new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n       tmpMap.put(_Fields.OUCH2, new org.apache.thrift.meta_data.FieldMetaData(\"ouch2\", org.apache.thrift.TFieldRequirementType.DEFAULT, \n           new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n+      tmpMap.put(_Fields.OUCH3, new org.apache.thrift.meta_data.FieldMetaData(\"ouch3\", org.apache.thrift.TFieldRequirementType.DEFAULT, \n+          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n       metaDataMap = Collections.unmodifiableMap(tmpMap);\n       org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(removeTableProperty_result.class, metaDataMap);\n     }\n@@ -42332,11 +42456,13 @@ public removeTableProperty_result() {\n \n     public removeTableProperty_result(\n       AccumuloException ouch1,\n-      AccumuloSecurityException ouch2)\n+      AccumuloSecurityException ouch2,\n+      TableNotFoundException ouch3)\n     {\n       this();\n       this.ouch1 = ouch1;\n       this.ouch2 = ouch2;\n+      this.ouch3 = ouch3;\n     }\n \n     /**\n@@ -42349,6 +42475,9 @@ public removeTableProperty_result(removeTableProperty_result other) {\n       if (other.isSetOuch2()) {\n         this.ouch2 = new AccumuloSecurityException(other.ouch2);\n       }\n+      if (other.isSetOuch3()) {\n+        this.ouch3 = new TableNotFoundException(other.ouch3);\n+      }\n     }\n \n     public removeTableProperty_result deepCopy() {\n@@ -42359,6 +42488,7 @@ public removeTableProperty_result deepCopy() {\n     public void clear() {\n       this.ouch1 = null;\n       this.ouch2 = null;\n+      this.ouch3 = null;\n     }\n \n     public AccumuloException getOuch1() {\n@@ -42409,6 +42539,30 @@ public void setOuch2IsSet(boolean value) {\n       }\n     }\n \n+    public TableNotFoundException getOuch3() {\n+      return this.ouch3;\n+    }\n+\n+    public removeTableProperty_result setOuch3(TableNotFoundException ouch3) {\n+      this.ouch3 = ouch3;\n+      return this;\n+    }\n+\n+    public void unsetOuch3() {\n+      this.ouch3 = null;\n+    }\n+\n+    /** Returns true if field ouch3 is set (has been assigned a value) and false otherwise */\n+    public boolean isSetOuch3() {\n+      return this.ouch3 != null;\n+    }\n+\n+    public void setOuch3IsSet(boolean value) {\n+      if (!value) {\n+        this.ouch3 = null;\n+      }\n+    }\n+\n     public void setFieldValue(_Fields field, Object value) {\n       switch (field) {\n       case OUCH1:\n@@ -42427,6 +42581,14 @@ public void setFieldValue(_Fields field, Object value) {\n         }\n         break;\n \n+      case OUCH3:\n+        if (value == null) {\n+          unsetOuch3();\n+        } else {\n+          setOuch3((TableNotFoundException)value);\n+        }\n+        break;\n+\n       }\n     }\n \n@@ -42438,6 +42600,9 @@ public Object getFieldValue(_Fields field) {\n       case OUCH2:\n         return getOuch2();\n \n+      case OUCH3:\n+        return getOuch3();\n+\n       }\n       throw new IllegalStateException();\n     }\n@@ -42453,6 +42618,8 @@ public boolean isSet(_Fields field) {\n         return isSetOuch1();\n       case OUCH2:\n         return isSetOuch2();\n+      case OUCH3:\n+        return isSetOuch3();\n       }\n       throw new IllegalStateException();\n     }\n@@ -42488,6 +42655,15 @@ public boolean equals(removeTableProperty_result that) {\n           return false;\n       }\n \n+      boolean this_present_ouch3 = true && this.isSetOuch3();\n+      boolean that_present_ouch3 = true && that.isSetOuch3();\n+      if (this_present_ouch3 || that_present_ouch3) {\n+        if (!(this_present_ouch3 && that_present_ouch3))\n+          return false;\n+        if (!this.ouch3.equals(that.ouch3))\n+          return false;\n+      }\n+\n       return true;\n     }\n \n@@ -42524,6 +42700,16 @@ public int compareTo(removeTableProperty_result other) {\n           return lastComparison;\n         }\n       }\n+      lastComparison = Boolean.valueOf(isSetOuch3()).compareTo(typedOther.isSetOuch3());\n+      if (lastComparison != 0) {\n+        return lastComparison;\n+      }\n+      if (isSetOuch3()) {\n+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch3, typedOther.ouch3);\n+        if (lastComparison != 0) {\n+          return lastComparison;\n+        }\n+      }\n       return 0;\n     }\n \n@@ -42559,6 +42745,14 @@ public String toString() {\n         sb.append(this.ouch2);\n       }\n       first = false;\n+      if (!first) sb.append(\", \");\n+      sb.append(\"ouch3:\");\n+      if (this.ouch3 == null) {\n+        sb.append(\"null\");\n+      } else {\n+        sb.append(this.ouch3);\n+      }\n+      first = false;\n       sb.append(\")\");\n       return sb.toString();\n     }\n@@ -42620,6 +42814,15 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, removeTableProperty\n                 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n               }\n               break;\n+            case 3: // OUCH3\n+              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\n+                struct.ouch3 = new TableNotFoundException();\n+                struct.ouch3.read(iprot);\n+                struct.setOuch3IsSet(true);\n+              } else { \n+                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n+              }\n+              break;\n             default:\n               org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n           }\n@@ -42645,6 +42848,11 @@ public void write(org.apache.thrift.protocol.TProtocol oprot, removeTablePropert\n           struct.ouch2.write(oprot);\n           oprot.writeFieldEnd();\n         }\n+        if (struct.ouch3 != null) {\n+          oprot.writeFieldBegin(OUCH3_FIELD_DESC);\n+          struct.ouch3.write(oprot);\n+          oprot.writeFieldEnd();\n+        }\n         oprot.writeFieldStop();\n         oprot.writeStructEnd();\n       }\n@@ -42669,19 +42877,25 @@ public void write(org.apache.thrift.protocol.TProtocol prot, removeTableProperty\n         if (struct.isSetOuch2()) {\n           optionals.set(1);\n         }\n-        oprot.writeBitSet(optionals, 2);\n+        if (struct.isSetOuch3()) {\n+          optionals.set(2);\n+        }\n+        oprot.writeBitSet(optionals, 3);\n         if (struct.isSetOuch1()) {\n           struct.ouch1.write(oprot);\n         }\n         if (struct.isSetOuch2()) {\n           struct.ouch2.write(oprot);\n         }\n+        if (struct.isSetOuch3()) {\n+          struct.ouch3.write(oprot);\n+        }\n       }\n \n       @Override\n       public void read(org.apache.thrift.protocol.TProtocol prot, removeTableProperty_result struct) throws org.apache.thrift.TException {\n         TTupleProtocol iprot = (TTupleProtocol) prot;\n-        BitSet incoming = iprot.readBitSet(2);\n+        BitSet incoming = iprot.readBitSet(3);\n         if (incoming.get(0)) {\n           struct.ouch1 = new AccumuloException();\n           struct.ouch1.read(iprot);\n@@ -42692,6 +42906,11 @@ public void read(org.apache.thrift.protocol.TProtocol prot, removeTableProperty_\n           struct.ouch2.read(iprot);\n           struct.setOuch2IsSet(true);\n         }\n+        if (incoming.get(2)) {\n+          struct.ouch3 = new TableNotFoundException();\n+          struct.ouch3.read(iprot);\n+          struct.setOuch3IsSet(true);\n+        }\n       }\n     }\n \n@@ -45818,6 +46037,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, setTableProperty_arg\n \n     private static final org.apache.thrift.protocol.TField OUCH1_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch1\", org.apache.thrift.protocol.TType.STRUCT, (short)1);\n     private static final org.apache.thrift.protocol.TField OUCH2_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch2\", org.apache.thrift.protocol.TType.STRUCT, (short)2);\n+    private static final org.apache.thrift.protocol.TField OUCH3_FIELD_DESC = new org.apache.thrift.protocol.TField(\"ouch3\", org.apache.thrift.protocol.TType.STRUCT, (short)3);\n \n     private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();\n     static {\n@@ -45827,11 +46047,13 @@ public void read(org.apache.thrift.protocol.TProtocol prot, setTableProperty_arg\n \n     public AccumuloException ouch1; // required\n     public AccumuloSecurityException ouch2; // required\n+    public TableNotFoundException ouch3; // required\n \n     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */\n     @SuppressWarnings(\"all\") public enum _Fields implements org.apache.thrift.TFieldIdEnum {\n       OUCH1((short)1, \"ouch1\"),\n-      OUCH2((short)2, \"ouch2\");\n+      OUCH2((short)2, \"ouch2\"),\n+      OUCH3((short)3, \"ouch3\");\n \n       private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();\n \n@@ -45850,6 +46072,8 @@ public static _Fields findByThriftId(int fieldId) {\n             return OUCH1;\n           case 2: // OUCH2\n             return OUCH2;\n+          case 3: // OUCH3\n+            return OUCH3;\n           default:\n             return null;\n         }\n@@ -45897,6 +46121,8 @@ public String getFieldName() {\n           new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n       tmpMap.put(_Fields.OUCH2, new org.apache.thrift.meta_data.FieldMetaData(\"ouch2\", org.apache.thrift.TFieldRequirementType.DEFAULT, \n           new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n+      tmpMap.put(_Fields.OUCH3, new org.apache.thrift.meta_data.FieldMetaData(\"ouch3\", org.apache.thrift.TFieldRequirementType.DEFAULT, \n+          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRUCT)));\n       metaDataMap = Collections.unmodifiableMap(tmpMap);\n       org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(setTableProperty_result.class, metaDataMap);\n     }\n@@ -45906,11 +46132,13 @@ public setTableProperty_result() {\n \n     public setTableProperty_result(\n       AccumuloException ouch1,\n-      AccumuloSecurityException ouch2)\n+      AccumuloSecurityException ouch2,\n+      TableNotFoundException ouch3)\n     {\n       this();\n       this.ouch1 = ouch1;\n       this.ouch2 = ouch2;\n+      this.ouch3 = ouch3;\n     }\n \n     /**\n@@ -45923,6 +46151,9 @@ public setTableProperty_result(setTableProperty_result other) {\n       if (other.isSetOuch2()) {\n         this.ouch2 = new AccumuloSecurityException(other.ouch2);\n       }\n+      if (other.isSetOuch3()) {\n+        this.ouch3 = new TableNotFoundException(other.ouch3);\n+      }\n     }\n \n     public setTableProperty_result deepCopy() {\n@@ -45933,6 +46164,7 @@ public setTableProperty_result deepCopy() {\n     public void clear() {\n       this.ouch1 = null;\n       this.ouch2 = null;\n+      this.ouch3 = null;\n     }\n \n     public AccumuloException getOuch1() {\n@@ -45983,6 +46215,30 @@ public void setOuch2IsSet(boolean value) {\n       }\n     }\n \n+    public TableNotFoundException getOuch3() {\n+      return this.ouch3;\n+    }\n+\n+    public setTableProperty_result setOuch3(TableNotFoundException ouch3) {\n+      this.ouch3 = ouch3;\n+      return this;\n+    }\n+\n+    public void unsetOuch3() {\n+      this.ouch3 = null;\n+    }\n+\n+    /** Returns true if field ouch3 is set (has been assigned a value) and false otherwise */\n+    public boolean isSetOuch3() {\n+      return this.ouch3 != null;\n+    }\n+\n+    public void setOuch3IsSet(boolean value) {\n+      if (!value) {\n+        this.ouch3 = null;\n+      }\n+    }\n+\n     public void setFieldValue(_Fields field, Object value) {\n       switch (field) {\n       case OUCH1:\n@@ -46001,6 +46257,14 @@ public void setFieldValue(_Fields field, Object value) {\n         }\n         break;\n \n+      case OUCH3:\n+        if (value == null) {\n+          unsetOuch3();\n+        } else {\n+          setOuch3((TableNotFoundException)value);\n+        }\n+        break;\n+\n       }\n     }\n \n@@ -46012,6 +46276,9 @@ public Object getFieldValue(_Fields field) {\n       case OUCH2:\n         return getOuch2();\n \n+      case OUCH3:\n+        return getOuch3();\n+\n       }\n       throw new IllegalStateException();\n     }\n@@ -46027,6 +46294,8 @@ public boolean isSet(_Fields field) {\n         return isSetOuch1();\n       case OUCH2:\n         return isSetOuch2();\n+      case OUCH3:\n+        return isSetOuch3();\n       }\n       throw new IllegalStateException();\n     }\n@@ -46062,6 +46331,15 @@ public boolean equals(setTableProperty_result that) {\n           return false;\n       }\n \n+      boolean this_present_ouch3 = true && this.isSetOuch3();\n+      boolean that_present_ouch3 = true && that.isSetOuch3();\n+      if (this_present_ouch3 || that_present_ouch3) {\n+        if (!(this_present_ouch3 && that_present_ouch3))\n+          return false;\n+        if (!this.ouch3.equals(that.ouch3))\n+          return false;\n+      }\n+\n       return true;\n     }\n \n@@ -46098,6 +46376,16 @@ public int compareTo(setTableProperty_result other) {\n           return lastComparison;\n         }\n       }\n+      lastComparison = Boolean.valueOf(isSetOuch3()).compareTo(typedOther.isSetOuch3());\n+      if (lastComparison != 0) {\n+        return lastComparison;\n+      }\n+      if (isSetOuch3()) {\n+        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.ouch3, typedOther.ouch3);\n+        if (lastComparison != 0) {\n+          return lastComparison;\n+        }\n+      }\n       return 0;\n     }\n \n@@ -46133,6 +46421,14 @@ public String toString() {\n         sb.append(this.ouch2);\n       }\n       first = false;\n+      if (!first) sb.append(\", \");\n+      sb.append(\"ouch3:\");\n+      if (this.ouch3 == null) {\n+        sb.append(\"null\");\n+      } else {\n+        sb.append(this.ouch3);\n+      }\n+      first = false;\n       sb.append(\")\");\n       return sb.toString();\n     }\n@@ -46194,6 +46490,15 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, setTableProperty_re\n                 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n               }\n               break;\n+            case 3: // OUCH3\n+              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {\n+                struct.ouch3 = new TableNotFoundException();\n+                struct.ouch3.read(iprot);\n+                struct.setOuch3IsSet(true);\n+              } else { \n+                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n+              }\n+              break;\n             default:\n               org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);\n           }\n@@ -46219,6 +46524,11 @@ public void write(org.apache.thrift.protocol.TProtocol oprot, setTableProperty_r\n           struct.ouch2.write(oprot);\n           oprot.writeFieldEnd();\n         }\n+        if (struct.ouch3 != null) {\n+          oprot.writeFieldBegin(OUCH3_FIELD_DESC);\n+          struct.ouch3.write(oprot);\n+          oprot.writeFieldEnd();\n+        }\n         oprot.writeFieldStop();\n         oprot.writeStructEnd();\n       }\n@@ -46243,19 +46553,25 @@ public void write(org.apache.thrift.protocol.TProtocol prot, setTableProperty_re\n         if (struct.isSetOuch2()) {\n           optionals.set(1);\n         }\n-        oprot.writeBitSet(optionals, 2);\n+        if (struct.isSetOuch3()) {\n+          optionals.set(2);\n+        }\n+        oprot.writeBitSet(optionals, 3);\n         if (struct.isSetOuch1()) {\n           struct.ouch1.write(oprot);\n         }\n         if (struct.isSetOuch2()) {\n           struct.ouch2.write(oprot);\n         }\n+        if (struct.isSetOuch3()) {\n+          struct.ouch3.write(oprot);\n+        }\n       }\n \n       @Override\n       public void read(org.apache.thrift.protocol.TProtocol prot, setTableProperty_result struct) throws org.apache.thrift.TException {\n         TTupleProtocol iprot = (TTupleProtocol) prot;\n-        BitSet incoming = iprot.readBitSet(2);\n+        BitSet incoming = iprot.readBitSet(3);\n         if (incoming.get(0)) {\n           struct.ouch1 = new AccumuloException();\n           struct.ouch1.read(iprot);\n@@ -46266,6 +46582,11 @@ public void read(org.apache.thrift.protocol.TProtocol prot, setTableProperty_res\n           struct.ouch2.read(iprot);\n           struct.setOuch2IsSet(true);\n         }\n+        if (incoming.get(2)) {\n+          struct.ouch3 = new TableNotFoundException();\n+          struct.ouch3.read(iprot);\n+          struct.setOuch3IsSet(true);\n+        }\n       }\n     }\n \n",
        "project": "accumulo",
        "linesAdd": 350,
        "jira_id": "1199",
        "nb_skipped": 0,
        "commit": "813109d7",
        "nb_failure": 0,
        "linesRem": 24,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 411,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.util.StatTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/Stat.java b/core/src/main/java/org/apache/accumulo/core/util/Stat.java\nindex e65265c6d..d2d560eac 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/Stat.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/Stat.java\n@@ -16,54 +16,66 @@\n  */\n package org.apache.accumulo.core.util;\n \n-public class Stat {\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+import org.apache.commons.math.stat.descriptive.moment.StandardDeviation;\n+import org.apache.commons.math.stat.descriptive.rank.Max;\n+import org.apache.commons.math.stat.descriptive.rank.Min;\n+import org.apache.commons.math.stat.descriptive.summary.Sum;\n \n-  long max = Long.MIN_VALUE;\n-  long min = Long.MAX_VALUE;\n-  long sum = 0;\n-  int count = 0;\n-  double partialStdDev = 0;\n+public class Stat {\n+  Min min;\n+  Max max;\n+  Sum sum;\n+  Mean mean;\n+  StandardDeviation sd;\n \n-  public void addStat(long stat) {\n-    if (stat > max)\n-      max = stat;\n-    if (stat < min)\n-      min = stat;\n+  StorelessUnivariateStatistic[] stats;\n \n-    sum += stat;\n+  public Stat() {\n+    min = new Min();\n+    max = new Max();\n+    sum = new Sum();\n+    mean = new Mean();\n+    sd = new StandardDeviation();\n \n-    partialStdDev += stat * stat;\n+    stats = new StorelessUnivariateStatistic[] {min, max, sum, mean, sd};\n+  }\n \n-    count++;\n+  public void addStat(long stat) {\n+    for (StorelessUnivariateStatistic statistic : stats) {\n+      statistic.increment(stat);\n+    }\n   }\n \n   public long getMin() {\n-    return min;\n+    return (long) min.getResult();\n   }\n \n   public long getMax() {\n-    return max;\n+    return (long) max.getResult();\n+  }\n+\n+  public long getSum() {\n+    return (long) sum.getResult();\n   }\n \n   public double getAverage() {\n-    return ((double) sum) / count;\n+    return mean.getResult();\n   }\n \n   public double getStdDev() {\n-    return Math.sqrt(partialStdDev / count - getAverage() * getAverage());\n+    return sd.getResult();\n   }\n \n   public String toString() {\n-    return String.format(\"%,d %,d %,.2f %,d\", getMin(), getMax(), getAverage(), count);\n+    return String.format(\"%,d %,d %,.2f %,d\", getMin(), getMax(), getAverage(), mean.getN());\n   }\n \n   public void clear() {\n-    sum = 0;\n-    count = 0;\n-    partialStdDev = 0;\n+    for (StorelessUnivariateStatistic statistic : stats) {\n+      statistic.clear();\n     }\n-  \n-  public long getSum() {\n-    return sum;\n   }\n+\n }\n",
        "project": "accumulo",
        "linesAdd": 37,
        "jira_id": "2494",
        "nb_skipped": 0,
        "commit": "0dc92ca1",
        "nb_failure": 2,
        "linesRem": 25,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 411,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mock.MockTableOperationsTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\nindex f088b1f3d..dc4a619d7 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n@@ -55,9 +55,9 @@\n import org.apache.hadoop.io.Text;\n \n public class MockTableOperations extends TableOperationsHelper {\n-\n-  final private MockAccumulo acu;\n-  final private String username;\n+  private static final byte[] ZERO = {0};\n+  private final MockAccumulo acu;\n+  private final String username;\n \n   MockTableOperations(MockAccumulo acu, String username) {\n     this.acu = acu;\n@@ -314,7 +314,11 @@ public void deleteRows(String tableName, Text start, Text end) throws AccumuloEx\n     if (!exists(tableName))\n       throw new TableNotFoundException(tableName, tableName, \"\");\n     MockTable t = acu.tables.get(tableName);\n-    Set<Key> keep = new TreeSet<Key>(t.table.tailMap(new Key(start)).headMap(new Key(end)).keySet());\n+    Text startText = new Text(start);\n+    Text endText = new Text(end);\n+    startText.append(ZERO, 0, 1);\n+    endText.append(ZERO, 0, 1);\n+    Set<Key> keep = new TreeSet<Key>(t.table.subMap(new Key(startText), new Key(endText)).keySet());\n     t.table.keySet().removeAll(keep);\n   }\n \n",
        "project": "accumulo",
        "linesAdd": 8,
        "jira_id": "2544",
        "nb_skipped": 0,
        "commit": "7ec60f1b",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 432,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.util.shell.command.FormatterCommandTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\nindex 5ff340b0a..0fbe879d4 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockShell.java\n@@ -44,15 +44,19 @@ public MockShell(InputStream in, Writer writer) throws IOException {\n     this.writer = writer;\n   }\n \n+  @Override\n   public boolean config(String... args) {\n-    configError = super.config(args);\n+    // If configuring the shell failed, fail quickly\n+    if (!super.config(args)) {\n+      return false;\n+    }\n \n     // Update the ConsoleReader with the input and output \"redirected\"\n     try {\n       this.reader = new ConsoleReader(in, writer);\n     } catch (Exception e) {\n       printException(e);\n-      configError = true;\n+      return false;\n     }\n \n     // Don't need this for testing purposes\n@@ -61,7 +65,7 @@ public boolean config(String... args) {\n \n     // Make the parsing from the client easier;\n     this.verbose = false;\n-    return configError;\n+    return true;\n   }\n \n   @Override\n@@ -71,9 +75,6 @@ protected void setInstance(CommandLine cl) {\n   }\n \n   public int start() throws IOException {\n-    if (configError)\n-      return 1;\n-\n     String input;\n     if (isVerbose())\n       printInfo();\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\nindex cc2053f6e..808d34025 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n@@ -185,7 +185,6 @@\n   private Token rootToken;\n   public final Map<String,Command> commandFactory = new TreeMap<String,Command>();\n   public final Map<String,Command[]> commandGrouping = new TreeMap<String,Command[]>();\n-  protected boolean configError = false;\n \n   // exit if true\n   private boolean exit = false;\n@@ -215,7 +214,11 @@ public Shell(ConsoleReader reader, PrintWriter writer) {\n     this.writer = writer;\n   }\n \n-  // Not for client use\n+  /**\n+   * Configures the shell using the provided options. Not for client use.\n+   *\n+   * @return true if the shell was successfully configured, false otherwise.\n+   */\n   public boolean config(String... args) {\n \n     CommandLine cl;\n@@ -225,9 +228,9 @@ public boolean config(String... args) {\n         throw new ParseException(\"Unrecognized arguments: \" + cl.getArgList());\n \n       if (cl.hasOption(helpOpt.getOpt())) {\n-        configError = true;\n         printHelp(\"shell\", SHELL_DESCRIPTION, opts);\n-        return true;\n+        exitCode = 0;\n+        return false;\n       }\n \n       setDebugging(cl.hasOption(debugOption.getLongOpt()));\n@@ -238,10 +241,10 @@ public boolean config(String... args) {\n         throw new MissingArgumentException(zooKeeperInstance);\n \n     } catch (Exception e) {\n-      configError = true;\n       printException(e);\n       printHelp(\"shell\", SHELL_DESCRIPTION, opts);\n-      return true;\n+      exitCode = 1;\n+      return false;\n     }\n \n     // get the options that were parsed\n@@ -316,7 +319,8 @@ public void start() {\n \n     } catch (Exception e) {\n       printException(e);\n-      configError = true;\n+      exitCode = 1;\n+      return false;\n     }\n \n     // decide whether to execute commands from a file and quit\n@@ -373,7 +377,7 @@ public void start() {\n     for (Command cmd : otherCommands) {\n       commandFactory.put(cmd.getName(), cmd);\n     }\n-    return configError;\n+    return true;\n   }\n \n   protected void setInstance(CommandLine cl) {\n@@ -408,15 +412,14 @@ public Connector getConnector() {\n \n   public static void main(String args[]) throws IOException {\n     Shell shell = new Shell();\n-    shell.config(args);\n+    if (!shell.config(args)) {\n+      System.exit(shell.getExitCode());\n+    }\n \n     System.exit(shell.start());\n   }\n \n   public int start() throws IOException {\n-    if (configError)\n-      return 1;\n-\n     String input;\n     if (isVerbose())\n       printInfo();\n",
        "project": "accumulo",
        "linesAdd": 16,
        "jira_id": "3475",
        "nb_skipped": 0,
        "commit": "7651b777",
        "nb_failure": 1,
        "linesRem": 17,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 601,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.data.ValueTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/data/Value.java b/core/src/main/java/org/apache/accumulo/core/data/Value.java\nindex 39ebbd0b2..11e60e159 100644\n--- a/core/src/main/java/org/apache/accumulo/core/data/Value.java\n+++ b/core/src/main/java/org/apache/accumulo/core/data/Value.java\n@@ -25,6 +25,8 @@\n import java.nio.ByteBuffer;\n import java.util.List;\n \n+import com.google.common.base.Preconditions;\n+\n import org.apache.accumulo.core.Constants;\n import org.apache.hadoop.io.BytesWritable;\n import org.apache.hadoop.io.WritableComparable;\n@@ -36,39 +38,52 @@\n  * 'immutable'.\n  */\n public class Value implements WritableComparable<Object> {\n+  private static final byte[] EMPTY = new byte[0];\n   protected byte[] value;\n \n   /**\n    * Create a zero-size sequence.\n    */\n   public Value() {\n-    super();\n+    this(EMPTY, false);\n   }\n   \n   /**\n    * Create a Value using the byte array as the initial value.\n    * \n-   * @param bytes\n-   *          This array becomes the backing storage for the object.\n+   * @param bytes May not be null\n    */\n-  \n   public Value(byte[] bytes) {\n     this(bytes, false);\n   }\n   \n+  /**\n+   * Create a Value using a copy of the ByteBuffer's content.\n+   * \n+   * @param bytes May not be null\n+   */\n   public Value(ByteBuffer bytes) {\n+    /* TODO ACCUMULO-2509 right now this uses the entire backing array, which must be accessible. */\n     this(toBytes(bytes), false);\n   }\n   \n   /**\n+   * @param bytes may not be null\n    * @deprecated A copy of the bytes in the buffer is always made. Use {@link #Value(ByteBuffer)} instead.\n    */\n   @Deprecated\n   public Value(ByteBuffer bytes, boolean copy) {\n+    /* TODO ACCUMULO-2509 right now this uses the entire backing array, which must be accessible. */\n     this(toBytes(bytes), false);\n   }\n   \n+  /**\n+   * Create a Value based on the given bytes.\n+   * @param bytes may not be null\n+   * @param copy signal if Value must make its own copy of bytes, or if it can use the array directly.\n+   */\n   public Value(byte[] bytes, boolean copy) {\n+    Preconditions.checkNotNull(bytes);\n     if (!copy) {\n       this.value = bytes;\n     } else {\n@@ -81,8 +96,7 @@ public Value(byte[] bytes, boolean copy) {\n   /**\n    * Set the new Value to a copy of the contents of the passed <code>ibw</code>.\n    * \n-   * @param ibw\n-   *          the value to set this Value to.\n+   * @param ibw may not be null.\n    */\n   public Value(final Value ibw) {\n     this(ibw.get(), 0, ibw.getSize());\n@@ -91,55 +105,49 @@ public Value(final Value ibw) {\n   /**\n    * Set the value to a copy of the given byte range\n    * \n-   * @param newData\n-   *          the new values to copy in\n+   * @param newData source of copy, may not be null\n    * @param offset\n    *          the offset in newData to start at\n    * @param length\n    *          the number of bytes to copy\n    */\n   public Value(final byte[] newData, final int offset, final int length) {\n+    Preconditions.checkNotNull(newData);\n     this.value = new byte[length];\n     System.arraycopy(newData, offset, this.value, 0, length);\n   }\n   \n   /**\n-   * Get the data from the BytesWritable.\n-   * \n-   * @return The data is only valid between 0 and getSize() - 1.\n+   * @return the underlying byte array directly.\n    */\n   public byte[] get() {\n-    if (this.value == null) {\n-      throw new IllegalStateException(\"Uninitialized. Null constructor \" + \"called w/o accompanying readFields invocation\");\n-    }\n+    assert(null != value);\n     return this.value;\n   }\n   \n   /**\n-   * @param b\n-   *          Use passed bytes as backing array for this instance.\n+   * @param b Use passed bytes as backing array for this instance, may not be null.\n    */\n   public void set(final byte[] b) {\n+    Preconditions.checkNotNull(b);\n     this.value = b;\n   }\n   \n   /**\n    * \n-   * @param b\n-   *          copy bytes\n+   * @param b copy the given byte array, may not be null.\n    */\n   public void copy(byte[] b) {\n+    Preconditions.checkNotNull(b);\n     this.value = new byte[b.length];\n     System.arraycopy(b, 0, this.value, 0, b.length);\n   }\n   \n   /**\n-   * @return the current size of the buffer.\n+   * @return the current size of the underlying buffer.\n    */\n   public int getSize() {\n-    if (this.value == null) {\n-      throw new IllegalStateException(\"Uninitialized. Null constructor \" + \"called w/o accompanying readFields invocation\");\n-    }\n+    assert(null != value);\n     return this.value.length;\n   }\n   \n",
        "project": "accumulo",
        "linesAdd": 10,
        "jira_id": "2487",
        "nb_skipped": 1,
        "commit": "f2920c26",
        "nb_failure": 3,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 158,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.server.fs.VolumeManagerImplTest"
        ],
        "patch": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java b/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\nindex 9ebdef481..2cdd3fe6f 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\n@@ -37,6 +37,7 @@\n import org.apache.accumulo.core.conf.Property;\n import org.apache.accumulo.core.data.Key;\n import org.apache.accumulo.core.data.KeyExtent;\n+import org.apache.accumulo.core.file.rfile.RFile;\n import org.apache.accumulo.core.util.CachedConfiguration;\n import org.apache.accumulo.core.volume.NonConfiguredVolume;\n import org.apache.accumulo.core.volume.Volume;\n@@ -55,6 +56,7 @@\n import org.apache.hadoop.hdfs.DFSConfigKeys;\n import org.apache.hadoop.hdfs.DistributedFileSystem;\n import org.apache.hadoop.util.Progressable;\n+import org.apache.hadoop.util.StringUtils;\n import org.apache.log4j.Logger;\n \n import com.google.common.collect.HashMultimap;\n@@ -538,10 +540,30 @@ public Path getFullPath(FileType fileType, String path) {\n       }\n     }\n \n-    // normalize the path\n-    Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());\n     if (path.startsWith(\"/\"))\n       path = path.substring(1);\n+\n+    // ACCUMULO-2974 To ensure that a proper absolute path is created, the caller needs to include the table ID\n+    // in the relative path. Fail when this doesn't appear to happen.\n+    if (FileType.TABLE == fileType) {\n+      // Trailing slash doesn't create an additional element\n+      String[] pathComponents = StringUtils.split(path, Path.SEPARATOR_CHAR);\n+\n+      // Is an rfile\n+      if (path.endsWith(RFile.EXTENSION)) {\n+        if (pathComponents.length < 3) {\n+          throw new IllegalArgumentException(\"Fewer components in file path than expected\");\n+        }\n+      } else {\n+        // is a directory\n+        if (pathComponents.length < 2) {\n+          throw new IllegalArgumentException(\"Fewer components in directory path than expected\");\n+        }\n+      }\n+    }\n+\n+    // normalize the path\n+    Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());\n     fullPath = new Path(fullPath, path);\n \n     FileSystem fs = getVolumeByPath(fullPath).getFileSystem();\ndiff --git a/server/master/src/main/java/org/apache/accumulo/master/TabletGroupWatcher.java b/server/master/src/main/java/org/apache/accumulo/master/TabletGroupWatcher.java\nindex d72abd29d..fbc97381f 100644\n--- a/server/master/src/main/java/org/apache/accumulo/master/TabletGroupWatcher.java\n+++ b/server/master/src/main/java/org/apache/accumulo/master/TabletGroupWatcher.java\n@@ -80,6 +80,7 @@\n import org.apache.accumulo.server.tables.TableManager;\n import org.apache.accumulo.server.tablets.TabletTime;\n import org.apache.accumulo.server.util.MetadataTableUtil;\n+import org.apache.hadoop.fs.Path;\n import org.apache.hadoop.io.Text;\n import org.apache.thrift.TException;\n \n@@ -512,7 +513,10 @@ private void deleteTablets(MergeInfo info) throws AccumuloException {\n         } else if (key.compareColumnFamily(TabletsSection.CurrentLocationColumnFamily.NAME) == 0) {\n           throw new IllegalStateException(\"Tablet \" + key.getRow() + \" is assigned during a merge!\");\n         } else if (TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.hasColumns(key)) {\n-          datafiles.add(new FileRef(entry.getValue().toString(), this.master.fs.getFullPath(FileType.TABLE, entry.getValue().toString())));\n+          // ACCUMULO-2974 Need to include the TableID when converting a relative path to an absolute path.\n+          // The value has the leading path separator already included so it doesn't need it included.\n+          datafiles.add(new FileRef(entry.getValue().toString(), this.master.fs.getFullPath(FileType.TABLE, Path.SEPARATOR + extent.getTableId()\n+              + entry.getValue().toString())));\n           if (datafiles.size() > 1000) {\n             MetadataTableUtil.addDeleteEntries(extent, datafiles, SystemCredentials.get());\n             datafiles.clear();\n",
        "project": "accumulo",
        "linesAdd": 21,
        "jira_id": "2974",
        "nb_skipped": 2,
        "commit": "5eceb10e",
        "nb_failure": 4,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 14,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.gc.GarbageCollectionTest"
        ],
        "patch": "diff --git a/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectionAlgorithm.java b/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectionAlgorithm.java\nindex 464d0d998..40fb8475b 100644\n--- a/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectionAlgorithm.java\n+++ b/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectionAlgorithm.java\n@@ -85,10 +85,7 @@ private String makeRelative(String path, int expectedLen) {\n       tokens = tmp.toArray(new String[tmp.size()]);\n     }\n \n-    if (tokens.length > 3) {\n-      if (!path.contains(\":\"))\n-        throw new IllegalArgumentException(path);\n-\n+    if (tokens.length > 3 && path.contains(\":\")) {\n       if (tokens[tokens.length - 4].equals(ServerConstants.TABLE_DIR) && (expectedLen == 0 || expectedLen == 3)) {\n         relPath = tokens[tokens.length - 3] + \"/\" + tokens[tokens.length - 2] + \"/\" + tokens[tokens.length - 1];\n       } else if (tokens[tokens.length - 3].equals(ServerConstants.TABLE_DIR) && (expectedLen == 0 || expectedLen == 2)) {\n@@ -96,9 +93,9 @@ private String makeRelative(String path, int expectedLen) {\n       } else {\n         throw new IllegalArgumentException(path);\n       }\n-    } else if (tokens.length == 3 && (expectedLen == 0 || expectedLen == 3)) {\n+    } else if (tokens.length == 3 && (expectedLen == 0 || expectedLen == 3) && !path.contains(\":\")) {\n       relPath = tokens[0] + \"/\" + tokens[1] + \"/\" + tokens[2];\n-    } else if (tokens.length == 2 && (expectedLen == 0 || expectedLen == 2)) {\n+    } else if (tokens.length == 2 && (expectedLen == 0 || expectedLen == 2) && !path.contains(\":\")) {\n       relPath = tokens[0] + \"/\" + tokens[1];\n     } else {\n       throw new IllegalArgumentException(path);\n@@ -112,7 +109,13 @@ private String makeRelative(String path, int expectedLen) {\n     SortedMap<String,String> ret = new TreeMap<String,String>();\n \n     for (String candidate : candidates) {\n-      String relPath = makeRelative(candidate, 0);\n+      String relPath;\n+      try {\n+        relPath = makeRelative(candidate, 0);\n+      } catch (IllegalArgumentException iae) {\n+        log.warn(\"Ingoring invalid deletion candidate \" + candidate);\n+        continue;\n+      }\n       ret.put(relPath, candidate);\n     }\n \n",
        "project": "accumulo",
        "linesAdd": 10,
        "jira_id": "2520",
        "nb_skipped": 0,
        "commit": "a64151e6",
        "nb_failure": 0,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 0,
        "nb_test": 697,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.lexicoder.ReverseLexicoderTest"
        ],
        "patch": "",
        "project": "accumulo",
        "linesAdd": 0,
        "jira_id": "3385",
        "nb_skipped": 2,
        "commit": "a3267d3e",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 415,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.BatchWriterConfigTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/BatchWriterConfig.java b/core/src/main/java/org/apache/accumulo/core/client/BatchWriterConfig.java\nindex d3ad3fe43..28955f580 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/BatchWriterConfig.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/BatchWriterConfig.java\n@@ -24,6 +24,7 @@\n import java.util.List;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.commons.lang.builder.HashCodeBuilder;\n import org.apache.hadoop.io.Writable;\n import org.apache.hadoop.util.StringUtils;\n \n@@ -223,4 +224,70 @@ public void readFields(DataInput in) throws IOException {\n       }\n     }\n   }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (o instanceof BatchWriterConfig) {\n+      BatchWriterConfig other = (BatchWriterConfig) o;\n+\n+      if (null != maxMemory) {\n+        if (!maxMemory.equals(other.maxMemory)) {\n+          return false;\n+        }\n+      } else {\n+        if (null != other.maxMemory) {\n+          return false;\n+        }\n+      }\n+\n+      if (null != maxLatency) {\n+        if (!maxLatency.equals(other.maxLatency)) {\n+          return false;\n+        }\n+      } else {\n+        if (null != other.maxLatency) {\n+          return false;\n+        }\n+      }\n+\n+      if (null != maxWriteThreads) {\n+        if (!maxWriteThreads.equals(other.maxWriteThreads)) {\n+          return false;\n+        }\n+      } else {\n+        if (null != other.maxWriteThreads) {\n+          return false;\n+        }\n+      }\n+\n+      if (null != timeout) {\n+        if (!timeout.equals(other.timeout)) {\n+          return false;\n+        }\n+      } else {\n+        if (null != other.timeout) {\n+          return false;\n+        }\n+      }\n+\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    HashCodeBuilder hcb = new HashCodeBuilder();\n+    hcb.append(maxMemory).append(maxLatency).append(maxWriteThreads).append(timeout);\n+    return hcb.toHashCode();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder(32);\n+    sb.append(\"[maxMemory=\").append(getMaxMemory()).append(\", maxLatency=\").append(getMaxLatency(TimeUnit.MILLISECONDS)).append(\", maxWriteThreads=\")\n+        .append(getMaxWriteThreads()).append(\", timeout=\").append(getTimeout(TimeUnit.MILLISECONDS)).append(\"]\");\n+    return sb.toString();\n+  }\n }\n",
        "project": "accumulo",
        "linesAdd": 67,
        "jira_id": "2928",
        "nb_skipped": 0,
        "commit": "f99b5654",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 510,
        "nb_error": 0,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.accumulo.core.security.ColumnVisibilityTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/security/ColumnVisibility.java b/core/src/main/java/org/apache/accumulo/core/security/ColumnVisibility.java\nindex 55763bc09..f9c83827c 100644\n--- a/core/src/main/java/org/apache/accumulo/core/security/ColumnVisibility.java\n+++ b/core/src/main/java/org/apache/accumulo/core/security/ColumnVisibility.java\n@@ -302,6 +302,7 @@ Node parse_(byte[] expression) {\n                 result.add(c);\n             else\n               result.add(child);\n+            result.end = index - 1;\n             return result;\n           }\n           case '\"': {\n",
        "project": "accumulo",
        "linesAdd": 1,
        "jira_id": "1730",
        "nb_skipped": 0,
        "commit": "872b6db3",
        "nb_failure": 4,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 4,
        "nb_test": 17,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.test.replication.StatusCombinerMacTest"
        ],
        "patch": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/init/Initialize.java b/server/base/src/main/java/org/apache/accumulo/server/init/Initialize.java\nindex 0a681c409..9b952ba44 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/init/Initialize.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/init/Initialize.java\n@@ -20,6 +20,7 @@\n import java.io.IOException;\n import java.nio.charset.StandardCharsets;\n import java.util.Arrays;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Locale;\n@@ -31,6 +32,8 @@\n import org.apache.accumulo.core.Constants;\n import org.apache.accumulo.core.cli.Help;\n import org.apache.accumulo.core.client.AccumuloSecurityException;\n+import org.apache.accumulo.core.client.IteratorSetting;\n+import org.apache.accumulo.core.client.IteratorSetting.Column;\n import org.apache.accumulo.core.client.impl.Namespaces;\n import org.apache.accumulo.core.client.impl.thrift.ThriftSecurityException;\n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n@@ -41,6 +44,8 @@\n import org.apache.accumulo.core.data.Value;\n import org.apache.accumulo.core.file.FileOperations;\n import org.apache.accumulo.core.file.FileSKVWriter;\n+import org.apache.accumulo.core.iterators.Combiner;\n+import org.apache.accumulo.core.iterators.IteratorUtil.IteratorScope;\n import org.apache.accumulo.core.iterators.user.VersioningIterator;\n import org.apache.accumulo.core.master.state.tables.TableState;\n import org.apache.accumulo.core.master.thrift.MasterGoalState;\n@@ -65,10 +70,12 @@\n import org.apache.accumulo.server.fs.VolumeManager;\n import org.apache.accumulo.server.fs.VolumeManagerImpl;\n import org.apache.accumulo.server.iterators.MetadataBulkLoadFilter;\n+import org.apache.accumulo.server.replication.StatusCombiner;\n import org.apache.accumulo.server.security.AuditedSecurityOperation;\n import org.apache.accumulo.server.security.SystemCredentials;\n import org.apache.accumulo.server.tables.TableManager;\n import org.apache.accumulo.server.tablets.TabletTime;\n+import org.apache.accumulo.server.util.ReplicationTableUtil;\n import org.apache.accumulo.server.util.TablePropUtil;\n import org.apache.accumulo.server.zookeeper.ZooReaderWriter;\n import org.apache.hadoop.conf.Configuration;\n@@ -566,6 +573,23 @@ public static void initMetadataConfig(String tableId) throws IOException {\n   protected static void initMetadataConfig() throws IOException {\n     initMetadataConfig(RootTable.ID);\n     initMetadataConfig(MetadataTable.ID);\n+\n+    // ACCUMULO-3077 Set the combiner on accumulo.metadata during init to reduce the likelihood of a race\n+    // condition where a tserver compacts away Status updates because it didn't see the Combiner configured\n+    IteratorSetting setting = new IteratorSetting(9, ReplicationTableUtil.COMBINER_NAME, StatusCombiner.class);\n+    Combiner.setColumns(setting, Collections.singletonList(new Column(MetadataSchema.ReplicationSection.COLF)));\n+    try {\n+      for (IteratorScope scope : IteratorScope.values()) {\n+        String root = String.format(\"%s%s.%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase(), setting.getName());\n+        for (Entry<String,String> prop : setting.getOptions().entrySet()) {\n+          TablePropUtil.setTableProperty(MetadataTable.ID, root + \".opt.\" + prop.getKey(), prop.getValue());\n+        }\n+        TablePropUtil.setTableProperty(MetadataTable.ID, root, setting.getPriority() + \",\" + setting.getIteratorClass());\n+      }\n+    } catch (Exception e) {\n+      log.fatal(\"Error talking to ZooKeeper\", e);\n+      throw new IOException(e);\n+    }\n   }\n \n   private static void setMetadataReplication(int replication, String reason) throws IOException {\ndiff --git a/server/base/src/main/java/org/apache/accumulo/server/util/ReplicationTableUtil.java b/server/base/src/main/java/org/apache/accumulo/server/util/ReplicationTableUtil.java\nindex 2a9774d7f..ab5ee8622 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/util/ReplicationTableUtil.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/util/ReplicationTableUtil.java\n@@ -187,7 +187,7 @@ public static void updateLogs(Credentials creds, KeyExtent extent, Collection<Lo\n    */\n   public static void updateFiles(Credentials creds, KeyExtent extent, Collection<String> files, Status stat) {\n     if (log.isDebugEnabled()) {\n-      log.debug(\"Updating replication for \" + extent + \" with \" + files + \" using \" + ProtobufUtil.toString(stat));\n+      log.debug(\"Updating replication status for \" + extent + \" with \" + files + \" using \" + ProtobufUtil.toString(stat));\n     }\n     // TODO could use batch writer, would need to handle failure and retry like update does - ACCUMULO-1294\n     if (files.isEmpty()) {\ndiff --git a/server/tserver/src/main/java/org/apache/accumulo/tserver/log/TabletServerLogger.java b/server/tserver/src/main/java/org/apache/accumulo/tserver/log/TabletServerLogger.java\nindex b4f14ec7b..26e6891d5 100644\n--- a/server/tserver/src/main/java/org/apache/accumulo/tserver/log/TabletServerLogger.java\n+++ b/server/tserver/src/main/java/org/apache/accumulo/tserver/log/TabletServerLogger.java\n@@ -276,8 +276,8 @@ private int write(final Collection<CommitSession> sessions, boolean mincFinish,\n                   logs.add(logger.getFileName());\n                 }\n                 Status status = StatusUtil.fileCreated(System.currentTimeMillis());\n-                log.debug(\"Writing \" + ProtobufUtil.toString(status) + \" to replication table for \" + logs);\n-                // Got some new WALs, note this in the replication table\n+                log.debug(\"Writing \" + ProtobufUtil.toString(status) + \" to metadata table for \" + logs);\n+                // Got some new WALs, note this in the metadata table\n                 ReplicationTableUtil.updateFiles(SystemCredentials.get(), commitSession.getExtent(), logs, status);\n               }\n             }\ndiff --git a/server/tserver/src/main/java/org/apache/accumulo/tserver/tablet/DatafileManager.java b/server/tserver/src/main/java/org/apache/accumulo/tserver/tablet/DatafileManager.java\nindex 5b46b7bd5..78a2ed6d7 100644\n--- a/server/tserver/src/main/java/org/apache/accumulo/tserver/tablet/DatafileManager.java\n+++ b/server/tserver/src/main/java/org/apache/accumulo/tserver/tablet/DatafileManager.java\n@@ -424,6 +424,9 @@ void bringMinorCompactionOnline(FileRef tmpDatafile, FileRef newDatafile, FileRe\n       // This WAL could still be in use by other Tablets *from the same table*, so we can only mark that there is data to replicate,\n       // but it is *not* closed\n       if (replicate) {\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"Recording that data has been ingested into \" + tablet.getExtent() + \" using \" + logFileOnly);\n+        }\n         ReplicationTableUtil.updateFiles(SystemCredentials.get(), tablet.getExtent(), logFileOnly, StatusUtil.openWithUnknownLength());\n       }\n     } finally {\n",
        "project": "accumulo",
        "linesAdd": 27,
        "jira_id": "3077",
        "nb_skipped": 0,
        "commit": "17654199",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 33,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoaderTest"
        ],
        "patch": "diff --git a/start/src/main/java/org/apache/accumulo/start/classloader/vfs/AccumuloVFSClassLoader.java b/start/src/main/java/org/apache/accumulo/start/classloader/vfs/AccumuloVFSClassLoader.java\nindex 983ad7c8b..bd1f943ed 100644\n--- a/start/src/main/java/org/apache/accumulo/start/classloader/vfs/AccumuloVFSClassLoader.java\n+++ b/start/src/main/java/org/apache/accumulo/start/classloader/vfs/AccumuloVFSClassLoader.java\n@@ -92,8 +92,6 @@ public void run() {\n \n   public static final String VFS_CACHE_DIR = \"general.vfs.cache.dir\";\n   \n-  public static final AtomicInteger uniqueDirectoryGenerator = new AtomicInteger(0);\n-\n   private static ClassLoader parent = null;\n   private static volatile ReloadingClassLoader loader = null;\n   private static final Object lock = new Object();\n@@ -279,10 +277,7 @@ public static FileSystemManager generateVfs() throws FileSystemException {\n     vfs.addMimeTypeMap(\"application/zip\", \"zip\");\n     vfs.setFileContentInfoFactory(new FileContentInfoFilenameFactory());\n     vfs.setFilesCache(new SoftRefFilesCache());\n-    String cacheDirPath = AccumuloClassLoader.getAccumuloString(VFS_CACHE_DIR, \"\");\n     File cacheDir = computeTopCacheDir(); \n-    if (!cacheDirPath.isEmpty())\n-      cacheDir = new File(cacheDirPath, \"\" + uniqueDirectoryGenerator.getAndIncrement());\n     vfs.setReplicator(new UniqueFileReplicator(cacheDir));\n     vfs.setCacheStrategy(CacheStrategy.ON_RESOLVE);\n     vfs.init();\n@@ -291,8 +286,9 @@ public static FileSystemManager generateVfs() throws FileSystemException {\n   }\n \n   private static File computeTopCacheDir() {\n+    String cacheDirPath = AccumuloClassLoader.getAccumuloString(VFS_CACHE_DIR, System.getProperty(\"java.io.tmpdir\"));\n     String procName = ManagementFactory.getRuntimeMXBean().getName();\n-    return new File(System.getProperty(\"java.io.tmpdir\"), \"accumulo-vfs-cache-\" + procName + \"-\" + System.getProperty(\"user.name\", \"nouser\"));\n+    return new File(cacheDirPath, \"accumulo-vfs-cache-\" + procName + \"-\" + System.getProperty(\"user.name\", \"nouser\"));\n   }\n \n   public interface Printer {\n",
        "project": "accumulo",
        "linesAdd": 2,
        "jira_id": "3383",
        "nb_skipped": 1,
        "commit": "97f16db4",
        "nb_failure": 1,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 158,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.server.fs.VolumeManagerImplTest"
        ],
        "patch": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java b/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\nindex 9ebdef481..2cdd3fe6f 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java\n@@ -37,6 +37,7 @@\n import org.apache.accumulo.core.conf.Property;\n import org.apache.accumulo.core.data.Key;\n import org.apache.accumulo.core.data.KeyExtent;\n+import org.apache.accumulo.core.file.rfile.RFile;\n import org.apache.accumulo.core.util.CachedConfiguration;\n import org.apache.accumulo.core.volume.NonConfiguredVolume;\n import org.apache.accumulo.core.volume.Volume;\n@@ -55,6 +56,7 @@\n import org.apache.hadoop.hdfs.DFSConfigKeys;\n import org.apache.hadoop.hdfs.DistributedFileSystem;\n import org.apache.hadoop.util.Progressable;\n+import org.apache.hadoop.util.StringUtils;\n import org.apache.log4j.Logger;\n \n import com.google.common.collect.HashMultimap;\n@@ -538,10 +540,30 @@ public Path getFullPath(FileType fileType, String path) {\n       }\n     }\n \n-    // normalize the path\n-    Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());\n     if (path.startsWith(\"/\"))\n       path = path.substring(1);\n+\n+    // ACCUMULO-2974 To ensure that a proper absolute path is created, the caller needs to include the table ID\n+    // in the relative path. Fail when this doesn't appear to happen.\n+    if (FileType.TABLE == fileType) {\n+      // Trailing slash doesn't create an additional element\n+      String[] pathComponents = StringUtils.split(path, Path.SEPARATOR_CHAR);\n+\n+      // Is an rfile\n+      if (path.endsWith(RFile.EXTENSION)) {\n+        if (pathComponents.length < 3) {\n+          throw new IllegalArgumentException(\"Fewer components in file path than expected\");\n+        }\n+      } else {\n+        // is a directory\n+        if (pathComponents.length < 2) {\n+          throw new IllegalArgumentException(\"Fewer components in directory path than expected\");\n+        }\n+      }\n+    }\n+\n+    // normalize the path\n+    Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());\n     fullPath = new Path(fullPath, path);\n \n     FileSystem fs = getVolumeByPath(fullPath).getFileSystem();\ndiff --git a/server/master/src/main/java/org/apache/accumulo/master/TabletGroupWatcher.java b/server/master/src/main/java/org/apache/accumulo/master/TabletGroupWatcher.java\nindex d72abd29d..fbc97381f 100644\n--- a/server/master/src/main/java/org/apache/accumulo/master/TabletGroupWatcher.java\n+++ b/server/master/src/main/java/org/apache/accumulo/master/TabletGroupWatcher.java\n@@ -80,6 +80,7 @@\n import org.apache.accumulo.server.tables.TableManager;\n import org.apache.accumulo.server.tablets.TabletTime;\n import org.apache.accumulo.server.util.MetadataTableUtil;\n+import org.apache.hadoop.fs.Path;\n import org.apache.hadoop.io.Text;\n import org.apache.thrift.TException;\n \n@@ -512,7 +513,10 @@ private void deleteTablets(MergeInfo info) throws AccumuloException {\n         } else if (key.compareColumnFamily(TabletsSection.CurrentLocationColumnFamily.NAME) == 0) {\n           throw new IllegalStateException(\"Tablet \" + key.getRow() + \" is assigned during a merge!\");\n         } else if (TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.hasColumns(key)) {\n-          datafiles.add(new FileRef(entry.getValue().toString(), this.master.fs.getFullPath(FileType.TABLE, entry.getValue().toString())));\n+          // ACCUMULO-2974 Need to include the TableID when converting a relative path to an absolute path.\n+          // The value has the leading path separator already included so it doesn't need it included.\n+          datafiles.add(new FileRef(entry.getValue().toString(), this.master.fs.getFullPath(FileType.TABLE, Path.SEPARATOR + extent.getTableId()\n+              + entry.getValue().toString())));\n           if (datafiles.size() > 1000) {\n             MetadataTableUtil.addDeleteEntries(extent, datafiles, SystemCredentials.get());\n             datafiles.clear();\n",
        "project": "accumulo",
        "linesAdd": 21,
        "jira_id": "2974",
        "nb_skipped": 2,
        "commit": "5eceb10e",
        "nb_failure": 4,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 179,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.server.master.balancer.DefaultLoadBalancerTest"
        ],
        "patch": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/master/balancer/DefaultLoadBalancer.java b/server/base/src/main/java/org/apache/accumulo/server/master/balancer/DefaultLoadBalancer.java\nindex 46b9b5f5d..349040562 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/master/balancer/DefaultLoadBalancer.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/master/balancer/DefaultLoadBalancer.java\n@@ -86,7 +86,7 @@ public TServerInstance getAssignment(SortedMap<TServerInstance,TabletServerStatu\n   \n   static class ServerCounts implements Comparable<ServerCounts> {\n     public final TServerInstance server;\n-    public final int count;\n+    public int count;\n     public final TabletServerStatus status;\n     \n     ServerCounts(int count, TServerInstance server, TabletServerStatus status) {\n@@ -145,7 +145,7 @@ public boolean getMigrations(Map<TServerInstance,TabletServerStatus> current, Li\n       int end = totals.size() - 1;\n       int movedAlready = 0;\n       int tooManyIndex = 0;\n-      while (tooManyIndex < totals.size() && end > tooManyIndex) {\n+      while (tooManyIndex < end) {\n         ServerCounts tooMany = totals.get(tooManyIndex);\n         int goal = even;\n         if (tooManyIndex < numServersOverEven) {\n@@ -255,7 +255,8 @@ public TableDiff(int diff, String table) {\n         tooLittleCount = 0;\n       }\n       tooLittleMap.put(table, tooLittleCount + 1);\n-      \n+      tooMuch.count--;\n+      tooLittle.count++;\n       result.add(new TabletMigration(extent, tooMuch.server, tooLittle.server));\n     }\n     return result;\n",
        "project": "accumulo",
        "linesAdd": 4,
        "jira_id": "2952",
        "nb_skipped": 2,
        "commit": "11d11e0d",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 432,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.util.shell.ShellTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\nindex bb3c06e95..fa0f5d45a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java\n@@ -493,7 +493,7 @@ public void printVerboseInfo() throws IOException {\n     if (disableAuthTimeout)\n       sb.append(\"- Authorization timeout: disabled\\n\");\n     else\n-      sb.append(\"- Authorization timeout: \").append(String.format(\"%.2fs%n\", TimeUnit.NANOSECONDS.toSeconds(authTimeout)));\n+      sb.append(\"- Authorization timeout: \").append(String.format(\"%ds%n\", TimeUnit.NANOSECONDS.toSeconds(authTimeout)));\n     sb.append(\"- Debug: \").append(isDebuggingEnabled() ? \"on\" : \"off\").append(\"\\n\");\n     if (!scanIteratorOptions.isEmpty()) {\n       for (Entry<String,List<IteratorSetting>> entry : scanIteratorOptions.entrySet()) {\n",
        "project": "accumulo",
        "linesAdd": 1,
        "jira_id": "3229",
        "nb_skipped": 0,
        "commit": "891584fb",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 278,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.data.KeyTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/data/Key.java b/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\nindex 3d1f92db7..afab88733 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/data/Key.java\n@@ -22,6 +22,8 @@\n  * \n  */\n \n+import static org.apache.accumulo.core.util.ByteBufferUtil.toBytes;\n+\n import java.io.DataInput;\n import java.io.DataOutput;\n import java.io.IOException;\n@@ -38,8 +40,6 @@\n import org.apache.hadoop.io.WritableComparator;\n import org.apache.hadoop.io.WritableUtils;\n \n-import static org.apache.accumulo.core.util.ByteBufferUtil.toBytes;\n-\n public class Key implements WritableComparable<Key>, Cloneable {\n   \n   protected byte[] row;\n@@ -444,8 +444,10 @@ public int hashCode() {\n   }\n   \n   public static String toPrintableString(byte ba[], int offset, int len, int maxLen) {\n-    StringBuilder sb = new StringBuilder();\n+    return appendPrintableString(ba, offset, len, maxLen, new StringBuilder()).toString();\n+  }\n   \n+  public static StringBuilder appendPrintableString(byte ba[], int offset, int len, int maxLen, StringBuilder sb) {\n     int plen = Math.min(len, maxLen);\n     \n     for (int i = 0; i < plen; i++) {\n@@ -460,26 +462,33 @@ public static String toPrintableString(byte ba[], int offset, int len, int maxLe\n       sb.append(\"... TRUNCATED\");\n     }\n     \n-    return sb.toString();\n+    return sb;\n   }\n   \n-  public String toString() {\n-    String labelString = new ColumnVisibility(colVisibility).toString();\n+  private StringBuilder rowColumnStringBuilder() {\n+    StringBuilder sb = new StringBuilder();\n+    appendPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT, sb);\n+    sb.append(\" \");\n+    appendPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT, sb);\n+    sb.append(\":\");\n+    appendPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT, sb);\n+    sb.append(\" [\");\n+    appendPrintableString(colVisibility, 0, colVisibility.length, Constants.MAX_DATA_TO_PRINT, sb);\n+    sb.append(\"]\");\n+    return sb;\n+  }\n   \n-    String s = toPrintableString(row, 0, row.length, Constants.MAX_DATA_TO_PRINT) + \" \"\n-        + toPrintableString(colFamily, 0, colFamily.length, Constants.MAX_DATA_TO_PRINT) + \":\"\n-        + toPrintableString(colQualifier, 0, colQualifier.length, Constants.MAX_DATA_TO_PRINT) + \" \" + labelString + \" \" + Long.toString(timestamp) + \" \"\n-        + deleted;\n-    return s;\n+  public String toString() {\n+    StringBuilder sb = rowColumnStringBuilder();\n+    sb.append(\" \");\n+    sb.append(Long.toString(timestamp));\n+    sb.append(\" \");\n+    sb.append(deleted);\n+    return sb.toString();\n   }\n   \n   public String toStringNoTime() {\n-    \n-    String labelString = new ColumnVisibility(colVisibility).toString();\n-    \n-    String s = new String(row, 0, row.length) + \" \" + new String(colFamily, 0, colFamily.length) + \":\" + new String(colQualifier, 0, colQualifier.length) + \" \"\n-        + labelString;\n-    return s;\n+    return rowColumnStringBuilder().toString();\n   }\n   \n   public int getLength() {\n",
        "project": "accumulo",
        "linesAdd": 26,
        "jira_id": "193",
        "nb_skipped": 0,
        "commit": "8ad5a888",
        "nb_failure": 0,
        "linesRem": 17,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 266,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.iterators.user.RegExFilterTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\nindex 0b3b73f11..fb5380190 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n@@ -17,6 +17,7 @@\n package org.apache.accumulo.core.iterators.user;\n \n import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n import java.util.Map;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n@@ -28,7 +29,6 @@\n import org.apache.accumulo.core.iterators.Filter;\n import org.apache.accumulo.core.iterators.IteratorEnvironment;\n import org.apache.accumulo.core.iterators.SortedKeyValueIterator;\n-import org.apache.accumulo.core.util.ByteArrayBackedCharSequence;\n \n /**\n  * A Filter that matches entries based on Java regular expressions.\n@@ -52,6 +52,9 @@\n   public static final String COLQ_REGEX = \"colqRegex\";\n   public static final String VALUE_REGEX = \"valueRegex\";\n   public static final String OR_FIELDS = \"orFields\";\n+  public static final String ENCODING = \"encoding\";\n+  \n+  public static final String ENCODING_DEFAULT = \"UTF-8\";\n   \n   private Matcher rowMatcher;\n   private Matcher colfMatcher;\n@@ -59,10 +62,9 @@\n   private Matcher valueMatcher;\n   private boolean orFields = false;\n   \n-  private ByteArrayBackedCharSequence babcs = new ByteArrayBackedCharSequence();\n+  private String encoding = ENCODING_DEFAULT;\n   \n-  private Matcher copyMatcher(Matcher m)\n-  {\n+  private Matcher copyMatcher(Matcher m) {\n     if (m == null)\n       return m;\n     else\n@@ -71,21 +73,25 @@ private Matcher copyMatcher(Matcher m)\n   \n   private boolean matches(Matcher matcher, ByteSequence bs) {\n     if (matcher != null) {\n-      babcs.set(bs);\n-      matcher.reset(babcs);\n+      try {\n+        matcher.reset(new String(bs.getBackingArray(), bs.offset(), bs.length(), encoding));\n         return matcher.matches();\n+      } catch (UnsupportedEncodingException e) {\n+        e.printStackTrace();\n+      }\n     }\n-    \n     return !orFields;\n   }\n   \n   private boolean matches(Matcher matcher, byte data[], int offset, int len) {\n     if (matcher != null) {\n-      babcs.set(data, offset, len);\n-      matcher.reset(babcs);\n+      try {\n+        matcher.reset(new String(data, offset, len, encoding));\n         return matcher.matches();\n+      } catch (UnsupportedEncodingException e) {\n+        e.printStackTrace();\n+      }\n     }\n-    \n     return !orFields;\n   }\n   \n@@ -130,6 +136,10 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n     } else {\n       orFields = false;\n     }\n+    \n+    if (options.containsKey(ENCODING)) {\n+      encoding = options.get(ENCODING);\n+    }\n   }\n   \n   @Override\n@@ -142,6 +152,7 @@ public IteratorOptions describeOptions() {\n     io.addNamedOption(RegExFilter.COLQ_REGEX, \"regular expression on column qualifier\");\n     io.addNamedOption(RegExFilter.VALUE_REGEX, \"regular expression on value\");\n     io.addNamedOption(RegExFilter.OR_FIELDS, \"use OR instread of AND when multiple regexes given\");\n+    io.addNamedOption(RegExFilter.ENCODING, \"character encoding of byte array value (default is \" + ENCODING_DEFAULT + \")\");\n     return io;\n   }\n   \n@@ -160,6 +171,17 @@ public boolean validateOptions(Map<String,String> options) {\n     if (options.containsKey(VALUE_REGEX))\n       Pattern.compile(options.get(VALUE_REGEX)).matcher(\"\");\n     \n+    if (options.containsKey(ENCODING)) {\n+      try {\n+        this.encoding = options.get(ENCODING);\n+        @SuppressWarnings(\"unused\")\n+        String test = new String(\"test\".getBytes(), encoding);\n+      } catch (UnsupportedEncodingException e) {\n+        e.printStackTrace();\n+        return false;\n+      }\n+    }\n+    \n     return true;\n   }\n   \n@@ -192,4 +214,19 @@ public static void setRegexs(IteratorSetting si, String rowTerm, String cfTerm,\n       si.addOption(RegExFilter.OR_FIELDS, \"true\");\n     }\n   }\n+  \n+  /**\n+   * Set the encoding string to use when interpreting characters\n+   * \n+   * @param si\n+   *          ScanIterator config to be updated\n+   * @param encoding\n+   *          the encoding string to use for character interpretation.\n+   * \n+   */\n+  public static void setEncoding(IteratorSetting si, String encoding) {\n+    if (!encoding.isEmpty()) {\n+      si.addOption(RegExFilter.ENCODING, encoding);\n+    }\n+  }\n }\n",
        "project": "accumulo",
        "linesAdd": 38,
        "jira_id": "209",
        "nb_skipped": 0,
        "commit": "76d727f0",
        "nb_failure": 1,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 722,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.util.shell.commands.CompactCommandTest",
            "org.apache.accumulo.core.util.shell.commands.MergeCommandTest",
            "org.apache.accumulo.core.util.shell.commands.DeleteRowsCommandTest",
            "org.apache.accumulo.core.util.shell.commands.FlushCommandTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\nindex 432f17a38..99e09e362 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\n@@ -117,7 +117,7 @@ public static OptionGroup addListDeleteGroup(final String name) {\n   }\n \n   public static Option startRowOpt() {\n-    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (NOT) inclusive\");\n+    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (exclusive)\");\n     o.setArgName(\"begin-row\");\n     return o;\n   }\n",
        "project": "accumulo",
        "linesAdd": 1,
        "jira_id": "4138",
        "nb_skipped": 2,
        "commit": "4d23d784",
        "nb_failure": 4,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.minicluster.MiniAccumuloClusterTest"
        ],
        "patch": "diff --git a/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java b/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\nindex 7c27dd817..43fa6cbf7 100644\n--- a/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\n+++ b/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\n@@ -337,7 +337,7 @@ public void run() {\n     if (!initialized) {\n       // sleep a little bit to let zookeeper come up before calling init, seems to work better\n       UtilWaitThread.sleep(250);\n-      Process initProcess = exec(Initialize.class, \"--instance-name\", config.getInstanceName(), \"--password\", config.getRootPassword(), \"--username\", \"root\");\n+      Process initProcess = exec(Initialize.class, \"--instance-name\", config.getInstanceName(), \"--password\", config.getRootPassword());\n       int ret = initProcess.waitFor();\n       if (ret != 0) {\n         throw new RuntimeException(\"Initialize process returned \" + ret);\n",
        "project": "accumulo",
        "linesAdd": 1,
        "jira_id": "1544",
        "nb_skipped": 0,
        "commit": "0cf2ff72",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 386,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.data.KeyTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/data/Key.java b/core/src/main/java/org/apache/accumulo/core/data/Key.java\nindex de9e22d9e..4b6867f75 100644\n--- a/core/src/main/java/org/apache/accumulo/core/data/Key.java\n+++ b/core/src/main/java/org/apache/accumulo/core/data/Key.java\n@@ -291,6 +291,19 @@ public Key(TKey tkey) {\n     this.colVisibility = toBytes(tkey.colVisibility);\n     this.timestamp = tkey.timestamp;\n     this.deleted = false;\n+\n+    if (row == null) {\n+      throw new IllegalArgumentException(\"null row\");\n+    }\n+    if (colFamily == null) {\n+      throw new IllegalArgumentException(\"null column family\");\n+    }\n+    if (colQualifier == null) {\n+      throw new IllegalArgumentException(\"null column qualifier\");\n+    }\n+    if (colVisibility == null) {\n+      throw new IllegalArgumentException(\"null column visibility\");\n+    }\n   }\n   \n   /**\n",
        "project": "accumulo",
        "linesAdd": 13,
        "jira_id": "1986",
        "nb_skipped": 0,
        "commit": "a5e3ed3b",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 272,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.iterators.CombinerTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\nindex 4da51d3..173b00d 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\n@@ -152,15 +152,15 @@ public void next() throws IOException {\n   private Key workKey = new Key();\n   \n   /*\n-   * Sets the topKey and topValue based on the top key of the source. If the column of the source top key is in the set of combiners, or if there are no columns\n-   * in the set of combiners, topKey will be the top key of the source and topValue will be the result of the reduce method. Otherwise, topKey and topValue will\n-   * be null.\n+   * Sets the topKey and topValue based on the top key of the source. If the column of the source top key is in the set of combiners, topKey will be the top key\n+   * of the source and topValue will be the result of the reduce method. Otherwise, topKey and topValue will be unchanged. (They are always set to null before\n+   * this method is called.)\n    */\n   private void findTop() throws IOException {\n     // check if aggregation is needed\n     if (super.hasTop()) {\n       workKey.set(super.getTopKey());\n-      if (combiners.isEmpty() || combiners.contains(workKey)) {\n+      if (combiners.contains(workKey)) {\n         if (workKey.isDeleted())\n           return;\n         topKey = workKey;\n",
        "project": "accumulo",
        "linesAdd": 1,
        "jira_id": "151",
        "nb_skipped": 0,
        "commit": "b007b22e",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 421,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mapred.RangeInputSplitTest",
            "org.apache.accumulo.core.client.mapreduce.RangeInputSplitTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\nindex 73c9b59f3..05316a1ae 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/RangeInputSplit.java\n@@ -204,6 +204,14 @@ public void readFields(DataInput in) throws IOException {\n       zooKeepers = in.readUTF();\n     }\n \n+    if (in.readBoolean()) {\n+      int numIterators = in.readInt();\n+      iterators = new ArrayList<IteratorSetting>(numIterators);\n+      for (int i = 0; i < numIterators; i++) {\n+        iterators.add(new IteratorSetting(in));\n+      }\n+    }\n+\n     if (in.readBoolean()) {\n       level = Level.toLevel(in.readInt());\n     }\n@@ -275,6 +283,14 @@ public void write(DataOutput out) throws IOException {\n       out.writeUTF(zooKeepers);\n     }\n \n+    out.writeBoolean(null != iterators);\n+    if (null != iterators) {\n+      out.writeInt(iterators.size());\n+      for (IteratorSetting iterator : iterators) {\n+        iterator.write(out);\n+      }\n+    }\n+\n     out.writeBoolean(null != level);\n     if (null != level) {\n       out.writeInt(level.toInt());\n",
        "project": "accumulo",
        "linesAdd": 16,
        "jira_id": "2962",
        "nb_skipped": 0,
        "commit": "023be574",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 786,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.ClientConfigurationTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/ClientConfiguration.java b/core/src/main/java/org/apache/accumulo/core/client/ClientConfiguration.java\nindex a926d3598..7aab80c6e 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/ClientConfiguration.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/ClientConfiguration.java\n@@ -302,8 +302,12 @@ private void checkType(ClientProperty property, PropertyType type) {\n   public Map<String,String> getAllPropertiesWithPrefix(ClientProperty property) {\n     checkType(property, PropertyType.PREFIX);\n \n-    Map<String,String> propMap = new HashMap<String,String>();\n-    Iterator<?> iter = this.getKeys(property.getKey());\n+    Map<String,String> propMap = new HashMap<>();\n+    String prefix = property.getKey();\n+    if (prefix.endsWith(\".\")) {\n+      prefix = prefix.substring(0, prefix.length() - 1);\n+    }\n+    Iterator<?> iter = this.getKeys(prefix);\n     while (iter.hasNext()) {\n       String p = (String) iter.next();\n       propMap.put(p, getString(p));\n",
        "project": "accumulo",
        "linesAdd": 6,
        "jira_id": "3746",
        "nb_skipped": 2,
        "commit": "47c64d9a",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 0,
        "nb_error": 0,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [],
        "patch": "diff --git a/server/master/src/main/java/org/apache/accumulo/master/tserverOps/ShutdownTServer.java b/server/master/src/main/java/org/apache/accumulo/master/tserverOps/ShutdownTServer.java\nindex 11cd91bee..171e31206 100644\n--- a/server/master/src/main/java/org/apache/accumulo/master/tserverOps/ShutdownTServer.java\n+++ b/server/master/src/main/java/org/apache/accumulo/master/tserverOps/ShutdownTServer.java\n@@ -58,6 +58,7 @@ public long isReady(long tid, Master master) throws Exception {\n     // only send this request once\n     if (!requestedShutdown) {\n       master.shutdownTServer(server);\n+      requestedShutdown = true;\n     }\n \n     if (master.onlineTabletServers().contains(server)) {\n",
        "project": "accumulo",
        "linesAdd": 1,
        "jira_id": "3897",
        "nb_skipped": 0,
        "commit": "699b8bf0",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 1,
        "nb_test": 266,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.iterators.user.RegExFilterTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\nindex fcf77c401..0b3b73f11 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n@@ -39,10 +39,10 @@\n   public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n     RegExFilter result = new RegExFilter();\n     result.setSource(getSource().deepCopy(env));\n-    result.rowMatcher = rowMatcher.pattern().matcher(\"\");\n-    result.colfMatcher = colfMatcher.pattern().matcher(\"\");\n-    result.colqMatcher = colqMatcher.pattern().matcher(\"\");\n-    result.valueMatcher = valueMatcher.pattern().matcher(\"\");\n+    result.rowMatcher = copyMatcher(rowMatcher);\n+    result.colfMatcher = copyMatcher(colfMatcher);\n+    result.colqMatcher = copyMatcher(colqMatcher);\n+    result.valueMatcher = copyMatcher(valueMatcher);\n     result.orFields = orFields;\n     return result;\n   }\n@@ -61,6 +61,14 @@\n   \n   private ByteArrayBackedCharSequence babcs = new ByteArrayBackedCharSequence();\n   \n+  private Matcher copyMatcher(Matcher m)\n+  {\n+\t  if(m == null)\n+\t\t  return m;\n+\t  else\n+\t\t  return m.pattern().matcher(\"\");\n+  }\n+  \n   private boolean matches(Matcher matcher, ByteSequence bs) {\n     if (matcher != null) {\n       babcs.set(bs);\n",
        "project": "accumulo",
        "linesAdd": 12,
        "jira_id": "189",
        "nb_skipped": 0,
        "commit": "6dbbdc21",
        "nb_failure": 0,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 24,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.proxy.TestProxyReadWrite"
        ],
        "patch": "diff --git a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\nindex 911d18740..167cecc54 100644\n--- a/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n+++ b/proxy/src/main/java/org/apache/accumulo/proxy/ProxyServer.java\n@@ -819,7 +819,17 @@ public String createBatchScanner(ByteBuffer login, String tableName, BatchScanOp\n           }\n         }\n         scanner.setRanges(ranges);\n+\n+        if (opts.columns != null) {\n+          for (ScanColumn col : opts.columns) {\n+            if (col.isSetColQualifier())\n+              scanner.fetchColumn(ByteBufferUtil.toText(col.colFamily), ByteBufferUtil.toText(col.colQualifier));\n+            else\n+              scanner.fetchColumnFamily(ByteBufferUtil.toText(col.colFamily));\n+          }\n         }\n+      }\n+\n       UUID uuid = UUID.randomUUID();\n       \n       ScannerPlusIterator spi = new ScannerPlusIterator();\n",
        "project": "accumulo",
        "linesAdd": 10,
        "jira_id": "1183",
        "nb_skipped": 0,
        "commit": "cfbf5999",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 6,
        "nb_error": 0,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.accumulo.minicluster.MiniAccumuloClusterTest"
        ],
        "patch": "diff --git a/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java b/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\nindex 8246c51a4..c9aa1f12a 100644\n--- a/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\n+++ b/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\n@@ -270,6 +270,7 @@ public MiniAccumuloCluster(MiniAccumuloConfig config) throws IOException {\n     mergePropWithRandomPort(siteConfig, Property.TSERV_CLIENTPORT.getKey());\n     mergePropWithRandomPort(siteConfig, Property.MONITOR_PORT.getKey());\n     mergePropWithRandomPort(siteConfig, Property.GC_PORT.getKey());\n+    mergePropWithRandomPort(siteConfig, Property.MONITOR_LOG4J_PORT.getKey());\n     \n     // since there is a small amount of memory, check more frequently for majc... setting may not be needed in 1.5\n     appendProp(fileWriter, Property.TSERV_MAJC_DELAY, \"3\", siteConfig);\n",
        "project": "accumulo",
        "linesAdd": 1,
        "jira_id": "3150",
        "nb_skipped": 0,
        "commit": "72fd6bec",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 1,
        "nb_test": 629,
        "nb_error": 8,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mapreduce.AccumuloOutputFormatTest",
            "org.apache.accumulo.core.client.mapreduce.AccumuloMultiTableInputFormatTest",
            "org.apache.accumulo.core.client.mapreduce.TokenFileTest",
            "org.apache.accumulo.core.client.mapreduce.AccumuloFileOutputFormatTest",
            "org.apache.accumulo.core.client.mapreduce.AccumuloInputFormatTest",
            "org.apache.accumulo.core.client.mapreduce.AccumuloRowInputFormatTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mapred/InputFormatBase.java b/core/src/main/java/org/apache/accumulo/core/client/mapred/InputFormatBase.java\nindex 54b983f6b..0cee355db 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mapred/InputFormatBase.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mapred/InputFormatBase.java\n@@ -322,6 +322,9 @@ protected void setupIterators(JobConf job, Scanner scanner, String tableName, or\n         iterators = getIterators(job);\n       } else {\n         iterators = split.getIterators();\n+        if (null == iterators) {\n+          iterators = getIterators(job);\n+        }\n       }\n \n       setupIterators(iterators, scanner);\n",
        "project": "accumulo",
        "linesAdd": 3,
        "jira_id": "2659",
        "nb_skipped": 1,
        "commit": "019edb16",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 700,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mapreduce.InputTableConfigTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/InputTableConfig.java b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/InputTableConfig.java\nindex e59451e83..fa3b7eb87 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mapreduce/InputTableConfig.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mapreduce/InputTableConfig.java\n@@ -281,6 +281,7 @@ public void write(DataOutput dataOutput) throws IOException {\n     dataOutput.writeBoolean(autoAdjustRanges);\n     dataOutput.writeBoolean(useLocalIterators);\n     dataOutput.writeBoolean(useIsolatedScanners);\n+    dataOutput.writeBoolean(offlineScan);\n   }\n \n   /**\n@@ -325,6 +326,7 @@ public void readFields(DataInput dataInput) throws IOException {\n     autoAdjustRanges = dataInput.readBoolean();\n     useLocalIterators = dataInput.readBoolean();\n     useIsolatedScanners = dataInput.readBoolean();\n+    offlineScan = dataInput.readBoolean();\n   }\n \n   @Override\n",
        "project": "accumulo",
        "linesAdd": 2,
        "jira_id": "3143",
        "nb_skipped": 1,
        "commit": "ddd2c3bc",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 383,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.util.shell.ShellTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/SetIterCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/SetIterCommand.java\nindex 4c6d2d293..26e38e649 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/SetIterCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/SetIterCommand.java\n@@ -175,14 +175,23 @@ private static String setUpOptions(ClassLoader classloader, final ConsoleReader\n       clazz = classloader.loadClass(className).asSubclass(OptionDescriber.class);\n       skvi = clazz.newInstance();\n     } catch (ClassNotFoundException e) {\n-      throw new IllegalArgumentException(e.getMessage());\n+      StringBuilder msg = new StringBuilder(\"Unable to load \").append(className);\n+      if (className.indexOf('.') < 0) {\n+        msg.append(\"; did you use a fully qualified package name?\");\n+      } else {\n+        msg.append(\"; class not found.\");\n+      }\n+      throw new ShellCommandException(ErrorCode.INITIALIZATION_FAILURE, msg.toString());\n     } catch (InstantiationException e) {\n       throw new IllegalArgumentException(e.getMessage());\n     } catch (IllegalAccessException e) {\n       throw new IllegalArgumentException(e.getMessage());\n     } catch (ClassCastException e) {\n-      throw new ShellCommandException(ErrorCode.INITIALIZATION_FAILURE, \"Unable to load \" + className + \" as type \" + OptionDescriber.class.getName()\n-          + \"; configure with 'config' instead\");\n+      StringBuilder msg = new StringBuilder(\"Loaded \");\n+      msg.append(className).append(\" but it does not implement \");\n+      msg.append(OptionDescriber.class.getSimpleName());\n+      msg.append(\"; use 'config -s' instead.\");\n+      throw new ShellCommandException(ErrorCode.INITIALIZATION_FAILURE, msg.toString());\n     }\n     \n     final IteratorOptions itopts = skvi.describeOptions();\n",
        "project": "accumulo",
        "linesAdd": 12,
        "jira_id": "1358",
        "nb_skipped": 0,
        "commit": "6c565dfb",
        "nb_failure": 3,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 64,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.server.constraints.MetadataConstraintsTest"
        ],
        "patch": "diff --git a/server/src/main/java/org/apache/accumulo/server/constraints/MetadataConstraints.java b/server/src/main/java/org/apache/accumulo/server/constraints/MetadataConstraints.java\nindex bd19d1fce..463b7b02d 100644\n--- a/server/src/main/java/org/apache/accumulo/server/constraints/MetadataConstraints.java\n+++ b/server/src/main/java/org/apache/accumulo/server/constraints/MetadataConstraints.java\n@@ -34,6 +34,7 @@\n import org.apache.accumulo.server.client.HdfsZooInstance;\n import org.apache.accumulo.server.zookeeper.ZooCache;\n import org.apache.accumulo.server.zookeeper.ZooLock;\n+import org.apache.accumulo.server.zookeeper.TransactionWatcher.ZooArbitrator;\n import org.apache.hadoop.io.Text;\n import org.apache.log4j.Logger;\n \n@@ -72,6 +73,22 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n     return false;\n   }\n   \n+  static private ArrayList<Short> addViolation(ArrayList<Short> lst, int violation) {\n+    if (lst == null)\n+      lst = new ArrayList<Short>();\n+    lst.add((short)violation);\n+    return lst;\n+  }\n+  \n+  static private ArrayList<Short> addIfNotPresent(ArrayList<Short> lst, int intViolation) {\n+    if (lst == null)\n+      return addViolation(lst, intViolation);\n+    short violation = (short)intViolation;\n+    if (!lst.contains(violation))\n+      return addViolation(lst, intViolation);\n+    return lst;\n+  }\n+  \n   public List<Short> check(Environment env, Mutation mutation) {\n     \n     ArrayList<Short> violations = null;\n@@ -96,44 +113,30 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n         break;\n       \n       if (!validTableNameChars[0xff & b]) {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        if (!violations.contains((short) 4))\n-          violations.add((short) 4);\n+        violations = addIfNotPresent(violations, 4);\n       }\n     }\n     \n     if (!containsSemiC) {\n       // see if last row char is <\n       if (row.length == 0 || row[row.length - 1] != '<') {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        if (!violations.contains((short) 4))\n-          violations.add((short) 4);\n+        violations = addIfNotPresent(violations, 4);\n       }\n     } else {\n       if (row.length == 0) {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        if (!violations.contains((short) 4))\n-          violations.add((short) 4);\n+        violations = addIfNotPresent(violations, 4);\n       }\n     }\n     \n     if (row.length > 0 && row[0] == '!') {\n       if (row.length < 3 || row[1] != '0' || (row[2] != '<' && row[2] != ';')) {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        if (!violations.contains((short) 4))\n-          violations.add((short) 4);\n+        violations = addIfNotPresent(violations, 4);\n       }\n     }\n     \n     // ensure row is not less than Constants.METADATA_TABLE_ID\n     if (new Text(row).compareTo(new Text(Constants.METADATA_TABLE_ID)) < 0) {\n-      if (violations == null)\n-        violations = new ArrayList<Short>();\n-      violations.add((short) 5);\n+      violations = addViolation(violations, 5);\n     }\n     \n     for (ColumnUpdate columnUpdate : colUpdates) {\n@@ -141,17 +144,13 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n       \n       if (columnUpdate.isDeleted()) {\n         if (!isValidColumn(columnUpdate)) {\n-          if (violations == null)\n-            violations = new ArrayList<Short>();\n-          violations.add((short) 2);\n+          violations = addViolation(violations, 2);\n         }\n         continue;\n       }\n       \n       if (columnUpdate.getValue().length == 0 && !columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\n-        if (violations == null)\n-          violations = new ArrayList<Short>();\n-        violations.add((short) 6);\n+        violations = addViolation(violations, 6);\n       }\n       \n       if (columnFamily.equals(Constants.METADATA_DATAFILE_COLUMN_FAMILY)) {\n@@ -159,26 +158,49 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n           DataFileValue dfv = new DataFileValue(columnUpdate.getValue());\n           \n           if (dfv.getSize() < 0 || dfv.getNumEntries() < 0) {\n-            if (violations == null)\n-              violations = new ArrayList<Short>();\n-            violations.add((short) 1);\n+            violations = addViolation(violations, 1);\n           }\n         } catch (NumberFormatException nfe) {\n-          if (violations == null)\n-            violations = new ArrayList<Short>();\n-          violations.add((short) 1);\n+          violations = addViolation(violations, 1);\n         } catch (ArrayIndexOutOfBoundsException aiooe) {\n-          if (violations == null)\n-            violations = new ArrayList<Short>();\n-          violations.add((short) 1);\n+          violations = addViolation(violations, 1);\n         }\n       } else if (columnFamily.equals(Constants.METADATA_SCANFILE_COLUMN_FAMILY)) {\n         \n+      } else if (columnFamily.equals(Constants.METADATA_BULKFILE_COLUMN_FAMILY)) {\n+        if (!columnUpdate.isDeleted()) {\n+          // splits, which also write the time reference, are allowed to write this reference even when\n+          // the transaction is not running because the other half of the tablet is holding a reference\n+          // to the file.\n+          boolean isSplitMutation = false;\n+          // When a tablet is assigned, it re-writes the metadata.  It should probably only update the location information, \n+          // but it writes everything.  We allow it to re-write the bulk information if it is setting the location. \n+          // See ACCUMULO-1230. \n+          boolean isLocationMutation = false;\n+          for (ColumnUpdate update : mutation.getUpdates()) {\n+            if (new ColumnFQ(update).equals(Constants.METADATA_TIME_COLUMN)) {\n+              isSplitMutation = true;\n+            }\n+            if (update.getColumnFamily().equals(Constants.METADATA_CURRENT_LOCATION_COLUMN_FAMILY)) {\n+              isLocationMutation = true;\n+            }\n+          }\n+          \n+          if (!isSplitMutation && !isLocationMutation) {\n+            String tidString = new String(columnUpdate.getValue());\n+            long tid = Long.parseLong(tidString);\n+            try {\n+              if (!new ZooArbitrator().transactionAlive(Constants.BULK_ARBITRATOR_TYPE, tid)) {\n+                violations = addViolation(violations, 8);\n+              }\n+            } catch (Exception ex) {\n+              violations = addViolation(violations, 8);\n+            }\n+          }\n+        }\n       } else {\n         if (!isValidColumn(columnUpdate)) {\n-          if (violations == null)\n-            violations = new ArrayList<Short>();\n-          violations.add((short) 2);\n+          violations = addViolation(violations, 2);\n         } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_PREV_ROW_COLUMN) && columnUpdate.getValue().length > 0\n             && (violations == null || !violations.contains((short) 4))) {\n           KeyExtent ke = new KeyExtent(new Text(mutation.getRow()), (Text) null);\n@@ -188,9 +210,7 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n           boolean prevEndRowLessThanEndRow = per == null || ke.getEndRow() == null || per.compareTo(ke.getEndRow()) < 0;\n           \n           if (!prevEndRowLessThanEndRow) {\n-            if (violations == null)\n-              violations = new ArrayList<Short>();\n-            violations.add((short) 3);\n+            violations = addViolation(violations, 3);\n           }\n         } else if (new ColumnFQ(columnUpdate).equals(Constants.METADATA_LOCK_COLUMN)) {\n           if (zooCache == null) {\n@@ -211,9 +231,7 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n           }\n           \n           if (!lockHeld) {\n-            if (violations == null)\n-              violations = new ArrayList<Short>();\n-            violations.add((short) 7);\n+            violations = addViolation(violations, 7);\n           }\n         }\n         \n@@ -221,7 +239,10 @@ private static boolean isValidColumn(ColumnUpdate cu) {\n     }\n     \n     if (violations != null) {\n-      log.debug(\" violating metadata mutation : \" + mutation);\n+      log.debug(\"violating metadata mutation : \" + new String(mutation.getRow()));\n+      for (ColumnUpdate update : mutation.getUpdates()) {\n+        log.debug(\" update: \" + new String(update.getColumnFamily()) + \":\" + new String(update.getColumnQualifier()) + \" value \" + (update.isDeleted() ? \"[delete]\" : new String(update.getValue())));\n+      }\n     }\n     \n     return violations;\n@@ -243,6 +264,8 @@ public String getViolationDescription(short violationCode) {\n         return \"Empty values are not allowed for any \" + Constants.METADATA_TABLE_NAME + \" column\";\n       case 7:\n         return \"Lock not held in zookeeper by writer\";\n+      case 8:\n+        return \"Bulk load transaction no longer running\";\n     }\n     return null;\n   }\n",
        "project": "accumulo",
        "linesAdd": 61,
        "jira_id": "1044",
        "nb_skipped": 0,
        "commit": "9396979b",
        "nb_failure": 1,
        "linesRem": 44,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 412,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mock.MockTableOperationsTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\nindex dc4a619d7..64f8225fc 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n@@ -314,8 +314,8 @@ public void deleteRows(String tableName, Text start, Text end) throws AccumuloEx\n     if (!exists(tableName))\n       throw new TableNotFoundException(tableName, tableName, \"\");\n     MockTable t = acu.tables.get(tableName);\n-    Text startText = new Text(start);\n-    Text endText = new Text(end);\n+    Text startText = start != null ? new Text(start) : new Text();\n+    Text endText = end != null ? new Text(end) : new Text(t.table.lastKey().getRow().getBytes());\n     startText.append(ZERO, 0, 1);\n     endText.append(ZERO, 0, 1);\n     Set<Key> keep = new TreeSet<Key>(t.table.subMap(new Key(startText), new Key(endText)).keySet());\n",
        "project": "accumulo",
        "linesAdd": 2,
        "jira_id": "2748",
        "nb_skipped": 0,
        "commit": "ff8c2383",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 399,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.data.MutationTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/data/Mutation.java b/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\nindex 407dbc046..56ae7a6e4 100644\n--- a/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\n+++ b/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\n@@ -223,6 +223,13 @@ public Mutation(TMutation tmutation) {\n     this.data = ByteBufferUtil.toBytes(tmutation.data);\n     this.entries = tmutation.entries;\n     this.values = ByteBufferUtil.toBytesList(tmutation.values);\n+    \n+    if (this.row == null) {\n+      throw new IllegalArgumentException(\"null row\");\n+    }\n+    if (this.data == null) {\n+      throw new IllegalArgumentException(\"null serialized data\");\n+    }\n   }\n   \n   public Mutation(Mutation m) {\n",
        "project": "accumulo",
        "linesAdd": 7,
        "jira_id": "1986",
        "nb_skipped": 0,
        "commit": "2d97b875",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 5,
        "nb_test": 722,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.util.shell.commands.CompactCommandTest",
            "org.apache.accumulo.core.util.shell.commands.MergeCommandTest",
            "org.apache.accumulo.core.util.shell.commands.FlushCommandTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperations.java b/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperations.java\nindex 536d6e667..bcad3a30f 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperations.java\n@@ -260,7 +260,7 @@ Text getMaxRow(String tableName, Authorizations auths, Text startRow, boolean st\n    * @param start\n    *          first tablet to be compacted contains the row after this row, null means the first tablet in table\n    * @param end\n-   *          last tablet to be merged contains this row, null means the last tablet in table\n+   *          last tablet to be compacted contains this row, null means the last tablet in table\n    * @param flush\n    *          when true, table memory is flushed before compaction starts\n    * @param wait\n@@ -276,7 +276,7 @@ Text getMaxRow(String tableName, Authorizations auths, Text startRow, boolean st\n    * @param start\n    *          first tablet to be compacted contains the row after this row, null means the first tablet in table\n    * @param end\n-   *          last tablet to be merged contains this row, null means the last tablet in table\n+   *          last tablet to be compacted contains this row, null means the last tablet in table\n    * @param iterators\n    *          A set of iterators that will be applied to each tablet compacted\n    * @param flush\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/DeleteRowsCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/DeleteRowsCommand.java\nindex 64968f05e..6ffa3f40e 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/DeleteRowsCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/DeleteRowsCommand.java\n@@ -54,9 +54,7 @@ public int numArgs() {\n   public Options getOptions() {\n     final Options o = new Options();\n     forceOpt = new Option(\"f\", \"force\", false, \"delete data even if start or end are not specified\");\n-    startRowOptExclusive = new Option(OptUtil.START_ROW_OPT, \"begin-row\", true, \"begin row (exclusive)\");\n-    startRowOptExclusive.setArgName(\"begin-row\");\n-    o.addOption(startRowOptExclusive);\n+    o.addOption(OptUtil.startRowOpt());\n     o.addOption(OptUtil.endRowOpt());\n     o.addOption(OptUtil.tableOpt(\"table to delete a row range from\"));\n     o.addOption(forceOpt);\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/MergeCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/MergeCommand.java\nindex 9213a06c8..18d519d36 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/MergeCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/MergeCommand.java\n@@ -96,9 +96,7 @@ public Options getOptions() {\n     sizeOpt = new Option(\"s\", \"size\", true, \"merge tablets to the given size over the entire table\");\n     forceOpt = new Option(\"f\", \"force\", false, \"merge small tablets to large tablets, even if it goes over the given size\");\n     allOpt = new Option(\"\", \"all\", false, \"allow an entire table to be merged into one tablet without prompting the user for confirmation\");\n-    Option startRowOpt = OptUtil.startRowOpt();\n-    startRowOpt.setDescription(\"begin row (NOT inclusive)\");\n-    o.addOption(startRowOpt);\n+    o.addOption(OptUtil.startRowOpt());\n     o.addOption(OptUtil.endRowOpt());\n     o.addOption(OptUtil.tableOpt(\"table to be merged\"));\n     o.addOption(verboseOpt);\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\nindex 9915bdf57..99e09e362 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/OptUtil.java\n@@ -117,7 +117,7 @@ public static OptionGroup addListDeleteGroup(final String name) {\n   }\n \n   public static Option startRowOpt() {\n-    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (inclusive)\");\n+    final Option o = new Option(START_ROW_OPT, \"begin-row\", true, \"begin row (exclusive)\");\n     o.setArgName(\"begin-row\");\n     return o;\n   }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/ScanCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/ScanCommand.java\nindex 9a0026af1..60ae0a7cc 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/ScanCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/ScanCommand.java\n@@ -57,6 +57,7 @@\n \n   protected Option timestampOpt;\n   private Option optStartRowExclusive;\n+  private Option optStartRowInclusive;\n   private Option optEndRowExclusive;\n   private Option timeoutOption;\n   private Option profileOpt;\n@@ -318,7 +319,9 @@ public Options getOptions() {\n \n     o.addOption(scanOptAuths);\n     o.addOption(scanOptRow);\n-    o.addOption(OptUtil.startRowOpt());\n+    optStartRowInclusive = new Option(OptUtil.START_ROW_OPT, \"begin-row\", true, \"begin row (inclusive)\");\n+    optStartRowInclusive.setArgName(\"begin-row\");\n+    o.addOption(optStartRowInclusive);\n     o.addOption(OptUtil.endRowOpt());\n     o.addOption(optStartRowExclusive);\n     o.addOption(optEndRowExclusive);\n",
        "project": "accumulo",
        "linesAdd": 7,
        "jira_id": "4138",
        "nb_skipped": 2,
        "commit": "eb0f9b41",
        "nb_failure": 3,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 364,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.cli.TestClientOpts"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/cli/ClientOpts.java b/core/src/main/java/org/apache/accumulo/core/cli/ClientOpts.java\nindex 50d739823..e426c4aba 100644\n--- a/core/src/main/java/org/apache/accumulo/core/cli/ClientOpts.java\n+++ b/core/src/main/java/org/apache/accumulo/core/cli/ClientOpts.java\n@@ -104,7 +104,7 @@ public ColumnVisibility convert(String value) {\n   public String principal = System.getProperty(\"user.name\");\n   \n   @Parameter(names = \"-p\", converter = PasswordConverter.class, description = \"Connection password\")\n-  public Password password = new Password(\"secret\");\n+  public Password password = null;\n   \n   @Parameter(names = \"--password\", converter = PasswordConverter.class, description = \"Enter the connection password\", password = true)\n   public Password securePassword = null;\n@@ -112,7 +112,7 @@ public ColumnVisibility convert(String value) {\n   public SecurityToken getToken() {\n     PasswordToken pt = new PasswordToken();\n     if (securePassword == null) {\n-      if (password.value == null)\n+      if (password == null)\n         return null;\n       return pt.setPassword(password.value);\n     }\n",
        "project": "accumulo",
        "linesAdd": 2,
        "jira_id": "1120",
        "nb_skipped": 0,
        "commit": "474b2577",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 281,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.iterators.FirstEntryInRowTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/iterators/FirstEntryInRowIterator.java b/core/src/main/java/org/apache/accumulo/core/iterators/FirstEntryInRowIterator.java\nindex 96c7b80c3..7507bff56 100644\n--- a/core/src/main/java/org/apache/accumulo/core/iterators/FirstEntryInRowIterator.java\n+++ b/core/src/main/java/org/apache/accumulo/core/iterators/FirstEntryInRowIterator.java\n@@ -75,6 +75,8 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n   // this is only ever called immediately after getting \"next\" entry\n   @Override\n   protected void consume() throws IOException {\n+    if (lastRowFound == null)\n+      return;\n     int count = 0;\n     while (getSource().hasTop() && lastRowFound.equals(getSource().getTopKey().getRow())) {\n       \n@@ -101,10 +103,17 @@ public void seek(Range range, Collection<ByteSequence> columnFamilies, boolean i\n     latestRange = range;\n     latestColumnFamilies = columnFamilies;\n     latestInclusive = inclusive;\n+    lastRowFound = null;\n     \n-    // seek to first possible pattern in range\n-    super.seek(range, columnFamilies, inclusive);\n-    lastRowFound = getSource().hasTop() ? getSource().getTopKey().getRow() : null;\n+    Key startKey = range.getStartKey();\n+    Range seekRange = new Range(startKey == null ? null : new Key(startKey.getRow()), true, range.getEndKey(), range.isEndKeyInclusive());\n+    super.seek(seekRange, columnFamilies, inclusive);\n+    \n+    if (getSource().hasTop()) {\n+      lastRowFound = getSource().getTopKey().getRow();\n+      if (range.beforeStartKey(getSource().getTopKey()))\n+        consume();\n+    }\n   }\n   \n   @Override\n",
        "project": "accumulo",
        "linesAdd": 12,
        "jira_id": "633",
        "nb_skipped": 0,
        "commit": "8dad5e0f",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 393,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.file.FileOperationsTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/file/FileOperations.java b/core/src/main/java/org/apache/accumulo/core/file/FileOperations.java\nindex 9f6072563..17e540b70 100644\n--- a/core/src/main/java/org/apache/accumulo/core/file/FileOperations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/file/FileOperations.java\n@@ -44,14 +44,13 @@ private FileOperations findFileFactory(String file) {\n     if (name.startsWith(Constants.MAPFILE_EXTENSION + \"_\")) {\n       return new MapFileOperations();\n     }\n-    \n     String[] sp = name.split(\"\\\\.\");\n     \n-    if (sp.length != 2) {\n+    if (sp.length < 2) {\n       throw new IllegalArgumentException(\"File name \" + name + \" has no extension\");\n     }\n     \n-    String extension = sp[1];\n+    String extension = sp[sp.length - 1];\n     \n     if (extension.equals(Constants.MAPFILE_EXTENSION) || extension.equals(Constants.MAPFILE_EXTENSION + \"_tmp\")) {\n       return new MapFileOperations();\n",
        "project": "accumulo",
        "linesAdd": 2,
        "jira_id": "1518",
        "nb_skipped": 0,
        "commit": "df4b1985",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 49,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.fate.zookeeper.ZooKeeperConnectionInfoTest"
        ],
        "patch": "diff --git a/fate/src/main/java/org/apache/accumulo/fate/zookeeper/ZooCache.java b/fate/src/main/java/org/apache/accumulo/fate/zookeeper/ZooCache.java\nindex b3dd19ac1..d72ac08ef 100644\n--- a/fate/src/main/java/org/apache/accumulo/fate/zookeeper/ZooCache.java\n+++ b/fate/src/main/java/org/apache/accumulo/fate/zookeeper/ZooCache.java\n@@ -162,7 +162,7 @@ private synchronized void retry(ZooRunnable op) {\n         if (code == Code.NONODE) {\n           log.error(\"Looked up non-existent node in cache \" + e.getPath(), e);\n         } else if (code == Code.CONNECTIONLOSS || code == Code.OPERATIONTIMEOUT || code == Code.SESSIONEXPIRED) {\n-          log.warn(\"Saw (possibly) transient exception communicating with ZooKeeper, wil retry\", e);\n+          log.warn(\"Saw (possibly) transient exception communicating with ZooKeeper, will retry\", e);\n           continue;\n         }\n         log.warn(\"Zookeeper error, will retry\", e);\ndiff --git a/fate/src/main/java/org/apache/accumulo/fate/zookeeper/ZooUtil.java b/fate/src/main/java/org/apache/accumulo/fate/zookeeper/ZooUtil.java\nindex 674c1d808..1a3af6b4e 100644\n--- a/fate/src/main/java/org/apache/accumulo/fate/zookeeper/ZooUtil.java\n+++ b/fate/src/main/java/org/apache/accumulo/fate/zookeeper/ZooUtil.java\n@@ -18,9 +18,11 @@\n \n import java.math.BigInteger;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n \n+import org.apache.commons.lang.builder.HashCodeBuilder;\n import org.apache.log4j.Logger;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n@@ -32,6 +34,8 @@\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Stat;\n \n+import com.google.common.base.Preconditions;\n+\n public class ZooUtil {\n   private static final Logger log = Logger.getLogger(ZooUtil.class);\n \n@@ -87,11 +91,68 @@ public String toString() {\n     byte[] auth;\n \n     public ZooKeeperConnectionInfo(String keepers, int timeout, String scheme, byte[] auth) {\n+      Preconditions.checkNotNull(keepers);\n       this.keepers = keepers;\n       this.timeout = timeout;\n       this.scheme = scheme;\n       this.auth = auth;\n     }\n+\n+    @Override\n+    public int hashCode() {\n+      final HashCodeBuilder hcb = new HashCodeBuilder(31, 47);\n+      hcb.append(keepers).append(timeout);\n+      if (null != scheme) {\n+        hcb.append(scheme);\n+      }\n+      if (null != auth) {\n+        hcb.append(auth);\n+      }\n+      return hcb.toHashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (o instanceof ZooKeeperConnectionInfo) {\n+        ZooKeeperConnectionInfo other = (ZooKeeperConnectionInfo) o;\n+        if (!keepers.equals(other.keepers) || timeout != other.timeout) {\n+          return false;\n+        }\n+\n+        if (null != scheme) {\n+          if (null == other.scheme) {\n+            // Ours is non-null, theirs is null\n+            return false;\n+          } else if (!scheme.equals(other.scheme)) {\n+            // Both non-null but not equal\n+            return false;\n+          }\n+        }\n+\n+        if (null != auth) {\n+          if (null == other.auth) {\n+            return false;\n+          } else if (!Arrays.equals(auth, other.auth)) {\n+            // both non-null but not equal\n+            return false;\n+          }\n+        }\n+\n+        return true;\n+      }\n+\n+      return false;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      StringBuilder sb = new StringBuilder(64);\n+      sb.append(\"zookeepers=\").append(keepers);\n+      sb.append(\", timeout=\").append(timeout);\n+      sb.append(\", scheme=\").append(scheme);\n+      sb.append(\", auth=\").append(null == auth ? \"null\" : \"REDACTED\");\n+      return sb.toString();\n+    }\n   }\n \n   public static final List<ACL> PRIVATE;\n@@ -206,8 +267,7 @@ public static boolean putPersistentData(ZooKeeperConnectionInfo info, String zPa\n   }\n \n   public static boolean putPersistentData(ZooKeeperConnectionInfo info, String zPath, byte[] data, int version, NodeExistsPolicy policy)\n-      throws KeeperException,\n-      InterruptedException {\n+      throws KeeperException, InterruptedException {\n     return putData(info, zPath, data, CreateMode.PERSISTENT, version, policy, PUBLIC);\n   }\n \n@@ -216,8 +276,7 @@ public static boolean putPersistentData(ZooKeeperConnectionInfo info, String zPa\n     return putData(info, zPath, data, CreateMode.PERSISTENT, version, policy, acls);\n   }\n \n-  private static boolean putData(ZooKeeperConnectionInfo info, String zPath, byte[] data, CreateMode mode, int version,\n-      NodeExistsPolicy policy, List<ACL> acls)\n+  private static boolean putData(ZooKeeperConnectionInfo info, String zPath, byte[] data, CreateMode mode, int version, NodeExistsPolicy policy, List<ACL> acls)\n       throws KeeperException, InterruptedException {\n     if (policy == null)\n       policy = NodeExistsPolicy.FAIL;\n@@ -347,11 +406,12 @@ public static void recursiveCopyPersistent(ZooKeeperConnectionInfo info, String\n           }\n           retry.waitForNextAttempt();\n         }\n-        for (String child : children)\n+        for (String child : children) {\n           recursiveCopyPersistent(info, source + \"/\" + child, destination + \"/\" + child, policy);\n         }\n       }\n     }\n+  }\n \n   public static boolean putPrivatePersistentData(ZooKeeperConnectionInfo info, String zPath, byte[] data, NodeExistsPolicy policy) throws KeeperException,\n       InterruptedException {\n",
        "project": "accumulo",
        "linesAdd": 63,
        "jira_id": "3242",
        "nb_skipped": 0,
        "commit": "15e83709",
        "nb_failure": 1,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 311,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mock.MockTableOperationsTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\nindex 8fb9f0ec6..c4262c038 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTable.java\n@@ -20,9 +20,11 @@\n import java.util.EnumSet;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.Set;\n import java.util.Map.Entry;\n import java.util.SortedMap;\n import java.util.SortedSet;\n+import java.util.TreeMap;\n import java.util.TreeSet;\n import java.util.concurrent.ConcurrentSkipListMap;\n \n@@ -86,6 +88,7 @@ public int compareTo(Key o) {\n   Map<String,EnumSet<TablePermission>> userPermissions = new HashMap<String,EnumSet<TablePermission>>();\n   private TimeType timeType;\n   SortedSet<Text> splits = new TreeSet<Text>();\n+  Map<String,Set<Text>> localityGroups = new TreeMap<String, Set<Text>>();\n   \n   MockTable(boolean limitVersion, TimeType timeType) {\n     this.timeType = timeType;\n@@ -122,4 +125,11 @@ public void addSplits(SortedSet<Text> partitionKeys) {\n   public Collection<Text> getSplits() {\n     return splits;\n   }\n+  \n+  public void setLocalityGroups(Map<String,Set<Text>> groups) {\n+    localityGroups = groups;\n+  }\n+  public Map<String,Set<Text>> getLocalityGroups() {\n+    return localityGroups;\n+  }\n }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\nindex b5ffc7324..5da7d6430 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n@@ -40,6 +40,7 @@\n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n import org.apache.accumulo.core.data.Key;\n import org.apache.accumulo.core.data.Mutation;\n+import org.apache.accumulo.core.data.PartialKey;\n import org.apache.accumulo.core.data.Range;\n import org.apache.accumulo.core.data.Value;\n import org.apache.accumulo.core.file.FileOperations;\n@@ -155,17 +156,23 @@ public void removeProperty(String tableName, String property) throws AccumuloExc\n   \n   @Override\n   public void setLocalityGroups(String tableName, Map<String,Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n+    acu.tables.get(tableName).setLocalityGroups(groups);\n   }\n   \n   @Override\n   public Map<String,Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n+    return acu.tables.get(tableName).getLocalityGroups();\n   }\n   \n   @Override\n   public Set<Range> splitRangeByTablets(String tableName, Range range, int maxSplits) throws AccumuloException, AccumuloSecurityException,\n       TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     return Collections.singleton(range);\n   }\n   \n@@ -262,15 +269,20 @@ public void importDirectory(String tableName, String dir, String failureDir, boo\n   \n   @Override\n   public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new AccumuloException(tableName + \" does not exists\");\n   }\n   \n   @Override\n-  public void online(String tableName) throws AccumuloSecurityException, AccumuloException {}\n+  public void online(String tableName) throws AccumuloSecurityException, AccumuloException {\n+    if (!exists(tableName))\n+      throw new AccumuloException(tableName + \" does not exists\");\n+  }\n   \n   @Override\n   public void clearLocatorCache(String tableName) throws TableNotFoundException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n   }\n   \n   @Override\n@@ -284,24 +296,31 @@ public void clearLocatorCache(String tableName) throws TableNotFoundException {\n   \n   @Override\n   public void merge(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n }\n   \n   @Override\n   public void deleteRows(String tableName, Text start, Text end) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n+    MockTable t = acu.tables.get(tableName);\n+    Set<Key> keep = new TreeSet<Key>(t.table.tailMap(new Key(start)).headMap(new Key(end)).keySet());\n+    t.table.keySet().removeAll(keep);\n   }\n   \n   @Override\n   public void compact(String tableName, Text start, Text end, boolean flush, boolean wait) throws AccumuloSecurityException, TableNotFoundException,\n       AccumuloException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n   }\n   \n   @Override\n   public void compact(String tableName, Text start, Text end, List<IteratorSetting> iterators, boolean flush, boolean wait) throws AccumuloSecurityException,\n       TableNotFoundException, AccumuloException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n   }\n   \n   @Override\n@@ -312,7 +331,8 @@ public void clone(String srcTableName, String newTableName, boolean flush, Map<S\n   \n   @Override\n   public void flush(String tableName, Text start, Text end, boolean wait) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n-    throw new NotImplementedException();\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n  }\n   \n   @Override\n",
        "project": "accumulo",
        "linesAdd": 40,
        "jira_id": "843",
        "nb_skipped": 0,
        "commit": "65390f8c",
        "nb_failure": 0,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 640,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.util.shell.command.HistoryCommandTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/HistoryCommand.java b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/HistoryCommand.java\nindex 9531d903a..d6068ba60 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/shell/commands/HistoryCommand.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/commands/HistoryCommand.java\n@@ -18,7 +18,6 @@\n \n import java.io.IOException;\n import java.util.Iterator;\n-import java.util.ListIterator;\n \n import jline.console.history.History.Entry;\n \n@@ -27,37 +26,31 @@\n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.Option;\n import org.apache.commons.cli.Options;\n-import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n+\n+import com.google.common.base.Function;\n+import com.google.common.collect.Iterators;\n \n public class HistoryCommand extends Command {\n   private Option clearHist;\n   private Option disablePaginationOpt;\n   \n-  @SuppressWarnings(\"unchecked\")\n   @Override\n   public int execute(final String fullCommand, final CommandLine cl, final Shell shellState) throws IOException {\n     if (cl.hasOption(clearHist.getOpt())) {\n       shellState.getReader().getHistory().clear();\n     } else {\n-      ListIterator<Entry> it = shellState.getReader().getHistory().entries();\n-      shellState.printLines(new HistoryLineIterator(it), !cl.hasOption(disablePaginationOpt.getOpt()));\n+      Iterator<Entry> source = shellState.getReader().getHistory().entries();\n+      Iterator<String> historyIterator = Iterators.transform(source, new Function<Entry,String>() {\n+        @Override\n+        public String apply(Entry input) {\n+          return String.format(\"%d: %s\", input.index() + 1, input.value());\n         }\n+      });\n \n-    return 0;\n+      shellState.printLines(historyIterator, !cl.hasOption(disablePaginationOpt.getOpt()));\n     }\n     \n-  /**\n-   * Decorator that converts an Iterator<History.Entry> to an Iterator<String>.\n-   */\n-  private static class HistoryLineIterator extends AbstractIteratorDecorator {\n-    public HistoryLineIterator(Iterator<Entry> iterator) {\n-      super(iterator);\n-    }\n-    \n-    @Override\n-    public String next() {\n-      return super.next().toString();\n-    }\n+    return 0;\n   }\n   \n   @Override\n",
        "project": "accumulo",
        "linesAdd": 11,
        "jira_id": "2742",
        "nb_skipped": 1,
        "commit": "1f7dd2d5",
        "nb_failure": 1,
        "linesRem": 15,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 362,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.util.shell.ShellTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/security/Authorizations.java b/core/src/main/java/org/apache/accumulo/core/security/Authorizations.java\nindex 5933325b1..a677f3f13 100644\n--- a/core/src/main/java/org/apache/accumulo/core/security/Authorizations.java\n+++ b/core/src/main/java/org/apache/accumulo/core/security/Authorizations.java\n@@ -23,10 +23,9 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n-import java.util.Set;\n-import java.util.TreeSet;\n \n import org.apache.accumulo.core.data.ArrayByteSequence;\n import org.apache.accumulo.core.data.ByteSequence;\n@@ -38,7 +37,7 @@\n   \n   private static final long serialVersionUID = 1L;\n   \n-  private Set<ByteSequence> auths = new TreeSet<ByteSequence>();\n+  private HashSet<ByteSequence> auths = new HashSet<ByteSequence>();\n   private List<byte[]> authsList = new ArrayList<byte[]>();\n   private List<byte[]> immutableList = Collections.unmodifiableList(authsList);\n   \n@@ -177,7 +176,6 @@ private void setAuthorizations(Charset charset, String... authorizations) {\n     return ByteBufferUtil.toByteBuffers(immutableList);\n   }\n   \n-  @Override\n   public String toString() {\n     StringBuilder sb = new StringBuilder();\n     String sep = \"\";\n@@ -198,7 +196,6 @@ public boolean contains(ByteSequence auth) {\n     return auths.contains(auth);\n   }\n   \n-  @Override\n   public boolean equals(Object o) {\n     if (o == null) {\n       return false;\n@@ -213,7 +210,6 @@ public boolean equals(Object o) {\n     return false;\n   }\n   \n-  @Override\n   public int hashCode() {\n     int result = 0;\n     for (ByteSequence b : auths)\n",
        "project": "accumulo",
        "linesAdd": 2,
        "jira_id": "1051",
        "nb_skipped": 0,
        "commit": "25cf3ccd",
        "nb_failure": 1,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 307,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.iterators.system.VisibilityFilterTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/iterators/system/VisibilityFilter.java b/core/src/main/java/org/apache/accumulo/core/iterators/system/VisibilityFilter.java\nindex a41f7bee7..4902e6176 100644\n--- a/core/src/main/java/org/apache/accumulo/core/iterators/system/VisibilityFilter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/iterators/system/VisibilityFilter.java\n@@ -25,6 +25,7 @@\n import org.apache.accumulo.core.security.ColumnVisibility;\n import org.apache.accumulo.core.security.VisibilityEvaluator;\n import org.apache.accumulo.core.security.VisibilityParseException;\n+import org.apache.accumulo.core.util.BadArgumentException;\n import org.apache.accumulo.core.util.TextUtil;\n import org.apache.commons.collections.map.LRUMap;\n import org.apache.hadoop.io.Text;\n@@ -73,6 +74,9 @@ else if (testVis.getLength() == 0)\n     } catch (VisibilityParseException e) {\n       log.error(\"Parse Error\", e);\n       return false;\n+    } catch (BadArgumentException e) {\n+      log.error(\"Parse Error\", e);\n+      return false;\n     }\n   }\n }\n",
        "project": "accumulo",
        "linesAdd": 4,
        "jira_id": "844",
        "nb_skipped": 0,
        "commit": "692efde2",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 8,
        "nb_test": 273,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.iterators.user.FilterTest",
            "org.apache.accumulo.core.iterators.user.CombinerTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\nindex 5281f4dcb..8532e56d6 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/Combiner.java\n@@ -227,6 +227,20 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n     combiners = new ColumnSet(Arrays.asList(encodedColumns.split(\",\")));\n   }\n   \n+  @Override\n+  public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n+    Combiner newInstance;\n+    try {\n+      newInstance = this.getClass().newInstance();\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+    newInstance.setSource(getSource().deepCopy(env));\n+    newInstance.combiners = combiners;\n+    newInstance.combineAllColumns = combineAllColumns;\n+    return newInstance;\n+  }\n+  \n   @Override\n   public IteratorOptions describeOptions() {\n     IteratorOptions io = new IteratorOptions(\"comb\", \"Combiners apply reduce functions to values with identical keys\", null, null);\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/TypedValueCombiner.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/TypedValueCombiner.java\nindex 628c9ddf2..7b8d636da 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/TypedValueCombiner.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/TypedValueCombiner.java\n@@ -145,6 +145,14 @@ protected void testEncoder(V v) {\n     }\n   }\n   \n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n+    TypedValueCombiner<V> newInstance = (TypedValueCombiner<V>) super.deepCopy(env);\n+    newInstance.setEncoder(encoder);\n+    return newInstance;\n+  }\n+  \n   @Override\n   public Value reduce(Key key, Iterator<Value> iter) {\n     return new Value(encoder.encode(typedReduce(key, new VIterator<V>(iter, encoder))));\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/VersioningIterator.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/VersioningIterator.java\nindex e38c68e02..9d92db328 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/VersioningIterator.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/VersioningIterator.java\n@@ -29,6 +29,8 @@\n   public VersioningIterator() {}\n   \n   public VersioningIterator(SortedKeyValueIterator<Key,Value> iterator, int maxVersions) {\n-    super(iterator, maxVersions);\n+    super();\n+    this.setSource(iterator);\n+    this.maxVersions = maxVersions;\n   }\n }\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/AgeOffFilter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/AgeOffFilter.java\nindex 9feffd81b..486e6cb3a 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/AgeOffFilter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/AgeOffFilter.java\n@@ -37,26 +37,6 @@\n   private long threshold;\n   private long currentTime;\n   \n-  public AgeOffFilter() {}\n-  \n-  /**\n-   * Constructs a filter that omits entries read from a source iterator if the Key's timestamp is less than currentTime - threshold.\n-   * \n-   * @param iterator\n-   *          The source iterator.\n-   * \n-   * @param threshold\n-   *          Maximum age in milliseconds of data to keep.\n-   * \n-   * @param threshold\n-   *          Current time in milliseconds.\n-   */\n-  private AgeOffFilter(SortedKeyValueIterator<Key,Value> iterator, long threshold, long currentTime) {\n-    setSource(iterator);\n-    this.threshold = threshold;\n-    this.currentTime = currentTime;\n-  }\n-  \n   /**\n    * Accepts entries whose timestamps are less than currentTime - threshold.\n    * \n@@ -93,7 +73,10 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n   \n   @Override\n   public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n-    return new AgeOffFilter(getSource(), threshold, currentTime);\n+    AgeOffFilter copy = (AgeOffFilter) super.deepCopy(env);\n+    copy.currentTime = currentTime;\n+    copy.threshold = threshold;\n+    return copy;\n   }\n   \n   @Override\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/ColumnAgeOffFilter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/ColumnAgeOffFilter.java\nindex 4bffbcb41..8c957287c 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/ColumnAgeOffFilter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/ColumnAgeOffFilter.java\n@@ -36,15 +36,6 @@\n  * Different thresholds are set for each column.\n  */\n public class ColumnAgeOffFilter extends Filter {\n-  \n-  public ColumnAgeOffFilter() {}\n-  \n-  private ColumnAgeOffFilter(SortedKeyValueIterator<Key,Value> iterator, TTLSet ttls, long currentTime) {\n-    setSource(iterator);\n-    this.ttls = ttls;\n-    this.currentTime = currentTime;\n-  }\n-  \n   public static class TTLSet extends ColumnToClassMapping<Long> {\n     public TTLSet(Map<String,String> objectStrings) {\n       super();\n@@ -87,7 +78,10 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n   \n   @Override\n   public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n-    return new ColumnAgeOffFilter(getSource(), ttls, currentTime);\n+    ColumnAgeOffFilter copy = (ColumnAgeOffFilter) super.deepCopy(env);\n+    copy.currentTime = currentTime;\n+    copy.ttls = ttls;\n+    return copy;\n   }\n   \n   public void overrideCurrentTime(long ts) {\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\nindex fb5380190..e50863127 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n@@ -37,8 +37,7 @@\n   \n   @Override\n   public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n-    RegExFilter result = new RegExFilter();\n-    result.setSource(getSource().deepCopy(env));\n+    RegExFilter result = (RegExFilter) super.deepCopy(env);\n     result.rowMatcher = copyMatcher(rowMatcher);\n     result.colfMatcher = copyMatcher(colfMatcher);\n     result.colqMatcher = copyMatcher(colqMatcher);\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java\nindex 5b652aa24..2dbfe66fd 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/TimestampFilter.java\n@@ -54,17 +54,6 @@ private static SimpleDateFormat initDateParser() {\n   \n   public TimestampFilter() {}\n   \n-  private TimestampFilter(SortedKeyValueIterator<Key,Value> iterator, boolean hasStart, long start, boolean startInclusive, boolean hasEnd, long end,\n-      boolean endInclusive) {\n-    setSource(iterator);\n-    this.start = start;\n-    this.startInclusive = startInclusive;\n-    this.hasStart = true;\n-    this.end = end;\n-    this.endInclusive = endInclusive;\n-    this.hasEnd = true;\n-  }\n-  \n   @Override\n   public boolean accept(Key k, Value v) {\n     long ts = k.getTimestamp();\n@@ -112,7 +101,14 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n   \n   @Override\n   public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n-    return new TimestampFilter(getSource(), hasStart, start, startInclusive, hasEnd, end, endInclusive);\n+    TimestampFilter copy = (TimestampFilter) super.deepCopy(env);\n+    copy.hasStart = hasStart;\n+    copy.start = start;\n+    copy.startInclusive = startInclusive;\n+    copy.hasEnd = hasEnd;\n+    copy.end = end;\n+    copy.endInclusive = endInclusive;\n+    return copy;\n   }\n   \n   @Override\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/VersioningIterator.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/VersioningIterator.java\nindex 0b2c76709..53833f4f5 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/VersioningIterator.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/VersioningIterator.java\n@@ -37,25 +37,14 @@\n   \n   private Key currentKey = new Key();\n   private int numVersions;\n-  private int maxVersions;\n+  protected int maxVersions;\n   \n   @Override\n   public VersioningIterator deepCopy(IteratorEnvironment env) {\n-    return new VersioningIterator(this, env);\n-  }\n-  \n-  private VersioningIterator(VersioningIterator other, IteratorEnvironment env) {\n-    setSource(other.getSource().deepCopy(env));\n-    maxVersions = other.maxVersions;\n-  }\n-  \n-  public VersioningIterator() {}\n-  \n-  public VersioningIterator(SortedKeyValueIterator<Key,Value> iterator, int maxVersions) {\n-    if (maxVersions < 1)\n-      throw new IllegalArgumentException(\"maxVersions for versioning iterator must be >= 1\");\n-    this.setSource(iterator);\n-    this.maxVersions = maxVersions;\n+    VersioningIterator copy = new VersioningIterator();\n+    copy.setSource(getSource().deepCopy(env));\n+    copy.maxVersions = maxVersions;\n+    return copy;\n   }\n   \n   @Override\n",
        "project": "accumulo",
        "linesAdd": 47,
        "jira_id": "334",
        "nb_skipped": 0,
        "commit": "9d8cc45d",
        "nb_failure": 1,
        "linesRem": 50,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 434,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.data.MutationTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/data/Mutation.java b/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\nindex 0861cc4f2..81ad5316d 100644\n--- a/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\n+++ b/core/src/main/java/org/apache/accumulo/core/data/Mutation.java\n@@ -191,6 +191,20 @@ private void serialize() {\n     }\n   }\n \n+  /* This is so hashCode & equals can be called without changing this object.\n+   *\n+   * It will return a copy of the current data buffer if serialized has not been\n+   * called previously. Otherwise, this.data will be returned since the buffer is\n+   * null and will not change.\n+   */\n+  private byte[] serializedSnapshot() {\n+    if (buffer != null) {\n+      return buffer.toArray();\n+    } else {\n+      return this.data;\n+    }\n+  }\n+\n   /**\n    * @since 1.5.0\n    */\n@@ -691,13 +705,13 @@ public boolean equals(Object o) {\n \n   @Override\n   public int hashCode() {\n-    return toThrift().hashCode();\n+    return toThrift(false).hashCode();\n   }\n \n   public boolean equals(Mutation m) {\n-    serialize();\n-    m.serialize();\n-    if (Arrays.equals(row, m.row) && entries == m.entries && Arrays.equals(data, m.data)) {\n+    byte[] myData = serializedSnapshot();\n+    byte[] otherData = m.serializedSnapshot();\n+    if (Arrays.equals(row, m.row) && entries == m.entries && Arrays.equals(myData, otherData)) {\n       if (values == null && m.values == null)\n         return true;\n \n@@ -716,7 +730,17 @@ public boolean equals(Mutation m) {\n   }\n \n   public TMutation toThrift() {\n-    serialize();\n+    return toThrift(true);\n+  }\n+\n+  private TMutation toThrift(boolean serialize) {\n+    byte[] data;\n+    if (serialize) {\n+      this.serialize();\n+      data = this.data;\n+    } else {\n+      data = serializedSnapshot();\n+    }\n     return new TMutation(java.nio.ByteBuffer.wrap(row), java.nio.ByteBuffer.wrap(data), ByteBufferUtil.toByteBuffers(values), entries);\n   }\n \n",
        "project": "accumulo",
        "linesAdd": 23,
        "jira_id": "3718",
        "nb_skipped": 0,
        "commit": "73ce9cfb",
        "nb_failure": 2,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 279,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.iterators.user.RegExFilterTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\nindex 0b3b73f11..86b2bde43 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n@@ -17,6 +17,7 @@\n package org.apache.accumulo.core.iterators.user;\n \n import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n import java.util.Map;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n@@ -28,7 +29,6 @@\n import org.apache.accumulo.core.iterators.Filter;\n import org.apache.accumulo.core.iterators.IteratorEnvironment;\n import org.apache.accumulo.core.iterators.SortedKeyValueIterator;\n-import org.apache.accumulo.core.util.ByteArrayBackedCharSequence;\n \n /**\n  * A Filter that matches entries based on Java regular expressions.\n@@ -52,6 +52,9 @@\n   public static final String COLQ_REGEX = \"colqRegex\";\n   public static final String VALUE_REGEX = \"valueRegex\";\n   public static final String OR_FIELDS = \"orFields\";\n+  public static final String ENCODING = \"encoding\";\n+  \n+  public static final String ENCODING_DEFAULT = \"UTF-8\";\n   \n   private Matcher rowMatcher;\n   private Matcher colfMatcher;\n@@ -59,10 +62,9 @@\n   private Matcher valueMatcher;\n   private boolean orFields = false;\n   \n-  private ByteArrayBackedCharSequence babcs = new ByteArrayBackedCharSequence();\n+  private String encoding = ENCODING_DEFAULT;\n   \n-  private Matcher copyMatcher(Matcher m)\n-  {\n+  private Matcher copyMatcher(Matcher m) {\n     if (m == null)\n       return m;\n     else\n@@ -71,21 +73,25 @@ private Matcher copyMatcher(Matcher m)\n   \n   private boolean matches(Matcher matcher, ByteSequence bs) {\n     if (matcher != null) {\n-      babcs.set(bs);\n-      matcher.reset(babcs);\n+      try {\n+        matcher.reset(new String(bs.getBackingArray(), encoding));\n         return matcher.matches();\n+      } catch (UnsupportedEncodingException e) {\n+        e.printStackTrace();\n+      }\n     }\n-    \n     return !orFields;\n   }\n   \n   private boolean matches(Matcher matcher, byte data[], int offset, int len) {\n     if (matcher != null) {\n-      babcs.set(data, offset, len);\n-      matcher.reset(babcs);\n+      try {\n+        matcher.reset(new String(data, offset, len, encoding));\n         return matcher.matches();\n+      } catch (UnsupportedEncodingException e) {\n+        e.printStackTrace();\n+      }\n     }\n-    \n     return !orFields;\n   }\n   \n@@ -130,6 +136,10 @@ public void init(SortedKeyValueIterator<Key,Value> source, Map<String,String> op\n     } else {\n       orFields = false;\n     }\n+    \n+    if (options.containsKey(ENCODING)) {\n+      encoding = options.get(ENCODING);\n+    }\n   }\n   \n   @Override\n@@ -142,6 +152,7 @@ public IteratorOptions describeOptions() {\n     io.addNamedOption(RegExFilter.COLQ_REGEX, \"regular expression on column qualifier\");\n     io.addNamedOption(RegExFilter.VALUE_REGEX, \"regular expression on value\");\n     io.addNamedOption(RegExFilter.OR_FIELDS, \"use OR instread of AND when multiple regexes given\");\n+    io.addNamedOption(RegExFilter.ENCODING, \"character encoding of byte array value (default is \" + ENCODING_DEFAULT + \")\");\n     return io;\n   }\n   \n@@ -160,6 +171,17 @@ public boolean validateOptions(Map<String,String> options) {\n     if (options.containsKey(VALUE_REGEX))\n       Pattern.compile(options.get(VALUE_REGEX)).matcher(\"\");\n     \n+    if (options.containsKey(ENCODING)) {\n+      try {\n+        this.encoding = options.get(ENCODING);\n+        @SuppressWarnings(\"unused\")\n+        String test = new String(\"test\".getBytes(), encoding);\n+      } catch (UnsupportedEncodingException e) {\n+        e.printStackTrace();\n+        return false;\n+      }\n+    }\n+    \n     return true;\n   }\n   \n@@ -192,4 +214,19 @@ public static void setRegexs(IteratorSetting si, String rowTerm, String cfTerm,\n       si.addOption(RegExFilter.OR_FIELDS, \"true\");\n     }\n   }\n+  \n+  /**\n+   * Set the encoding string to use when interpreting characters\n+   * \n+   * @param si\n+   *          ScanIterator config to be updated\n+   * @param encoding\n+   *          the encoding string to use for character interpretation.\n+   * \n+   */\n+  public static void setEncoding(IteratorSetting si, String encoding) {\n+    if (!encoding.isEmpty()) {\n+      si.addOption(RegExFilter.ENCODING, encoding);\n+    }\n+  }\n }\n",
        "project": "accumulo",
        "linesAdd": 38,
        "jira_id": "209",
        "nb_skipped": 0,
        "commit": "397f86f6",
        "nb_failure": 1,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 8,
        "nb_test": 276,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.iterators.user.FilterTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java b/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java\nindex 4f95e1a6c..83283ac18 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/conf/Property.java\n@@ -65,7 +65,6 @@\n   MASTER_RECOVERY_POOL(\"master.recovery.pool\", \"recovery\", PropertyType.STRING, \"Priority queue to use for log recovery map/reduce jobs.\"),\n   MASTER_RECOVERY_SORT_MAPREDUCE(\"master.recovery.sort.mapreduce\", \"false\", PropertyType.BOOLEAN,\n       \"If true, use map/reduce to sort write-ahead logs during recovery\"),\n-  MASTER_BULK_SERVERS(\"master.bulk.server.max\", \"4\", PropertyType.COUNT, \"The number of servers to use during a bulk load\"),\n   MASTER_BULK_RETRIES(\"master.bulk.retries\", \"3\", PropertyType.COUNT, \"The number of attempts to bulk-load a file before giving up.\"),\n   MASTER_BULK_THREADPOOL_SIZE(\"master.bulk.threadpool.size\", \"5\", PropertyType.COUNT, \"The number of threads to use when coordinating a bulk-import.\"),\n   MASTER_MINTHREADS(\"master.server.threads.minimum\", \"2\", PropertyType.COUNT, \"The minimum number of threads to use to handle incoming requests.\"),\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/Filter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/Filter.java\nindex 94daf03bf..a9ed76c19 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/Filter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/Filter.java\n@@ -69,7 +69,7 @@ public void seek(Range range, Collection<ByteSequence> columnFamilies, boolean i\n    * Iterates over the source until an acceptable key/value pair is found.\n    */\n   protected void findTop() {\n-    while (getSource().hasTop() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {\n+    while (getSource().hasTop() && !getSource().getTopKey().isDeleted() && (negate == accept(getSource().getTopKey(), getSource().getTopValue()))) {\n       try {\n         getSource().next();\n       } catch (IOException e) {\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/SortedKeyValueIterator.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/SortedKeyValueIterator.java\nindex 8bbf18af7..edeaa1d2a 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/SortedKeyValueIterator.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/SortedKeyValueIterator.java\n@@ -59,7 +59,9 @@\n   boolean hasTop();\n   \n   /**\n-   * Advances to the next K,V pair.\n+   * Advances to the next K,V pair. Note that in minor compaction scope and in non-full major compaction scopes the iterator may see deletion entries. These\n+   * entries should be preserved by all iterators except ones that are strictly scan-time iterators that will never be configured for the minc or majc scopes.\n+   * Deletion entries are only removed during full major compactions.\n    * \n    * @throws IOException\n    *           if an I/O error occurs.\n@@ -88,7 +90,9 @@\n   void seek(Range range, Collection<ByteSequence> columnFamilies, boolean inclusive) throws IOException;\n   \n   /**\n-   * Returns top key. Can be called 0 or more times without affecting behavior of next() or hasTop().\n+   * Returns top key. Can be called 0 or more times without affecting behavior of next() or hasTop(). Note that in minor compaction scope and in non-full major\n+   * compaction scopes the iterator may see deletion entries. These entries should be preserved by all iterators except ones that are strictly scan-time\n+   * iterators that will never be configured for the minc or majc scopes. Deletion entries are only removed during full major compactions.\n    * \n    * @return <tt>K</tt>\n    * @exception IllegalStateException\ndiff --git a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java\nindex 5e82a7d1e..bb4ae64e3 100644\n--- a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java\n+++ b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitionedMapper.java\n@@ -42,14 +42,13 @@\n import org.apache.hadoop.conf.Configuration;\n import org.apache.hadoop.io.Text;\n import org.apache.hadoop.mapreduce.Mapper;\n-import org.apache.log4j.Logger;\n \n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Multimap;\n \n public class WikipediaPartitionedMapper extends Mapper<Text,Article,Text,Mutation> {\n   \n-  private static final Logger log = Logger.getLogger(WikipediaPartitionedMapper.class);\n+  // private static final Logger log = Logger.getLogger(WikipediaPartitionedMapper.class);\n   \n   public final static Charset UTF8 = Charset.forName(\"UTF-8\");\n   public static final String DOCUMENT_COLUMN_FAMILY = \"d\";\ndiff --git a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java\nindex 82af9fd52..3507108b3 100644\n--- a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java\n+++ b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/ingest/WikipediaPartitioner.java\n@@ -23,40 +23,21 @@\n import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStreamReader;\n-import java.io.StringReader;\n import java.nio.charset.Charset;\n-import java.util.HashSet;\n-import java.util.IllegalFormatException;\n-import java.util.Map.Entry;\n-import java.util.Set;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-import org.apache.accumulo.core.data.Mutation;\n-import org.apache.accumulo.core.data.Value;\n-import org.apache.accumulo.core.security.ColumnVisibility;\n import org.apache.accumulo.examples.wikisearch.ingest.ArticleExtractor.Article;\n import org.apache.accumulo.examples.wikisearch.ingest.WikipediaInputFormat.WikipediaInputSplit;\n-import org.apache.accumulo.examples.wikisearch.normalizer.LcNoDiacriticsNormalizer;\n-import org.apache.accumulo.examples.wikisearch.protobuf.Uid;\n-import org.apache.accumulo.examples.wikisearch.protobuf.Uid.List.Builder;\n-import org.apache.commons.codec.binary.Base64;\n-import org.apache.commons.lang.StringUtils;\n import org.apache.hadoop.conf.Configuration;\n import org.apache.hadoop.io.LongWritable;\n import org.apache.hadoop.io.Text;\n import org.apache.hadoop.mapreduce.Mapper;\n import org.apache.hadoop.mapreduce.lib.input.FileSplit;\n-import org.apache.log4j.Logger;\n-import org.apache.lucene.analysis.tokenattributes.TermAttribute;\n-import org.apache.lucene.wikipedia.analysis.WikipediaTokenizer;\n-\n-import com.google.common.collect.HashMultimap;\n-import com.google.common.collect.Multimap;\n \n public class WikipediaPartitioner extends Mapper<LongWritable,Text,Text,Article> {\n   \n-  private static final Logger log = Logger.getLogger(WikipediaPartitioner.class);\n+  // private static final Logger log = Logger.getLogger(WikipediaPartitioner.class);\n   \n   public final static Charset UTF8 = Charset.forName(\"UTF-8\");\n   public static final String DOCUMENT_COLUMN_FAMILY = \"d\";\ndiff --git a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java\nindex d8c57c2f9..2738e2c0b 100644\n--- a/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java\n+++ b/src/examples/wikisearch/ingest/src/main/java/org/apache/accumulo/examples/wikisearch/output/SortingRFileOutputFormat.java\n@@ -4,20 +4,18 @@\n \n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n import org.apache.accumulo.core.data.Mutation;\n-import org.apache.accumulo.examples.wikisearch.ingest.WikipediaMapper;\n import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.io.Text;\n import org.apache.hadoop.mapreduce.JobContext;\n import org.apache.hadoop.mapreduce.OutputCommitter;\n import org.apache.hadoop.mapreduce.OutputFormat;\n import org.apache.hadoop.mapreduce.RecordWriter;\n import org.apache.hadoop.mapreduce.TaskAttemptContext;\n-import org.apache.hadoop.fs.FileSystem;\n-import org.apache.hadoop.io.Text;\n-import org.apache.log4j.Logger;\n \n public class SortingRFileOutputFormat extends OutputFormat<Text,Mutation> {\n \n-  private static final Logger log = Logger.getLogger(SortingRFileOutputFormat.class);\n+  // private static final Logger log = Logger.getLogger(SortingRFileOutputFormat.class);\n \n   public static final String PATH_NAME = \"sortingrfileoutputformat.path\";\n   public static final String MAX_BUFFER_SIZE = \"sortingrfileoutputformat.max.buffer.size\";\ndiff --git a/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java b/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java\nindex 071b8bd26..4ee5371f2 100644\n--- a/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java\n+++ b/src/server/src/main/java/org/apache/accumulo/server/client/BulkImporter.java\n@@ -38,8 +38,8 @@\n import org.apache.accumulo.core.client.Instance;\n import org.apache.accumulo.core.client.impl.ServerClient;\n import org.apache.accumulo.core.client.impl.TabletLocator;\n-import org.apache.accumulo.core.client.impl.Translator;\n import org.apache.accumulo.core.client.impl.TabletLocator.TabletLocation;\n+import org.apache.accumulo.core.client.impl.Translator;\n import org.apache.accumulo.core.client.impl.thrift.ClientService;\n import org.apache.accumulo.core.client.impl.thrift.ThriftTableOperationException;\n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n@@ -150,7 +150,7 @@ public void run() {\n             } catch (Exception ex) {\n               log.warn(\"Unable to find tablets that overlap file \" + mapFile.toString());\n             }\n-            \n+            log.debug(\"Map file \" + mapFile + \" found to overlap \" + tabletsToAssignMapFileTo.size() + \" tablets\");\n             if (tabletsToAssignMapFileTo.size() == 0) {\n               List<KeyExtent> empty = Collections.emptyList();\n               completeFailures.put(mapFile, empty);\n@@ -652,33 +652,41 @@ public String toString() {\n     return findOverlappingTablets(acuConf, fs, locator, file, start, failed.getEndRow());\n   }\n   \n+  final static byte[] byte0 = {0};\n+\n   public static List<TabletLocation> findOverlappingTablets(AccumuloConfiguration acuConf, FileSystem fs, TabletLocator locator, Path file, Text startRow,\n       Text endRow) throws Exception {\n     List<TabletLocation> result = new ArrayList<TabletLocation>();\n-    \n     Collection<ByteSequence> columnFamilies = Collections.emptyList();\n-    \n-    FileSKVIterator reader = FileOperations.getInstance().openReader(file.toString(), true, fs, fs.getConf(), acuConf);\n+    String filename = file.toString();\n+    // log.debug(filename + \" finding overlapping tablets \" + startRow + \" -> \" + endRow);\n+    FileSKVIterator reader = FileOperations.getInstance().openReader(filename, true, fs, fs.getConf(), acuConf);\n     try {\n       Text row = startRow;\n       if (row == null)\n         row = new Text();\n       while (true) {\n+        // log.debug(filename + \" Seeking to row \" + row);\n         reader.seek(new Range(row, null), columnFamilies, false);\n-        if (!reader.hasTop())\n+        if (!reader.hasTop()) {\n+          // log.debug(filename + \" not found\");\n           break;\n+        }\n         row = reader.getTopKey().getRow();\n         TabletLocation tabletLocation = locator.locateTablet(row, false, true);\n+        // log.debug(filename + \" found row \" + row + \" at location \" + tabletLocation);\n         result.add(tabletLocation);\n         row = tabletLocation.tablet_extent.getEndRow();\n-        if (row != null && (endRow == null || row.compareTo(endRow) < 0))\n-          row = Range.followingPrefix(row);\n-        else\n+        if (row != null && (endRow == null || row.compareTo(endRow) < 0)) {\n+          row = new Text(row);\n+          row.append(byte0, 0, byte0.length);\n+        } else\n           break;\n       }\n     } finally {\n       reader.close();\n     }\n+    // log.debug(filename + \" to be sent to \" + result);\n     return result;\n   }\n   \ndiff --git a/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java b/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java\nindex c4a3f5091..05c353dae 100644\n--- a/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java\n+++ b/src/server/src/main/java/org/apache/accumulo/server/master/tableOps/BulkImport.java\n@@ -19,11 +19,15 @@\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Set;\n+import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n import java.util.concurrent.LinkedBlockingQueue;\n@@ -41,12 +45,13 @@\n import org.apache.accumulo.core.client.impl.thrift.TableOperationExceptionType;\n import org.apache.accumulo.core.client.impl.thrift.ThriftTableOperationException;\n import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.conf.SiteConfiguration;\n import org.apache.accumulo.core.file.FileOperations;\n import org.apache.accumulo.core.master.state.tables.TableState;\n import org.apache.accumulo.core.security.thrift.AuthInfo;\n import org.apache.accumulo.core.util.CachedConfiguration;\n import org.apache.accumulo.core.util.Daemon;\n-import org.apache.accumulo.core.util.LoggingRunnable;\n+import org.apache.accumulo.core.util.ThriftUtil;\n import org.apache.accumulo.core.util.UtilWaitThread;\n import org.apache.accumulo.server.ServerConstants;\n import org.apache.accumulo.server.client.HdfsZooInstance;\n@@ -370,7 +375,7 @@ public LoadFiles(String tableId, String source, String bulk, String errorDir, bo\n   \n   @Override\n   public Repo<Master> call(final long tid, Master master) throws Exception {\n-    \n+    final SiteConfiguration conf = ServerConfiguration.getSiteConfiguration();\n     FileSystem fs = TraceFileSystem.wrap(org.apache.accumulo.core.file.FileUtil.getFileSystem(CachedConfiguration.getInstance(),\n         ServerConfiguration.getSiteConfiguration()));\n     List<FileStatus> files = new ArrayList<FileStatus>();\n@@ -389,42 +394,68 @@ public LoadFiles(String tableId, String source, String bulk, String errorDir, bo\n     }\n     fs.delete(writable, false);\n     \n-    // group files into N-sized chunks, send the chunks to random servers\n-    final int SERVERS_TO_USE = Math.min(ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_SERVERS), master.onlineTabletServers()\n-        .size());\n-    \n-    log.debug(\"tid \" + tid + \" using \" + SERVERS_TO_USE + \" servers\");\n-    // wait for success, repeat failures R times\n     final List<String> filesToLoad = Collections.synchronizedList(new ArrayList<String>());\n     for (FileStatus f : files)\n       filesToLoad.add(f.getPath().toString());\n     \n-    final int RETRIES = Math.max(1, ServerConfiguration.getSystemConfiguration().getCount(Property.MASTER_BULK_RETRIES));\n-    for (int i = 0; i < RETRIES && filesToLoad.size() > 0; i++) {\n-      List<Future<?>> results = new ArrayList<Future<?>>();\n-      for (List<String> chunk : groupFiles(filesToLoad, SERVERS_TO_USE)) {\n-        final List<String> attempt = chunk;\n-        results.add(threadPool.submit(new LoggingRunnable(log, new Runnable() {\n+\n+    final int RETRIES = Math.max(1, conf.getCount(Property.MASTER_BULK_RETRIES));\n+    for (int attempt = 0; attempt < RETRIES && filesToLoad.size() > 0; attempt++) {\n+      List<Future<List<String>>> results = new ArrayList<Future<List<String>>>();\n+      \n+      // Figure out which files will be sent to which server\n+      Set<TServerInstance> currentServers = Collections.synchronizedSet(new HashSet<TServerInstance>(master.onlineTabletServers()));\n+      Map<String,List<String>> loadAssignments = new HashMap<String,List<String>>();\n+      for (TServerInstance server : currentServers) {\n+        loadAssignments.put(server.hostPort(), new ArrayList<String>());\n+      }\n+      int i = 0;\n+      List<Entry<String,List<String>>> entries = new ArrayList<Entry<String,List<String>>>(loadAssignments.entrySet());\n+      for (String file : filesToLoad) {\n+        entries.get(i % entries.size()).getValue().add(file);\n+        i++;\n+      }\n+      \n+      // Use the threadpool to assign files one-at-a-time to the server\n+      for (Entry<String,List<String>> entry : entries) {\n+        if (entry.getValue().isEmpty()) {\n+          continue;\n+        }\n+        final Entry<String,List<String>> finalEntry = entry;\n+        results.add(threadPool.submit(new Callable<List<String>>() {\n           @Override\n-          public void run() {\n+          public List<String> call() {\n+            if (log.isDebugEnabled()) {\n+              log.debug(\"Asking \" + finalEntry.getKey() + \" to load \" + sampleList(finalEntry.getValue(), 10));\n+            }\n+            List<String> failures = new ArrayList<String>();\n             ClientService.Iface client = null;\n             try {\n-              client = ServerClient.getConnection(HdfsZooInstance.getInstance());\n+              client = ThriftUtil.getTServerClient(finalEntry.getKey(), conf);\n+              for (String file : finalEntry.getValue()) {\n+                List<String> attempt = Collections.singletonList(file);\n+                log.debug(\"Asking \" + finalEntry.getKey() + \" to bulk import \" + file);\n                 List<String> fail = client.bulkImportFiles(null, SecurityConstants.getSystemCredentials(), tid, tableId, attempt, errorDir, setTime);\n-              attempt.removeAll(fail);\n-              filesToLoad.removeAll(attempt);\n+                if (fail.isEmpty()) {\n+                  filesToLoad.remove(file);\n+                } else {\n+                  failures.addAll(fail);\n+                }\n+              }\n             } catch (Exception ex) {\n               log.error(ex, ex);\n             } finally {\n               ServerClient.close(client);\n             }\n+            return failures;\n           }\n-        })));\n+        }));\n       }\n-      for (Future<?> f : results)\n-        f.get();\n+      Set<String> failures = new HashSet<String>();\n+      for (Future<List<String>> f : results)\n+        failures.addAll(f.get());\n       if (filesToLoad.size() > 0) {\n-        log.debug(\"tid \" + tid + \" attempt \" + (i + 1) + \" \" + filesToLoad + \" failed\");\n+        log.debug(\"tid \" + tid + \" attempt \" + (i + 1) + \" \" + sampleList(filesToLoad, 10) + \" failed\");\n         UtilWaitThread.sleep(100);\n       }\n     }\n@@ -449,16 +480,24 @@ public void run() {\n     return new CompleteBulkImport(tableId, source, bulk, errorDir);\n   }\n   \n-  private List<List<String>> groupFiles(List<String> files, int groups) {\n-    List<List<String>> result = new ArrayList<List<String>>();\n-    Iterator<String> iter = files.iterator();\n-    for (int i = 0; i < groups && iter.hasNext(); i++) {\n-      List<String> group = new ArrayList<String>();\n-      for (int j = 0; j < Math.ceil(files.size() / (double) groups) && iter.hasNext(); j++) {\n-        group.add(iter.next());\n+  static String sampleList(Collection<?> potentiallyLongList, int max) {\n+    StringBuffer result = new StringBuffer();\n+    result.append(\"[\");\n+    int i = 0;\n+    for (Object obj : potentiallyLongList) {\n+      result.append(obj);\n+      if (i >= max) {\n+        result.append(\"...\");\n+        break;\n+      } else {\n+        result.append(\", \");\n       }\n-      result.add(group);\n+      i++;\n     }\n-    return result;\n+    if (i < max)\n+      result.delete(result.length() - 2, result.length());\n+    result.append(\"]\");\n+    return result.toString();\n   }\n+\n }\n",
        "project": "accumulo",
        "linesAdd": 84,
        "jira_id": "412",
        "nb_skipped": 0,
        "commit": "be2fdba7",
        "nb_failure": 1,
        "linesRem": 68,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 279,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.iterators.user.RegExFilterTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\nindex fcf77c401..0b3b73f11 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/iterators/user/RegExFilter.java\n@@ -39,10 +39,10 @@\n   public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n     RegExFilter result = new RegExFilter();\n     result.setSource(getSource().deepCopy(env));\n-    result.rowMatcher = rowMatcher.pattern().matcher(\"\");\n-    result.colfMatcher = colfMatcher.pattern().matcher(\"\");\n-    result.colqMatcher = colqMatcher.pattern().matcher(\"\");\n-    result.valueMatcher = valueMatcher.pattern().matcher(\"\");\n+    result.rowMatcher = copyMatcher(rowMatcher);\n+    result.colfMatcher = copyMatcher(colfMatcher);\n+    result.colqMatcher = copyMatcher(colqMatcher);\n+    result.valueMatcher = copyMatcher(valueMatcher);\n     result.orFields = orFields;\n     return result;\n   }\n@@ -61,6 +61,14 @@\n   \n   private ByteArrayBackedCharSequence babcs = new ByteArrayBackedCharSequence();\n   \n+  private Matcher copyMatcher(Matcher m)\n+  {\n+\t  if(m == null)\n+\t\t  return m;\n+\t  else\n+\t\t  return m.pattern().matcher(\"\");\n+  }\n+  \n   private boolean matches(Matcher matcher, ByteSequence bs) {\n     if (matcher != null) {\n       babcs.set(bs);\n",
        "project": "accumulo",
        "linesAdd": 12,
        "jira_id": "189",
        "nb_skipped": 0,
        "commit": "cd7feb4d",
        "nb_failure": 0,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 270,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.client.mock.MockTableOperationsTest"
        ],
        "patch": "diff --git a/src/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsHelper.java b/src/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsHelper.java\nindex 96a31e7cd..31f740569 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsHelper.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/client/admin/TableOperationsHelper.java\n@@ -48,6 +48,8 @@ public void attachIterator(String tableName, IteratorSetting setting) throws Acc\n   @Override\n   public void removeIterator(String tableName, String name, EnumSet<IteratorScope> scopes) throws AccumuloSecurityException, AccumuloException,\n       TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(null, tableName, null);\n     Map<String,String> copy = new TreeMap<String,String>();\n     for (Entry<String,String> property : this.getProperties(tableName)) {\n       copy.put(property.getKey(), property.getValue());\n@@ -64,6 +66,8 @@ public void removeIterator(String tableName, String name, EnumSet<IteratorScope>\n   @Override\n   public IteratorSetting getIteratorSetting(String tableName, String name, IteratorScope scope) throws AccumuloSecurityException, AccumuloException,\n       TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(null, tableName, null);\n     int priority = -1;\n     String classname = null;\n     Map<String,String> settings = new HashMap<String,String>();\n@@ -90,6 +94,8 @@ public IteratorSetting getIteratorSetting(String tableName, String name, Iterato\n   \n   @Override\n   public Set<String> listIterators(String tableName) throws AccumuloSecurityException, AccumuloException, TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(null, tableName, null);\n     Set<String> result = new HashSet<String>();\n     Set<String> lifecycles = new HashSet<String>();\n     for (IteratorScope scope : IteratorScope.values())\n@@ -107,6 +113,8 @@ public IteratorSetting getIteratorSetting(String tableName, String name, Iterato\n   \n   @Override\n   public void checkIteratorConflicts(String tableName, IteratorSetting setting) throws AccumuloException, TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(null, tableName, null);\n     for (IteratorScope scope : setting.getScopes()) {\n       String scopeStr = String.format(\"%s%s\", Property.TABLE_ITERATOR_PREFIX, scope.name().toLowerCase());\n       String nameStr = String.format(\"%s.%s\", scopeStr, setting.getName());\ndiff --git a/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java b/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\nindex 4063b7667..1b2a3d0f2 100644\n--- a/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n+++ b/src/core/src/main/java/org/apache/accumulo/core/client/mock/MockTableOperations.java\n@@ -81,6 +81,8 @@ public void create(String tableName, boolean versioningIter, TimeType timeType)\n     if (!tableName.matches(Constants.VALID_TABLE_NAME_REGEX)) {\n       throw new IllegalArgumentException();\n     }\n+    if (exists(tableName))\n+      throw new TableExistsException(tableName, tableName, \"\");\n     acu.createTable(username, tableName, versioningIter, timeType);\n   }\n   \n@@ -90,30 +92,42 @@ public void create(String tableName, boolean versioningIter, TimeType timeType)\n   @Override\n   public void addAggregators(String tableName, List<? extends PerColumnIteratorConfig> aggregators) throws AccumuloSecurityException, TableNotFoundException,\n       AccumuloException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     acu.addAggregators(tableName, aggregators);\n   }\n   \n   @Override\n-  public void addSplits(String tableName, SortedSet<Text> partitionKeys) throws TableNotFoundException, AccumuloException, AccumuloSecurityException {}\n+  public void addSplits(String tableName, SortedSet<Text> partitionKeys) throws TableNotFoundException, AccumuloException, AccumuloSecurityException {\n+    throw new NotImplementedException();\n+  }\n   \n   @Override\n-  public Collection<Text> getSplits(String tableName) {\n+  public Collection<Text> getSplits(String tableName) throws TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     return Collections.emptyList();\n   }\n   \n   @Override\n-  public Collection<Text> getSplits(String tableName, int maxSplits) {\n-    return Collections.emptyList();\n+  public Collection<Text> getSplits(String tableName, int maxSplits) throws TableNotFoundException {\n+    return getSplits(tableName);\n   }\n   \n   @Override\n   public void delete(String tableName) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     acu.tables.remove(tableName);\n   }\n   \n   @Override\n   public void rename(String oldTableName, String newTableName) throws AccumuloSecurityException, TableNotFoundException, AccumuloException,\n       TableExistsException {\n+    if (!exists(oldTableName))\n+      throw new TableNotFoundException(oldTableName, oldTableName, \"\");\n+    if (exists(newTableName))\n+      throw new TableExistsException(newTableName, newTableName, \"\");\n     MockTable t = acu.tables.remove(oldTableName);\n     acu.tables.put(newTableName, t);\n   }\n@@ -133,15 +147,19 @@ public void removeProperty(String tableName, String property) throws AccumuloExc\n   \n   @Override\n   public Iterable<Entry<String,String>> getProperties(String tableName) throws TableNotFoundException {\n+    if (!exists(tableName))\n+      throw new TableNotFoundException(tableName, tableName, \"\");\n     return acu.tables.get(tableName).settings.entrySet();\n   }\n   \n   @Override\n-  public void setLocalityGroups(String tableName, Map<String,Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {}\n+  public void setLocalityGroups(String tableName, Map<String,Set<Text>> groups) throws AccumuloException, AccumuloSecurityException, TableNotFoundException {\n+    throw new NotImplementedException();\n+  }\n   \n   @Override\n   public Map<String,Set<Text>> getLocalityGroups(String tableName) throws AccumuloException, TableNotFoundException {\n-    return null;\n+    throw new NotImplementedException();\n   }\n   \n   @Override\n@@ -163,13 +181,17 @@ public void importDirectory(String tableName, String dir, String failureDir, boo\n   }\n   \n   @Override\n-  public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {}\n+  public void offline(String tableName) throws AccumuloSecurityException, AccumuloException {\n+    throw new NotImplementedException();\n+  }\n   \n   @Override\n   public void online(String tableName) throws AccumuloSecurityException, AccumuloException {}\n   \n   @Override\n-  public void clearLocatorCache(String tableName) throws TableNotFoundException {}\n+  public void clearLocatorCache(String tableName) throws TableNotFoundException {\n+    throw new NotImplementedException();\n+  }\n   \n   @Override\n   public Map<String,String> tableIdMap() {\n",
        "project": "accumulo",
        "linesAdd": 38,
        "jira_id": "217",
        "nb_skipped": 0,
        "commit": "46f62443",
        "nb_failure": 0,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 5,
        "nb_test": 434,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.core.security.CredentialsTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/client/impl/ConnectorImpl.java b/core/src/main/java/org/apache/accumulo/core/client/impl/ConnectorImpl.java\nindex 14df55f61..bd1156912 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/impl/ConnectorImpl.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/impl/ConnectorImpl.java\n@@ -55,6 +55,9 @@\n   \n   public ConnectorImpl(final Instance instance, Credentials cred) throws AccumuloException, AccumuloSecurityException {\n     ArgumentChecker.notNull(instance, cred);\n+    if (cred.getToken().isDestroyed())\n+      throw new AccumuloSecurityException(cred.getPrincipal(), SecurityErrorCode.TOKEN_EXPIRED);\n+    \n     this.instance = instance;\n     \n     this.credentials = cred;\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockConnector.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockConnector.java\nindex 4af2ea516..80ec51333 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockConnector.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockConnector.java\n@@ -18,6 +18,7 @@\n \n import java.util.concurrent.TimeUnit;\n \n+import org.apache.accumulo.core.client.AccumuloSecurityException;\n import org.apache.accumulo.core.client.BatchDeleter;\n import org.apache.accumulo.core.client.BatchScanner;\n import org.apache.accumulo.core.client.BatchWriter;\n@@ -32,7 +33,10 @@\n import org.apache.accumulo.core.client.admin.InstanceOperations;\n import org.apache.accumulo.core.client.admin.SecurityOperations;\n import org.apache.accumulo.core.client.admin.TableOperations;\n+import org.apache.accumulo.core.client.impl.thrift.SecurityErrorCode;\n+import org.apache.accumulo.core.client.security.tokens.NullToken;\n import org.apache.accumulo.core.security.Authorizations;\n+import org.apache.accumulo.core.security.Credentials;\n \n public class MockConnector extends Connector {\n   \n@@ -40,12 +44,14 @@\n   private final MockAccumulo acu;\n   private final Instance instance;\n   \n-  MockConnector(String username, MockInstance instance) {\n-    this(username, new MockAccumulo(MockInstance.getDefaultFileSystem()), instance);\n+  MockConnector(String username, MockInstance instance) throws AccumuloSecurityException {\n+    this(new Credentials(username, new NullToken()), new MockAccumulo(MockInstance.getDefaultFileSystem()), instance);\n   }\n   \n-  MockConnector(String username, MockAccumulo acu, MockInstance instance) {\n-    this.username = username;\n+  MockConnector(Credentials credentials, MockAccumulo acu, MockInstance instance) throws AccumuloSecurityException {\n+    if (credentials.getToken().isDestroyed())\n+      throw new AccumuloSecurityException(credentials.getPrincipal(), SecurityErrorCode.TOKEN_EXPIRED);\n+    this.username = credentials.getPrincipal();\n     this.acu = acu;\n     this.instance = instance;\n   }\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/mock/MockInstance.java b/core/src/main/java/org/apache/accumulo/core/client/mock/MockInstance.java\nindex f37994d3f..2ba8c674a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/mock/MockInstance.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/mock/MockInstance.java\n@@ -31,6 +31,7 @@\n import org.apache.accumulo.core.client.security.tokens.AuthenticationToken;\n import org.apache.accumulo.core.client.security.tokens.PasswordToken;\n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n+import org.apache.accumulo.core.security.Credentials;\n import org.apache.accumulo.core.util.ByteBufferUtil;\n import org.apache.accumulo.core.util.CachedConfiguration;\n import org.apache.accumulo.core.util.TextUtil;\n@@ -150,7 +151,7 @@ public void setConfiguration(AccumuloConfiguration conf) {\n   \n   @Override\n   public Connector getConnector(String principal, AuthenticationToken token) throws AccumuloException, AccumuloSecurityException {\n-    Connector conn = new MockConnector(principal, acu, this);\n+    Connector conn = new MockConnector(new Credentials(principal, token), acu, this);\n     if (!acu.users.containsKey(principal))\n       conn.securityOperations().createLocalUser(principal, (PasswordToken) token);\n     else if (!acu.users.get(principal).token.equals(token))\ndiff --git a/core/src/main/java/org/apache/accumulo/core/client/security/tokens/PasswordToken.java b/core/src/main/java/org/apache/accumulo/core/client/security/tokens/PasswordToken.java\nindex c39fb8d9a..11bbf49c6 100644\n--- a/core/src/main/java/org/apache/accumulo/core/client/security/tokens/PasswordToken.java\n+++ b/core/src/main/java/org/apache/accumulo/core/client/security/tokens/PasswordToken.java\n@@ -46,7 +46,9 @@\n   /**\n    * Constructor for use with {@link Writable}. Call {@link #readFields(DataInput)}.\n    */\n-  public PasswordToken() {}\n+  public PasswordToken() {\n+    password = new byte[0];\n+  }\n   \n   /**\n    * Constructs a token from a copy of the password. Destroying the argument after construction will not destroy the copy in this token, and destroying this\ndiff --git a/core/src/main/java/org/apache/accumulo/core/security/Credentials.java b/core/src/main/java/org/apache/accumulo/core/security/Credentials.java\nindex 71a09f6de..0552e7e6e 100644\n--- a/core/src/main/java/org/apache/accumulo/core/security/Credentials.java\n+++ b/core/src/main/java/org/apache/accumulo/core/security/Credentials.java\n@@ -22,6 +22,7 @@\n import org.apache.accumulo.core.client.AccumuloSecurityException;\n import org.apache.accumulo.core.client.Connector;\n import org.apache.accumulo.core.client.Instance;\n+import org.apache.accumulo.core.client.impl.thrift.SecurityErrorCode;\n import org.apache.accumulo.core.client.security.tokens.AuthenticationToken;\n import org.apache.accumulo.core.client.security.tokens.AuthenticationToken.AuthenticationTokenSerializer;\n import org.apache.accumulo.core.security.thrift.TCredentials;\n@@ -58,7 +59,11 @@ public AuthenticationToken getToken() {\n    * {@link AuthenticationToken}, so this should be used just before placing on the wire, and references to it should be tightly controlled.\n    */\n   public TCredentials toThrift(Instance instance) {\n-    return new TCredentials(principal, token.getClass().getName(), ByteBuffer.wrap(AuthenticationTokenSerializer.serialize(token)), instance.getInstanceID());\n+    TCredentials tCreds = new TCredentials(getPrincipal(), getToken().getClass().getName(),\n+        ByteBuffer.wrap(AuthenticationTokenSerializer.serialize(getToken())), instance.getInstanceID());\n+    if (getToken().isDestroyed())\n+      throw new RuntimeException(\"Token has been destroyed\", new AccumuloSecurityException(getPrincipal(), SecurityErrorCode.TOKEN_EXPIRED));\n+    return tCreds;\n   }\n   \n   /**\n",
        "project": "accumulo",
        "linesAdd": 24,
        "jira_id": "1312",
        "nb_skipped": 0,
        "commit": "d9ab8449",
        "nb_failure": 1,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 290,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.server.security.delegation.ZooAuthenticationKeyWatcherTest"
        ],
        "patch": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/security/delegation/ZooAuthenticationKeyWatcher.java b/server/base/src/main/java/org/apache/accumulo/server/security/delegation/ZooAuthenticationKeyWatcher.java\nindex 2913343f9..fe4407e71 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/security/delegation/ZooAuthenticationKeyWatcher.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/security/delegation/ZooAuthenticationKeyWatcher.java\n@@ -22,6 +22,7 @@\n \n import org.apache.accumulo.fate.zookeeper.ZooReader;\n import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.KeeperException.NoNodeException;\n import org.apache.zookeeper.WatchedEvent;\n import org.apache.zookeeper.Watcher;\n import org.apache.zookeeper.Watcher.Event.EventType;\n@@ -131,10 +132,15 @@ private int updateAuthKeys(String path) throws KeeperException, InterruptedExcep\n     int keysAdded = 0;\n     for (String child : zk.getChildren(path, this)) {\n       String childPath = path + \"/\" + child;\n+      try {\n         // Get the node data and reset the watcher\n         AuthenticationKey key = deserializeKey(zk.getData(childPath, this, null));\n         secretManager.addKey(key);\n         keysAdded++;\n+      } catch (NoNodeException e) {\n+        // The master expired(deleted) the key between when we saw it in getChildren() and when we went to add it to our secret manager.\n+        log.trace(\"{} was deleted when we tried to access it\", childPath);\n+      }\n     }\n     return keysAdded;\n   }\n",
        "project": "accumulo",
        "linesAdd": 5,
        "jira_id": "3634",
        "nb_skipped": 2,
        "commit": "9339ecf8",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.accumulo.minicluster.MiniAccumuloClusterStartStopTest"
        ],
        "patch": "diff --git a/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java b/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\nindex 7a9bc0d36..8246c51a4 100644\n--- a/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\n+++ b/minicluster/src/main/java/org/apache/accumulo/minicluster/MiniAccumuloCluster.java\n@@ -53,6 +53,8 @@\n import org.apache.log4j.Logger;\n import org.apache.zookeeper.server.ZooKeeperServerMain;\n \n+import com.google.common.base.Preconditions;\n+\n /**\n  * A utility class that will create Zookeeper and Accumulo processes that write all of their data to a single local directory. This class makes it easy to test\n  * code against a real Accumulo instance. Its much more accurate for testing than MockAccumulo, but much slower than MockAccumulo.\n@@ -306,7 +308,7 @@ public MiniAccumuloCluster(MiniAccumuloConfig config) throws IOException {\n    * @throws IllegalStateException\n    *           if already started\n    */\n-  public void start() throws IOException, InterruptedException {\n+  public synchronized void start() throws IOException, InterruptedException {\n     if (zooKeeperProcess != null)\n       throw new IllegalStateException(\"Already started\");\n     \n@@ -365,10 +367,15 @@ public String getZooKeepers() {\n   }\n   \n   /**\n-   * Stops Accumulo and Zookeeper processes. If stop is not called, there is a shutdown hook that is setup to kill the processes. Howerver its probably best to\n+   * Stops Accumulo and Zookeeper processes. If stop is not called, there is a shutdown hook that is setup to kill the processes. However its probably best to\n    * call stop in a finally block as soon as possible.\n    */\n-  public void stop() throws IOException, InterruptedException {\n+  public synchronized void stop() throws IOException, InterruptedException {\n+    if (null == executor) {\n+      // keep repeated calls to stop() from failing\n+      return;\n+    }\n+\n     if (zooKeeperProcess != null) {\n       try {\n         stopProcessWithTimeout(zooKeeperProcess, 30, TimeUnit.SECONDS);\n@@ -436,6 +443,7 @@ protected ExecutorService getShutdownExecutor() {\n   }\n   \n   private int stopProcessWithTimeout(final Process proc, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n+    Preconditions.checkNotNull(executor, \"Executor was already null\");\n     FutureTask<Integer> future = new FutureTask<Integer>(new Callable<Integer>() {\n       @Override\n       public Integer call() throws InterruptedException {\n",
        "project": "accumulo",
        "linesAdd": 9,
        "jira_id": "3055",
        "nb_skipped": 0,
        "commit": "94c2a31f",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 245,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.plugin.PluginParameterExceptionTest"
        ],
        "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterException.java b/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterException.java\nindex 07302e573..350349d99 100644\n--- a/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterException.java\n+++ b/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterException.java\n@@ -19,8 +19,10 @@\n  * under the License.\n  */\n \n+import java.util.Collection;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n \n import org.apache.maven.plugin.descriptor.MojoDescriptor;\n import org.apache.maven.plugin.descriptor.Parameter;\n@@ -78,9 +80,50 @@ private static void decomposeParameterIntoUserInstructions( MojoDescriptor mojo,\n         \n         if ( param.isEditable() )\n         {\n-            messageBuffer.append( \"Inside the definition for plugin \\'\" + mojo.getPluginDescriptor().getArtifactId()\n-                + \"\\', specify the following:\\n\\n<configuration>\\n  ...\\n  <\" + param.getName() + \">VALUE</\"\n-                + param.getName() + \">\\n</configuration>\" );\n+            boolean isArray = param.getType().endsWith( \"[]\" );\n+            boolean isCollection = false;\n+            boolean isMap = false;\n+            if ( !isArray )\n+            {\n+                try\n+                {\n+                    //assuming Type is available in current ClassLoader\n+                    isCollection = Collection.class.isAssignableFrom( Class.forName( param.getType() ) );\n+                    isMap = Map.class.isAssignableFrom( Class.forName( param.getType() ) );\n+                }\n+                catch ( ClassNotFoundException e )\n+                {\n+                    // assume it is not assignable from Collection or Map\n+                }\n+            }\n+            \n+            messageBuffer.append( \"Inside the definition for plugin \\'\");\n+            messageBuffer.append( mojo.getPluginDescriptor().getArtifactId() );\n+            messageBuffer.append( \"\\', specify the following:\\n\\n<configuration>\\n  ...\\n\" );\n+            messageBuffer.append( \"  <\" ).append( param.getName() ).append( '>' );\n+            if( isArray || isCollection )\n+            {\n+                messageBuffer.append(  '\\n' );\n+                messageBuffer.append( \"    <item>\" );\n+            }\n+            else if ( isMap )\n+            {\n+                messageBuffer.append(  '\\n' );\n+                messageBuffer.append( \"    <KEY>\" );\n+            }\n+            messageBuffer.append( \"VALUE\" );\n+            if( isArray || isCollection )\n+            {\n+                messageBuffer.append( \"</item>\\n\" );\n+                messageBuffer.append( \"  \" );\n+            }    \n+            else if ( isMap )\n+            {\n+                messageBuffer.append( \"</KEY>\\n\" );\n+                messageBuffer.append( \"  \" );\n+            }    \n+            messageBuffer.append( \"</\" ).append( param.getName() ).append( \">\\n\" );\n+            messageBuffer.append( \"</configuration>\" );\n \n             String alias = param.getAlias();\n             if ( StringUtils.isNotEmpty( alias ) && !alias.equals( param.getName() ) )\n",
        "project": "maven",
        "linesAdd": 44,
        "jira_id": "3131",
        "nb_skipped": 0,
        "commit": "56cd921f",
        "nb_failure": 3,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 80,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.project.ModelUtilsTest"
        ],
        "patch": "diff --git a/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java b/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java\nindex ec56f1b7d..b0c6c758b 100644\n--- a/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java\n+++ b/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java\n@@ -53,6 +53,7 @@\n import java.util.Map;\n import java.util.Properties;\n import java.util.TreeMap;\n+import java.util.HashMap;\n \n public final class ModelUtils\n {\n@@ -208,6 +209,8 @@ public static void mergePluginDefinitions( Plugin child, Plugin parent, boolean\n \n         child.setConfiguration( childConfiguration );\n \n+        child.setDependencies( mergeDependencyList( child.getDependencies(), parent.getDependencies() ) );\n+\n         // from here to the end of the method is dealing with merging of the <executions/> section.\n         String parentInherited = parent.getInherited();\n \n@@ -1000,4 +1003,30 @@ public static void mergeFilterLists( List childFilters, List parentFilters )\n             }\n         }\n     }\n+\n+    public static List mergeDependencyList( List child, List parent )\n+    {\n+        Map depsMap = new HashMap();\n+\n+        if ( parent != null )\n+        {\n+            for ( Iterator it = parent.iterator(); it.hasNext(); )\n+            {\n+                Dependency dependency = (Dependency) it.next();\n+                depsMap.put( dependency.getManagementKey(), dependency );\n+            }\n+        }\n+\n+        if ( child != null )\n+        {\n+            for ( Iterator it = child.iterator(); it.hasNext(); )\n+            {\n+                Dependency dependency = (Dependency) it.next();\n+                depsMap.put( dependency.getManagementKey(), dependency );\n+            }\n+        }\n+\n+        return new ArrayList( depsMap.values() );\n+    }\n+\n }\n",
        "project": "maven",
        "linesAdd": 29,
        "jira_id": "1703",
        "nb_skipped": 0,
        "commit": "b68c84b8",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 39,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.artifact.resolver.DefaultArtifactCollectorTest"
        ],
        "patch": "diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\nindex b6d379ec2..108a976d1 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n@@ -137,18 +137,7 @@ private void recurse( ResolutionNode node, Map resolvedArtifacts, Map managedVer\n                     VersionRange previousRange = previous.getArtifact().getVersionRange();\n                     VersionRange currentRange = node.getArtifact().getVersionRange();\n \n-                    // TODO: why do we force the version on it? what if they don't match?\n-                    if ( previousRange == null )\n-                    {\n-                        // version was already resolved\n-                        node.getArtifact().setVersion( previous.getArtifact().getVersion() );\n-                    }\n-                    else if ( currentRange == null )\n-                    {\n-                        // version was already resolved\n-                        previous.getArtifact().setVersion( node.getArtifact().getVersion() );\n-                    }\n-                    else\n+                    if ( previousRange != null && currentRange != null )\n                     {\n                         // TODO: shouldn't need to double up on this work, only done for simplicity of handling recommended\n                         // version but the restriction is identical\n@@ -185,7 +174,8 @@ else if ( currentRange == null )\n \n                     // TODO: should this be part of mediation?\n                     // previous one is more dominant\n-                    ResolutionNode nearest, farthest;\n+                    ResolutionNode nearest;\n+                    ResolutionNode farthest;\n                     if ( previous.getDepth() <= node.getDepth() )\n                     {\n                         nearest = previous;\n@@ -197,11 +187,9 @@ else if ( currentRange == null )\n                         farthest = previous;\n                     }\n \n-                    /* if we need to update scope of nearest to use farthest scope */\n                     if ( checkScopeUpdate( farthest, nearest, listeners ) )\n                     {\n-                        fireEvent( ResolutionListener.UPDATE_SCOPE, listeners, nearest, farthest.getArtifact() );\n-                        /* we need nearest version but farthest scope */\n+                        // if we need to update scope of nearest to use farthest scope, use the nearest version, but farthest scope\n                         nearest.disable();\n                         farthest.getArtifact().setVersion( nearest.getArtifact().getVersion() );\n                     }\n@@ -321,13 +309,14 @@ else if ( currentRange == null )\n     }\n \n     /**\n-     * Check if the scope of the nearest needs to be updated with the scope of the farthest.\n+     * Check if the scope needs to be updated.\n      * <a href=\"http://docs.codehaus.org/x/IGU#DependencyMediationandConflictResolution-Scoperesolution\">More info</a>.\n+     *\n      * @param farthest  farthest resolution node\n      * @param nearest   nearest resolution node\n      * @param listeners\n      */\n-    private boolean checkScopeUpdate( ResolutionNode farthest, ResolutionNode nearest, List listeners )\n+    boolean checkScopeUpdate( ResolutionNode farthest, ResolutionNode nearest, List listeners )\n     {\n         boolean updateScope = false;\n         Artifact farthestArtifact = farthest.getArtifact();\n@@ -354,6 +343,16 @@ private boolean checkScopeUpdate( ResolutionNode farthest, ResolutionNode neares\n             fireEvent( ResolutionListener.UPDATE_SCOPE_CURRENT_POM, listeners, nearest, farthestArtifact );\n         }\n \n+        if ( updateScope )\n+        {\n+            fireEvent( ResolutionListener.UPDATE_SCOPE, listeners, nearest, farthestArtifact );\n+\n+            // previously we cloned the artifact, but it is more effecient to just update the scope\n+            // if problems are later discovered that the original object needs its original scope value, cloning may\n+            // again be appropriate\n+            nearestArtifact.setScope( farthestArtifact.getScope() );\n+        }\n+\n         return updateScope;\n     }\n \ndiff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java\nindex 067e790f2..7d39bf961 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java\n@@ -219,7 +219,7 @@ public boolean filterTrail( ArtifactFilter filter )\n \n     public String toString()\n     {\n-        return artifact.toString() + \" (\" + depth + \")\";\n+        return artifact.toString() + \" (\" + depth + \"; \" + ( active ? \"enabled\" : \"disabled\" ) + \")\";\n     }\n \n }\n",
        "project": "maven",
        "linesAdd": 12,
        "jira_id": "1895",
        "nb_skipped": 0,
        "commit": "806eaeb0",
        "nb_failure": 1,
        "linesRem": 13,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 13,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.artifact.repository.metadata.AbstractRepositoryMetadataTest"
        ],
        "patch": "diff --git a/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java b/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java\nindex 603dfea08..d5a6460a6 100644\n--- a/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java\n+++ b/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java\n@@ -119,10 +119,10 @@ protected void updateRepositoryMetadata( ArtifactRepository localRepository, Art\n         if ( version != null && ( Artifact.LATEST_VERSION.equals( version ) || Artifact.RELEASE_VERSION.equals( version ) ) )\n         {\n             // meta-versions are not valid <version/> values...don't write them.\n-            changed = false;\n+            metadata.setVersion( null );\n         }\n \n-        if ( changed )\n+        if ( changed || !metadataFile.exists() )\n         {\n             Writer writer = null;\n             try\ndiff --git a/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/DefaultRepositoryMetadataManager.java b/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/DefaultRepositoryMetadataManager.java\nindex c82d60739..ddc23c08d 100644\n--- a/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/DefaultRepositoryMetadataManager.java\n+++ b/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/DefaultRepositoryMetadataManager.java\n@@ -106,7 +108,7 @@ else if ( repository.isBlacklisted() )\n                     {\n                         file.setLastModified( System.currentTimeMillis() );\n                     }\n-                    else if ( !metadataIsEmpty )\n+                    else\n                     {\n                         // this ensures that files are not continuously checked when they don't exist remotely\n                         try\n",
        "project": "maven",
        "linesAdd": 3,
        "jira_id": "2712",
        "nb_skipped": 0,
        "commit": "06090da4",
        "nb_failure": 2,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 45,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.model.profile.activation.JdkVersionProfileActivatorTest"
        ],
        "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\nindex 9cf3123cd..617ffa22b 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\n@@ -103,7 +103,9 @@ private static int getRelationOrder( String value, RangeValue rangeValue, boolea\n             return isLeft ? 1 : -1;\n         }\n \n-        List<String> valueTokens = new ArrayList<String>( Arrays.asList( value.split( \"\\\\.\" ) ) );\n+        value = value.replaceAll( \"[^0-9\\\\.\\\\-\\\\_]\", \"\" );\n+\n+        List<String> valueTokens = new ArrayList<String>( Arrays.asList( value.split( \"[\\\\.\\\\-\\\\_]\" ) ) );\n         List<String> rangeValueTokens = new ArrayList<String>( Arrays.asList( rangeValue.value.split( \"\\\\.\" ) ) );\n \n         int max = Math.max( valueTokens.size(), rangeValueTokens.size() );\n@@ -119,7 +121,7 @@ private static int getRelationOrder( String value, RangeValue rangeValue, boolea\n             return 0;\n         }\n \n-        for ( int i = 0; i < valueTokens.size(); i++ )\n+        for ( int i = 0; i < valueTokens.size() && i < rangeValueTokens.size(); i++ )\n         {\n             int x = Integer.parseInt( valueTokens.get( i ) );\n             int y = Integer.parseInt( rangeValueTokens.get( i ) );\n",
        "project": "maven",
        "linesAdd": 4,
        "jira_id": "4512",
        "nb_skipped": 0,
        "commit": "8cb04253",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 238,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.project.MavenProjectTest"
        ],
        "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/project/MavenProject.java b/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\nindex 088289dc9..1e235f247 100644\n--- a/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\n+++ b/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\n@@ -504,7 +504,11 @@ public void addTestCompileSourceRoot( String path )\n     {\n         List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );\n \n-        list.add( getBuild().getOutputDirectory() );\n+        String d = getBuild().getOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n \n         for ( Artifact a : getArtifacts() )\n         {                        \n@@ -580,9 +584,17 @@ public void addTestCompileSourceRoot( String path )\n     {\n         List<String> list = new ArrayList<String>( getArtifacts().size() + 2 );\n \n-        list.add( getBuild().getTestOutputDirectory() );\n+        String d = getBuild().getTestOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n \n-        list.add( getBuild().getOutputDirectory() );\n+        d = getBuild().getOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n         \n         for ( Artifact a : getArtifacts() )\n         {            \n@@ -644,7 +656,11 @@ public void addTestCompileSourceRoot( String path )\n     {\n         List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );\n \n-        list.add( getBuild().getOutputDirectory() );\n+        String d = getBuild().getOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n \n         for ( Artifact a : getArtifacts() )\n         {\n@@ -717,7 +733,11 @@ public void addTestCompileSourceRoot( String path )\n     {\n         List<String> list = new ArrayList<String>( getArtifacts().size() );\n \n-        list.add( getBuild().getOutputDirectory() );\n+        String d = getBuild().getOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n \n         for ( Artifact a : getArtifacts() )\n         {\n",
        "project": "maven",
        "linesAdd": 25,
        "jira_id": "5209",
        "nb_skipped": 0,
        "commit": "87884c7b",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 91,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.model.validation.DefaultModelValidatorTest"
        ],
        "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\nindex 33b2f2613..8a2f63409 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n@@ -764,41 +764,49 @@ private boolean validateVersion( String fieldName, ModelProblemCollector problem\n             return true;\n         }\n \n-        if ( !hasExpression( string ) )\n+        if ( hasExpression( string ) )\n         {\n-            return true;\n+            addViolation( problems, severity, fieldName, sourceHint,\n+                          \"must be a valid version but is '\" + string + \"'.\", tracker );\n+            return false;\n         }\n \n-        addViolation( problems, severity, fieldName, sourceHint, \"must be a valid version but is '\" + string + \"'.\",\n-                      tracker );\n-\n+        if ( !validateBannedCharacters( fieldName, problems, severity, string, sourceHint, tracker,\n+                                        ILLEGAL_VERSION_CHARS ) )\n+        {\n             return false;\n         }\n \n+        return true;\n+    }\n+\n     private boolean validatePluginVersion( String fieldName, ModelProblemCollector problems, String string,\n                                            String sourceHint, InputLocationTracker tracker,\n                                            ModelBuildingRequest request )\n     {\n-        Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );\n-\n         if ( string == null )\n         {\n             // NOTE: The check for missing plugin versions is handled directly by the model builder\n             return true;\n         }\n \n-        if ( string.length() > 0 && !hasExpression( string ) && !\"RELEASE\".equals( string )\n-            && !\"LATEST\".equals( string ) )\n+        Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );\n+\n+        if ( !validateVersion( fieldName, problems, errOn30, string, sourceHint, tracker ) )\n         {\n-            return true;\n+            return false;\n         }\n \n+        if ( string.length() <= 0 || \"RELEASE\".equals( string ) || \"LATEST\".equals( string ) )\n+        {\n             addViolation( problems, errOn30, fieldName, sourceHint, \"must be a valid version but is '\" + string + \"'.\",\n                           tracker );\n-\n             return false;\n         }\n \n+        return true;\n+    }\n+\n     private static void addViolation( ModelProblemCollector problems, Severity severity, String fieldName,\n                                       String sourceHint, String message, InputLocationTracker tracker )\n     {\n",
        "project": "maven",
        "linesAdd": 19,
        "jira_id": "4915",
        "nb_skipped": 0,
        "commit": "1c3abfba",
        "nb_failure": 2,
        "linesRem": 11,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 16,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.repository.internal.DefaultArtifactDescriptorReaderTest"
        ],
        "patch": "diff --git a/maven-aether-provider/src/main/java/org/apache/maven/repository/internal/DefaultArtifactDescriptorReader.java b/maven-aether-provider/src/main/java/org/apache/maven/repository/internal/DefaultArtifactDescriptorReader.java\nindex 380a6078c..59a955d9c 100644\n--- a/maven-aether-provider/src/main/java/org/apache/maven/repository/internal/DefaultArtifactDescriptorReader.java\n+++ b/maven-aether-provider/src/main/java/org/apache/maven/repository/internal/DefaultArtifactDescriptorReader.java\n@@ -275,6 +275,7 @@ private Model loadPom( RepositorySystemSession session, ArtifactDescriptorReques\n         Set<String> visited = new LinkedHashSet<String>();\n         for ( Artifact artifact = request.getArtifact();; )\n         {\n+            Artifact pomArtifact = ArtifactDescriptorUtils.toPomArtifact( artifact );\n             try\n             {\n                 VersionRequest versionRequest =\n@@ -283,6 +284,13 @@ private Model loadPom( RepositorySystemSession session, ArtifactDescriptorReques\n                 VersionResult versionResult = versionResolver.resolveVersion( session, versionRequest );\n \n                 artifact = artifact.setVersion( versionResult.getVersion() );\n+\n+                versionRequest =\n+                    new VersionRequest( pomArtifact, request.getRepositories(), request.getRequestContext() );\n+                versionRequest.setTrace( trace );\n+                versionResult = versionResolver.resolveVersion( session, versionRequest );\n+\n+                pomArtifact = pomArtifact.setVersion( versionResult.getVersion() );\n             }\n             catch ( VersionResolutionException e )\n             {\n@@ -303,8 +311,6 @@ private Model loadPom( RepositorySystemSession session, ArtifactDescriptorReques\n                 throw new ArtifactDescriptorException( result );\n             }\n \n-            Artifact pomArtifact = ArtifactDescriptorUtils.toPomArtifact( artifact );\n-\n             ArtifactResult resolveResult;\n             try\n             {\n",
        "project": "maven",
        "linesAdd": 8,
        "jira_id": "5459",
        "nb_skipped": 0,
        "commit": "c225847e",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 262,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.toolchain.DefaultToolchainManagerPrivateTest"
        ],
        "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/toolchain/DefaultToolchainManagerPrivate.java b/maven-core/src/main/java/org/apache/maven/toolchain/DefaultToolchainManagerPrivate.java\nindex 923db002f..e2eacea99 100644\n--- a/maven-core/src/main/java/org/apache/maven/toolchain/DefaultToolchainManagerPrivate.java\n+++ b/maven-core/src/main/java/org/apache/maven/toolchain/DefaultToolchainManagerPrivate.java\n@@ -74,7 +74,7 @@\n             throw new MisconfiguredToolchainException( e.getMessage(), e );\n         }\n         \n-        PersistedToolchains pers = buildResult.getEffectiveToolchains();\n+        PersistedToolchains effectiveToolchains = buildResult.getEffectiveToolchains();\n \n         List<ToolchainPrivate> toRet = new ArrayList<ToolchainPrivate>();\n \n@@ -84,9 +84,9 @@\n             logger.error( \"Missing toolchain factory for type: \" + type\n                 + \". Possibly caused by misconfigured project.\" );\n         }\n-        else if ( pers != null )\n+        else\n         {\n-            List<ToolchainModel> lst = pers.getToolchains();\n+            List<ToolchainModel> lst = effectiveToolchains.getToolchains();\n             if ( lst != null )\n             {\n                 for ( ToolchainModel toolchainModel : lst )\n@@ -97,11 +97,9 @@ else if ( pers != null )\n                     }\n                 }\n             }\n-        }\n             \n-        for ( ToolchainFactory toolchainFactory : factories.values() )\n-        {\n-            ToolchainPrivate tool = toolchainFactory.createDefaultToolchain();\n+            // add default toolchain\n+            ToolchainPrivate tool = fact.createDefaultToolchain();\n             if ( tool != null )\n             {\n                 toRet.add( tool );\ndiff --git a/maven-core/src/main/java/org/apache/maven/toolchain/building/DefaultToolchainsBuildingResult.java b/maven-core/src/main/java/org/apache/maven/toolchain/building/DefaultToolchainsBuildingResult.java\nindex b50473fdd..b72e5aa00 100644\n--- a/maven-core/src/main/java/org/apache/maven/toolchain/building/DefaultToolchainsBuildingResult.java\n+++ b/maven-core/src/main/java/org/apache/maven/toolchain/building/DefaultToolchainsBuildingResult.java\n@@ -26,6 +26,7 @@\n import org.apache.maven.toolchain.model.PersistedToolchains;\n \n /**\n+ * Holds the result of the merged toolchains and holds the problems during this build, if any.\n  * \n  * @author Robert Scholte\n  * @since 3.2.6\n@@ -38,6 +39,12 @@\n     \n     private List<Problem> problems;\n     \n+    /**\n+     * Default constructor\n+     * \n+     * @param effectiveToolchains the merged toolchains, may not be {@code null}\n+     * @param problems the problems while building the effectiveToolchains, if any.\n+     */\n     public DefaultToolchainsBuildingResult( PersistedToolchains effectiveToolchains, List<Problem> problems )\n     {\n         this.effectiveToolchains = effectiveToolchains;\n",
        "project": "maven",
        "linesAdd": 4,
        "jira_id": "5716",
        "nb_skipped": 0,
        "commit": "2d0ec942",
        "nb_failure": 3,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 106,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.project.artifact.MavenMetadataSourceTest"
        ],
        "patch": "diff --git a/maven-project/src/main/java/org/apache/maven/profiles/DefaultProfileManager.java b/maven-project/src/main/java/org/apache/maven/profiles/DefaultProfileManager.java\nindex 5f6534d85..68acd290b 100644\n--- a/maven-project/src/main/java/org/apache/maven/profiles/DefaultProfileManager.java\n+++ b/maven-project/src/main/java/org/apache/maven/profiles/DefaultProfileManager.java\n@@ -66,13 +66,14 @@ public DefaultProfileManager( PlexusContainer container )\n      */\n     public DefaultProfileManager( PlexusContainer container, Properties props )\n     {\n-        this( container, (Settings)null );\n-        if (props != null) {\n-            systemProperties = props;\n-        }\n+        this( container, (Settings)null, props );\n         \n     }\n \n+    /**\n+     * @deprecated without passing in the system properties, the SystemPropertiesProfileActivator will not work correctly\n+     * in embedded envirnments.\n+     */\n     public DefaultProfileManager( PlexusContainer container, Settings settings )\n     {\n         this.container = container;\n@@ -80,6 +81,23 @@ public DefaultProfileManager( PlexusContainer container, Settings settings )\n         loadSettingsProfiles( settings );\n     }\n     \n+    /**\n+     * the properties passed to the profile manager are the props that\n+     * are passed to maven, possibly containing profile activator properties\n+     *\n+     */\n+    public DefaultProfileManager( PlexusContainer container, Settings settings, Properties props )\n+    {\n+        this.container = container;\n+\n+        loadSettingsProfiles( settings );\n+        \n+        if ( props != null )\n+        {\n+            systemProperties = props;\n+        }\n+    }\n+    \n     public Properties getSystemProperties() {\n         return systemProperties;\n     }\ndiff --git a/maven-project/src/main/java/org/apache/maven/project/artifact/MavenMetadataSource.java b/maven-project/src/main/java/org/apache/maven/project/artifact/MavenMetadataSource.java\nindex ffa3ac6fa..bde81f380 100644\n--- a/maven-project/src/main/java/org/apache/maven/project/artifact/MavenMetadataSource.java\n+++ b/maven-project/src/main/java/org/apache/maven/project/artifact/MavenMetadataSource.java\n@@ -48,7 +48,6 @@\n import java.io.File;\n import java.util.ArrayList;\n import java.util.Collections;\n-import java.util.HashSet;\n import java.util.Iterator;\n import java.util.LinkedHashSet;\n import java.util.List;\n@@ -337,7 +336,9 @@ public static Set createArtifacts( ArtifactFactory artifactFactory, List depende\n                 artifact.setFile( new File( d.getSystemPath() ) );\n             }\n \n-            if ( artifact != null && ( dependencyFilter == null || dependencyFilter.include( artifact ) ) )\n+            ArtifactFilter artifactFilter = dependencyFilter;\n+            \n+            if ( artifact != null && ( artifactFilter == null || artifactFilter.include( artifact ) ) )\n             {\n                 if ( d.getExclusions() != null && !d.getExclusions().isEmpty() )\n                 {\n@@ -350,20 +351,20 @@ public static Set createArtifacts( ArtifactFactory artifactFactory, List depende\n \n                     ArtifactFilter newFilter = new ExcludesArtifactFilter( exclusions );\n \n-                    if ( dependencyFilter != null )\n+                    if ( artifactFilter != null )\n                     {\n                         AndArtifactFilter filter = new AndArtifactFilter();\n-                        filter.add( dependencyFilter );\n+                        filter.add( artifactFilter );\n                         filter.add( newFilter );\n-                        dependencyFilter = filter;\n+                        artifactFilter = filter;\n                     }\n                     else\n                     {\n-                        dependencyFilter = newFilter;\n+                        artifactFilter = newFilter;\n                     }\n                 }\n \n-                artifact.setDependencyFilter( dependencyFilter );\n+                artifact.setDependencyFilter( artifactFilter );\n \n                 if ( project != null )\n                 {\n",
        "project": "maven",
        "linesAdd": 21,
        "jira_id": "1797",
        "nb_skipped": 0,
        "commit": "5d99b35c",
        "nb_failure": 1,
        "linesRem": 11,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 46,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.model.interpolation.StringSearchModelInterpolatorTest"
        ],
        "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/StringSearchModelInterpolator.java b/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/StringSearchModelInterpolator.java\nindex 712508da4..6ff36b499 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/StringSearchModelInterpolator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/StringSearchModelInterpolator.java\n@@ -32,6 +32,7 @@\n import java.io.File;\n import java.lang.reflect.Array;\n import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n import java.security.AccessController;\n import java.security.PrivilegedAction;\n import java.util.ArrayList;\n@@ -329,6 +330,11 @@ private boolean isQualifiedForInterpolation( Field field, Class<?> fieldType )\n                 return false;\n             }\n \n+            if ( Modifier.isFinal( field.getModifiers() ) )\n+            {\n+                return false;\n+            }\n+\n             return true;\n         }\n \n",
        "project": "maven",
        "linesAdd": 6,
        "jira_id": "4529",
        "nb_skipped": 0,
        "commit": "03a383e3",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 245,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.execution.scope.internal.MojoExecutionScopeTest"
        ],
        "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/execution/scope/internal/MojoExecutionScope.java b/maven-core/src/main/java/org/apache/maven/execution/scope/internal/MojoExecutionScope.java\nindex fc8b1e612..d8a5f6c9d 100644\n--- a/maven-core/src/main/java/org/apache/maven/execution/scope/internal/MojoExecutionScope.java\n+++ b/maven-core/src/main/java/org/apache/maven/execution/scope/internal/MojoExecutionScope.java\n@@ -19,6 +19,8 @@\n  * under the License.\n  */\n \n+import java.util.Collection;\n+import java.util.IdentityHashMap;\n import java.util.LinkedList;\n import java.util.Map;\n \n@@ -177,36 +179,42 @@ protected void configure()\n     public void beforeMojoExecution( MojoExecutionEvent event )\n         throws MojoExecutionException\n     {\n-        for ( Object provided : getScopeState().provided.values() )\n-        {\n-            if ( provided instanceof WeakMojoExecutionListener )\n+        for ( WeakMojoExecutionListener provided : getProvidedListeners() )\n         {\n-                ( (WeakMojoExecutionListener) provided ).beforeMojoExecution( event );\n-            }\n+            provided.beforeMojoExecution( event );\n         }\n     }\n \n     public void afterMojoExecutionSuccess( MojoExecutionEvent event )\n         throws MojoExecutionException\n     {\n-        for ( Object provided : getScopeState().provided.values() )\n-        {\n-            if ( provided instanceof WeakMojoExecutionListener )\n+        for ( WeakMojoExecutionListener provided : getProvidedListeners() )\n         {\n-                ( (WeakMojoExecutionListener) provided ).afterMojoExecutionSuccess( event );\n-            }\n+            provided.afterMojoExecutionSuccess( event );\n         }\n     }\n \n     public void afterExecutionFailure( MojoExecutionEvent event )\n     {\n+        for ( WeakMojoExecutionListener provided : getProvidedListeners() )\n+        {\n+            provided.afterExecutionFailure( event );\n+        }\n+    }\n+\n+    private Collection<WeakMojoExecutionListener> getProvidedListeners()\n+    {\n+        // the same instance can be provided multiple times under different Key's\n+        // deduplicate instances to avoid redundant beforeXXX/afterXXX callbacks\n+        IdentityHashMap<WeakMojoExecutionListener, Object> listeners =\n+            new IdentityHashMap<WeakMojoExecutionListener, Object>();\n         for ( Object provided : getScopeState().provided.values() )\n         {\n             if ( provided instanceof WeakMojoExecutionListener )\n             {\n-                ( (WeakMojoExecutionListener) provided ).afterExecutionFailure( event );\n+                listeners.put( (WeakMojoExecutionListener) provided, null );\n             }\n         }\n+        return listeners.keySet();\n     }\n-\n }\n",
        "project": "maven",
        "linesAdd": 18,
        "jira_id": "5655",
        "nb_skipped": 0,
        "commit": "96337372",
        "nb_failure": 1,
        "linesRem": 12,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 13,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.artifact.repository.metadata.AbstractRepositoryMetadataTest"
        ],
        "patch": "diff --git a/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java b/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java\nindex 3b092527f..603dfea08 100644\n--- a/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java\n+++ b/maven-artifact-manager/src/main/java/org/apache/maven/artifact/repository/metadata/AbstractRepositoryMetadata.java\n@@ -114,6 +114,14 @@ protected void updateRepositoryMetadata( ArtifactRepository localRepository, Art\n             changed = metadata.merge( this.metadata );\n         }\n         \n+        // beware meta-versions!\n+        String version = metadata.getVersion();\n+        if ( version != null && ( Artifact.LATEST_VERSION.equals( version ) || Artifact.RELEASE_VERSION.equals( version ) ) )\n+        {\n+            // meta-versions are not valid <version/> values...don't write them.\n+            changed = false;\n+        }\n+\n         if ( changed )\n         {\n             Writer writer = null;\n",
        "project": "maven",
        "linesAdd": 6,
        "jira_id": "2408",
        "nb_skipped": 0,
        "commit": "b92af0e4",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 146,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.project.builder.PomConstructionTest"
        ],
        "patch": "diff --git a/maven-project/src/main/java/org/apache/maven/project/builder/PomClassicDomainModel.java b/maven-project/src/main/java/org/apache/maven/project/builder/PomClassicDomainModel.java\nindex 547581999..5abb68ccc 100644\n--- a/maven-project/src/main/java/org/apache/maven/project/builder/PomClassicDomainModel.java\n+++ b/maven-project/src/main/java/org/apache/maven/project/builder/PomClassicDomainModel.java\n@@ -306,6 +306,7 @@ public File getFile()\n             s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.xUri);\n             s.add(ProjectUri.Reporting.Plugins.Plugin.ReportSets.ReportSet.configuration);\n             s.add(ProjectUri.Build.Plugins.Plugin.Executions.Execution.configuration);\n+            s.add(ProjectUri.Profiles.Profile.Build.Plugins.Plugin.configuration);//TODO: More profile info\n             modelProperties = ModelMarshaller.marshallXmlToModelProperties(\n                 getInputStream(), ProjectUri.baseUri, s );\n         }\ndiff --git a/maven-project/src/main/java/org/apache/maven/project/builder/impl/DefaultProjectBuilder.java b/maven-project/src/main/java/org/apache/maven/project/builder/impl/DefaultProjectBuilder.java\nindex c5604bb21..085bc4ddd 100644\n--- a/maven-project/src/main/java/org/apache/maven/project/builder/impl/DefaultProjectBuilder.java\n+++ b/maven-project/src/main/java/org/apache/maven/project/builder/impl/DefaultProjectBuilder.java\n@@ -213,14 +213,29 @@ private PomClassicDomainModel buildModel( File pom,\n \n         PomClassicDomainModel domainModel = new PomClassicDomainModel( pom );\n         domainModel.setProjectDirectory( pom.getParentFile() );\n+        List<DomainModel> domainModels = new ArrayList<DomainModel>();\n+        domainModels.add( domainModel );\n \n         ProfileContext profileContext = new ProfileContext(new DefaultModelDataSource(domainModel.getModelProperties(),\n                 PomTransformer.MODEL_CONTAINER_FACTORIES), activeProfileIds, properties);\n+\n         Collection<ModelContainer> profileContainers = profileContext.getActiveProfiles();\n-        //get mixin\n \n-        List<DomainModel> domainModels = new ArrayList<DomainModel>();\n-        domainModels.add( domainModel );\n+        for(ModelContainer mc : profileContainers)\n+        {\n+            List<ModelProperty> transformed = new ArrayList<ModelProperty>();\n+            transformed.add(new ModelProperty(ProjectUri.xUri, null));\n+            for(ModelProperty mp : mc.getProperties())\n+            {\n+                if(mp.getUri().startsWith(ProjectUri.Profiles.Profile.xUri) && !mp.getUri().equals(ProjectUri.Profiles.Profile.id)\n+                        && !mp.getUri().startsWith(ProjectUri.Profiles.Profile.Activation.xUri) )\n+                {\n+                    transformed.add(new ModelProperty(mp.getUri().replace(ProjectUri.Profiles.Profile.xUri, ProjectUri.xUri),\n+                            mp.getResolvedValue()));\n+                }\n+            }\n+            domainModels.add(new PomClassicDomainModel(transformed));\n+        }\n \n         File parentFile = null;\n         int lineageCount = 0;\n",
        "project": "maven",
        "linesAdd": 19,
        "jira_id": "2174",
        "nb_skipped": 0,
        "commit": "778f044e",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 246,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.plugin.PluginParameterExceptionTest"
        ],
        "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterException.java b/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterException.java\nindex 350349d99..4027fccf0 100644\n--- a/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterException.java\n+++ b/maven-core/src/main/java/org/apache/maven/plugin/PluginParameterException.java\n@@ -23,6 +23,7 @@\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.Properties;\n \n import org.apache.maven.plugin.descriptor.MojoDescriptor;\n import org.apache.maven.plugin.descriptor.Parameter;\n@@ -83,6 +84,7 @@ private static void decomposeParameterIntoUserInstructions( MojoDescriptor mojo,\n             boolean isArray = param.getType().endsWith( \"[]\" );\n             boolean isCollection = false;\n             boolean isMap = false;\n+            boolean isProperties = false;\n             if ( !isArray )\n             {\n                 try\n@@ -90,6 +92,7 @@ private static void decomposeParameterIntoUserInstructions( MojoDescriptor mojo,\n                     //assuming Type is available in current ClassLoader\n                     isCollection = Collection.class.isAssignableFrom( Class.forName( param.getType() ) );\n                     isMap = Map.class.isAssignableFrom( Class.forName( param.getType() ) );\n+                    isProperties = Properties.class.isAssignableFrom( Class.forName( param.getType() ) );\n                 }\n                 catch ( ClassNotFoundException e )\n                 {\n@@ -106,6 +109,13 @@ private static void decomposeParameterIntoUserInstructions( MojoDescriptor mojo,\n                 messageBuffer.append(  '\\n' );\n                 messageBuffer.append( \"    <item>\" );\n             }\n+            else if ( isProperties )\n+            {\n+                messageBuffer.append(  '\\n' );\n+                messageBuffer.append( \"    <property>\\n\" );\n+                messageBuffer.append( \"      <name>KEY</name>\\n\" );\n+                messageBuffer.append( \"      <value>\" );\n+            }\n             else if ( isMap )\n             {\n                 messageBuffer.append(  '\\n' );\n@@ -117,6 +127,12 @@ else if ( isMap )\n                 messageBuffer.append( \"</item>\\n\" );\n                 messageBuffer.append( \"  \" );\n             }\n+            else if ( isProperties )\n+            {\n+                messageBuffer.append( \"</value>\\n\" );\n+                messageBuffer.append( \"    </property>\\n\" );\n+                messageBuffer.append( \"  \" );\n+            }\n             else if ( isMap )\n             {\n                 messageBuffer.append( \"</KEY>\\n\" );\n",
        "project": "maven",
        "linesAdd": 16,
        "jira_id": "3131",
        "nb_skipped": 0,
        "commit": "f6f4ef5e",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 155,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.project.path.DefaultPathTranslatorTest"
        ],
        "patch": "diff --git a/maven-compat/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java b/maven-compat/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java\nindex c9ec15de6..020b65265 100644\n--- a/maven-compat/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java\n+++ b/maven-compat/src/main/java/org/apache/maven/project/path/DefaultPathTranslator.java\n@@ -38,6 +38,11 @@\n \n     public void alignToBaseDirectory( Model model, File basedir )\n     {\n+        if ( basedir == null )\n+        {\n+            return;\n+        }\n+\n         Build build = model.getBuild();\n \n         if ( build != null )\n@@ -83,6 +88,11 @@ public void alignToBaseDirectory( Model model, File basedir )\n \n     public String alignToBaseDirectory( String path, File basedir )\n     {\n+        if ( basedir == null )\n+        {\n+            return path;\n+        }\n+\n         if ( path == null )\n         {\n             return null;\n@@ -166,6 +176,11 @@ private String chopLeadingFileSeparator( String path )\n \n     public void unalignFromBaseDirectory( Model model, File basedir )\n     {\n+        if ( basedir == null )\n+        {\n+            return;\n+        }\n+\n         Build build = model.getBuild();\n \n         if ( build != null )\n@@ -209,14 +224,37 @@ public void unalignFromBaseDirectory( Model model, File basedir )\n         }\n     }\n \n-    public String unalignFromBaseDirectory( String directory, File basedir )\n+    public String unalignFromBaseDirectory( String path, File basedir )\n+    {\n+        if ( basedir == null )\n+        {\n+            return path;\n+        }\n+\n+        if ( path == null )\n+        {\n+            return null;\n+        }\n+\n+        path = path.trim();\n+\n+        String base = basedir.getAbsolutePath();\n+        if ( path.startsWith( base ) )\n+        {\n+            path = chopLeadingFileSeparator( path.substring( base.length() ) );\n+        }\n+\n+        if ( path.length() <= 0 )\n         {\n-        String path = basedir.getPath();\n-        if ( directory.startsWith( path ) )\n+            path = \".\";\n+        }\n+\n+        if ( !new File( path ).isAbsolute() )\n         {\n-            directory = directory.substring( path.length() + 1 ).replace( '\\\\', '/' );\n+            path = path.replace( '\\\\', '/' );\n         }\n-        return directory;\n+\n+        return path;\n     }\n \n }\n",
        "project": "maven",
        "linesAdd": 43,
        "jira_id": "4933",
        "nb_skipped": 0,
        "commit": "469d0096",
        "nb_failure": 0,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 237,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.plugin.PluginManagerTest"
        ],
        "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java b/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java\nindex 96b82740b..8bb69095e 100644\n--- a/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java\n+++ b/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java\n@@ -96,6 +96,8 @@ protected static PluginDescriptor clone( PluginDescriptor original )\n             clone.setId( original.getId() );\n             clone.setIsolatedRealm( original.isIsolatedRealm() );\n             clone.setSource( original.getSource() );\n+\n+            clone.setDependencies( original.getDependencies() );\n         }\n \n         return clone;\n",
        "project": "maven",
        "linesAdd": 2,
        "jira_id": "5212",
        "nb_skipped": 0,
        "commit": "c53d95ce",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 22,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.artifact.versioning.DefaultArtifactVersionTest"
        ],
        "patch": "diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/DefaultArtifactVersion.java b/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/DefaultArtifactVersion.java\nindex 745afddad..6a6ab7439 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/DefaultArtifactVersion.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/DefaultArtifactVersion.java\n@@ -21,6 +21,7 @@\n \n import java.util.StringTokenizer;\n import java.util.regex.Pattern;\n+import java.util.NoSuchElementException;\n \n /**\n  * Default implementation of artifact versioning.\n@@ -204,6 +205,7 @@ public final void parseVersion( String version )\n \n     private static Integer getNextIntegerToken( StringTokenizer tok )\n     {\n+        try {\n             String s = tok.nextToken();\n             if ( ( s.length() > 1 ) && s.startsWith( \"0\" ) )\n             {\n@@ -211,6 +213,11 @@ private static Integer getNextIntegerToken( StringTokenizer tok )\n             }\n             return Integer.valueOf( s );\n         } \n+        catch( NoSuchElementException e )\n+        {\n+            throw new NumberFormatException( \"Number is invalid\" );\n+        }\n+    }\n \n     @Override\n     public String toString()\n",
        "project": "maven",
        "linesAdd": 7,
        "jira_id": "5645",
        "nb_skipped": 0,
        "commit": "af1ecd5f",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 30,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.artifact.resolver.DefaultArtifactCollectorTest"
        ],
        "patch": "diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\nindex 8f26cc7d9..3daff677e 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n@@ -82,7 +82,7 @@ public ArtifactResolutionResult collect( Set artifacts, Artifact originatingArti\n                     if ( node.filterTrail( filter ) )\n                     {\n                         // If it was optional, we don't add it or its children, just allow the update of the version and scope\n-                        if ( !artifact.isOptional() )\n+                        if ( node.isChildOfRootNode() || !artifact.isOptional() )\n                         {\n                             artifact.setDependencyTrail( node.getDependencyTrail() );\n \n@@ -224,7 +224,7 @@ else if ( currentRange == null )\n             {\n                 ResolutionNode child = (ResolutionNode) i.next();\n                 // We leave in optional ones, but don't pick up its dependencies\n-                if ( !child.isResolved() && !child.getArtifact().isOptional() )\n+                if ( !child.isResolved() && ( !child.getArtifact().isOptional() || child.isChildOfRootNode() ) )\n                 {\n                     Artifact artifact = child.getArtifact();\n                     try\ndiff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java\nindex ef477942d..c3f1f666b 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/ResolutionNode.java\n@@ -147,6 +147,11 @@ public boolean isResolved()\n         return children != null;\n     }\n     \n+    public boolean isChildOfRootNode()\n+    {\n+        return parent != null && parent.parent == null;\n+    }\n+\n     public Iterator getChildrenIterator()\n     {\n         return children.iterator();\n",
        "project": "maven",
        "linesAdd": 7,
        "jira_id": "1205",
        "nb_skipped": 0,
        "commit": "1bdeeccc",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 79,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.project.inheritance.DefaultModelInheritanceAssemblerTest"
        ],
        "patch": "diff --git a/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java b/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java\nindex 39b84882c..2839c50f4 100644\n--- a/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java\n+++ b/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java\n@@ -16,15 +16,6 @@\n  * limitations under the License.\n  */\n \n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Properties;\n-import java.util.StringTokenizer;\n-import java.util.TreeMap;\n-\n import org.apache.maven.model.Build;\n import org.apache.maven.model.Dependency;\n import org.apache.maven.model.DependencyManagement;\n@@ -38,6 +29,15 @@\n import org.apache.maven.project.ModelUtils;\n import org.codehaus.plexus.util.StringUtils;\n \n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.StringTokenizer;\n+import java.util.TreeMap;\n+\n /**\n  * @author <a href=\"mailto:jason@maven.org\">Jason van Zyl </a>\n  * @version $Id: DefaultModelInheritanceAssembler.java,v 1.4 2004/08/23 20:24:54\n@@ -275,6 +275,8 @@ private void assembleReportingInheritance( Model child, Model parent )\n                 child.setReporting( childReporting );\n             }\n \n+            childReporting.setExcludeDefaults( parentReporting.isExcludeDefaults() );\n+\n             if ( StringUtils.isEmpty( childReporting.getOutputDirectory() ) )\n             {\n                 childReporting.setOutputDirectory( parentReporting.getOutputDirectory() );\n@@ -422,25 +424,28 @@ private void assembleScmInheritance( Model child, Model parent, String childPath\n \n             if ( StringUtils.isEmpty( childScm.getConnection() ) && !StringUtils.isEmpty( parentScm.getConnection() ) )\n             {\n-                childScm.setConnection( appendPath( parentScm.getConnection(), child.getArtifactId(), childPathAdjustment, appendPaths ) );\n+                childScm.setConnection(\n+                    appendPath( parentScm.getConnection(), child.getArtifactId(), childPathAdjustment, appendPaths ) );\n             }\n \n             if ( StringUtils.isEmpty( childScm.getDeveloperConnection() ) &&\n                 !StringUtils.isEmpty( parentScm.getDeveloperConnection() ) )\n             {\n                 childScm\n-                    .setDeveloperConnection(\n-                        appendPath( parentScm.getDeveloperConnection(), child.getArtifactId(), childPathAdjustment, appendPaths ) );\n+                    .setDeveloperConnection( appendPath( parentScm.getDeveloperConnection(), child.getArtifactId(),\n+                                                         childPathAdjustment, appendPaths ) );\n             }\n \n             if ( StringUtils.isEmpty( childScm.getUrl() ) && !StringUtils.isEmpty( parentScm.getUrl() ) )\n             {\n-                childScm.setUrl( appendPath( parentScm.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths ) );\n+                childScm.setUrl(\n+                    appendPath( parentScm.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths ) );\n             }\n         }\n     }\n \n-    private void assembleDistributionInheritence( Model child, Model parent, String childPathAdjustment, boolean appendPaths )\n+    private void assembleDistributionInheritence( Model child, Model parent, String childPathAdjustment,\n+                                                  boolean appendPaths )\n     {\n         if ( parent.getDistributionManagement() != null )\n         {\n@@ -471,7 +476,8 @@ private void assembleDistributionInheritence( Model child, Model parent, String\n \n                     if ( site.getUrl() != null )\n                     {\n-                        site.setUrl( appendPath( site.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths ) );\n+                        site.setUrl(\n+                            appendPath( site.getUrl(), child.getArtifactId(), childPathAdjustment, appendPaths ) );\n                     }\n                 }\n             }\n",
        "project": "maven",
        "linesAdd": 21,
        "jira_id": "1999",
        "nb_skipped": 0,
        "commit": "ad38e46b",
        "nb_failure": 1,
        "linesRem": 15,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 74,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.profiles.DefaultProfileManagerTest"
        ],
        "patch": "diff --git a/maven-project/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java b/maven-project/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java\nindex 72575fe52..7b068e7dc 100644\n--- a/maven-project/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java\n+++ b/maven-project/src/main/java/org/apache/maven/profiles/activation/OperatingSystemProfileActivator.java\n@@ -36,14 +36,25 @@ public boolean isActive( Profile profile )\n         Activation activation = profile.getActivation();\n         ActivationOS os = activation.getOs();\n \n-        boolean hasNonNull = ensureAtLeastOneNonNull( os );\n+        boolean result = ensureAtLeastOneNonNull( os );\n \n-        boolean isFamily = determineFamilyMatch( os.getFamily() );\n-        boolean isName = determineNameMatch( os.getName() );\n-        boolean isArch = determineArchMatch( os.getArch() );\n-        boolean isVersion = determineVersionMatch( os.getVersion() );\n-        \n-        return hasNonNull && isFamily && isName && isArch && isVersion;\n+        if ( result && os.getFamily() != null )\n+        {\n+            result = determineFamilyMatch( os.getFamily() );\n+        }\n+        if ( result && os.getName() != null )\n+        {\n+            result = determineNameMatch( os.getName() );\n+        }\n+        if ( result && os.getArch() != null )\n+        {\n+            result = determineArchMatch( os.getArch() );\n+        }\n+        if ( result && os.getVersion() != null )\n+        {\n+            result = determineVersionMatch( os.getVersion() );\n+        }\n+        return result;\n     }\n \n     private boolean ensureAtLeastOneNonNull( ActivationOS os )\n",
        "project": "maven",
        "linesAdd": 18,
        "jira_id": "1509",
        "nb_skipped": 0,
        "commit": "4e955c05",
        "nb_failure": 0,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 226,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.plugin.PluginManagerTest"
        ],
        "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultPluginDependenciesResolver.java b/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultPluginDependenciesResolver.java\nindex 954616f5f..57374d2e5 100644\n--- a/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultPluginDependenciesResolver.java\n+++ b/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultPluginDependenciesResolver.java\n@@ -97,8 +97,11 @@ public Artifact resolve( Plugin plugin, ArtifactResolutionRequest request )\n \n         Set<Artifact> overrideArtifacts = new LinkedHashSet<Artifact>();\n         for ( Dependency dependency : plugin.getDependencies() )\n+        {\n+\t          if ( !Artifact.SCOPE_SYSTEM.equals( dependency.getScope() ) )\n \t          {\n \t              dependency.setScope( Artifact.SCOPE_RUNTIME );\n+\t          }\n             overrideArtifacts.add( repositorySystem.createDependencyArtifact( dependency ) );\n         }\n \n",
        "project": "maven",
        "linesAdd": 3,
        "jira_id": "4761",
        "nb_skipped": 0,
        "commit": "8cdb461f",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 21,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.artifact.versioning.VersionRangeTest"
        ],
        "patch": "diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/Restriction.java b/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/Restriction.java\nindex a3a1b772c..f8de2c95e 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/Restriction.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/Restriction.java\n@@ -20,6 +19,8 @@\n  * under the License.\n  */\n \n+import org.apache.maven.artifact.Artifact;\n+\n /**\n  * Describes a restriction in versioning.\n  *\n@@ -71,9 +72,17 @@ public boolean isUpperBoundInclusive()\n \n     public boolean containsVersion( ArtifactVersion version )\n     {\n+        boolean snapshot = isSnapshot( version );\n+\n         if ( lowerBound != null )\n         {\n             int comparison = lowerBound.compareTo( version );\n+\n+            if ( snapshot && comparison == 0 )\n+            {\n+                return true;\n+            }\n+\n             if ( ( comparison == 0 ) && !lowerBoundInclusive )\n             {\n                 return false;\n@@ -86,6 +95,12 @@ public boolean containsVersion( ArtifactVersion version )\n         if ( upperBound != null )\n         {\n             int comparison = upperBound.compareTo( version );\n+\n+            if ( snapshot && comparison == 0 )\n+            {\n+                return true;\n+            }\n+\n             if ( ( comparison == 0 ) && !upperBoundInclusive )\n             {\n                 return false;\n@@ -95,9 +110,20 @@ public boolean containsVersion( ArtifactVersion version )\n                 return false;\n             }\n         }\n+\n+        if ( lowerBound != null || upperBound != null )\n+        {\n+            return !snapshot;\n+        }\n+\n         return true;\n     }\n \n+    private boolean isSnapshot( ArtifactVersion version )\n+    {\n+        return Artifact.SNAPSHOT_VERSION.equals( version.getQualifier() );\n+    }\n+\n     @Override\n     public int hashCode()\n     {\n",
        "project": "maven",
        "linesAdd": 27,
        "jira_id": "3092",
        "nb_skipped": 0,
        "commit": "5ffd8903",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 6,
        "nb_test": 96,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.model.building.ComplexActivationTest"
        ],
        "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileSelector.java b/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileSelector.java\nindex c376c999e..0aeed9d1e 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileSelector.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/profile/DefaultProfileSelector.java\n@@ -104,13 +104,19 @@ else if ( isActiveByDefault( profile ) )\n \n     private boolean isActive( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )\n     {\n+        boolean isActive = false;\n+        for ( ProfileActivator activator : activators ) {\n+            if ( activator.presentInConfig( profile, context, problems ) ) {\n+                isActive = true;\n+            }\n+        }\n         for ( ProfileActivator activator : activators )\n         {\n             try\n             {\n-                if ( activator.isActive( profile, context, problems ) )\n+                if ( activator.presentInConfig( profile, context, problems ) )\n                 {\n-                    return true;\n+                    isActive &=  activator.isActive( profile, context, problems );\n                 }\n             }\n             catch ( RuntimeException e )\n@@ -122,7 +128,7 @@ private boolean isActive( Profile profile, ProfileActivationContext context, Mod\n                 return false;\n             }\n         }\n-        return false;\n+        return isActive;\n     }\n \n     private boolean isActiveByDefault( Profile profile )\ndiff --git a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/FileProfileActivator.java b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/FileProfileActivator.java\nindex 07ba79b4a..b1d04427a 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/FileProfileActivator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/FileProfileActivator.java\n@@ -167,4 +167,23 @@ else if ( path.contains( \"${basedir}\" ) )\n         return missing ? !fileExists : fileExists;\n     }\n \n+    @Override\n+    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )\n+    {\n+        Activation activation = profile.getActivation();\n+\n+        if ( activation == null )\n+        {\n+            return false;\n+        }\n+\n+        ActivationFile file = activation.getFile();\n+\n+        if ( file == null )\n+        {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n }\ndiff --git a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\nindex 62b6cfb7b..10747de6b 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\n@@ -83,6 +83,25 @@ else if ( isRange( jdk ) )\n         }\n     }\n \n+    @Override\n+    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )\n+    {\n+        Activation activation = profile.getActivation();\n+\n+        if ( activation == null )\n+        {\n+            return false;\n+        }\n+\n+        String jdk = activation.getJdk();\n+\n+        if ( jdk == null )\n+        {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     private static boolean isInRange( String value, List<RangeValue> range )\n     {\n         int leftRelation = getRelationOrder( value, range.get( 0 ), true );\ndiff --git a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java\nindex 94d380cd1..b6d3f052b 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/OperatingSystemProfileActivator.java\n@@ -76,6 +76,25 @@ public boolean isActive( Profile profile, ProfileActivationContext context, Mode\n         return active;\n     }\n \n+    @Override\n+    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )\n+    {\n+        Activation activation = profile.getActivation();\n+\n+        if ( activation == null )\n+        {\n+            return false;\n+        }\n+\n+        ActivationOS os = activation.getOs();\n+\n+        if ( os == null )\n+        {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     private boolean ensureAtLeastOneNonNull( ActivationOS os )\n     {\n         return os.getArch() != null || os.getFamily() != null || os.getName() != null || os.getVersion() != null;\ndiff --git a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/ProfileActivator.java b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/ProfileActivator.java\nindex 142dddf6b..7094a3f86 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/ProfileActivator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/ProfileActivator.java\n@@ -43,4 +43,17 @@\n      */\n     boolean isActive( Profile profile, ProfileActivationContext context, ModelProblemCollector problems );\n \n+    /**\n+     * Determines whether specified activation method is present in configuration or not. It should help to have AND between\n+     * activation conditions\n+     * Need for solving http://jira.codehaus.org/browse/MNG-4565\n+     * @param profile The profile whose activation status should be determined, must not be {@code null}.\n+     * @param context The environmental context used to determine the activation status of the profile, must not be\n+     *            {@code null}.\n+     * @param problems The container used to collect problems (e.g. bad syntax) that were encountered, must not be\n+     *            {@code null}.\n+     * @return {@code true} if the profile is active, {@code false} otherwise.\n+     */\n+    boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems );\n+\n }\ndiff --git a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/PropertyProfileActivator.java b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/PropertyProfileActivator.java\nindex 374647fd2..e8e6e998e 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/PropertyProfileActivator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/PropertyProfileActivator.java\n@@ -103,4 +103,23 @@ public boolean isActive( Profile profile, ProfileActivationContext context, Mode\n         }\n     }\n \n+    @Override\n+    public boolean presentInConfig( Profile profile, ProfileActivationContext context, ModelProblemCollector problems )\n+    {\n+        Activation activation = profile.getActivation();\n+\n+        if ( activation == null )\n+        {\n+            return false;\n+        }\n+\n+        ActivationProperty property = activation.getProperty();\n+\n+        if ( property == null )\n+        {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n }\n",
        "project": "maven",
        "linesAdd": 87,
        "jira_id": "4565",
        "nb_skipped": 0,
        "commit": "c6529932",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 251,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.project.MavenProjectTest"
        ],
        "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/project/MavenProject.java b/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\nindex d6f308fe8..91038b382 100644\n--- a/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\n+++ b/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\n@@ -102,6 +102,8 @@\n \n     public static final String EMPTY_PROJECT_VERSION = \"0\";\n \n+    private static final MavenProject ERROR_BUILDING_PARENT = new MavenProject();\n+\n     private Model model;\n \n     private MavenProject parent;\n@@ -343,6 +345,10 @@ public Model getModel()\n         return model;\n     }\n \n+    /**\n+     * Returns the project corresponding to a declared parent.\n+     * @return the parent, or null if no parent is declared or there was an error building it\n+     */\n     public MavenProject getParent()\n     {\n         if ( parent == null )\n@@ -363,7 +369,11 @@ public MavenProject getParent()\n                 }\n                 catch ( ProjectBuildingException e )\n                 {\n-                    throw new IllegalStateException( \"Failed to build parent project for \" + getId(), e );\n+                    if ( logger != null )\n+                    {\n+                        logger.error( \"Failed to build parent project for \" + getId(), e );\n+                    }\n+                    parent = ERROR_BUILDING_PARENT;\n                 }\n             }\n             else if ( model.getParent() != null )\n@@ -378,11 +388,15 @@ else if ( model.getParent() != null )\n                 }\n                 catch ( ProjectBuildingException e )\n                 {\n-                    throw new IllegalStateException( \"Failed to build parent project for \" + getId(), e );\n+                    if ( logger != null )\n+                    {\n+                        logger.error( \"Failed to build parent project for \" + getId(), e );\n+                    }\n+                    parent = ERROR_BUILDING_PARENT;\n                 }\n             }\n         }\n-        return parent;\n+        return parent == ERROR_BUILDING_PARENT ? null : parent;\n     }\n \n     public void setParent( MavenProject parent )\n",
        "project": "maven",
        "linesAdd": 13,
        "jira_id": "5075",
        "nb_skipped": 0,
        "commit": "2eb419ed",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 259,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.plugin.PluginManagerTest"
        ],
        "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultMavenPluginManager.java b/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultMavenPluginManager.java\nindex c81592080..570427656 100644\n--- a/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultMavenPluginManager.java\n+++ b/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultMavenPluginManager.java\n@@ -390,8 +390,6 @@ private void createPluginRealm( PluginDescriptor pluginDescriptor, MavenSession\n         RepositorySystemSession repositorySession = session.getRepositorySession();\n         if ( plugin.isExtensions() )\n         {\n-            // TODO discover components in #setupExtensionsRealm\n-\n             ExtensionRealmCache.CacheRecord extensionRecord;\n             try\n             {\n@@ -406,6 +404,11 @@ private void createPluginRealm( PluginDescriptor pluginDescriptor, MavenSession\n \n             pluginRealm = extensionRecord.realm;\n             pluginArtifacts = extensionRecord.artifacts;\n+\n+            for ( ComponentDescriptor<?> componentDescriptor : pluginDescriptor.getComponents() )\n+            {\n+                componentDescriptor.setRealm( pluginRealm );\n+            }\n         }\n         else\n         {\n@@ -877,6 +880,8 @@ public void releaseMojo( Object mojo, MojoExecution mojoExecution )\n         {\n             ClassRealm extensionRealm = classRealmManager.createExtensionRealm( plugin, toAetherArtifacts( artifacts ) );\n \n+            // TODO figure out how to use the same PluginDescriptor when running mojos\n+\n             PluginDescriptor pluginDescriptor = null;\n             if ( plugin.isExtensions() && !artifacts.isEmpty() )\n             {\n",
        "project": "maven",
        "linesAdd": 6,
        "jira_id": "5742",
        "nb_skipped": 0,
        "commit": "6ab41ee8",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 80,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.project.inheritance.DefaultModelInheritanceAssemblerTest"
        ],
        "patch": "diff --git a/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java b/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java\nindex 2839c50f4..1d2268fb0 100644\n--- a/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java\n+++ b/maven-project/src/main/java/org/apache/maven/project/inheritance/DefaultModelInheritanceAssembler.java\n@@ -107,10 +107,6 @@ private void assembleModelInheritance( Model child, Model parent, String childPa\n             }\n         }\n \n-        // ----------------------------------------------------------------------\n-        // Distribution\n-        // ----------------------------------------------------------------------\n-\n         assembleDistributionInheritence( child, parent, childPathAdjustment, appendPaths );\n \n         // issueManagement\n@@ -177,8 +173,6 @@ private void assembleModelInheritance( Model child, Model parent, String childPa\n \n         assembleDependencyManagementInheritance( child, parent );\n \n-        assembleDistributionManagementInheritance( child, parent );\n-\n         Properties props = new Properties();\n         props.putAll( parent.getProperties() );\n         props.putAll( child.getProperties() );\n@@ -186,46 +180,6 @@ private void assembleModelInheritance( Model child, Model parent, String childPa\n         child.setProperties( props );\n     }\n \n-    private void assembleDistributionManagementInheritance( Model child, Model parent )\n-    {\n-        DistributionManagement cDistMgmt = child.getDistributionManagement();\n-        DistributionManagement pDistMgmt = parent.getDistributionManagement();\n-\n-        if ( cDistMgmt == null )\n-        {\n-            child.setDistributionManagement( pDistMgmt );\n-        }\n-        else if ( pDistMgmt != null )\n-        {\n-            if ( cDistMgmt.getRepository() == null )\n-            {\n-                cDistMgmt.setRepository( pDistMgmt.getRepository() );\n-            }\n-\n-            if ( cDistMgmt.getSnapshotRepository() == null )\n-            {\n-                cDistMgmt.setSnapshotRepository( pDistMgmt.getSnapshotRepository() );\n-            }\n-\n-            if ( StringUtils.isEmpty( cDistMgmt.getDownloadUrl() ) )\n-            {\n-                cDistMgmt.setDownloadUrl( pDistMgmt.getDownloadUrl() );\n-            }\n-\n-            if ( cDistMgmt.getRelocation() == null )\n-            {\n-                cDistMgmt.setRelocation( pDistMgmt.getRelocation() );\n-            }\n-\n-            if ( cDistMgmt.getSite() == null )\n-            {\n-                cDistMgmt.setSite( pDistMgmt.getSite() );\n-            }\n-\n-            // NOTE: We SHOULD NOT be inheriting status, since this is an assessment of the POM quality.\n-        }\n-    }\n-\n     private void assembleDependencyManagementInheritance( Model child, Model parent )\n     {\n         DependencyManagement parentDepMgmt = parent.getDependencyManagement();\n@@ -486,38 +440,46 @@ private void assembleDistributionInheritence( Model child, Model parent, String\n             {\n                 if ( parentDistMgmt.getRepository() != null )\n                 {\n-                    DeploymentRepository repository = new DeploymentRepository();\n-\n+                    DeploymentRepository repository = copyDistributionRepository( parentDistMgmt.getRepository() );\n                     childDistMgmt.setRepository( repository );\n-\n-                    repository.setId( parentDistMgmt.getRepository().getId() );\n-\n-                    repository.setName( parentDistMgmt.getRepository().getName() );\n-\n-                    repository.setUrl( parentDistMgmt.getRepository().getUrl() );\n-\n-                    repository.setUniqueVersion( parentDistMgmt.getRepository().isUniqueVersion() );\n                 }\n             }\n \n             if ( childDistMgmt.getSnapshotRepository() == null )\n             {\n                 if ( parentDistMgmt.getSnapshotRepository() != null )\n+                {\n+                    DeploymentRepository repository =\n+                        copyDistributionRepository( parentDistMgmt.getSnapshotRepository() );\n+                    childDistMgmt.setSnapshotRepository( repository );\n+                }\n+            }\n+\n+            if ( StringUtils.isEmpty( childDistMgmt.getDownloadUrl() ) )\n+            {\n+                childDistMgmt.setDownloadUrl( parentDistMgmt.getDownloadUrl() );\n+            }\n+\n+            // NOTE: We SHOULD NOT be inheriting status, since this is an assessment of the POM quality.\n+            // NOTE: We SHOULD NOT be inheriting relocation, since this relates to a single POM\n+        }\n+    }\n+\n+    private static DeploymentRepository copyDistributionRepository( DeploymentRepository parentRepository )\n     {\n         DeploymentRepository repository = new DeploymentRepository();\n \n-                    childDistMgmt.setSnapshotRepository( repository );\n+        repository.setId( parentRepository.getId() );\n \n-                    repository.setId( parentDistMgmt.getSnapshotRepository().getId() );\n+        repository.setName( parentRepository.getName() );\n \n-                    repository.setName( parentDistMgmt.getSnapshotRepository().getName() );\n+        repository.setUrl( parentRepository.getUrl() );\n \n-                    repository.setUrl( parentDistMgmt.getSnapshotRepository().getUrl() );\n+        repository.setLayout( parentRepository.getLayout() );\n \n-                    repository.setUniqueVersion( parentDistMgmt.getSnapshotRepository().isUniqueVersion() );\n-                }\n-            }\n-        }\n+        repository.setUniqueVersion( parentRepository.isUniqueVersion() );\n+\n+        return repository;\n     }\n \n     protected String appendPath( String parentPath, String childPath, String pathAdjustment, boolean appendPaths )\n",
        "project": "maven",
        "linesAdd": 24,
        "jira_id": "1856",
        "nb_skipped": 0,
        "commit": "faa5cf27",
        "nb_failure": 1,
        "linesRem": 60,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 237,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.plugin.PluginManagerTest"
        ],
        "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java b/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java\nindex 96b82740b..8bb69095e 100644\n--- a/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java\n+++ b/maven-core/src/main/java/org/apache/maven/plugin/DefaultPluginDescriptorCache.java\n@@ -96,6 +96,8 @@ protected static PluginDescriptor clone( PluginDescriptor original )\n             clone.setId( original.getId() );\n             clone.setIsolatedRealm( original.isIsolatedRealm() );\n             clone.setSource( original.getSource() );\n+\n+            clone.setDependencies( original.getDependencies() );\n         }\n \n         return clone;\n",
        "project": "maven",
        "linesAdd": 2,
        "jira_id": "5212",
        "nb_skipped": 0,
        "commit": "712c4fff",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 35,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.model.validation.DefaultModelValidatorTest"
        ],
        "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\nindex c60c446f4..4e429a4aa 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n@@ -139,8 +139,7 @@ public void validateEffectiveModel( Model model, ModelBuildingRequest request, M\n \n         validateStringNotEmpty( \"version\", problems, false, model.getVersion() );\n \n-        boolean warnOnBadBoolean = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\n-        boolean warnOnBadDependencyScope = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\n+        boolean warnOnly = request.getValidationLevel() < ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0;\n \n         for ( Dependency d : model.getDependencies() )\n         {\n@@ -178,12 +177,15 @@ else if ( StringUtils.isNotEmpty( d.getSystemPath() ) )\n \n             if ( request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )\n             {\n-                validateBoolean( \"dependencies.dependency.optional\", problems, warnOnBadBoolean, d.getOptional(),\n+                validateVersion( \"dependencies.dependency.version\", problems, warnOnly, d.getVersion(),\n+                                 d.getManagementKey() );\n+\n+                validateBoolean( \"dependencies.dependency.optional\", problems, warnOnly, d.getOptional(),\n                                  d.getManagementKey() );\n \n                 /*\n                  * TODO: Extensions like Flex Mojos use custom scopes like \"merged\", \"internal\", \"external\", etc. In\n-                 * order to don't break backward-compat with those, only warn but don't error our.\n+                 * order to don't break backward-compat with those, only warn but don't error out.\n                  */\n                 validateEnum( \"dependencies.dependency.scope\", problems, true, d.getScope(),\n                               d.getManagementKey(), \"provided\", \"compile\", \"runtime\", \"test\", \"system\" );\n@@ -227,8 +229,8 @@ else if ( StringUtils.isNotEmpty( d.getSystemPath() ) )\n \n                 if ( request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )\n                 {\n-                    validateBoolean( \"dependencyManagement.dependencies.dependency.optional\", problems,\n-                                     warnOnBadBoolean, d.getOptional(), d.getManagementKey() );\n+                    validateBoolean( \"dependencyManagement.dependencies.dependency.optional\", problems, warnOnly,\n+                                     d.getOptional(), d.getManagementKey() );\n                 }\n             }\n         }\n@@ -250,16 +252,16 @@ else if ( StringUtils.isNotEmpty( d.getSystemPath() ) )\n                     validateStringNotEmpty( \"build.plugins.plugin.version\", problems, warnOnMissingPluginVersion,\n                                             p.getVersion(), p.getKey() );\n \n-                    validateBoolean( \"build.plugins.plugin.inherited\", problems, warnOnBadBoolean, p.getInherited(),\n+                    validateBoolean( \"build.plugins.plugin.inherited\", problems, warnOnly, p.getInherited(),\n                                      p.getKey() );\n \n-                    validateBoolean( \"build.plugins.plugin.extensions\", problems, warnOnBadBoolean, p.getExtensions(),\n+                    validateBoolean( \"build.plugins.plugin.extensions\", problems, warnOnly, p.getExtensions(),\n                                      p.getKey() );\n \n                     for ( Dependency d : p.getDependencies() )\n                     {\n                         validateEnum( \"build.plugins.plugin[\" + p.getKey() + \"].dependencies.dependency.scope\",\n-                                      problems, warnOnBadDependencyScope, d.getScope(), d.getManagementKey(),\n+                                      problems, warnOnly, d.getScope(), d.getManagementKey(),\n                                       \"compile\", \"runtime\", \"system\" );\n                     }\n                 }\n@@ -578,11 +580,12 @@ private boolean validateBoolean( String fieldName, ModelProblemCollector problem\n \n         if ( sourceHint != null )\n         {\n-            addViolation( problems, warning, \"'\" + fieldName + \"' must be 'true' or 'false' for \" + sourceHint );\n+            addViolation( problems, warning, \"'\" + fieldName + \"' must be 'true' or 'false' for \" + sourceHint\n+                + \" but is '\" + string + \"'.\" );\n         }\n         else\n         {\n-            addViolation( problems, warning, \"'\" + fieldName + \"' must be 'true' or 'false'.\" );\n+            addViolation( problems, warning, \"'\" + fieldName + \"' must be 'true' or 'false' but is '\" + string + \"'.\" );\n         }\n \n         return false;\n@@ -605,11 +608,39 @@ private boolean validateEnum( String fieldName, ModelProblemCollector problems,\n \n         if ( sourceHint != null )\n         {\n-            addViolation( problems, warning, \"'\" + fieldName + \"' must be one of \" + values + \" for \" + sourceHint );\n+            addViolation( problems, warning, \"'\" + fieldName + \"' must be one of \" + values + \" for \" + sourceHint\n+                + \" but is '\" + string + \"'.\" );\n+        }\n+        else\n+        {\n+            addViolation( problems, warning, \"'\" + fieldName + \"' must be one of \" + values + \" but is '\" + string\n+                + \"'.\" );\n+        }\n+\n+        return false;\n+    }\n+\n+    private boolean validateVersion( String fieldName, ModelProblemCollector problems, boolean warning, String string,\n+                                     String sourceHint )\n+    {\n+        if ( string == null || string.length() <= 0 )\n+        {\n+            return true;\n+        }\n+\n+        if ( !hasExpression( string ) )\n+        {\n+            return true;\n+        }\n+\n+        if ( sourceHint != null )\n+        {\n+            addViolation( problems, warning, \"'\" + fieldName + \"' must be a valid version for \" + sourceHint\n+                + \" but is '\" + string + \"'.\" );\n         }\n         else\n         {\n-            addViolation( problems, warning, \"'\" + fieldName + \"' must be one of \" + values );\n+            addViolation( problems, warning, \"'\" + fieldName + \"' must be a valid version but is '\" + string + \"'.\" );\n         }\n \n         return false;\n",
        "project": "maven",
        "linesAdd": 43,
        "jira_id": "4383",
        "nb_skipped": 0,
        "commit": "0f3d4d24",
        "nb_failure": 1,
        "linesRem": 12,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 11,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.artifact.versioning.ComparableVersionTest"
        ],
        "patch": "diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java b/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java\nindex 3f36455ef..cf617d662 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/versioning/ComparableVersion.java\n@@ -145,7 +145,7 @@ public String toString()\n     private static class StringItem\n         implements Item\n     {\n-        private final static String[] QUALIFIERS = { \"snapshot\", \"alpha\", \"beta\", \"milestone\", \"rc\", \"\", \"sp\" };\n+        private final static String[] QUALIFIERS = { \"alpha\", \"beta\", \"milestone\", \"rc\", \"snapshot\", \"\", \"sp\" };\n \n         private final static List<String> _QUALIFIERS = Arrays.asList( QUALIFIERS );\n \n",
        "project": "maven",
        "linesAdd": 1,
        "jira_id": "2281",
        "nb_skipped": 0,
        "commit": "f0fcef7e",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 93,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.project.ModelUtilsTest"
        ],
        "patch": "diff --git a/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java b/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java\nindex 66527df42..7e6de40f6 100644\n--- a/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java\n+++ b/maven-project/src/main/java/org/apache/maven/project/ModelUtils.java\n@@ -82,6 +82,11 @@ public static void mergePluginLists( PluginContainer childContainer, PluginConta\n \n                 String parentInherited = parentPlugin.getInherited();\n \n+                // only merge plugin definition from the parent if at least one \n+                // of these is true:\n+                // 1. we're not processing the plugins in an inheritance-based merge\n+                // 2. the parent's <inherited/> flag is not set\n+                // 3. the parent's <inherited/> flag is set to true\n                 if ( !handleAsInheritance || parentInherited == null ||\n                     Boolean.valueOf( parentInherited ).booleanValue() )\n                 {\n@@ -97,18 +102,21 @@ public static void mergePluginLists( PluginContainer childContainer, PluginConta\n                         mergePluginDefinitions( childPlugin, parentPlugin, handleAsInheritance );\n                     }\n \n+                    // if we're processing this as an inheritance-based merge, and\n+                    // the parent's <inherited/> flag is not set, then we need to\n+                    // clear the inherited flag in the merge result.\n                     if ( handleAsInheritance && parentInherited == null )\n                     {\n                         assembledPlugin.unsetInheritanceApplied();\n                     }\n \n                     mergedPlugins.add(assembledPlugin);\n+\n+                    // fix for MNG-2221 (assembly cache was not being populated for later reference):\n+                    assembledPlugins.put(  assembledPlugin.getKey(), assembledPlugin );\n                 }\n             }\n \n-\t    // FIXME: not sure what's intended here, but this entire\n-\t    // loop can be replaced by 'mergedPlugins.addAll( childPlugins.values() );\n-\t    // since assembledPlugins is never updated and remains empty.\n             for ( Iterator it = childPlugins.values().iterator(); it.hasNext(); )\n             {\n                 Plugin childPlugin = (Plugin) it.next();\n",
        "project": "maven",
        "linesAdd": 2,
        "jira_id": "2221",
        "nb_skipped": 0,
        "commit": "cc859f5c",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 198,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.settings.validation.DefaultSettingsValidatorTest"
        ],
        "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/settings/validation/DefaultSettingsValidator.java b/maven-core/src/main/java/org/apache/maven/settings/validation/DefaultSettingsValidator.java\nindex b44d8d9ba..0b6eaaf8a 100644\n--- a/maven-core/src/main/java/org/apache/maven/settings/validation/DefaultSettingsValidator.java\n+++ b/maven-core/src/main/java/org/apache/maven/settings/validation/DefaultSettingsValidator.java\n@@ -21,12 +21,15 @@\n \n import java.util.List;\n \n+import org.apache.maven.settings.Mirror;\n import org.apache.maven.settings.Profile;\n import org.apache.maven.settings.Repository;\n+import org.apache.maven.settings.Server;\n import org.apache.maven.settings.Settings;\n import org.apache.maven.settings.building.SettingsProblem;\n import org.apache.maven.settings.building.SettingsProblemCollector;\n import org.codehaus.plexus.component.annotations.Component;\n+import org.codehaus.plexus.util.StringUtils;\n \n /**\n  * @author Milos Kleint\n@@ -36,16 +39,69 @@\n     implements SettingsValidator\n {\n \n+    private static final String ID_REGEX = \"[A-Za-z0-9_\\\\-.]+\";\n+\n     public void validate( Settings settings, SettingsProblemCollector problems )\n     {\n+        if ( settings.isUsePluginRegistry() )\n+        {\n+            addWarn( problems, \"'usePluginRegistry' is deprecated and has no effect.\" );\n+        }\n+\n+        List<String> pluginGroups = settings.getPluginGroups();\n+\n+        if ( pluginGroups != null )\n+        {\n+            for ( int i = 0; i < pluginGroups.size(); i++ )\n+            {\n+                String pluginGroup = pluginGroups.get( i ).trim();\n+\n+                if ( StringUtils.isBlank( pluginGroup ) )\n+                {\n+                    addError( problems, \"'pluginGroups.pluginGroup[\" + i + \"]' must not be empty.\" );\n+                }\n+                else if ( !pluginGroup.matches( ID_REGEX ) )\n+                {\n+                    addError( problems, \"'pluginGroups.pluginGroup[\" + i\n+                        + \"]' must denote a valid group id and match the pattern \" + ID_REGEX );\n+                }\n+            }\n+        }\n+\n+        List<Server> servers = settings.getServers();\n+\n+        if ( servers != null )\n+        {\n+            for ( int i = 0; i < servers.size(); i++ )\n+            {\n+                Server server = servers.get( i );\n+\n+                validateStringNotEmpty( problems, \"servers.server[\" + i + \"].id\", server.getId(), null );\n+            }\n+        }\n+\n+        List<Mirror> mirrors = settings.getMirrors();\n+\n+        if ( mirrors != null )\n+        {\n+            for ( Mirror mirror : mirrors )\n+            {\n+                validateStringNotEmpty( problems, \"mirrors.mirror.id\", mirror.getId(), mirror.getUrl() );\n+\n+                validateStringNotEmpty( problems, \"mirrors.mirror.url\", mirror.getUrl(), mirror.getId() );\n+\n+                validateStringNotEmpty( problems, \"mirrors.mirror.mirrorOf\", mirror.getMirrorOf(), mirror.getId() );\n+            }\n+        }\n+\n         List<Profile> profiles = settings.getProfiles();\n \n         if ( profiles != null )\n         {\n-            for ( Profile prof : profiles )\n+            for ( Profile profile : profiles )\n             {\n-                validateRepositories( problems, prof.getRepositories(), \"repositories.repository\" );\n-                validateRepositories( problems, prof.getPluginRepositories(), \"pluginRepositories.pluginRepository\" );\n+                validateRepositories( problems, profile.getRepositories(), \"repositories.repository\" );\n+                validateRepositories( problems, profile.getPluginRepositories(), \"pluginRepositories.pluginRepository\" );\n             }\n         }\n     }\n@@ -54,9 +110,15 @@ private void validateRepositories( SettingsProblemCollector problems, List<Repos\n     {\n         for ( Repository repository : repositories )\n         {\n-            validateStringNotEmpty( problems, prefix + \".id\", repository.getId() );\n+            validateStringNotEmpty( problems, prefix + \".id\", repository.getId(), repository.getUrl() );\n \n-            validateStringNotEmpty( problems, prefix + \".url\", repository.getUrl() );\n+            validateStringNotEmpty( problems, prefix + \".url\", repository.getUrl(), repository.getId() );\n+\n+            if ( \"legacy\".equals( repository.getLayout() ) )\n+            {\n+                addWarn( problems, \"'\" + prefix + \".layout' for \" + repository.getId()\n+                    + \" uses the deprecated value 'legacy'.\" );\n+            }\n         }\n     }\n \n@@ -64,11 +126,6 @@ private void validateRepositories( SettingsProblemCollector problems, List<Repos\n     // Field validation\n     // ----------------------------------------------------------------------\n \n-    private boolean validateStringNotEmpty( SettingsProblemCollector problems, String fieldName, String string )\n-    {\n-        return validateStringNotEmpty( problems, fieldName, string, null );\n-    }\n-\n     /**\n      * Asserts:\n      * <p/>\n@@ -137,4 +194,9 @@ private void addError( SettingsProblemCollector problems, String msg )\n         problems.add( SettingsProblem.Severity.ERROR, msg, -1, -1, null );\n     }\n \n+    private void addWarn( SettingsProblemCollector problems, String msg )\n+    {\n+        problems.add( SettingsProblem.Severity.WARNING, msg, -1, -1, null );\n+    }\n+\n }\n",
        "project": "maven",
        "linesAdd": 72,
        "jira_id": "3616",
        "nb_skipped": 0,
        "commit": "912a565f",
        "nb_failure": 1,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 45,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.model.profile.activation.JdkVersionProfileActivatorTest"
        ],
        "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\nindex 617ffa22b..1ae90e18c 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/profile/activation/JdkVersionProfileActivator.java\n@@ -108,20 +108,10 @@ private static int getRelationOrder( String value, RangeValue rangeValue, boolea\n         List<String> valueTokens = new ArrayList<String>( Arrays.asList( value.split( \"[\\\\.\\\\-\\\\_]\" ) ) );\n         List<String> rangeValueTokens = new ArrayList<String>( Arrays.asList( rangeValue.value.split( \"\\\\.\" ) ) );\n \n-        int max = Math.max( valueTokens.size(), rangeValueTokens.size() );\n-        addZeroTokens( valueTokens, max );\n-        addZeroTokens( rangeValueTokens, max );\n+        addZeroTokens( valueTokens, 3 );\n+        addZeroTokens( rangeValueTokens, 3 );\n \n-        if ( value.equals( rangeValue.getValue() ) )\n-        {\n-            if ( !rangeValue.isClosed() )\n-            {\n-                return isLeft ? -1 : 1;\n-            }\n-            return 0;\n-        }\n-\n-        for ( int i = 0; i < valueTokens.size() && i < rangeValueTokens.size(); i++ )\n+        for ( int i = 0; i < 3; i++ )\n         {\n             int x = Integer.parseInt( valueTokens.get( i ) );\n             int y = Integer.parseInt( rangeValueTokens.get( i ) );\n@@ -143,14 +133,11 @@ else if ( x > y )\n \n     private static void addZeroTokens( List<String> tokens, int max )\n     {\n-        if ( tokens.size() < max )\n-        {\n-            for ( int i = 0; i < ( max - tokens.size() ); i++ )\n+        while ( tokens.size() < max )\n         {\n             tokens.add( \"0\" );\n         }\n     }\n-    }\n \n     private static boolean isRange( String value )\n     {\n",
        "project": "maven",
        "linesAdd": 4,
        "jira_id": "4518",
        "nb_skipped": 0,
        "commit": "f5ebc72d",
        "nb_failure": 2,
        "linesRem": 17,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 258,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.project.ProjectBuilderTest"
        ],
        "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java b/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java\nindex 839c08919..e01ffc3ae 100644\n--- a/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java\n+++ b/maven-core/src/main/java/org/apache/maven/bridge/MavenRepositorySystem.java\n@@ -107,6 +107,11 @@ public Artifact createProjectArtifact( String groupId, String artifactId, String\n     // DefaultProjectBuilder\n     public Artifact createDependencyArtifact( Dependency d )\n     {\n+        if ( d.getVersion() == null )\n+        {\n+            return null;\n+        }\n+\n         VersionRange versionRange;\n         try\n         {\ndiff --git a/maven-core/src/main/java/org/apache/maven/project/DefaultProjectBuilder.java b/maven-core/src/main/java/org/apache/maven/project/DefaultProjectBuilder.java\nindex e359bcf00..5365756a9 100644\n--- a/maven-core/src/main/java/org/apache/maven/project/DefaultProjectBuilder.java\n+++ b/maven-core/src/main/java/org/apache/maven/project/DefaultProjectBuilder.java\n@@ -807,14 +807,12 @@ private void initProject( MavenProject project, Map<String, MavenProject> projec\n                 {\n                     Artifact artifact = repositorySystem.createDependencyArtifact( d );\n \n-                    if ( artifact == null )\n+                    if ( artifact != null )\n                     {\n-                        map = Collections.emptyMap();\n-                    }\n-\n                         map.put( d.getManagementKey(), artifact );\n                     }\n                 }\n+            }\n             else\n             {\n                 map = Collections.emptyMap();\n",
        "project": "maven",
        "linesAdd": 7,
        "jira_id": "5727",
        "nb_skipped": 0,
        "commit": "ce6f0bfd",
        "nb_failure": 0,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 89,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.model.interpolation.StringSearchModelInterpolatorTest"
        ],
        "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/StringSearchModelInterpolator.java b/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/StringSearchModelInterpolator.java\nindex 8f7085ad8..590f2dab0 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/StringSearchModelInterpolator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/StringSearchModelInterpolator.java\n@@ -324,6 +324,11 @@ private boolean isQualifiedForInterpolation( Class<?> cls )\n \n         private boolean isQualifiedForInterpolation( Field field, Class<?> fieldType )\n         {\n+            if ( Map.class.equals( fieldType ) && \"locations\".equals( field.getName() ) )\n+            {\n+                return false;\n+            }\n+\n             Boolean primitive = fieldIsPrimitiveByClass.get( fieldType );\n             if ( primitive == null )\n             {\n",
        "project": "maven",
        "linesAdd": 5,
        "jira_id": "4837",
        "nb_skipped": 0,
        "commit": "3fca2bb2",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 40,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.artifact.resolver.DefaultArtifactCollectorTest"
        ],
        "patch": "diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\nindex 47e7acfa4..9a923d82b 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n@@ -69,8 +69,7 @@ public ArtifactResolutionResult collect( Set artifacts, Artifact originatingArti\n \n         root.addDependencies( artifacts, remoteRepositories, filter );\n \n-        ManagedVersionMap versionMap = (managedVersions != null && managedVersions instanceof ManagedVersionMap) ?\n-            (ManagedVersionMap)managedVersions : new ManagedVersionMap(managedVersions);\n+        ManagedVersionMap versionMap = getManagedVersionsMap( originatingArtifact, managedVersions );\n \n         recurse( root, resolvedArtifacts, versionMap, localRepository, remoteRepositories, source, filter,\n                  listeners );\n@@ -107,6 +106,45 @@ public ArtifactResolutionResult collect( Set artifacts, Artifact originatingArti\n         return result;\n     }\n \n+    /**\n+     * Get the map of managed versions, removing the originating artifact if it is also in managed versions\n+     * @param originatingArtifact artifact we are processing\n+     * @param managedVersions original managed versions\n+     */\n+    private ManagedVersionMap getManagedVersionsMap( Artifact originatingArtifact, Map managedVersions )\n+    {\n+        ManagedVersionMap versionMap;\n+        if ( managedVersions != null && managedVersions instanceof ManagedVersionMap )\n+        {\n+            versionMap = (ManagedVersionMap) managedVersions;\n+        }\n+        else\n+        {\n+            versionMap = new ManagedVersionMap( managedVersions );\n+        }\n+\n+        /* remove the originating artifact if it is also in managed versions to avoid being modified during resolution */\n+        Artifact managedOriginatingArtifact = (Artifact) versionMap.get( originatingArtifact.getDependencyConflictId() );\n+        if ( managedOriginatingArtifact != null )\n+        {\n+            String managedVersion = managedOriginatingArtifact.getVersion();\n+            String version = originatingArtifact.getVersion();\n+            if ( !managedVersion.equals( version ) )\n+            {\n+                // TODO we probably want to warn the user that he is building and artifact with a\n+                // different version than in dependencyManagement \n+                if ( managedVersions instanceof ManagedVersionMap )\n+                {\n+                    /* avoid modifying the managedVersions parameter creating a new map */\n+                    versionMap = new ManagedVersionMap( managedVersions );\n+                }\n+                versionMap.remove( originatingArtifact.getDependencyConflictId() );\n+            }\n+        }\n+\n+        return versionMap;\n+    }\n+\n     private void recurse( ResolutionNode node, Map resolvedArtifacts, ManagedVersionMap managedVersions,\n                           ArtifactRepository localRepository, List remoteRepositories, ArtifactMetadataSource source,\n                           ArtifactFilter filter, List listeners )\n",
        "project": "maven",
        "linesAdd": 31,
        "jira_id": "2931",
        "nb_skipped": 0,
        "commit": "d7422212",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 173,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.repository.legacy.DefaultWagonManagerTest"
        ],
        "patch": "diff --git a/maven-compat/src/main/java/org/apache/maven/repository/legacy/DefaultWagonManager.java b/maven-compat/src/main/java/org/apache/maven/repository/legacy/DefaultWagonManager.java\nindex 00e7f388a..0b4f3aec7 100644\n--- a/maven-compat/src/main/java/org/apache/maven/repository/legacy/DefaultWagonManager.java\n+++ b/maven-compat/src/main/java/org/apache/maven/repository/legacy/DefaultWagonManager.java\n@@ -46,6 +46,7 @@\n import org.codehaus.plexus.component.annotations.Component;\n import org.codehaus.plexus.component.annotations.Requirement;\n import org.codehaus.plexus.component.repository.exception.ComponentLifecycleException;\n+import org.codehaus.plexus.component.repository.exception.ComponentLookupException;\n import org.codehaus.plexus.logging.Logger;\n import org.codehaus.plexus.util.FileUtils;\n \n@@ -67,9 +68,6 @@\n     @Requirement\n     private PlexusContainer container;\n \n-    @Requirement(role = Wagon.class)\n-    private Map<String, Wagon> wagons;\n-\n     @Requirement\n     private UpdateCheckManager updateCheckManager;\n \n@@ -686,11 +684,16 @@ public Wagon getWagon( String protocol )\n         }\n \n         String hint = protocol.toLowerCase( java.util.Locale.ENGLISH );\n-        Wagon wagon = (Wagon) wagons.get( hint );\n \n-        if ( wagon == null )\n+        Wagon wagon;\n+        try\n+        {\n+            wagon = container.lookup( Wagon.class, hint );\n+        }\n+        catch ( ComponentLookupException e )\n         {\n-            throw new UnsupportedProtocolException( \"Cannot find wagon which supports the requested protocol: \" + protocol );\n+            throw new UnsupportedProtocolException( \"Cannot find wagon which supports the requested protocol: \"\n+                + protocol, e );\n         }\n \n         return wagon;\n",
        "project": "maven",
        "linesAdd": 9,
        "jira_id": "4474",
        "nb_skipped": 0,
        "commit": "269c956e",
        "nb_failure": 1,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 34,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.model.validation.DefaultModelValidatorTest"
        ],
        "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\nindex 586141e84..c60c446f4 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n@@ -181,7 +181,11 @@ else if ( StringUtils.isNotEmpty( d.getSystemPath() ) )\n                 validateBoolean( \"dependencies.dependency.optional\", problems, warnOnBadBoolean, d.getOptional(),\n                                  d.getManagementKey() );\n \n-                validateEnum( \"dependencies.dependency.scope\", problems, warnOnBadDependencyScope, d.getScope(),\n+                /*\n+                 * TODO: Extensions like Flex Mojos use custom scopes like \"merged\", \"internal\", \"external\", etc. In\n+                 * order to don't break backward-compat with those, only warn but don't error our.\n+                 */\n+                validateEnum( \"dependencies.dependency.scope\", problems, true, d.getScope(),\n                               d.getManagementKey(), \"provided\", \"compile\", \"runtime\", \"test\", \"system\" );\n             }\n         }\n",
        "project": "maven",
        "linesAdd": 1,
        "jira_id": "3991",
        "nb_skipped": 0,
        "commit": "2169c4a3",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 82,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.model.validation.DefaultModelValidatorTest"
        ],
        "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\nindex fa262c89a..bed7b4714 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n@@ -253,12 +253,7 @@ public void validateEffectiveModel( Model model, ModelBuildingRequest request, M\n                     validateBoolean( \"build.plugins.plugin.extensions\", problems, errOn30, p.getExtensions(),\n                                      p.getKey() );\n \n-                    for ( Dependency d : p.getDependencies() )\n-                    {\n-                        validateEnum( \"build.plugins.plugin[\" + p.getKey() + \"].dependencies.dependency.scope\",\n-                                      problems, errOn30, d.getScope(), d.getManagementKey(),\n-                                      \"compile\", \"runtime\", \"system\" );\n-                    }\n+                    validateEffectivePluginDependencies( problems, p, request );\n                 }\n \n                 validateResources( problems, build.getResources(), \"build.resources.resource\", request );\n@@ -365,24 +360,70 @@ else if ( \"system\".equals( dependency.getScope() ) )\n     }\n \n     private void validateEffectiveDependencies( ModelProblemCollector problems, List<Dependency> dependencies,\n-                                                boolean managed, ModelBuildingRequest request )\n+                                                boolean management, ModelBuildingRequest request )\n     {\n         Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );\n \n-        String prefix = managed ? \"dependencyManagement.dependencies.dependency.\" : \"dependencies.dependency.\";\n+        String prefix = management ? \"dependencyManagement.dependencies.dependency.\" : \"dependencies.dependency.\";\n \n         for ( Dependency d : dependencies )\n+        {\n+            validateEffectiveDependency( problems, d, management, prefix, request );\n+\n+            if ( request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )\n+            {\n+                validateBoolean( prefix + \"optional\", problems, errOn30, d.getOptional(), d.getManagementKey() );\n+\n+                if ( !management )\n+                {\n+                    validateVersion( prefix + \"version\", problems, errOn30, d.getVersion(), d.getManagementKey() );\n+\n+                    /*\n+                     * TODO: Extensions like Flex Mojos use custom scopes like \"merged\", \"internal\", \"external\", etc. In\n+                     * order to don't break backward-compat with those, only warn but don't error out.\n+                     */\n+                    validateEnum( prefix + \"scope\", problems, Severity.WARNING, d.getScope(), d.getManagementKey(),\n+                                  \"provided\", \"compile\", \"runtime\", \"test\", \"system\" );\n+                }\n+            }\n+        }\n+    }\n+\n+    private void validateEffectivePluginDependencies( ModelProblemCollector problems, Plugin plugin,\n+                                                      ModelBuildingRequest request )\n+    {\n+        List<Dependency> dependencies = plugin.getDependencies();\n+\n+        if ( !dependencies.isEmpty() )\n+        {\n+            String prefix = \"build.plugins.plugin[\" + plugin.getKey() + \"].dependencies.dependency.\";\n+\n+            Severity errOn30 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );\n+\n+            for ( Dependency d : dependencies )\n+            {\n+                validateEffectiveDependency( problems, d, false, prefix, request );\n+\n+                validateVersion( prefix + \"version\", problems, errOn30, d.getVersion(), d.getManagementKey() );\n+\n+                validateEnum( prefix + \"scope\", problems, errOn30, d.getScope(), d.getManagementKey(), \"compile\",\n+                              \"runtime\", \"system\" );\n+            }\n+        }\n+    }\n+\n+    private void validateEffectiveDependency( ModelProblemCollector problems, Dependency d, boolean management,\n+                                              String prefix, ModelBuildingRequest request )\n     {\n         validateId( prefix + \"artifactId\", problems, d.getArtifactId(), d.getManagementKey() );\n \n         validateId( prefix + \"groupId\", problems, d.getGroupId(), d.getManagementKey() );\n \n-            if ( !managed )\n+        if ( !management )\n         {\n             validateStringNotEmpty( prefix + \"type\", problems, Severity.ERROR, d.getType(), d.getManagementKey() );\n \n-                validateStringNotEmpty( prefix + \"version\", problems, Severity.ERROR, d.getVersion(),\n-                                        d.getManagementKey() );\n+            validateStringNotEmpty( prefix + \"version\", problems, Severity.ERROR, d.getVersion(), d.getManagementKey() );\n         }\n \n         if ( \"system\".equals( d.getScope() ) )\n@@ -420,24 +461,6 @@ else if ( StringUtils.isNotEmpty( d.getSystemPath() ) )\n             addViolation( problems, Severity.ERROR, prefix + \"systemPath\", d.getManagementKey(), \"must be omitted.\"\n                 + \" This field may only be specified for a dependency with system scope.\" );\n         }\n-\n-            if ( request.getValidationLevel() >= ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_2_0 )\n-            {\n-                validateBoolean( prefix + \"optional\", problems, errOn30, d.getOptional(), d.getManagementKey() );\n-\n-                if ( !managed )\n-                {\n-                    validateVersion( prefix + \"version\", problems, errOn30, d.getVersion(), d.getManagementKey() );\n-\n-                    /*\n-                     * TODO: Extensions like Flex Mojos use custom scopes like \"merged\", \"internal\", \"external\", etc. In\n-                     * order to don't break backward-compat with those, only warn but don't error out.\n-                     */\n-                    validateEnum( prefix + \"scope\", problems, Severity.WARNING, d.getScope(), d.getManagementKey(),\n-                                  \"provided\", \"compile\", \"runtime\", \"test\", \"system\" );\n-                }\n-            }\n-        }\n     }\n \n     private void validateRepositories( ModelProblemCollector problems, List<Repository> repositories, String prefix,\n",
        "project": "maven",
        "linesAdd": 48,
        "jira_id": "4648",
        "nb_skipped": 0,
        "commit": "83389c34",
        "nb_failure": 4,
        "linesRem": 25,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 252,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.DefaultProjectDependencyGraphTest"
        ],
        "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/DefaultProjectDependencyGraph.java b/maven-core/src/main/java/org/apache/maven/DefaultProjectDependencyGraph.java\nindex 84d2cc51e..4074e584d 100644\n--- a/maven-core/src/main/java/org/apache/maven/DefaultProjectDependencyGraph.java\n+++ b/maven-core/src/main/java/org/apache/maven/DefaultProjectDependencyGraph.java\n@@ -23,6 +23,7 @@\n import java.util.Collection;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n \n import org.apache.maven.execution.ProjectDependencyGraph;\n import org.apache.maven.project.DuplicateProjectException;\n@@ -48,7 +49,8 @@\n      * @throws DuplicateProjectException\n      * @throws CycleDetectedException\n      */\n-    public DefaultProjectDependencyGraph( Collection<MavenProject> projects ) throws CycleDetectedException, DuplicateProjectException\n+    public DefaultProjectDependencyGraph( Collection<MavenProject> projects )\n+        throws CycleDetectedException, DuplicateProjectException\n     {\n         this.sorter = new ProjectSorter( projects );\n     }\n@@ -65,14 +67,14 @@ public DefaultProjectDependencyGraph( Collection<MavenProject> projects ) throws\n             throw new IllegalArgumentException( \"project missing\" );\n         }\n \n-        Collection<String> projectIds = new HashSet<String>();\n+        Set<String> projectIds = new HashSet<String>();\n \n         getDownstreamProjects( ProjectSorter.getId( project ), projectIds, transitive );\n \n-        return getProjects( projectIds );\n+        return getSortedProjects( projectIds );\n     }\n \n-    private void getDownstreamProjects( String projectId, Collection<String> projectIds, boolean transitive )\n+    private void getDownstreamProjects( String projectId, Set<String> projectIds, boolean transitive )\n     {\n         for ( String id : sorter.getDependents( projectId ) )\n         {\n@@ -90,11 +92,11 @@ private void getDownstreamProjects( String projectId, Collection<String> project\n             throw new IllegalArgumentException( \"project missing\" );\n         }\n \n-        Collection<String> projectIds = new HashSet<String>();\n+        Set<String> projectIds = new HashSet<String>();\n \n         getUpstreamProjects( ProjectSorter.getId( project ), projectIds, transitive );\n \n-        return getProjects( projectIds );\n+        return getSortedProjects( projectIds );\n     }\n \n     private void getUpstreamProjects( String projectId, Collection<String> projectIds, boolean transitive )\n@@ -108,21 +110,19 @@ private void getUpstreamProjects( String projectId, Collection<String> projectId\n         }\n     }\n \n-    private List<MavenProject> getProjects( Collection<String> projectIds )\n+    private List<MavenProject> getSortedProjects( Set<String> projectIds )\n     {\n-        List<MavenProject> projects = new ArrayList<MavenProject>( projectIds.size() );\n+        List<MavenProject> result = new ArrayList<MavenProject>( projectIds.size() );\n \n-        for ( String projectId : projectIds )\n+        for ( MavenProject mavenProject : sorter.getSortedProjects() )\n         {\n-            MavenProject project = sorter.getProjectMap().get( projectId );\n-\n-            if ( project != null )\n+            if ( projectIds.contains( ProjectSorter.getId( mavenProject ) ) )\n             {\n-                projects.add( project );\n+                result.add( mavenProject );\n             }\n         }\n \n-        return projects;\n+        return result;\n     }\n \n     @Override\n",
        "project": "maven",
        "linesAdd": 14,
        "jira_id": "5687",
        "nb_skipped": 0,
        "commit": "3d2d8619",
        "nb_failure": 4,
        "linesRem": 14,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 243,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.DefaultMavenTest"
        ],
        "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/DefaultMaven.java b/maven-core/src/main/java/org/apache/maven/DefaultMaven.java\nindex 632881916..ab47efd00 100644\n--- a/maven-core/src/main/java/org/apache/maven/DefaultMaven.java\n+++ b/maven-core/src/main/java/org/apache/maven/DefaultMaven.java\n@@ -267,13 +267,13 @@ private MavenExecutionResult doExecute( MavenExecutionRequest request )\n         //\n         ProjectDependencyGraph projectDependencyGraph = createProjectDependencyGraph( projects, request, result, true );\n \n-        session.setProjects( projectDependencyGraph.getSortedProjects() );\n-        \n         if ( result.hasExceptions() )\n         {\n             return result;\n         }\n \n+        session.setProjects( projectDependencyGraph.getSortedProjects() );\n+\n         try\n         {\n             session.setProjectMap( getProjectMap( session.getProjects() ) );\n",
        "project": "maven",
        "linesAdd": 2,
        "jira_id": "5613",
        "nb_skipped": 0,
        "commit": "bef7fac6",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 31,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.artifact.resolver.DefaultArtifactCollectorTest"
        ],
        "patch": "diff --git a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\nindex c467098de..b6d379ec2 100644\n--- a/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n+++ b/maven-artifact/src/main/java/org/apache/maven/artifact/resolver/DefaultArtifactCollector.java\n@@ -201,15 +201,16 @@ else if ( currentRange == null )\n                     if ( checkScopeUpdate( farthest, nearest, listeners ) )\n                     {\n                         fireEvent( ResolutionListener.UPDATE_SCOPE, listeners, nearest, farthest.getArtifact() );\n-\n-                        // previously we cloned the artifact, but it is more effecient to just update the scope\n-                        // if problems are later discovered that the original object needs its original scope value, cloning may\n-                        // again be appropriate\n-                        nearest.getArtifact().setScope( farthest.getArtifact().getScope() );\n+                        /* we need nearest version but farthest scope */\n+                        nearest.disable();\n+                        farthest.getArtifact().setVersion( nearest.getArtifact().getVersion() );\n                     }\n-                    fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, farthest, nearest.getArtifact() );\n+                    else\n+                    {\n                         farthest.disable();\n                     }\n+                    fireEvent( ResolutionListener.OMIT_FOR_NEARER, listeners, farthest, nearest.getArtifact() );\n+                }\n             }\n         }\n         else\n",
        "project": "maven",
        "linesAdd": 6,
        "jira_id": "1895",
        "nb_skipped": 0,
        "commit": "24db0eb9",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 238,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.project.MavenProjectTest"
        ],
        "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/project/MavenProject.java b/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\nindex 088289dc9..1e235f247 100644\n--- a/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\n+++ b/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\n@@ -504,7 +504,11 @@ public void addTestCompileSourceRoot( String path )\n     {\n         List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );\n \n-        list.add( getBuild().getOutputDirectory() );\n+        String d = getBuild().getOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n \n         for ( Artifact a : getArtifacts() )\n         {                        \n@@ -580,9 +584,17 @@ public void addTestCompileSourceRoot( String path )\n     {\n         List<String> list = new ArrayList<String>( getArtifacts().size() + 2 );\n \n-        list.add( getBuild().getTestOutputDirectory() );\n+        String d = getBuild().getTestOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n \n-        list.add( getBuild().getOutputDirectory() );\n+        d = getBuild().getOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n         \n         for ( Artifact a : getArtifacts() )\n         {            \n@@ -644,7 +656,11 @@ public void addTestCompileSourceRoot( String path )\n     {\n         List<String> list = new ArrayList<String>( getArtifacts().size() + 1 );\n \n-        list.add( getBuild().getOutputDirectory() );\n+        String d = getBuild().getOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n \n         for ( Artifact a : getArtifacts() )\n         {\n@@ -717,7 +733,11 @@ public void addTestCompileSourceRoot( String path )\n     {\n         List<String> list = new ArrayList<String>( getArtifacts().size() );\n \n-        list.add( getBuild().getOutputDirectory() );\n+        String d = getBuild().getOutputDirectory();\n+        if ( d != null )\n+        {\n+            list.add( d );\n+        }\n \n         for ( Artifact a : getArtifacts() )\n         {\n",
        "project": "maven",
        "linesAdd": 25,
        "jira_id": "5209",
        "nb_skipped": 0,
        "commit": "ed651a4d",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 232,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.project.MavenProjectTest"
        ],
        "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/project/MavenProject.java b/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\nindex 8a7d64b6f..de3c278e8 100644\n--- a/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\n+++ b/maven-core/src/main/java/org/apache/maven/project/MavenProject.java\n@@ -1407,7 +1407,7 @@ public ArtifactRepository getDistributionManagementArtifactRepository()\n \n     public void setActiveProfiles( List<Profile> activeProfiles )\n     {\n-        this.activeProfiles.addAll( activeProfiles );\n+        this.activeProfiles = activeProfiles;\n     }\n \n     public List<Profile> getActiveProfiles()\n",
        "project": "maven",
        "linesAdd": 1,
        "jira_id": "4918",
        "nb_skipped": 0,
        "commit": "691a03a7",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 236,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.plugin.PluginManagerTest"
        ],
        "patch": "diff --git a/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultMavenPluginManager.java b/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultMavenPluginManager.java\nindex 0c541b1d9..603e67040 100644\n--- a/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultMavenPluginManager.java\n+++ b/maven-core/src/main/java/org/apache/maven/plugin/internal/DefaultMavenPluginManager.java\n@@ -311,6 +311,10 @@ public synchronized void setupPluginRealm( PluginDescriptor pluginDescriptor, Ma\n         {\n             pluginDescriptor.setClassRealm( cacheRecord.realm );\n             pluginDescriptor.setArtifacts( new ArrayList<Artifact>( cacheRecord.artifacts ) );\n+            for ( ComponentDescriptor<?> componentDescriptor : pluginDescriptor.getComponents() )\n+            {\n+                componentDescriptor.setRealm( cacheRecord.realm );\n+            }\n         }\n         else\n         {\n",
        "project": "maven",
        "linesAdd": 4,
        "jira_id": "5003",
        "nb_skipped": 0,
        "commit": "a7d9b689",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.plugin.descriptor.PluginDescriptorBuilderTest"
        ],
        "patch": "diff --git a/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/PluginDescriptorBuilder.java b/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/PluginDescriptorBuilder.java\nindex 894709483..66b16916d 100644\n--- a/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/PluginDescriptorBuilder.java\n+++ b/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/PluginDescriptorBuilder.java\n@@ -254,6 +254,13 @@ public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDes\n             mojo.setThreadSafe( Boolean.parseBoolean( threadSafe ) );\n         }\n \n+        // ----------------------------------------------------------------------\n+        // Configuration\n+        // ----------------------------------------------------------------------\n+\n+        PlexusConfiguration mojoConfig = c.getChild( \"configuration\" );\n+        mojo.setMojoConfiguration( mojoConfig );\n+\n         // ----------------------------------------------------------------------\n         // Parameters\n         // ----------------------------------------------------------------------\n@@ -292,6 +299,13 @@ public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDes\n \n             parameter.setImplementation( d.getChild( \"implementation\" ).getValue() );\n \n+            PlexusConfiguration paramConfig = mojoConfig.getChild( parameter.getName(), false );\n+            if ( paramConfig != null )\n+            {\n+                parameter.setExpression( paramConfig.getValue( null ) );\n+                parameter.setDefaultValue( paramConfig.getAttribute( \"default-value\" ) );\n+            }\n+\n             parameters.add( parameter );\n         }\n \n@@ -299,15 +313,6 @@ public MojoDescriptor buildComponentDescriptor( PlexusConfiguration c, PluginDes\n \n         // TODO: this should not need to be handed off...\n \n-        // ----------------------------------------------------------------------\n-        // Configuration\n-        // ----------------------------------------------------------------------\n-\n-        mojo.setMojoConfiguration( c.getChild( \"configuration\" ) );\n-\n-        // TODO: Go back to this when we get the container ready to configure mojos...\n-        //        mojo.setConfiguration( c.getChild( \"configuration\" ) );\n-\n         // ----------------------------------------------------------------------\n         // Requirements\n         // ----------------------------------------------------------------------\n",
        "project": "maven",
        "linesAdd": 11,
        "jira_id": "4941",
        "nb_skipped": 0,
        "commit": "c4002945",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 83,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.model.validation.DefaultModelValidatorTest"
        ],
        "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\nindex 429144397..73fb915b7 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/validation/DefaultModelValidator.java\n@@ -28,6 +28,7 @@\n import java.util.Set;\n \n import org.apache.maven.model.Build;\n+import org.apache.maven.model.BuildBase;\n import org.apache.maven.model.Dependency;\n import org.apache.maven.model.DependencyManagement;\n import org.apache.maven.model.DistributionManagement;\n@@ -103,12 +104,12 @@ public void validateRawModel( Model model, ModelBuildingRequest request, ModelPr\n             Build build = model.getBuild();\n             if ( build != null )\n             {\n-                validateRawPlugins( problems, build.getPlugins(), false, request );\n+                validateRawPlugins( problems, build.getPlugins(), \"build.plugins.plugin\", request );\n \n                 PluginManagement mngt = build.getPluginManagement();\n                 if ( mngt != null )\n                 {\n-                    validateRawPlugins( problems, mngt.getPlugins(), true, request );\n+                    validateRawPlugins( problems, mngt.getPlugins(), \"build.pluginManagement.plugins.plugin\", request );\n                 }\n             }\n \n@@ -116,38 +117,49 @@ public void validateRawModel( Model model, ModelBuildingRequest request, ModelPr\n \n             for ( Profile profile : model.getProfiles() )\n             {\n+                String prefix = \"profiles.profile[\" + profile.getId() + \"]\";\n+\n                 if ( !profileIds.add( profile.getId() ) )\n                 {\n                     addViolation( problems, errOn30, \"profiles.profile.id\", null,\n                                   \"must be unique but found duplicate profile with id \" + profile.getId(), profile );\n                 }\n \n-                validateRawDependencies( problems, profile.getDependencies(), \"profiles.profile[\" + profile.getId()\n-                    + \"].dependencies.dependency\", request );\n+                validateRawDependencies( problems, profile.getDependencies(), prefix + \".dependencies.dependency\",\n+                                         request );\n \n                 if ( profile.getDependencyManagement() != null )\n                 {\n-                    validateRawDependencies( problems, profile.getDependencyManagement().getDependencies(),\n-                                          \"profiles.profile[\" + profile.getId()\n-                                              + \"].dependencyManagement.dependencies.dependency\", request );\n+                    validateRawDependencies( problems, profile.getDependencyManagement().getDependencies(), prefix\n+                        + \".dependencyManagement.dependencies.dependency\", request );\n                 }\n \n-                validateRepositories( problems, profile.getRepositories(), \"profiles.profile[\" + profile.getId()\n-                    + \"].repositories.repository\", request );\n+                validateRepositories( problems, profile.getRepositories(), prefix + \".repositories.repository\", request );\n+\n+                validateRepositories( problems, profile.getPluginRepositories(), prefix\n+                    + \".pluginRepositories.pluginRepository\", request );\n \n-                validateRepositories( problems, profile.getPluginRepositories(), \"profiles.profile[\" + profile.getId()\n-                    + \"].pluginRepositories.pluginRepository\", request );\n+                BuildBase buildBase = profile.getBuild();\n+                if ( buildBase != null )\n+                {\n+                    validateRawPlugins( problems, buildBase.getPlugins(), prefix + \".plugins.plugin\", request );\n+\n+                    PluginManagement mngt = buildBase.getPluginManagement();\n+                    if ( mngt != null )\n+                    {\n+                        validateRawPlugins( problems, mngt.getPlugins(), prefix + \".pluginManagement.plugins.plugin\",\n+                                            request );\n+                    }\n+                }\n             }\n         }\n     }\n \n-    private void validateRawPlugins( ModelProblemCollector problems, List<Plugin> plugins, boolean managed,\n+    private void validateRawPlugins( ModelProblemCollector problems, List<Plugin> plugins, String prefix,\n                                      ModelBuildingRequest request )\n     {\n         Severity errOn31 = getSeverity( request, ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_1 );\n \n-        String prefix = ( managed ? \"build.pluginManagement.\" : \"build.\" ) + \"plugins.plugin.\";\n-\n         Map<String, Plugin> index = new HashMap<String, Plugin>();\n \n         for ( Plugin plugin : plugins )\n@@ -158,7 +170,7 @@ private void validateRawPlugins( ModelProblemCollector problems, List<Plugin> pl\n \n             if ( existing != null )\n             {\n-                addViolation( problems, errOn31, prefix + \"(groupId:artifactId)\", null,\n+                addViolation( problems, errOn31, prefix + \".(groupId:artifactId)\", null,\n                               \"must be unique but found duplicate declaration of plugin \" + key, plugin );\n             }\n             else\n@@ -172,7 +184,7 @@ private void validateRawPlugins( ModelProblemCollector problems, List<Plugin> pl\n             {\n                 if ( !executionIds.add( exec.getId() ) )\n                 {\n-                    addViolation( problems, Severity.ERROR, \"build.plugins.plugin[\" + plugin.getKey()\n+                    addViolation( problems, Severity.ERROR, prefix + \"[\" + plugin.getKey()\n                         + \"].executions.execution.id\", null, \"must be unique but found duplicate execution with id \"\n                         + exec.getId(), exec );\n                 }\n",
        "project": "maven",
        "linesAdd": 28,
        "jira_id": "4695",
        "nb_skipped": 0,
        "commit": "bb39b480",
        "nb_failure": 2,
        "linesRem": 16,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 98,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.maven.model.interpolation.StringSearchModelInterpolatorTest"
        ],
        "patch": "diff --git a/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/MavenBuildTimestamp.java b/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/MavenBuildTimestamp.java\nindex d3425667b..447f0efee 100644\n--- a/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/MavenBuildTimestamp.java\n+++ b/maven-model-builder/src/main/java/org/apache/maven/model/interpolation/MavenBuildTimestamp.java\n@@ -26,7 +26,8 @@\n \n public class MavenBuildTimestamp\n {\n-    public static final String DEFAULT_BUILD_TIMESTAMP_FORMAT = \"yyyyMMdd-HHmm\";\n+    // ISO 8601-compliant timestamp for machine readability\n+    public static final String DEFAULT_BUILD_TIMESTAMP_FORMAT = \"yyyy-MM-dd'T'HH:mm:ss'Z'\";\n \n     public static final String BUILD_TIMESTAMP_FORMAT_PROPERTY = \"maven.build.timestamp.format\";\n \n",
        "project": "maven",
        "linesAdd": 1,
        "jira_id": "5647",
        "nb_skipped": 0,
        "commit": "cdb8ad6d",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1062,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "typeutils.PojoTypeInfoTest"
        ],
        "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex 1dec90b740..0281da670a 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -30,6 +30,7 @@\n import java.util.List;\n \n import org.apache.avro.specific.SpecificRecordBase;\n+import org.apache.commons.lang3.ClassUtils;\n import org.apache.flink.api.common.functions.CoGroupFunction;\n import org.apache.flink.api.common.functions.CrossFunction;\n import org.apache.flink.api.common.functions.FlatJoinFunction;\n@@ -1299,22 +1300,26 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\treturn true;\n \t\t} else {\n \t\t\tboolean hasGetter = false, hasSetter = false;\n-\t\t\tfinal String fieldNameLow = f.getName().toLowerCase();\n+\t\t\tfinal String fieldNameLow = f.getName().toLowerCase().replaceAll(\"_\", \"\");\n \n \t\t\tType fieldType = f.getGenericType();\n+\t\t\tClass<?> fieldTypeWrapper = ClassUtils.primitiveToWrapper(f.getType());\n+\n \t\t\tTypeVariable<?> fieldTypeGeneric = null;\n \t\t\tif(fieldType instanceof TypeVariable) {\n \t\t\t\tfieldTypeGeneric = (TypeVariable<?>) fieldType;\n \t\t\t\tfieldType = materializeTypeVariable(typeHierarchy, (TypeVariable<?>)fieldType);\n \t\t\t}\n \t\t\tfor(Method m : clazz.getMethods()) {\n+\t\t\t\tfinal String methodNameLow = m.getName().toLowerCase().replaceAll(\"_\", \"\");\n+\n \t\t\t\t// check for getter\n \t\t\t\tif(\t// The name should be \"get<FieldName>\" or \"<fieldName>\" (for scala) or \"is<fieldName>\" for boolean fields.\n-\t\t\t\t\t(m.getName().toLowerCase().equals(\"get\"+fieldNameLow) || m.getName().toLowerCase().equals(\"is\"+fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&\n+\t\t\t\t\t(methodNameLow.equals(\"get\"+fieldNameLow) || methodNameLow.equals(\"is\"+fieldNameLow) || methodNameLow.equals(fieldNameLow)) &&\n \t\t\t\t\t// no arguments for the getter\n \t\t\t\t\tm.getParameterTypes().length == 0 &&\n \t\t\t\t\t// return type is same as field type (or the generic variant of it)\n-\t\t\t\t\t(m.getGenericReturnType().equals( fieldType ) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )\n+\t\t\t\t\t(m.getGenericReturnType().equals( fieldType ) || (fieldTypeWrapper != null && m.getReturnType().equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )\n \t\t\t\t) {\n \t\t\t\t\tif(hasGetter) {\n \t\t\t\t\t\tthrow new IllegalStateException(\"Detected more than one getter\");\n@@ -1322,9 +1327,9 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\t\t\thasGetter = true;\n \t\t\t\t}\n \t\t\t\t// check for setters (<FieldName>_$eq for scala)\n-\t\t\t\tif((m.getName().toLowerCase().equals(\"set\"+fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow+\"_$eq\")) &&\n+\t\t\t\tif((methodNameLow.equals(\"set\"+fieldNameLow) || methodNameLow.equals(fieldNameLow+\"_$eq\")) &&\n \t\t\t\t\tm.getParameterTypes().length == 1 && // one parameter of the field's type\n-\t\t\t\t\t( m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&\n+\t\t\t\t\t(m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeWrapper != null && m.getParameterTypes()[0].equals( fieldTypeWrapper )) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&\n \t\t\t\t\t// return type is void.\n \t\t\t\t\tm.getReturnType().equals(Void.TYPE)\n \t\t\t\t) {\n",
        "project": "flink",
        "linesAdd": 10,
        "jira_id": "2874",
        "nb_skipped": 0,
        "commit": "17e7b423",
        "nb_failure": 2,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1807,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "typeutils.runtime.kryo.KryoGenericTypeSerializerTest"
        ],
        "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java b/flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\nindex d5c2f676ce..e74e2519fc 100644\n--- a/flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\n+++ b/flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\n@@ -327,9 +327,8 @@ private void checkKryoInitialized() {\n \t\tif (this.kryo == null) {\n \t\t\tthis.kryo = getKryoInstance();\n \n-\t\t\t// disable reference tracking. reference tracking is costly, usually unnecessary, and\n-\t\t\t// inconsistent with Flink's own serialization (which does not do reference tracking)\n-\t\t\tkryo.setReferences(false);\n+\t\t\t// Enable reference tracking. \n+\t\t\tkryo.setReferences(true);\n \t\t\t\n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n",
        "project": "flink",
        "linesAdd": 1,
        "jira_id": "3762",
        "nb_skipped": 0,
        "commit": "dc78a747",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 6,
        "nb_test": 719,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.io.network.partition.SpillableSubpartitionTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 931790a03e..3b7a2a6385 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n@@ -41,7 +41,7 @@\n \tprivate boolean isFinished;\n \n \t/** Flag indicating whether the subpartition has been released. */\n-\tprivate boolean isReleased;\n+\tprivate volatile boolean isReleased;\n \n \t/**\n \t * A data availability listener. Registered, when the consuming task is faster than the\n@@ -166,6 +166,11 @@ public int releaseMemory() {\n \t\treturn 0;\n \t}\n \n+\t@Override\n+\tpublic boolean isReleased() {\n+\t\treturn isReleased;\n+\t}\n+\n \t@Override\n \tpublic PipelinedSubpartitionView createReadView(BufferProvider bufferProvider) {\n \t\tsynchronized (buffers) {\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\nindex e9dfe32131..b7ca9c4af5 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\n@@ -81,4 +81,6 @@ protected Throwable getFailureCause() {\n \n \tabstract int releaseMemory() throws IOException;\n \n+\tabstract public boolean isReleased();\n+\n }\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java\nindex 4a18691b7b..21e9cc6904 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java\n@@ -59,7 +59,7 @@\n \tprivate boolean isFinished;\n \n \t/** Flag indicating whether the subpartition has been released. */\n-\tboolean isReleased;\n+\tprivate volatile boolean isReleased;\n \n \t/** The read view to consume this subpartition. */\n \tprivate ResultSubpartitionView readView;\n@@ -167,6 +167,11 @@ public int releaseMemory() throws IOException {\n \t\treturn 0;\n \t}\n \n+\t@Override\n+\tpublic boolean isReleased() {\n+\t\treturn isReleased;\n+\t}\n+\n \t@Override\n \tpublic ResultSubpartitionView createReadView(BufferProvider bufferProvider) throws IOException {\n \t\tsynchronized (buffers) {\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java\nindex 972e34bc07..c9da40a33e 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java\n@@ -73,7 +73,7 @@ public Buffer getNextBuffer() throws IOException, InterruptedException {\n \n \t\t// 1) In-memory\n \t\tsynchronized (parent.buffers) {\n-\t\t\tif (parent.isReleased) {\n+\t\t\tif (parent.isReleased()) {\n \t\t\t\treturn null;\n \t\t\t}\n \n@@ -162,7 +162,7 @@ public void releaseAllResources() throws IOException {\n \n \t@Override\n \tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n+\t\treturn parent.isReleased() || isReleased.get();\n \t}\n \n \t@Override\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpilledSubpartitionViewAsyncIO.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpilledSubpartitionViewAsyncIO.java\nindex ea5c20b740..052a7cd7a9 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpilledSubpartitionViewAsyncIO.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpilledSubpartitionViewAsyncIO.java\n@@ -187,7 +187,7 @@ public void releaseAllResources() throws IOException {\n \n \t@Override\n \tpublic boolean isReleased() {\n-\t\treturn isReleased;\n+\t\treturn parent.isReleased() || isReleased;\n \t}\n \n \t@Override\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpilledSubpartitionViewSyncIO.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpilledSubpartitionViewSyncIO.java\nindex 24099a78ab..5b91668e81 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpilledSubpartitionViewSyncIO.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpilledSubpartitionViewSyncIO.java\n@@ -108,7 +108,7 @@ public void releaseAllResources() throws IOException {\n \n \t@Override\n \tpublic boolean isReleased() {\n-\t\treturn isReleased.get();\n+\t\treturn parent.isReleased() || isReleased.get();\n \t}\n \n \t@Override\n",
        "project": "flink",
        "linesAdd": 18,
        "jira_id": "2460",
        "nb_skipped": 0,
        "commit": "a17d4e82",
        "nb_failure": 2,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 940,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.checkpoint.stats.SimpleCheckpointStatsTrackerTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTracker.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTracker.java\nindex 5881f4fff0..fba3f22114 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTracker.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTracker.java\n@@ -299,9 +299,9 @@ else if (latestCompletedCheckpoint != null && subTaskStats != null) {\n \t\t\t\tlong[][] subTaskStats = this.subTaskStats.get(operatorId);\n \n \t\t\t\tif (subTaskStats == null) {\n-\t\t\t\t\tthrow new IllegalArgumentException(\"Unknown operator ID.\");\n+\t\t\t\t\treturn Option.empty();\n \t\t\t\t}\n-\n+\t\t\t\telse {\n \t\t\t\t\tlong maxDuration = Long.MIN_VALUE;\n \t\t\t\t\tlong stateSize = 0;\n \n@@ -325,6 +325,7 @@ else if (latestCompletedCheckpoint != null && subTaskStats != null) {\n \n \t\t\t\t\treturn Option.apply(stats);\n \t\t\t\t}\n+\t\t\t}\n \t\t\telse {\n \t\t\t\treturn Option.empty();\n \t\t\t}\n",
        "project": "flink",
        "linesAdd": 3,
        "jira_id": "3251",
        "nb_skipped": 1,
        "commit": "117ba95f",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 4,
        "nb_test": 335,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.optimizer.IterationsCompilerTest"
        ],
        "patch": "diff --git a/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/BulkIterationNode.java b/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/BulkIterationNode.java\nindex 3d95c22f34..556e2e33c8 100644\n--- a/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/BulkIterationNode.java\n+++ b/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/BulkIterationNode.java\n@@ -28,7 +28,6 @@\n import org.apache.flink.api.common.operators.SemanticProperties;\n import org.apache.flink.api.common.operators.SemanticProperties.EmptySemanticProperties;\n import org.apache.flink.api.common.operators.base.BulkIterationBase;\n-import org.apache.flink.api.common.operators.util.FieldList;\n import org.apache.flink.optimizer.CompilerException;\n import org.apache.flink.optimizer.DataStatistics;\n import org.apache.flink.optimizer.traversals.InterestingPropertyVisitor;\n@@ -48,6 +47,7 @@\n import org.apache.flink.optimizer.plan.PlanNode;\n import org.apache.flink.optimizer.plan.SingleInputPlanNode;\n import org.apache.flink.optimizer.plan.PlanNode.FeedbackPropertiesMeetRequirementsReport;\n+import org.apache.flink.optimizer.util.NoOpUnaryUdfOp;\n import org.apache.flink.runtime.operators.DriverStrategy;\n import org.apache.flink.util.Visitor;\n \n@@ -273,7 +273,7 @@ public void computeUnclosedBranchStack() {\n \t\tthis.openBranches = (result == null || result.isEmpty()) ? Collections.<UnclosedBranchDescriptor>emptyList() : result;\n \t}\n \n-\n+\t@SuppressWarnings(\"unchecked\")\n \t@Override\n \tprotected void instantiateCandidate(OperatorDescriptorSingle dps, Channel in, List<Set<? extends NamedChannel>> broadcastPlanChannels, \n \t\t\tList<PlanNode> target, CostEstimator estimator, RequestedGlobalProperties globPropsReq, RequestedLocalProperties locPropsReq)\n@@ -322,7 +322,9 @@ else if (report == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {\n \t\t\t\t\tglobPropsReq.parameterizeChannel(toNoOp, false, rootConnection.getDataExchangeMode(), false);\n \t\t\t\t\tlocPropsReq.parameterizeChannel(toNoOp);\n \n-\t\t\t\t\tUnaryOperatorNode rebuildPropertiesNode = new UnaryOperatorNode(\"Rebuild Partial Solution Properties\", FieldList.EMPTY_LIST);\n+\t\t\t\t\tNoOpUnaryUdfOp noOpUnaryUdfOp = new NoOpUnaryUdfOp<>();\n+\t\t\t\t\tnoOpUnaryUdfOp.setInput(candidate.getProgramOperator());\n+\t\t\t\t\tUnaryOperatorNode rebuildPropertiesNode = new UnaryOperatorNode(\"Rebuild Partial Solution Properties\", noOpUnaryUdfOp, true);\n \t\t\t\t\trebuildPropertiesNode.setParallelism(candidate.getParallelism());\n \t\t\t\t\t\n \t\t\t\t\tSingleInputPlanNode rebuildPropertiesPlanNode = new SingleInputPlanNode(rebuildPropertiesNode, \"Rebuild Partial Solution Properties\", toNoOp, DriverStrategy.UNARY_NO_OP);\n@@ -343,6 +345,8 @@ else if (report == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {\n \t\t\t\t\tplanDeleter.remove();\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tcandidates.addAll(newCandidates);\n \t\t}\n \n \t\tif (candidates.isEmpty()) {\ndiff --git a/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/UnaryOperatorNode.java b/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/UnaryOperatorNode.java\nindex 0c4803324f..0ec0264085 100644\n--- a/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/UnaryOperatorNode.java\n+++ b/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/UnaryOperatorNode.java\n@@ -18,10 +18,12 @@\n \n package org.apache.flink.optimizer.dag;\n \n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n \n import org.apache.flink.api.common.operators.SemanticProperties;\n+import org.apache.flink.api.common.operators.SingleInputOperator;\n import org.apache.flink.api.common.operators.SingleInputSemanticProperties;\n import org.apache.flink.api.common.operators.util.FieldSet;\n import org.apache.flink.optimizer.DataStatistics;\n@@ -30,11 +32,17 @@\n \n public class UnaryOperatorNode extends SingleInputNode {\n \t\n-\tprivate final List<OperatorDescriptorSingle> operator;\n+\tprivate final List<OperatorDescriptorSingle> operators;\n \t\n \tprivate final String name;\n \n+\tpublic UnaryOperatorNode(String name, SingleInputOperator<?, ?, ?> operator, boolean onDynamicPath) {\n+\t\tsuper(operator);\n \n+\t\tthis.name = name;\n+\t\tthis.operators = new ArrayList<>();\n+\t\tthis.onDynamicPath = onDynamicPath;\n+\t}\n \t\n \tpublic UnaryOperatorNode(String name, FieldSet keys, OperatorDescriptorSingle ... operators) {\n \t\tthis(name, keys, Arrays.asList(operators));\n@@ -43,13 +51,13 @@ public UnaryOperatorNode(String name, FieldSet keys, OperatorDescriptorSingle ..\n \tpublic UnaryOperatorNode(String name, FieldSet keys, List<OperatorDescriptorSingle> operators) {\n \t\tsuper(keys);\n \t\t\n-\t\tthis.operator = operators;\n+\t\tthis.operators = operators;\n \t\tthis.name = name;\n \t}\n \n \t@Override\n \tprotected List<OperatorDescriptorSingle> getPossibleProperties() {\n-\t\treturn this.operator;\n+\t\treturn this.operators;\n \t}\n \n \t@Override\ndiff --git a/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/WorksetIterationNode.java b/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/WorksetIterationNode.java\nindex 15b9a50b41..7969a94c81 100644\n--- a/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/WorksetIterationNode.java\n+++ b/flink-optimizer/src/main/java/org/apache/flink/optimizer/dag/WorksetIterationNode.java\n@@ -52,6 +52,7 @@\n import org.apache.flink.optimizer.plan.WorksetPlanNode;\n import org.apache.flink.optimizer.plan.PlanNode.FeedbackPropertiesMeetRequirementsReport;\n import org.apache.flink.optimizer.util.NoOpBinaryUdfOp;\n+import org.apache.flink.optimizer.util.NoOpUnaryUdfOp;\n import org.apache.flink.runtime.operators.DriverStrategy;\n import org.apache.flink.runtime.operators.shipping.ShipStrategyType;\n import org.apache.flink.runtime.operators.util.LocalStrategy;\n@@ -308,6 +309,7 @@ public void clearInterestingProperties() {\n \t\tthis.solutionSetDelta.accept(InterestingPropertiesClearer.INSTANCE);\n \t}\n \n+\t@SuppressWarnings(\"unchecked\")\n \t@Override\n \tprotected void instantiate(OperatorDescriptorDual operator, Channel solutionSetIn, Channel worksetIn,\n \t\t\tList<Set<? extends NamedChannel>> broadcastPlanChannels, List<PlanNode> target, CostEstimator estimator,\n@@ -368,8 +370,13 @@ else if (report == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnextWorksetRootConnection.getDataExchangeMode(), false);\n \t\t\t\t\tlocPropsReqWorkset.parameterizeChannel(toNoOp);\n \n-\t\t\t\t\tUnaryOperatorNode rebuildWorksetPropertiesNode = new UnaryOperatorNode(\"Rebuild Workset Properties\",\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFieldList.EMPTY_LIST);\n+\t\t\t\t\tNoOpUnaryUdfOp noOpUnaryUdfOp = new NoOpUnaryUdfOp<>();\n+\t\t\t\t\tnoOpUnaryUdfOp.setInput(candidate.getProgramOperator());\n+\n+\t\t\t\t\tUnaryOperatorNode rebuildWorksetPropertiesNode = new UnaryOperatorNode(\n+\t\t\t\t\t\t\"Rebuild Workset Properties\",\n+\t\t\t\t\t\tnoOpUnaryUdfOp,\n+\t\t\t\t\t\ttrue);\n \t\t\t\t\t\n \t\t\t\t\trebuildWorksetPropertiesNode.setParallelism(candidate.getParallelism());\n \t\t\t\t\t\ndiff --git a/flink-optimizer/src/main/java/org/apache/flink/optimizer/util/NoOpUnaryUdfOp.java b/flink-optimizer/src/main/java/org/apache/flink/optimizer/util/NoOpUnaryUdfOp.java\nindex cc4a4d655c..8537b9c164 100644\n--- a/flink-optimizer/src/main/java/org/apache/flink/optimizer/util/NoOpUnaryUdfOp.java\n+++ b/flink-optimizer/src/main/java/org/apache/flink/optimizer/util/NoOpUnaryUdfOp.java\n@@ -36,7 +36,7 @@\n \t@SuppressWarnings(\"rawtypes\")\n \tpublic static final NoOpUnaryUdfOp INSTANCE = new NoOpUnaryUdfOp();\n \t\n-\tprivate NoOpUnaryUdfOp() {\n+\tpublic NoOpUnaryUdfOp() {\n \t\t// pass null here because we override getOutputType to return type\n \t\t// of input operator\n \t\tsuper(new UserCodeClassWrapper<NoOpFunction>(NoOpFunction.class), null, \"\");\n",
        "project": "flink",
        "linesAdd": 28,
        "jira_id": "3052",
        "nb_skipped": 0,
        "commit": "8dc70f2e",
        "nb_failure": 2,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 892,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.operators.hash.HashTableTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/HashPartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/HashPartition.java\nindex 32fd74a51e..97bef4a602 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/HashPartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/HashPartition.java\n@@ -207,7 +207,8 @@ public final boolean isInMemory() {\n \t */\n \tpublic int getNumOccupiedMemorySegments() {\n \t\t// either the number of memory segments, or one for spilling\n-\t\tfinal int numPartitionBuffers = this.partitionBuffers != null ? this.partitionBuffers.length : 1;\n+\t\tfinal int numPartitionBuffers = this.partitionBuffers != null ?\n+\t\t\tthis.partitionBuffers.length : this.buildSideWriteBuffer.getNumOccupiedMemorySegments();\n \t\treturn numPartitionBuffers + numOverflowSegments;\n \t}\n \t\n@@ -542,6 +543,11 @@ int getBlockCount() {\n \t\t\treturn this.currentBlockNumber + 1;\n \t\t}\n \n+\t\tint getNumOccupiedMemorySegments() {\n+\t\t\t// return the current segment + all filled segments\n+\t\t\treturn this.targetList.size() + 1;\n+\t\t}\n+\t\t\n \t\tint spill(BlockChannelWriter<MemorySegment> writer) throws IOException {\n \t\t\tthis.writer = writer;\n \t\t\tfinal int numSegments = this.targetList.size();\n",
        "project": "flink",
        "linesAdd": 6,
        "jira_id": "2964",
        "nb_skipped": 1,
        "commit": "76bebd42",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 535,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "type.extractor.PojoTypeExtractionTest"
        ],
        "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex 7836e74e61..6a56e46aa0 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -975,10 +974,10 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\t\t\t// no arguments for the getter\n \t\t\t\t\tm.getParameterTypes().length == 0 &&\n \t\t\t\t\t// return type is same as field type (or the generic variant of it)\n-\t\t\t\t\tm.getReturnType().equals( fieldType ) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric) )\n+\t\t\t\t\t(m.getReturnType().equals( fieldType ) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )\n \t\t\t\t) {\n \t\t\t\t\tif(hasGetter) {\n-\t\t\t\t\t\tthrow new IllegalStateException(\"Detected more than one getters\");\n+\t\t\t\t\t\tthrow new IllegalStateException(\"Detected more than one getter\");\n \t\t\t\t\t}\n \t\t\t\t\thasGetter = true;\n \t\t\t\t}\n@@ -990,7 +989,7 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\t\t\tm.getReturnType().equals(Void.TYPE)\n \t\t\t\t) {\n \t\t\t\t\tif(hasSetter) {\n-\t\t\t\t\t\tthrow new IllegalStateException(\"Detected more than one getters\");\n+\t\t\t\t\t\tthrow new IllegalStateException(\"Detected more than one setter\");\n \t\t\t\t\t}\n \t\t\t\t\thasSetter = true;\n \t\t\t\t}\n",
        "project": "flink",
        "linesAdd": 3,
        "jira_id": "1145",
        "nb_skipped": 2,
        "commit": "22c370d9",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 700,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.io.network.partition.SpillableSubpartitionTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java\nindex 91f20426a6..4a18691b7b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java\n@@ -59,7 +59,7 @@\n \tprivate boolean isFinished;\n \n \t/** Flag indicating whether the subpartition has been released. */\n-\tprivate boolean isReleased;\n+\tboolean isReleased;\n \n \t/** The read view to consume this subpartition. */\n \tprivate ResultSubpartitionView readView;\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java\nindex d37f04290e..972e34bc07 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java\n@@ -73,6 +73,10 @@ public Buffer getNextBuffer() throws IOException, InterruptedException {\n \n \t\t// 1) In-memory\n \t\tsynchronized (parent.buffers) {\n+\t\t\tif (parent.isReleased) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n \t\t\tif (parent.spillWriter == null) {\n \t\t\t\tif (currentQueuePosition < numberOfBuffers) {\n \t\t\t\t\tBuffer buffer = parent.buffers.get(currentQueuePosition);\n",
        "project": "flink",
        "linesAdd": 5,
        "jira_id": "2412",
        "nb_skipped": 0,
        "commit": "a56aad74",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 299,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.streaming.api.streamtask.StreamIterationHeadTest"
        ],
        "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/StreamInputProcessor.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/StreamInputProcessor.java\nindex f50ddcd832..80563b84e7 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/StreamInputProcessor.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/StreamInputProcessor.java\n@@ -79,7 +79,7 @@\n \n \tprivate final DeserializationDelegate<StreamElement> deserializationDelegate;\n \n-\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+\t@SuppressWarnings(\"unchecked\")\n \tpublic StreamInputProcessor(InputGate[] inputGates, TypeSerializer<IN> inputSerializer,\n \t\t\t\t\t\t\t\tEventListener<CheckpointBarrier> checkpointListener,\n \t\t\t\t\t\t\t\tCheckpointingMode checkpointMode,\n@@ -125,7 +125,6 @@ else if (checkpointMode == CheckpointingMode.AT_LEAST_ONCE) {\n \t\tlastEmittedWatermark = Long.MIN_VALUE;\n \t}\n \n-\t@SuppressWarnings(\"unchecked\")\n \tpublic boolean processInput(OneInputStreamOperator<IN, ?> streamOperator, Object lock) throws Exception {\n \t\tif (isFinished) {\n \t\t\treturn false;\ndiff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamIterationHead.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamIterationHead.java\nindex 2ad2d2da2f..c937e51d05 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamIterationHead.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamIterationHead.java\n@@ -23,6 +23,7 @@\n import java.util.concurrent.TimeUnit;\n \n import org.apache.flink.api.common.JobID;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n import org.apache.flink.streaming.runtime.io.RecordWriterOutput;\n import org.apache.flink.streaming.runtime.io.BlockingQueueBroker;\n import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n@@ -64,6 +64,13 @@ protected void run() throws Exception {\n \t\t\tCollection<RecordWriterOutput<OUT>> outputs = \n \t\t\t\t\t(Collection<RecordWriterOutput<OUT>>) (Collection<?>) outputHandler.getOutputs();\n \n+\t\t\t// If timestamps are enabled we make sure to remove cyclic watermark dependencies\n+\t\t\tif (getExecutionConfig().areTimestampsEnabled()) {\n+\t\t\t\tfor (RecordWriterOutput<OUT> output : outputs) {\n+\t\t\t\t\toutput.emitWatermark(new Watermark(Long.MAX_VALUE));\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\twhile (running) {\n \t\t\t\tStreamRecord<OUT> nextRecord = shouldWait ?\n \t\t\t\t\tdataChannel.poll(iterationWaitTime, TimeUnit.MILLISECONDS) :\n",
        "project": "flink",
        "linesAdd": 8,
        "jira_id": "2802",
        "nb_skipped": 3,
        "commit": "88a97768",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 954,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.checkpoint.stats.SimpleCheckpointStatsTrackerTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTracker.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTracker.java\nindex fba3f22114..5ee4fc3e9c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTracker.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/stats/SimpleCheckpointStatsTracker.java\n@@ -136,7 +136,7 @@ public void onCompletedCheckpoint(CompletedCheckpoint checkpoint) {\n \t\t}\n \n \t\tsynchronized (statsLock) {\n-\t\t\tint overallStateSize = 0;\n+\t\t\tlong overallStateSize = 0;\n \n \t\t\t// Operator stats\n \t\t\tMap<JobVertexID, long[][]> statsForSubTasks = new HashMap<>();\n",
        "project": "flink",
        "linesAdd": 1,
        "jira_id": "3342",
        "nb_skipped": 1,
        "commit": "8e3e2f8f",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 832,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.operators.hash.HashTableTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/HashPartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/HashPartition.java\nindex 7baaee76b9..32fd74a51e 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/HashPartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/HashPartition.java\n@@ -199,6 +199,19 @@ public final boolean isInMemory() {\n \t\treturn this.buildSideChannel == null;\n \t}\n \n+\t/**\n+\t * Gets the number of memory segments used by this partition, which includes build side\n+\t * memory buffers and overflow memory segments.\n+\t * \n+\t * @return The number of occupied memory segments.\n+\t */\n+\tpublic int getNumOccupiedMemorySegments() {\n+\t\t// either the number of memory segments, or one for spilling\n+\t\tfinal int numPartitionBuffers = this.partitionBuffers != null ? this.partitionBuffers.length : 1;\n+\t\treturn numPartitionBuffers + numOverflowSegments;\n+\t}\n+\t\n+\t\n \tpublic int getBuildSideBlockCount() {\n \t\treturn this.partitionBuffers == null ? this.buildSideWriteBuffer.getBlockCount() : this.partitionBuffers.length;\n \t}\n@@ -284,7 +297,7 @@ public int spillPartition(List<MemorySegment> target, IOManager ioAccess, FileIO\n \t\t\tthrow new RuntimeException(\"Bug in Hybrid Hash Join: \" +\n \t\t\t\t\t\"Request to spill a partition that has already been spilled.\");\n \t\t}\n-\t\tif (getBuildSideBlockCount() + this.numOverflowSegments < 2) {\n+\t\tif (getNumOccupiedMemorySegments() < 2) {\n \t\t\tthrow new RuntimeException(\"Bug in Hybrid Hash Join: \" +\n \t\t\t\t\"Request to spill a partition with less than two buffers.\");\n \t\t}\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/MutableHashTable.java b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/MutableHashTable.java\nindex 2ad01aae46..efaceeacec 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/MutableHashTable.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/hash/MutableHashTable.java\n@@ -1093,8 +1093,8 @@ protected int spillPartition() throws IOException {\n \t\t\n \t\tfor (int i = 0; i < partitions.size(); i++) {\n \t\t\tHashPartition<BT, PT> p = partitions.get(i);\n-\t\t\tif (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {\n-\t\t\t\tlargestNumBlocks = p.getBuildSideBlockCount();\n+\t\t\tif (p.isInMemory() && p.getNumOccupiedMemorySegments() > largestNumBlocks) {\n+\t\t\t\tlargestNumBlocks = p.getNumOccupiedMemorySegments();\n \t\t\t\tlargestPartNum = i;\n \t\t\t}\n \t\t}\n",
        "project": "flink",
        "linesAdd": 9,
        "jira_id": "2763",
        "nb_skipped": 0,
        "commit": "af477563",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 617,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.taskmanager.TaskManagerRegistrationTest",
            "org.apache.flink.runtime.taskmanager.TaskInputSplitProviderTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\nindex 3ba378c5f4..baed9474dc 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n@@ -328,7 +328,7 @@ public void deployToSlot(final SimpleSlot slot) throws JobException {\n \t\t\t// register this execution at the execution graph, to receive call backs\n \t\t\tvertex.getExecutionGraph().registerExecution(this);\n \n-\t\t\tInstance instance = slot.getInstance();\n+\t\t\tfinal Instance instance = slot.getInstance();\n \t\t\tFuture<Object> deployAction = Patterns.ask(instance.getTaskManager(),\n \t\t\t\t\tnew SubmitTask(deployment), new Timeout(timeout));\n \n@@ -338,7 +338,9 @@ public void deployToSlot(final SimpleSlot slot) throws JobException {\n \t\t\t\tpublic void onComplete(Throwable failure, Object success) throws Throwable {\n \t\t\t\t\tif (failure != null) {\n \t\t\t\t\t\tif (failure instanceof TimeoutException) {\n-\t\t\t\t\t\t\tmarkFailed(new Exception(\"Cannot deploy task - TaskManager not responding.\", failure));\n+\t\t\t\t\t\t\tmarkFailed(new Exception(\n+\t\t\t\t\t\t\t\t\t\"Cannot deploy task - TaskManager \" + instance + \" not responding.\",\n+\t\t\t\t\t\t\t\t\tfailure));\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse {\n \t\t\t\t\t\t\tmarkFailed(failure);\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/TaskInputSplitProvider.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/TaskInputSplitProvider.java\nindex 1bdc34683b..5a698509c9 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/TaskInputSplitProvider.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/TaskInputSplitProvider.java\n@@ -68,10 +68,6 @@ public InputSplit getNextInputSplit() {\n \n \t\t\tfinal Object result = Await.result(response, timeout.duration());\n \n-\t\t\tif (result == null) {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\n \t\t\tif(!(result instanceof JobManagerMessages.NextInputSplit)){\n \t\t\t\tthrow new RuntimeException(\"RequestNextInputSplit requires a response of type \" +\n \t\t\t\t\t\t\"NextInputSplit. Instead response is of type \" + result.getClass() + \".\");\n@@ -80,10 +76,15 @@ public InputSplit getNextInputSplit() {\n \t\t\t\t\t\t(JobManagerMessages.NextInputSplit) result;\n \n \t\t\t\tbyte[] serializedData = nextInputSplit.splitData();\n+\n+\t\t\t\tif(serializedData == null) {\n+\t\t\t\t\treturn null;\n+\t\t\t\t} else {\n \t\t\t\t\tObject deserialized = InstantiationUtil.deserializeObject(serializedData,\n \t\t\t\t\t\t\tusercodeClassLoader);\n \t\t\t\t\treturn (InputSplit) deserialized;\n \t\t\t\t}\n+\t\t\t}\n \t\t} catch (Exception e) {\n \t\t\tthrow new RuntimeException(\"Requesting the next InputSplit failed.\", e);\n \t\t}\n",
        "project": "flink",
        "linesAdd": 9,
        "jira_id": "1922",
        "nb_skipped": 0,
        "commit": "ccd574a4",
        "nb_failure": 1,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 299,
        "nb_error": 4,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.streaming.api.AggregationFunctionTest"
        ],
        "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/util/keys/KeySelectorUtil.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/util/keys/KeySelectorUtil.java\nindex d8839a0022..9c76d95ba8 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/util/keys/KeySelectorUtil.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/util/keys/KeySelectorUtil.java\n@@ -28,6 +28,8 @@\n import org.apache.flink.api.java.functions.KeySelector;\n import org.apache.flink.api.java.operators.Keys;\n import org.apache.flink.api.java.tuple.Tuple;\n+import org.apache.flink.api.java.typeutils.ResultTypeQueryable;\n+import org.apache.flink.api.java.typeutils.TupleTypeInfo;\n \n /**\n  * Utility class that contains helper methods to manipulating {@link KeySelector} for streaming.\n@@ -47,12 +49,14 @@\n \t\t\n \t\t// use ascending order here, the code paths for that are usually a slight bit faster\n \t\tboolean[] orders = new boolean[numKeyFields];\n+\t\tTypeInformation[] typeInfos = new TypeInformation[numKeyFields];\n \t\tfor (int i = 0; i < numKeyFields; i++) {\n \t\t\torders[i] = true;\n+\t\t\ttypeInfos[i] = compositeType.getTypeAt(logicalKeyPositions[i]);\n \t\t}\n \n \t\tTypeComparator<X> comparator = compositeType.createComparator(logicalKeyPositions, orders, 0, executionConfig);\n-\t\treturn new ComparableKeySelector<X>(comparator, numKeyFields);\n+\t\treturn new ComparableKeySelector<>(comparator, numKeyFields, new TupleTypeInfo<>(typeInfos));\n \t}\n \n \t\n@@ -70,7 +74,7 @@\n \n \t\tTypeComparator<X> comparator = ((CompositeType<X>) typeInfo).createComparator(\n \t\t\t\tlogicalKeyPositions, new boolean[1], 0, executionConfig);\n-\t\treturn new OneKeySelector<X, K>(comparator);\n+\t\treturn new OneKeySelector<>(comparator);\n \t}\n \n \t/**\n@@ -111,21 +115,23 @@ public K getKey(IN value) throws Exception {\n \t *\n \t * @param <IN> The type from which the key is extracted.\n \t */\n-\tpublic static final class ComparableKeySelector<IN> implements KeySelector<IN, Tuple> {\n+\tpublic static final class ComparableKeySelector<IN> implements KeySelector<IN, Tuple>, ResultTypeQueryable<Tuple> {\n \n \t\tprivate static final long serialVersionUID = 1L;\n \n \t\tprivate final TypeComparator<IN> comparator;\n \t\tprivate final int keyLength;\n+\t\tprivate final TupleTypeInfo tupleTypeInfo;\n \n \t\t/** Reusable array to hold the key objects. Since this is initially empty (all positions\n \t\t * are null), it does not have any serialization problems */\n \t\t@SuppressWarnings(\"NonSerializableFieldInSerializableClass\")\n \t\tprivate final Object[] keyArray;\n \n-\t\tpublic ComparableKeySelector(TypeComparator<IN> comparator, int keyLength) {\n+\t\tpublic ComparableKeySelector(TypeComparator<IN> comparator, int keyLength, TupleTypeInfo tupleTypeInfo) {\n \t\t\tthis.comparator = comparator;\n \t\t\tthis.keyLength = keyLength;\n+\t\t\tthis.tupleTypeInfo = tupleTypeInfo;\n \t\t\tkeyArray = new Object[keyLength];\n \t\t}\n \n@@ -139,6 +145,10 @@ public Tuple getKey(IN value) throws Exception {\n \t\t\treturn key;\n \t\t}\n \n+\t\t@Override\n+\t\tpublic TypeInformation<Tuple> getProducedType() {\n+\t\t\treturn tupleTypeInfo;\n+\t\t}\n \t}\n \n \t// ------------------------------------------------------------------------\n",
        "project": "flink",
        "linesAdd": 14,
        "jira_id": "2812",
        "nb_skipped": 5,
        "commit": "e494c279",
        "nb_failure": 0,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 608,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.io.network.buffer.LocalBufferPoolTest",
            "org.apache.flink.runtime.io.network.buffer.NetworkBufferPoolTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java\nindex 1da2b8b50a..4cb1521682 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java\n@@ -141,7 +141,7 @@ private Buffer requestBuffer(boolean isBlocking) throws InterruptedException, IO\n \n \t\t\twhile (availableMemorySegments.isEmpty()) {\n \t\t\t\tif (isDestroyed) {\n-\t\t\t\t\treturn null;\n+\t\t\t\t\tthrow new IllegalStateException(\"Buffer pool is destroyed.\");\n \t\t\t\t}\n \n \t\t\t\tif (numberOfRequestedMemorySegments < currentPoolSize) {\n",
        "project": "flink",
        "linesAdd": 1,
        "jira_id": "1930",
        "nb_skipped": 0,
        "commit": "4dbf030a",
        "nb_failure": 3,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 456,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "type.extractor.TypeExtractorTest"
        ],
        "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex d5f3619d84..55f6b1f1c9 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -421,15 +421,12 @@ else if (inType instanceof ParameterizedType && Tuple.class.isAssignableFrom(((C\n \t\t\tType[] tupleElements = ((ParameterizedType) inType).getActualTypeArguments();\n \t\t\t// go thru all tuple elements and search for type variables\n \t\t\tfor(int i = 0; i < tupleElements.length; i++) {\n-\t\t\t\tif(tupleElements[i] instanceof TypeVariable) {\n-\t\t\t\t\tinType = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) tupleElements[i]);\n-\t\t\t\t\tinfo = findCorrespondingInfo(returnTypeVar, inType, ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i));\n+\t\t\t\tinfo = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, tupleElements[i], ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i));\n \t\t\t\tif(info != null) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\t}\n \t\treturn info;\n \t}\n \t\n",
        "project": "flink",
        "linesAdd": 1,
        "jira_id": "1133",
        "nb_skipped": 1,
        "commit": "02c08456",
        "nb_failure": 0,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 819,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.api.common.io.FileOutputFormatTest",
            "org.apache.flink.core.fs.PathTest"
        ],
        "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/core/fs/Path.java b/flink-core/src/main/java/org/apache/flink/core/fs/Path.java\nindex a104d86a90..30a2a65394 100644\n--- a/flink-core/src/main/java/org/apache/flink/core/fs/Path.java\n+++ b/flink-core/src/main/java/org/apache/flink/core/fs/Path.java\n@@ -37,6 +37,8 @@\n /**\n  * Names a file or directory in a {@link FileSystem}. Path strings use slash as\n  * the directory separator. A path string is absolute if it begins with a slash.\n+ *\n+ * Tailing slashes are removed from the path.\n  */\n public class Path implements IOReadableWritable, Serializable {\n \t\n@@ -71,7 +73,7 @@ public Path() {}\n \t * Constructs a path object from a given URI.\n \t * \n \t * @param uri\n-\t *        the URI to contruct the path object from\n+\t *        the URI to construct the path object from\n \t */\n \tpublic Path(URI uri) {\n \t\tthis.uri = uri;\n@@ -145,18 +147,22 @@ public Path(Path parent, Path child) {\n \t/**\n  \t * Checks if the provided path string is either null or has zero length and throws\n \t * a {@link IllegalArgumentException} if any of the two conditions apply.\n+\t * In addition, leading and tailing whitespaces are removed.\n \t *\n \t * @param path\n \t *        the path string to be checked\n+\t * @return The checked and trimmed path.\n \t */\n-\tprivate void checkPathArg(String path) {\n+\tprivate String checkAndTrimPathArg(String path) {\n \t\t// disallow construction of a Path from an empty string\n \t\tif (path == null) {\n \t\t\tthrow new IllegalArgumentException(\"Can not create a Path from a null string\");\n \t\t}\n+\t\tpath = path.trim();\n \t\tif (path.length() == 0) {\n \t\t\tthrow new IllegalArgumentException(\"Can not create a Path from an empty string\");\n \t\t}\n+\t\treturn path;\n \t}\n \n \t/**\n@@ -167,7 +173,7 @@ private void checkPathArg(String path) {\n \t *        the string to construct a path from\n \t */\n \tpublic Path(String pathString) {\n-\t\tcheckPathArg(pathString);\n+\t\tpathString = checkAndTrimPathArg(pathString);\n \n \t\t// We can't use 'new URI(String)' directly, since it assumes things are\n \t\t// escaped, which we don't require of Paths.\n@@ -217,7 +223,7 @@ public Path(String pathString) {\n \t *        the path string\n \t */\n \tpublic Path(String scheme, String authority, String path) {\n-\t\tcheckPathArg(path);\n+\t\tpath = checkAndTrimPathArg(path);\n \t\tinitialize(scheme, authority, path);\n \t}\n \n@@ -247,9 +253,18 @@ private void initialize(String scheme, String authority, String path) {\n \t * @return the normalized path string\n \t */\n \tprivate String normalizePath(String path) {\n-\t\t// remove double slashes & backslashes\n-\t\tpath = path.replace(\"//\", \"/\");\n+\n+\t\t// remove leading and tailing whitespaces\n+\t\tpath = path.trim();\n+\n+\t\t// remove consecutive slashes & backslashes\n \t\tpath = path.replace(\"\\\\\", \"/\");\n+\t\tpath = path.replaceAll(\"/+\", \"/\");\n+\n+\t\t// remove tailing separator\n+\t\tif(!path.equals(SEPARATOR) && path.endsWith(SEPARATOR)) {\n+\t\t\tpath = path.substring(0, path.length() - SEPARATOR.length());\n+\t\t}\n \n \t\treturn path;\n \t}\n@@ -306,23 +321,19 @@ public boolean isAbsolute() {\n \t}\n \n \t/**\n-\t * Returns the final component of this path.\n+\t * Returns the final component of this path, i.e., everything that follows the last separator.\n \t * \n \t * @return the final component of the path\n \t */\n \tpublic String getName() {\n \t\tfinal String path = uri.getPath();\n-\t\tif (path.endsWith(SEPARATOR)) {\n-\t\t\tfinal int slash = path.lastIndexOf(SEPARATOR, path.length() - SEPARATOR.length() - 1);\n-\t\t\treturn path.substring(slash + 1, path.length() - SEPARATOR.length());\n-\t\t} else {\n \t\tfinal int slash = path.lastIndexOf(SEPARATOR);\n \t\treturn path.substring(slash + 1);\n \t}\n-\t}\n \n \t/**\n-\t * Returns the parent of a path or <code>null</code> if at root.\n+\t * Returns the parent of a path, i.e., everything that precedes the last separator\n+\t * or <code>null</code> if at root.\n \t * \n \t * @return the parent of a path or <code>null</code> if at root.\n \t */\n",
        "project": "flink",
        "linesAdd": 13,
        "jira_id": "1640",
        "nb_skipped": 0,
        "commit": "8f321c72",
        "nb_failure": 8,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 213,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.streaming.runtime.io.BarrierBufferTest"
        ],
        "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BarrierBuffer.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BarrierBuffer.java\nindex b7766eea99..fd896c9d83 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BarrierBuffer.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BarrierBuffer.java\n@@ -76,7 +76,7 @@\n \n \t/**\n \t * \n-\t * @param inputGate Teh input gate to draw the buffers and events from.\n+\t * @param inputGate The input gate to draw the buffers and events from.\n \t * @param ioManager The I/O manager that gives access to the temp directories.\n \t * \n \t * @throws IOException Thrown, when the spilling to temp files cannot be initialized.\n@@ -102,6 +102,7 @@ public BufferOrEvent getNextNonBlocked() throws IOException, InterruptedExceptio\n \t\t\tif (currentBuffered != null) {\n \t\t\t\tnext = currentBuffered.getNext();\n \t\t\t\tif (next == null) {\n+\t\t\t\t\tcurrentBuffered.cleanup();\n \t\t\t\t\tcurrentBuffered = queuedBuffered.pollFirst();\n \t\t\t\t\tif (currentBuffered != null) {\n \t\t\t\t\t\tcurrentBuffered.open();\n",
        "project": "flink",
        "linesAdd": 1,
        "jira_id": "2484",
        "nb_skipped": 1,
        "commit": "d738430c",
        "nb_failure": 10,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 3,
        "nb_test": 284,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.streaming.runtime.operators.windowing.WindowOperatorTest"
        ],
        "patch": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java\nindex 1e4e453a43..84ee0b93cb 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java\n@@ -82,15 +82,11 @@ public void processElement(StreamRecord<IN> element) throws Exception {\n \t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(),\n \t\t\t\telement.getTimestamp());\n \n-\t\tK key = (K) getStateBackend().getCurrentKey();\n+\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n \n \t\tif (windowAssigner instanceof MergingWindowAssigner) {\n-\t\t\tMergingWindowSet<W> mergingWindows = mergingWindowsByKey.get(getStateBackend().getCurrentKey());\n-\t\t\tif (mergingWindows == null) {\n-\t\t\t\tmergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner);\n-\t\t\t\tmergingWindowsByKey.put(key, mergingWindows);\n-\t\t\t}\n \n+\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n \n \t\t\tfor (W window : elementWindows) {\n \t\t\t\t// If there is a merge, it can only result in a window that contains our new\n@@ -107,6 +103,7 @@ public void processElement(StreamRecord<IN> element) throws Exception {\n \t\t\t\t\t\t\tpublic void merge(W mergeResult,\n \t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n \t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n+\t\t\t\t\t\t\t\tcontext.key = key;\n \t\t\t\t\t\t\t\tcontext.window = mergeResult;\n \n \t\t\t\t\t\t\t\t// store for later use\n@@ -141,7 +138,7 @@ public void merge(W mergeResult,\n \t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult,\n \t\t\t\t\t\tmergeTriggerResult.f0);\n \n-\t\t\t\tprocessTriggerResult(combinedTriggerResult, key, actualWindow);\n+\t\t\t\tprocessTriggerResult(combinedTriggerResult, actualWindow);\n \t\t\t}\n \n \t\t} else {\n@@ -157,14 +154,14 @@ public void merge(W mergeResult,\n \t\t\t\tcontext.window = window;\n \t\t\t\tTriggerResult triggerResult = context.onElement(element);\n \n-\t\t\t\tprocessTriggerResult(triggerResult, key, window);\n+\t\t\t\tprocessTriggerResult(triggerResult, window);\n \t\t\t}\n \t\t}\n \t}\n \n \t@Override\n \t@SuppressWarnings(\"unchecked,rawtypes\")\n-\tprotected void processTriggerResult(TriggerResult triggerResult, K key, W window) throws Exception {\n+\tprotected void processTriggerResult(TriggerResult triggerResult, W window) throws Exception {\n \t\tif (!triggerResult.isFire() && !triggerResult.isPurge()) {\n \t\t\t// do nothing\n \t\t\treturn;\n@@ -175,7 +172,7 @@ protected void processTriggerResult(TriggerResult triggerResult, K key, W window\n \t\tMergingWindowSet<W> mergingWindows = null;\n \n \t\tif (windowAssigner instanceof MergingWindowAssigner) {\n-\t\t\tmergingWindows = mergingWindowsByKey.get(key);\n+\t\t\tmergingWindows = getMergingWindowSet();\n \t\t\tW stateWindow = mergingWindows.getStateWindow(window);\n \t\t\twindowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n \ndiff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/MergingWindowSet.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/MergingWindowSet.java\nindex 7ef1af4700..49a2017549 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/MergingWindowSet.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/MergingWindowSet.java\n@@ -17,6 +17,8 @@\n  */\n package org.apache.flink.streaming.runtime.operators.windowing;\n \n+import org.apache.flink.api.common.state.ListState;\n+import org.apache.flink.api.java.tuple.Tuple2;\n import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;\n import org.apache.flink.streaming.api.windowing.windows.Window;\n import org.slf4j.Logger;\n@@ -72,6 +74,24 @@ public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner) {\n \t\twindows = new HashMap<>();\n \t}\n \n+\t/**\n+\t * Restores a {@link MergingWindowSet} from the given state.\n+\t */\n+\tpublic MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception {\n+\t\tthis.windowAssigner = windowAssigner;\n+\t\twindows = new HashMap<>();\n+\n+\t\tfor (Tuple2<W, W> window: state.get()) {\n+\t\t\twindows.put(window.f0, window.f1);\n+\t\t}\n+\t}\n+\n+\tpublic void persist(ListState<Tuple2<W, W>> state) throws Exception {\n+\t\tfor (Map.Entry<W, W> window: windows.entrySet()) {\n+\t\t\tstate.add(new Tuple2<>(window.getKey(), window.getValue()));\n+\t\t}\n+\t}\n+\n \t/**\n \t * Returns the state window for the given in-flight {@code Window}. The state window is the\n \t * {@code Window} in which we keep the actual state of a given in-flight window. Windows\ndiff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java\nindex c106e70c0f..919cee7465 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java\n@@ -22,6 +22,8 @@\n import org.apache.flink.annotation.Internal;\n import org.apache.flink.api.common.ExecutionConfig;\n import org.apache.flink.api.common.state.AppendingState;\n+import org.apache.flink.api.common.state.ListState;\n+import org.apache.flink.api.common.state.ListStateDescriptor;\n import org.apache.flink.api.common.state.MergingState;\n import org.apache.flink.api.common.state.State;\n import org.apache.flink.api.common.state.StateDescriptor;\n@@ -29,10 +31,13 @@\n import org.apache.flink.api.common.state.ValueStateDescriptor;\n import org.apache.flink.api.common.typeinfo.TypeInformation;\n import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.api.common.typeutils.base.VoidSerializer;\n import org.apache.flink.api.java.functions.KeySelector;\n import org.apache.flink.api.java.tuple.Tuple1;\n+import org.apache.flink.api.java.tuple.Tuple2;\n import org.apache.flink.api.java.typeutils.InputTypeConfigurable;\n import org.apache.flink.api.java.typeutils.TypeExtractor;\n+import org.apache.flink.api.java.typeutils.runtime.TupleSerializer;\n import org.apache.flink.core.memory.DataInputView;\n import org.apache.flink.runtime.state.AbstractStateBackend;\n import org.apache.flink.runtime.state.StateHandle;\n@@ -224,6 +229,25 @@ public final void open() throws Exception {\n \t@Override\n \tpublic final void close() throws Exception {\n \t\tsuper.close();\n+\t\ttimestampedCollector = null;\n+\t\twatermarkTimers = null;\n+\t\twatermarkTimersQueue = null;\n+\t\tprocessingTimeTimers = null;\n+\t\tprocessingTimeTimersQueue = null;\n+\t\tcontext = null;\n+\t\tmergingWindowsByKey = null;\n+\t}\n+\n+\t@Override\n+\tpublic void dispose() {\n+\t\tsuper.dispose();\n+\t\ttimestampedCollector = null;\n+\t\twatermarkTimers = null;\n+\t\twatermarkTimersQueue = null;\n+\t\tprocessingTimeTimers = null;\n+\t\tprocessingTimeTimersQueue = null;\n+\t\tcontext = null;\n+\t\tmergingWindowsByKey = null;\n \t}\n \n \t@Override\n@@ -231,15 +255,10 @@ public final void close() throws Exception {\n \tpublic void processElement(StreamRecord<IN> element) throws Exception {\n \t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n \n-\t\tK key = (K) getStateBackend().getCurrentKey();\n+\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n \n \t\tif (windowAssigner instanceof MergingWindowAssigner) {\n-\t\t\tMergingWindowSet<W> mergingWindows = mergingWindowsByKey.get(getStateBackend().getCurrentKey());\n-\t\t\tif (mergingWindows == null) {\n-\t\t\t\tmergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner);\n-\t\t\t\tmergingWindowsByKey.put(key, mergingWindows);\n-\t\t\t}\n-\n+\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n \n \t\t\tfor (W window: elementWindows) {\n \t\t\t\t// If there is a merge, it can only result in a window that contains our new\n@@ -255,6 +274,7 @@ public void processElement(StreamRecord<IN> element) throws Exception {\n \t\t\t\t\tpublic void merge(W mergeResult,\n \t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n \t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n+\t\t\t\t\t\tcontext.key = key;\n \t\t\t\t\t\tcontext.window = mergeResult;\n \n \t\t\t\t\t\t// store for later use\n@@ -286,7 +306,7 @@ public void merge(W mergeResult,\n \n \t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n \n-\t\t\t\tprocessTriggerResult(combinedTriggerResult, key, actualWindow);\n+\t\t\t\tprocessTriggerResult(combinedTriggerResult, actualWindow);\n \t\t\t}\n \n \t\t} else {\n@@ -301,13 +321,40 @@ public void merge(W mergeResult,\n \t\t\t\tcontext.window = window;\n \t\t\t\tTriggerResult triggerResult = context.onElement(element);\n \n-\t\t\t\tprocessTriggerResult(triggerResult, key, window);\n+\t\t\t\tprocessTriggerResult(triggerResult, window);\n \t\t\t}\n \t\t}\n \t}\n \n+\t/**\n+\t * Retrieves the {@link MergingWindowSet} for the currently active key. The caller must\n+\t * ensure that the correct key is set in the state backend.\n+\t */\n \t@SuppressWarnings(\"unchecked\")\n-\tprotected void processTriggerResult(TriggerResult triggerResult, K key, W window) throws Exception {\n+\tprotected MergingWindowSet<W> getMergingWindowSet() throws Exception {\n+\t\tMergingWindowSet<W> mergingWindows = mergingWindowsByKey.get((K) getStateBackend().getCurrentKey());\n+\t\tif (mergingWindows == null) {\n+\t\t\t// try to retrieve from state\n+\n+\t\t\tTupleSerializer<Tuple2<W, W>> tupleSerializer = new TupleSerializer<>((Class) Tuple2.class, new TypeSerializer[] {windowSerializer, windowSerializer} );\n+\t\t\tListStateDescriptor<Tuple2<W, W>> mergeStateDescriptor = new ListStateDescriptor<>(\"merging-window-set\", tupleSerializer);\n+\t\t\tListState<Tuple2<W, W>> mergeState = getStateBackend().getPartitionedState(null, VoidSerializer.INSTANCE, mergeStateDescriptor);\n+\n+\t\t\tmergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner, mergeState);\n+\t\t\tmergeState.clear();\n+\n+\t\t\tmergingWindowsByKey.put((K) getStateBackend().getCurrentKey(), mergingWindows);\n+\t\t}\n+\t\treturn mergingWindows;\n+\t}\n+\n+\n+\t/**\n+\t * Process {@link TriggerResult} for the currently active key and the given window. The caller\n+\t * must ensure that the correct key is set in the state backend and the context object.\n+\t */\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected void processTriggerResult(TriggerResult triggerResult, W window) throws Exception {\n \t\tif (!triggerResult.isFire() && !triggerResult.isPurge()) {\n \t\t\t// do nothing\n \t\t\treturn;\n@@ -318,7 +365,7 @@ protected void processTriggerResult(TriggerResult triggerResult, K key, W window\n \t\tMergingWindowSet<W> mergingWindows = null;\n \n \t\tif (windowAssigner instanceof MergingWindowAssigner) {\n-\t\t\tmergingWindows = mergingWindowsByKey.get(key);\n+\t\t\tmergingWindows = getMergingWindowSet();\n \t\t\tW stateWindow = mergingWindows.getStateWindow(window);\n \t\t\twindowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n \n@@ -366,7 +413,7 @@ private void processTriggersFor(Watermark mark) throws Exception {\n \t\t\t\tcontext.window = timer.window;\n \t\t\t\tsetKeyContext(timer.key);\n \t\t\t\tTriggerResult triggerResult = context.onEventTime(timer.timestamp);\n-\t\t\t\tprocessTriggerResult(triggerResult, context.key, context.window);\n+\t\t\t\tprocessTriggerResult(triggerResult, context.window);\n \t\t\t} else {\n \t\t\t\tfire = false;\n \t\t\t}\n@@ -389,7 +436,7 @@ public final void trigger(long time) throws Exception {\n \t\t\t\tcontext.window = timer.window;\n \t\t\t\tsetKeyContext(timer.key);\n \t\t\t\tTriggerResult triggerResult = context.onProcessingTime(timer.timestamp);\n-\t\t\t\tprocessTriggerResult(triggerResult, context.key, context.window);\n+\t\t\t\tprocessTriggerResult(triggerResult, context.window);\n \t\t\t} else {\n \t\t\t\tfire = false;\n \t\t\t}\n@@ -604,7 +651,20 @@ public String toString() {\n \t// ------------------------------------------------------------------------\n \n \t@Override\n+\t@SuppressWarnings(\"unchecked\")\n \tpublic StreamTaskState snapshotOperatorState(long checkpointId, long timestamp) throws Exception {\n+\n+\t\tif (mergingWindowsByKey != null) {\n+\t\t\tTupleSerializer<Tuple2<W, W>> tupleSerializer = new TupleSerializer<>((Class) Tuple2.class, new TypeSerializer[] {windowSerializer, windowSerializer} );\n+\t\t\tListStateDescriptor<Tuple2<W, W>> mergeStateDescriptor = new ListStateDescriptor<>(\"merging-window-set\", tupleSerializer);\n+\t\t\tfor (Map.Entry<K, MergingWindowSet<W>> key: mergingWindowsByKey.entrySet()) {\n+\t\t\t\tsetKeyContext(key.getKey());\n+\t\t\t\tListState<Tuple2<W, W>> mergeState = getStateBackend().getPartitionedState(null, VoidSerializer.INSTANCE, mergeStateDescriptor);\n+\t\t\t\tmergeState.clear();\n+\t\t\t\tkey.getValue().persist(mergeState);\n+\t\t\t}\n+\t\t}\n+\n \t\tStreamTaskState taskState = super.snapshotOperatorState(checkpointId, timestamp);\n \n \t\tAbstractStateBackend.CheckpointStateOutputView out =\n",
        "project": "flink",
        "linesAdd": 88,
        "jira_id": "3740",
        "nb_skipped": 1,
        "commit": "f2f5bd5b",
        "nb_failure": 1,
        "linesRem": 23,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 327,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.optimizer.plantranslate.TempInIterationsTest"
        ],
        "patch": "diff --git a/flink-optimizer/src/main/java/org/apache/flink/optimizer/plantranslate/JobGraphGenerator.java b/flink-optimizer/src/main/java/org/apache/flink/optimizer/plantranslate/JobGraphGenerator.java\nindex dc21c13795..26300196f3 100644\n--- a/flink-optimizer/src/main/java/org/apache/flink/optimizer/plantranslate/JobGraphGenerator.java\n+++ b/flink-optimizer/src/main/java/org/apache/flink/optimizer/plantranslate/JobGraphGenerator.java\n@@ -1163,8 +1163,9 @@ private void addLocalInfoFromChannelToConfig(Channel channel, TaskConfig config,\n \t\t\tfinal TempMode tm = channel.getTempMode();\n \n \t\t\tboolean needsMemory = false;\n-\t\t\t// Don't add a pipeline breaker if the data exchange is already blocking.\n-\t\t\tif (tm.breaksPipeline() && channel.getDataExchangeMode() != DataExchangeMode.BATCH) {\n+\t\t\t// Don't add a pipeline breaker if the data exchange is already blocking, EXCEPT the channel is within an iteration.\n+\t\t\tif (tm.breaksPipeline() &&\n+\t\t\t\t\t(channel.isOnDynamicPath() || channel.getDataExchangeMode() != DataExchangeMode.BATCH) ) {\n \t\t\t\tconfig.setInputAsynchronouslyMaterialized(inputNum, true);\n \t\t\t\tneedsMemory = true;\n \t\t\t}\n",
        "project": "flink",
        "linesAdd": 2,
        "jira_id": "1951",
        "nb_skipped": 0,
        "commit": "adb321d6",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 831,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.operators.sort.FixedLengthRecordSorterTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/sort/FixedLengthRecordSorter.java b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/sort/FixedLengthRecordSorter.java\nindex da96b17506..3a44ab5b12 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/sort/FixedLengthRecordSorter.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/sort/FixedLengthRecordSorter.java\n@@ -447,11 +447,13 @@ public void writeToOutput(final ChannelWriterOutputView output, final int start,\n \t\t\t\tnum -= recordsPerSegment;\n \t\t\t} else {\n \t\t\t\t// partially filled segment\n-\t\t\t\tfor (; num > 0; num--) {\n+\t\t\t\tfor (; num > 0 && offset <= this.lastEntryOffset; num--, offset += this.recordSize) {\n \t\t\t\t\trecord = comparator.readWithKeyDenormalization(record, inView);\n \t\t\t\t\tserializer.serialize(record, output);\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\toffset = 0;\n \t\t}\n \t}\n \t\n",
        "project": "flink",
        "linesAdd": 3,
        "jira_id": "2754",
        "nb_skipped": 0,
        "commit": "68912126",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 93,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.compiler.java.IterationCompilerTest"
        ],
        "patch": "diff --git a/flink-compiler/src/main/java/org/apache/flink/compiler/dag/BulkIterationNode.java b/flink-compiler/src/main/java/org/apache/flink/compiler/dag/BulkIterationNode.java\nindex a5f80268d6..d3f0fbb6fd 100644\n--- a/flink-compiler/src/main/java/org/apache/flink/compiler/dag/BulkIterationNode.java\n+++ b/flink-compiler/src/main/java/org/apache/flink/compiler/dag/BulkIterationNode.java\n@@ -132,7 +132,7 @@ public void setNextPartialSolution(OptimizerNode nextPartialSolution, OptimizerN\n \t\t// check if the root of the step function has the same DOP as the iteration\n \t\t// or if the steo function has any operator at all\n \t\tif (nextPartialSolution.getDegreeOfParallelism() != getDegreeOfParallelism() ||\n-\t\t\tnextPartialSolution == partialSolution)\n+\t\t\tnextPartialSolution == partialSolution || nextPartialSolution instanceof BinaryUnionNode)\n \t\t{\n \t\t\t// add a no-op to the root to express the re-partitioning\n \t\t\tNoOpNode noop = new NoOpNode();\ndiff --git a/flink-compiler/src/main/java/org/apache/flink/compiler/dag/WorksetIterationNode.java b/flink-compiler/src/main/java/org/apache/flink/compiler/dag/WorksetIterationNode.java\nindex 7638cca086..b6ae34e850 100644\n--- a/flink-compiler/src/main/java/org/apache/flink/compiler/dag/WorksetIterationNode.java\n+++ b/flink-compiler/src/main/java/org/apache/flink/compiler/dag/WorksetIterationNode.java\n@@ -160,7 +160,7 @@ public void setNextPartialSolution(OptimizerNode solutionSetDelta, OptimizerNode\n \t\t\n \t\t// there needs to be at least one node in the workset path, so\n \t\t// if the next workset is equal to the workset, we need to inject a no-op node\n-\t\tif (nextWorkset == worksetNode) {\n+\t\tif (nextWorkset == worksetNode || nextWorkset instanceof BinaryUnionNode) {\n \t\t\tNoOpNode noop = new NoOpNode();\n \t\t\tnoop.setDegreeOfParallelism(getDegreeOfParallelism());\n \ndiff --git a/flink-compiler/src/main/java/org/apache/flink/compiler/plandump/PlanJSONDumpGenerator.java b/flink-compiler/src/main/java/org/apache/flink/compiler/plandump/PlanJSONDumpGenerator.java\nindex 00e2bc21e9..60500b81f8 100644\n--- a/flink-compiler/src/main/java/org/apache/flink/compiler/plandump/PlanJSONDumpGenerator.java\n+++ b/flink-compiler/src/main/java/org/apache/flink/compiler/plandump/PlanJSONDumpGenerator.java\n@@ -26,7 +25,6 @@\n import java.io.StringWriter;\n import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n@@ -47,7 +45,6 @@\n import org.apache.flink.compiler.dataproperties.LocalProperties;\n import org.apache.flink.compiler.plan.BulkIterationPlanNode;\n import org.apache.flink.compiler.plan.Channel;\n-import org.apache.flink.compiler.plan.NAryUnionPlanNode;\n import org.apache.flink.compiler.plan.OptimizedPlan;\n import org.apache.flink.compiler.plan.PlanNode;\n import org.apache.flink.compiler.plan.SingleInputPlanNode;\n@@ -265,31 +262,16 @@ private boolean visit(DumpableNode<?> node, PrintWriter writer, boolean first) {\n \t\tif (inConns != null && inConns.hasNext()) {\n \t\t\t// start predecessor list\n \t\t\twriter.print(\",\\n\\t\\t\\\"predecessors\\\": [\");\n-\t\t\tint connNum = 0;\n \t\t\tint inputNum = 0;\n \t\t\t\n \t\t\twhile (inConns.hasNext()) {\n-\t\t\t\tfinal DumpableConnection<?> conn = inConns.next();\n-\t\t\t\t\n-\t\t\t\tfinal Collection<DumpableConnection<?>> inConnsForInput;\n-\t\t\t\tif (conn.getSource() instanceof NAryUnionPlanNode) {\n-\t\t\t\t\tinConnsForInput = new ArrayList<DumpableConnection<?>>();\n-\t\t\t\t\t\n-\t\t\t\t\tfor (DumpableConnection<?> inputOfUnion : conn.getSource().getDumpableInputs()) {\n-\t\t\t\t\t\tinConnsForInput.add(inputOfUnion);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tinConnsForInput = Collections.<DumpableConnection<?>>singleton(conn);\n-\t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tfor (DumpableConnection<?> inConn : inConnsForInput) {\n+\t\t\t\tfinal DumpableConnection<?> inConn = inConns.next();\n \t\t\t\tfinal DumpableNode<?> source = inConn.getSource();\n-\t\t\t\t\twriter.print(connNum == 0 ? \"\\n\" : \",\\n\");\n-\t\t\t\t\tif (connNum == 0) {\n+\t\t\t\twriter.print(inputNum == 0 ? \"\\n\" : \",\\n\");\n+\t\t\t\tif (inputNum == 0) {\n \t\t\t\t\tchild1name += child1name.length() > 0 ? \", \" : \"\"; \n \t\t\t\t\tchild1name += source.getOptimizerNode().getPactContract().getName();\n-\t\t\t\t\t} else if (connNum == 1) {\n+\t\t\t\t} else if (inputNum == 1) {\n \t\t\t\t\tchild2name += child2name.length() > 0 ? \", \" : \"\"; \n \t\t\t\t\tchild2name = source.getOptimizerNode().getPactContract().getName();\n \t\t\t\t}\n@@ -331,7 +313,7 @@ private boolean visit(DumpableNode<?> node, PrintWriter writer, boolean first) {\n \t\t\t\t\t\tshipStrategy = \"Rebalance\";\n \t\t\t\t\t\tbreak;\n \t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tthrow new CompilerException(\"Unknown ship strategy '\" + conn.getShipStrategy().name()\n+\t\t\t\t\t\tthrow new CompilerException(\"Unknown ship strategy '\" + inConn.getShipStrategy().name()\n \t\t\t\t\t\t\t+ \"' in JSON generator.\");\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -378,8 +360,6 @@ private boolean visit(DumpableNode<?> node, PrintWriter writer, boolean first) {\n \t\t\t\t}\n \t\t\t\t\n \t\t\t\twriter.print('}');\n-\t\t\t\t\tconnNum++;\n-\t\t\t\t}\n \t\t\t\tinputNum++;\n \t\t\t}\n \t\t\t// finish predecessors\n",
        "project": "flink",
        "linesAdd": 7,
        "jira_id": "1167",
        "nb_skipped": 0,
        "commit": "259f10c0",
        "nb_failure": 2,
        "linesRem": 26,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1802,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.api.common.state.ValueStateDescriptorTest"
        ],
        "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/api/common/state/StateDescriptor.java b/flink-core/src/main/java/org/apache/flink/api/common/state/StateDescriptor.java\nindex 10ac5bae09..243ebcd20b 100644\n--- a/flink-core/src/main/java/org/apache/flink/api/common/state/StateDescriptor.java\n+++ b/flink-core/src/main/java/org/apache/flink/api/common/state/StateDescriptor.java\n@@ -284,12 +284,10 @@ private void readObject(final ObjectInputStream in) throws IOException, ClassNot\n \t\tboolean hasDefaultValue = in.readBoolean();\n \t\tif (hasDefaultValue) {\n \t\t\tint size = in.readInt();\n+\n \t\t\tbyte[] buffer = new byte[size];\n-\t\t\tint bytesRead = in.read(buffer);\n \n-\t\t\tif (bytesRead != size) {\n-\t\t\t\tthrow new RuntimeException(\"Read size does not match expected size.\");\n-\t\t\t}\n+\t\t\tin.readFully(buffer);\n \n \t\t\ttry (ByteArrayInputStream bais = new ByteArrayInputStream(buffer);\n \t\t\t\t\tDataInputViewStreamWrapper inView = new DataInputViewStreamWrapper(bais))\n",
        "project": "flink",
        "linesAdd": 2,
        "jira_id": "3760",
        "nb_skipped": 0,
        "commit": "494212b3",
        "nb_failure": 0,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 744,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "type.extractor.TypeExtractorTest"
        ],
        "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex 99292a6398..124055cc37 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -893,6 +893,10 @@ private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, C\n \t\twhile (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {\n \t\t\ttypeHierarchy.add(curT);\n \t\t\tcurT = typeToClass(curT).getGenericSuperclass();\n+\n+\t\t\tif (curT == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n \t\treturn curT;\n \t}\n@@ -1090,11 +1094,6 @@ private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeV\n \t\t\tParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\n \t\tValidate.notNull(clazz);\n \t\t\n-\t\t// check for abstract classes or interfaces\n-\t\tif (!clazz.isPrimitive() && (Modifier.isInterface(clazz.getModifiers()) || (Modifier.isAbstract(clazz.getModifiers()) && !clazz.isArray()))) {\n-\t\t\tthrow new InvalidTypesException(\"Interfaces and abstract classes are not valid types: \" + clazz);\n-\t\t}\n-\n \t\tif (clazz.equals(Object.class)) {\n \t\t\treturn new GenericTypeInfo<OUT>(clazz);\n \t\t}\n@@ -1153,6 +1152,11 @@ private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeV\n \n \t\talreadySeen.add(clazz);\n \n+\t\tif (Modifier.isInterface(clazz.getModifiers())) {\n+\t\t\t// Interface has no members and is therefore not handled as POJO\n+\t\t\treturn new GenericTypeInfo<OUT>(clazz);\n+\t\t}\n+\n \t\tif (clazz.equals(Class.class)) {\n \t\t\t// special case handling for Class, this should not be handled by the POJO logic\n \t\t\treturn new GenericTypeInfo<OUT>(clazz);\n@@ -1228,10 +1232,10 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\t\treturn true;\n \t\t\t} else {\n \t\t\t\tif(!hasGetter) {\n-\t\t\t\t\tLOG.warn(\"Class \"+clazz+\" does not contain a getter for field \"+f.getName() );\n+\t\t\t\t\tLOG.debug(\"Class \"+clazz+\" does not contain a getter for field \"+f.getName() );\n \t\t\t\t}\n \t\t\t\tif(!hasSetter) {\n-\t\t\t\t\tLOG.warn(\"Class \"+clazz+\" does not contain a setter for field \"+f.getName() );\n+\t\t\t\t\tLOG.debug(\"Class \"+clazz+\" does not contain a setter for field \"+f.getName() );\n \t\t\t\t}\n \t\t\t\treturn false;\n \t\t\t}\n@@ -1251,11 +1255,16 @@ else if(typeHierarchy.size() <= 1) {\n \t\t}\n \t\t\n \t\tList<Field> fields = getAllDeclaredFields(clazz);\n+\t\tif(fields.size() == 0) {\n+\t\t\tLOG.info(\"No fields detected for class \" + clazz + \". Cannot be used as a PojoType. Will be handled as GenericType\");\n+\t\t\treturn new GenericTypeInfo<OUT>(clazz);\n+\t\t}\n+\n \t\tList<PojoField> pojoFields = new ArrayList<PojoField>();\n \t\tfor (Field field : fields) {\n \t\t\tType fieldType = field.getGenericType();\n \t\t\tif(!isValidPojoField(field, clazz, typeHierarchy)) {\n-\t\t\t\tLOG.warn(\"Class \"+clazz+\" is not a valid POJO type\");\n+\t\t\t\tLOG.info(\"Class \" + clazz + \" is not a valid POJO type\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\ttry {\n@@ -1281,7 +1290,7 @@ else if(typeHierarchy.size() <= 1) {\n \t\tList<Method> methods = getAllDeclaredMethods(clazz);\n \t\tfor (Method method : methods) {\n \t\t\tif (method.getName().equals(\"readObject\") || method.getName().equals(\"writeObject\")) {\n-\t\t\t\tLOG.warn(\"Class \"+clazz+\" contains custom serialization methods we do not call.\");\n+\t\t\t\tLOG.info(\"Class \"+clazz+\" contains custom serialization methods we do not call.\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t}\n@@ -1291,9 +1300,14 @@ else if(typeHierarchy.size() <= 1) {\n \t\ttry {\n \t\t\tclazz.getDeclaredConstructor();\n \t\t} catch (NoSuchMethodException e) {\n-\t\t\tLOG.warn(\"Class \" + clazz + \" must have a default constructor to be used as a POJO.\");\n+\t\t\tif (clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers())) {\n+\t\t\t\tLOG.info(\"Class \" + clazz + \" is abstract or an interface, having a concrete \" +\n+\t\t\t\t\t\t\"type can increase performance.\");\n+\t\t\t} else {\n+\t\t\t\tLOG.info(\"Class \" + clazz + \" must have a default constructor to be used as a POJO.\");\n \t\t\t\treturn null;\n \t\t\t}\n+\t\t}\n \t\t\n \t\t// everything is checked, we return the pojo\n \t\treturn pojoType;\n",
        "project": "flink",
        "linesAdd": 23,
        "jira_id": "1458",
        "nb_skipped": 0,
        "commit": "91f9bfc7",
        "nb_failure": 1,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 856,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "typeutils.runtime.PojoSerializerTest"
        ],
        "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java\nindex b81ab67945..c61ad8d157 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java\n@@ -293,7 +293,14 @@ public T copy(T from, T reuse) {\n \t\t\t\tfor (int i = 0; i < numFields; i++) {\n \t\t\t\t\tObject value = fields[i].get(from);\n \t\t\t\t\tif (value != null) {\n-\t\t\t\t\t\tObject copy = fieldSerializers[i].copy(fields[i].get(from), fields[i].get(reuse));\n+\t\t\t\t\t\tObject reuseValue = fields[i].get(reuse);\n+\t\t\t\t\t\tObject copy;\n+\t\t\t\t\t\tif(reuseValue != null) {\n+\t\t\t\t\t\t\tcopy = fieldSerializers[i].copy(value, reuseValue);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\tcopy = fieldSerializers[i].copy(value);\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tfields[i].set(reuse, copy);\n \t\t\t\t\t}\n \t\t\t\t\telse {\n@@ -484,7 +491,15 @@ public T deserialize(T reuse, DataInputView source) throws IOException {\n \t\t\t\t\tif (isNull) {\n \t\t\t\t\t\tfields[i].set(reuse, null);\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tObject field = fieldSerializers[i].deserialize(fields[i].get(reuse), source);\n+\t\t\t\t\t\tObject field;\n+\n+\t\t\t\t\t\tObject reuseField = fields[i].get(reuse);\n+\t\t\t\t\t\tif(reuseField != null) {\n+\t\t\t\t\t\t\tfield = fieldSerializers[i].deserialize(reuseField, source);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\tfield = fieldSerializers[i].deserialize(source);\n+\t\t\t\t\t\t}\n \n \t\t\t\t\t\tfields[i].set(reuse, field);\n \t\t\t\t\t}\n",
        "project": "flink",
        "linesAdd": 17,
        "jira_id": "1978",
        "nb_skipped": 0,
        "commit": "0078c44e",
        "nb_failure": 3,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1100,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "typeutils.runtime.kryo.KryoGenericTypeSerializerTest"
        ],
        "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\nindex f1287faa40..276ffc4073 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\n@@ -323,6 +323,10 @@ private void checkKryoInitialized() {\n \t\tif (this.kryo == null) {\n \t\t\tthis.kryo = getKryoInstance();\n \n+\t\t\t// disable reference tracking. reference tracking is costly, usually unnecessary, and\n+\t\t\t// inconsistent with Flink's own serialization (which does not do reference tracking)\n+\t\t\tkryo.setReferences(false);\n+\t\t\t\n \t\t\t// Throwable and all subclasses should be serialized via java serialization\n \t\t\tkryo.addDefaultSerializer(Throwable.class, new JavaSerializer());\n \n",
        "project": "flink",
        "linesAdd": 2,
        "jira_id": "3267",
        "nb_skipped": 0,
        "commit": "ed3810b1",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 860,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.api.common.io.EnumerateNestedFilesTest"
        ],
        "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/api/common/io/FileInputFormat.java b/flink-core/src/main/java/org/apache/flink/api/common/io/FileInputFormat.java\nindex 37739f547c..a8f334b8d2 100644\n--- a/flink-core/src/main/java/org/apache/flink/api/common/io/FileInputFormat.java\n+++ b/flink-core/src/main/java/org/apache/flink/api/common/io/FileInputFormat.java\n@@ -330,7 +330,7 @@ protected FileBaseStatistics getFileStats(FileBaseStatistics cachedStats, Path f\n \n \t\t// enumerate all files\n \t\tif (file.isDir()) {\n-\t\t\ttotalLength += addFilesInDir(file.getPath(), files, totalLength, false);\n+\t\t\ttotalLength += addFilesInDir(file.getPath(), files, false);\n \t\t} else {\n \t\t\tfiles.add(file);\n \t\t\ttestForUnsplittable(file);\n@@ -390,7 +390,7 @@ public LocatableInputSplitAssigner getInputSplitAssigner(FileInputSplit[] splits\n \t\tfinal FileStatus pathFile = fs.getFileStatus(path);\n \n \t\tif (pathFile.isDir()) {\n-\t\t\ttotalLength += addFilesInDir(path, files, totalLength, true);\n+\t\t\ttotalLength += addFilesInDir(path, files, true);\n \t\t} else {\n \t\t\ttestForUnsplittable(pathFile);\n \n@@ -497,14 +497,16 @@ public LocatableInputSplitAssigner getInputSplitAssigner(FileInputSplit[] splits\n \t * Enumerate all files in the directory and recursive if enumerateNestedFiles is true.\n \t * @return the total length of accepted files.\n \t */\n-\tprivate long addFilesInDir(Path path, List<FileStatus> files, long length, boolean logExcludedFiles)\n+\tprivate long addFilesInDir(Path path, List<FileStatus> files, boolean logExcludedFiles)\n \t\t\tthrows IOException {\n \t\tfinal FileSystem fs = path.getFileSystem();\n \n+\t\tlong length = 0;\n+\n \t\tfor(FileStatus dir: fs.listStatus(path)) {\n \t\t\tif (dir.isDir()) {\n \t\t\t\tif (acceptFile(dir) && enumerateNestedFiles) {\n-\t\t\t\t\tlength += addFilesInDir(dir.getPath(), files, length, logExcludedFiles);\n+\t\t\t\t\tlength += addFilesInDir(dir.getPath(), files, logExcludedFiles);\n \t\t\t\t} else {\n \t\t\t\t\tif (logExcludedFiles && LOG.isDebugEnabled()) {\n \t\t\t\t\t\tLOG.debug(\"Directory \"+dir.getPath().toString()+\" did not pass the file-filter and is excluded.\");\n",
        "project": "flink",
        "linesAdd": 6,
        "jira_id": "2121",
        "nb_skipped": 0,
        "commit": "03340919",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 680,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.taskmanager.TaskTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java\nindex 40198dc94f..625083786d 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java\n@@ -537,7 +537,7 @@ else if (current == ExecutionState.CANCELING) {\n \t\t\t//  actual task core work\n \t\t\t// ----------------------------------------------------------------\n \n-\t\t\t// we must make strictly sure that the invokable is accessible to teh cancel() call\n+\t\t\t// we must make strictly sure that the invokable is accessible to the cancel() call\n \t\t\t// by the time we switched to running.\n \t\t\tthis.invokable = invokable;\n \n@@ -597,24 +597,27 @@ else if (current == ExecutionState.CANCELING) {\n \t\t\t\t// to failExternally()\n \t\t\t\twhile (true) {\n \t\t\t\t\tExecutionState current = this.executionState;\n+\n \t\t\t\t\tif (current == ExecutionState.RUNNING || current == ExecutionState.DEPLOYING) {\n+\t\t\t\t\t\tif (t instanceof CancelTaskException) {\n+\t\t\t\t\t\t\tif (STATE_UPDATER.compareAndSet(this, current, ExecutionState.CANCELED)) {\n+\t\t\t\t\t\t\t\tcancelInvokable();\n+\n+\t\t\t\t\t\t\t\tnotifyObservers(ExecutionState.CANCELED, null);\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n \t\t\t\t\t\t\tif (STATE_UPDATER.compareAndSet(this, current, ExecutionState.FAILED)) {\n \t\t\t\t\t\t\t\t// proper failure of the task. record the exception as the root cause\n \t\t\t\t\t\t\t\tfailureCause = t;\n-\t\t\t\t\t\t\tnotifyObservers(ExecutionState.FAILED, t);\n+\t\t\t\t\t\t\t\tcancelInvokable();\n \n-\t\t\t\t\t\t\t// in case of an exception during execution, we still call \"cancel()\" on the task\n-\t\t\t\t\t\t\tif (invokable != null && this.invokable != null && invokableHasBeenCanceled.compareAndSet(false, true)) {\n-\t\t\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t\t\tinvokable.cancel();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tcatch (Throwable t2) {\n-\t\t\t\t\t\t\t\t\tLOG.error(\"Error while canceling task \" + taskNameWithSubtask, t2);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tnotifyObservers(ExecutionState.FAILED, t);\n \t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t\telse if (current == ExecutionState.CANCELING) {\n \t\t\t\t\t\tif (STATE_UPDATER.compareAndSet(this, current, ExecutionState.CANCELED)) {\n \t\t\t\t\t\t\tnotifyObservers(ExecutionState.CANCELED, null);\n@@ -746,7 +749,7 @@ public void cancelExecution() {\n \t}\n \n \t/**\n-\t * Marks task execution failed for an external reason (a reason other than th task code itself\n+\t * Marks task execution failed for an external reason (a reason other than the task code itself\n \t * throwing an exception). If the task is already in a terminal state\n \t * (such as FINISHED, CANCELED, FAILED), or if the task is already canceling this does nothing.\n \t * Otherwise it sets the state to FAILED, and, if the invokable code is running,\n@@ -962,6 +965,18 @@ private void executeAsyncCallRunnable(Runnable runnable, String callName) {\n \t//  Utilities\n \t// ------------------------------------------------------------------------\n \n+\tprivate void cancelInvokable() {\n+\t\t// in case of an exception during execution, we still call \"cancel()\" on the task\n+\t\tif (invokable != null && this.invokable != null && invokableHasBeenCanceled.compareAndSet(false, true)) {\n+\t\t\ttry {\n+\t\t\t\tinvokable.cancel();\n+\t\t\t}\n+\t\t\tcatch (Throwable t) {\n+\t\t\t\tLOG.error(\"Error while canceling task \" + taskNameWithSubtask, t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \t@Override\n \tpublic String toString() {\n \t\treturn getTaskNameWithSubtasks() + \" [\" + executionState + ']';\n",
        "project": "flink",
        "linesAdd": 24,
        "jira_id": "2109",
        "nb_skipped": 0,
        "commit": "d594d024",
        "nb_failure": 1,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 894,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.executiongraph.ExecutionGraphRestartTest",
            "org.apache.flink.runtime.leaderelection.LeaderChangeStateCleanupTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\nindex aae0b7ce69..1e5d02cb95 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\n@@ -711,6 +711,26 @@ public void cancel() {\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n+\t\t\t// Executions are being canceled. Go into cancelling and wait for\n+\t\t\t// all vertices to be in their final state.\n+\t\t\telse if (current == JobStatus.FAILING) {\n+\t\t\t\tif (transitionState(current, JobStatus.CANCELLING)) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// All vertices have been cancelled and it's safe to directly go\n+\t\t\t// into the canceled state.\n+\t\t\telse if (current == JobStatus.RESTARTING) {\n+\t\t\t\tsynchronized (progressLock) {\n+\t\t\t\t\tif (transitionState(current, JobStatus.CANCELED)) {\n+\t\t\t\t\t\tpostRunCleanup();\n+\t\t\t\t\t\tprogressLock.notifyAll();\n+\n+\t\t\t\t\t\tLOG.info(\"Canceled during restart.\");\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n \t\t\telse {\n \t\t\t\t// no need to treat other states\n \t\t\t\treturn;\n@@ -747,9 +767,16 @@ else if (transitionState(current, JobStatus.FAILING, t)) {\n \tpublic void restart() {\n \t\ttry {\n \t\t\tsynchronized (progressLock) {\n-\t\t\t\tif (state != JobStatus.RESTARTING) {\n+\t\t\t\tJobStatus current = state;\n+\n+\t\t\t\tif (current == JobStatus.CANCELED) {\n+\t\t\t\t\tLOG.info(\"Canceled job during restart. Aborting restart.\");\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\telse if (current != JobStatus.RESTARTING) {\n \t\t\t\t\tthrow new IllegalStateException(\"Can only restart job from state restarting.\");\n \t\t\t\t}\n+\n \t\t\t\tif (scheduler == null) {\n \t\t\t\t\tthrow new IllegalStateException(\"The execution graph has not been scheduled before - scheduler is null.\");\n \t\t\t\t}\n",
        "project": "flink",
        "linesAdd": 24,
        "jira_id": "3011",
        "nb_skipped": 1,
        "commit": "5a86a0a1",
        "nb_failure": 3,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 0,
        "nb_test": 125,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.stormcompatibility.api.FlinkTopologyBuilderTest"
        ],
        "patch": "",
        "project": "flink",
        "linesAdd": 0,
        "jira_id": "2658",
        "nb_skipped": 0,
        "commit": "ce68cbd9",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 45,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.client.CliFrontendInfoTest"
        ],
        "patch": "diff --git a/flink-clients/src/main/java/org/apache/flink/client/cli/CliFrontendParser.java b/flink-clients/src/main/java/org/apache/flink/client/cli/CliFrontendParser.java\nindex 4e081fdb9b..07d409e3ed 100644\n--- a/flink-clients/src/main/java/org/apache/flink/client/cli/CliFrontendParser.java\n+++ b/flink-clients/src/main/java/org/apache/flink/client/cli/CliFrontendParser.java\n@@ -339,7 +339,7 @@ public static SavepointOptions parseSavepointCommand(String[] args) throws CliAr\n \tpublic static InfoOptions parseInfoCommand(String[] args) throws CliArgsException {\n \t\ttry {\n \t\t\tPosixParser parser = new PosixParser();\n-\t\t\tCommandLine line = parser.parse(INFO_OPTIONS, args, false);\n+\t\t\tCommandLine line = parser.parse(INFO_OPTIONS, args, true);\n \t\t\treturn new InfoOptions(line);\n \t\t}\n \t\tcatch (ParseException e) {\n",
        "project": "flink",
        "linesAdd": 1,
        "jira_id": "3189",
        "nb_skipped": 0,
        "commit": "a5b05566",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 892,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.executiongraph.ExecutionGraphRestartTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\nindex 9430d802d4..aae0b7ce69 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\n@@ -746,12 +746,6 @@ else if (transitionState(current, JobStatus.FAILING, t)) {\n \n \tpublic void restart() {\n \t\ttry {\n-\t\t\tif (state == JobStatus.FAILED) {\n-\t\t\t\tif (!transitionState(JobStatus.FAILED, JobStatus.RESTARTING)) {\n-\t\t\t\t\tthrow new IllegalStateException(\"Execution Graph left the state FAILED while trying to restart.\");\n-\t\t\t\t}\n-\t\t\t}\n-\n \t\t\tsynchronized (progressLock) {\n \t\t\t\tif (state != JobStatus.RESTARTING) {\n \t\t\t\t\tthrow new IllegalStateException(\"Can only restart job from state restarting.\");\n",
        "project": "flink",
        "linesAdd": 0,
        "jira_id": "3011",
        "nb_skipped": 1,
        "commit": "a402002d",
        "nb_failure": 0,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 745,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "type.extractor.TypeExtractorTest"
        ],
        "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex 124055cc37..c99a80f248 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -680,10 +680,20 @@ private static void validateInputType(Type t, TypeInformation<?> inType) {\n \t\t}\n \t}\n \t\n-\tprivate static void validateInputType(Class<?> baseClass, Class<?> clazz, int inputParamPos, TypeInformation<?> inType) {\n+\tprivate static void validateInputType(Class<?> baseClass, Class<?> clazz, int inputParamPos, TypeInformation<?> inTypeInfo) {\n \t\tArrayList<Type> typeHierarchy = new ArrayList<Type>();\n+\n+\t\t// try to get generic parameter\n+\t\tType inType;\n+\t\ttry {\n+\t\t\tinType = getParameterType(baseClass, typeHierarchy, clazz, inputParamPos);\n+\t\t}\n+\t\tcatch (IllegalArgumentException e) {\n+\t\t\treturn; // skip input validation e.g. for raw types\n+\t\t}\n+\n \t\ttry {\n-\t\t\tvalidateInfo(typeHierarchy, getParameterType(baseClass, typeHierarchy, clazz, inputParamPos), inType);\n+\t\t\tvalidateInfo(typeHierarchy, inType, inTypeInfo);\n \t\t}\n \t\tcatch(InvalidTypesException e) {\n \t\t\tthrow new InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n",
        "project": "flink",
        "linesAdd": 11,
        "jira_id": "1471",
        "nb_skipped": 0,
        "commit": "d033fa8f",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 242,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.streaming.api.state.StatefulOperatorTest"
        ],
        "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/PartitionedStreamOperatorState.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/PartitionedStreamOperatorState.java\nindex 115a97c71f..408a0f0323 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/PartitionedStreamOperatorState.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/PartitionedStreamOperatorState.java\n@@ -55,6 +55,8 @@\n \tprivate IN currentInput;\n \n \tprivate ClassLoader cl;\n+\tprivate boolean restored = true;\n+\tprivate StateHandle<Serializable> checkpoint = null;\n \n \tpublic PartitionedStreamOperatorState(StateCheckpointer<S, C> checkpointer,\n \t\t\tStateHandleProvider<C> provider, KeySelector<IN, Serializable> keySelector, ClassLoader cl) {\n@@ -76,6 +78,10 @@ public S value() throws IOException {\n \t\tif (currentInput == null) {\n \t\t\tthrow new IllegalStateException(\"Need a valid input for accessing the state.\");\n \t\t} else {\n+\t\t\tif (!restored) {\n+\t\t\t\t// If the state is not restored yet, restore now\n+\t\t\t\trestoreWithCheckpointer();\n+\t\t\t}\n \t\t\tSerializable key;\n \t\t\ttry {\n \t\t\t\tkey = keySelector.getKey(currentInput);\n@@ -100,6 +106,10 @@ public void update(S state) throws IOException {\n \t\tif (currentInput == null) {\n \t\t\tthrow new IllegalStateException(\"Need a valid input for updating a state.\");\n \t\t} else {\n+\t\t\tif (!restored) {\n+\t\t\t\t// If the state is not restored yet, restore now\n+\t\t\t\trestoreWithCheckpointer();\n+\t\t\t}\n \t\t\tSerializable key;\n \t\t\ttry {\n \t\t\t\tkey = keySelector.getKey(currentInput);\n@@ -131,12 +141,26 @@ public void setCurrentInput(IN input) {\n \n \t@Override\n \tpublic StateHandle<Serializable> snapshotState(long checkpointId, long checkpointTimestamp) throws Exception {\n-\t\treturn stateStore.snapshotStates(checkpointId, checkpointTimestamp);\n+\t\t// If the state is restored we take a snapshot, otherwise return the last checkpoint\n+\t\treturn restored ? stateStore.snapshotStates(checkpointId, checkpointTimestamp) : provider\n+\t\t\t\t.createStateHandle(checkpoint.getState(cl));\n \t}\n \t\n \t@Override\n-\tpublic void restoreState(StateHandle<Serializable> snapshots, ClassLoader userCodeClassLoader) throws Exception {\n-\t\tstateStore.restoreStates(snapshots, userCodeClassLoader);\n+\tpublic void restoreState(StateHandle<Serializable> snapshot, ClassLoader userCodeClassLoader) throws Exception {\n+\t\t// We store the snapshot for lazy restore\n+\t\tcheckpoint = snapshot;\n+\t\trestored = false;\n+\t}\n+\t\n+\tprivate void restoreWithCheckpointer() throws IOException {\n+\t\ttry {\n+\t\t\tstateStore.restoreStates(checkpoint, cl);\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new IOException(e);\n+\t\t}\n+\t\trestored = true;\n+\t\tcheckpoint = null;\n \t}\n \n \t@Override\n@@ -144,6 +168,12 @@ public void restoreState(StateHandle<Serializable> snapshots, ClassLoader userCo\n \t\treturn stateStore.getPartitionedState();\n \t}\n \t\n+\t@Override\n+\tpublic void setCheckpointer(StateCheckpointer<S, C> checkpointer) {\n+\t\tsuper.setCheckpointer(checkpointer);\n+\t\tstateStore.setCheckPointer(checkpointer);\n+\t}\n+\n \t@Override\n \tpublic String toString() {\n \t\treturn stateStore.toString();\ndiff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/StreamOperatorState.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/StreamOperatorState.java\nindex 29a19b58ec..c33b94ea26 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/StreamOperatorState.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/state/StreamOperatorState.java\n@@ -44,7 +44,10 @@\n \n \tprivate S state;\n \tprotected StateCheckpointer<S, C> checkpointer;\n-\tprivate final StateHandleProvider<Serializable> provider;\n+\tprotected final StateHandleProvider<Serializable> provider;\n+\t\n+\tprivate boolean restored = true;\n+\tprivate Serializable checkpoint = null;\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic StreamOperatorState(StateCheckpointer<S, C> checkpointer, StateHandleProvider<C> provider) {\n@@ -59,6 +62,10 @@ public StreamOperatorState(StateHandleProvider<C> provider) {\n \n \t@Override\n \tpublic S value() throws IOException {\n+\t\tif (!restored) {\n+\t\t\t// If the state is not restore it yet, restore at this point\n+\t\t\trestoreWithCheckpointer();\n+\t\t}\n \t\treturn state;\n \t}\n \n@@ -67,6 +74,11 @@ public void update(S state) throws IOException {\n \t\tif (state == null) {\n \t\t\tthrow new RuntimeException(\"Cannot set state to null.\");\n \t\t}\n+\t\tif (!restored) {\n+\t\t\t// If the value is updated before the restore it is overwritten\n+\t\t\trestored = true;\n+\t\t\tcheckpoint = false;\n+\t\t}\n \t\tthis.state = state;\n \t}\n \t\n@@ -90,14 +102,22 @@ public void setCheckpointer(StateCheckpointer<S, C> checkpointer) {\n \n \tpublic StateHandle<Serializable> snapshotState(long checkpointId, long checkpointTimestamp)\n \t\t\tthrows Exception {\n-\t\treturn provider.createStateHandle(checkpointer.snapshotState(value(), checkpointId,\n-\t\t\t\tcheckpointTimestamp));\n+\t\t// If the state is restored we take a snapshot, otherwise return the last checkpoint\n+\t\treturn provider.createStateHandle(restored ? checkpointer.snapshotState(value(), checkpointId,\n+\t\t\t\tcheckpointTimestamp) : checkpoint);\n+\t}\n \n+\tpublic void restoreState(StateHandle<Serializable> snapshot, ClassLoader userCodeClassLoader) throws Exception {\n+\t\t// We set the checkpoint for lazy restore\n+\t\tcheckpoint = snapshot.getState(userCodeClassLoader);\n+\t\trestored = false;\n \t}\n \t\n \t@SuppressWarnings(\"unchecked\")\n-\tpublic void restoreState(StateHandle<Serializable> snapshot, ClassLoader userCodeClassLoader) throws Exception {\n-\t\tupdate(checkpointer.restoreState((C) snapshot.getState(userCodeClassLoader)));\n+\tprivate void restoreWithCheckpointer() throws IOException {\n+\t\tupdate(checkpointer.restoreState((C) checkpoint));\n+\t\trestored = true;\n+\t\tcheckpoint = null;\n \t}\n \n \tpublic Map<Serializable, S> getPartitionedState() throws Exception {\n",
        "project": "flink",
        "linesAdd": 50,
        "jira_id": "2713",
        "nb_skipped": 1,
        "commit": "63d9800e",
        "nb_failure": 0,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 962,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.executiongraph.ExecutionGraphRestartTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\nindex eb2e68c8eb..db037bb30b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n@@ -435,7 +435,7 @@ else if (current == FINISHED || current == FAILED) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\telse if (current == CREATED || current == SCHEDULED) {\n-\t\t\t\t// from here, we can directly switch to cancelled, because the no task has been deployed\n+\t\t\t\t// from here, we can directly switch to cancelled, because no task has been deployed\n \t\t\t\tif (transitionState(current, CANCELED)) {\n \t\t\t\t\t\n \t\t\t\t\t// we skip the canceling state. set the timestamp, for a consistent appearance\n@@ -754,11 +754,10 @@ private boolean processFail(Throwable t, boolean isCallback) {\n \t\t\t\treturn false;\n \t\t\t}\n \n-\t\t\tif (current == CANCELED) {\n-\t\t\t\t// we are already aborting or are already aborted\n+\t\t\tif (current == CANCELED || current == FINISHED) {\n+\t\t\t\t// we are already aborting or are already aborted or we are already finished\n \t\t\t\tif (LOG.isDebugEnabled()) {\n-\t\t\t\t\tLOG.debug(String.format(\"Ignoring transition of vertex %s to %s while being %s\", \n-\t\t\t\t\t\t\tgetVertexWithAttempt(), FAILED, CANCELED));\n+\t\t\t\t\tLOG.debug(\"Ignoring transition of vertex {} to {} while being {}.\", getVertexWithAttempt(), FAILED, current);\n \t\t\t\t}\n \t\t\t\treturn false;\n \t\t\t}\n@@ -928,6 +927,11 @@ private boolean transitionState(ExecutionState currentState, ExecutionState targ\n \t}\n \n \tprivate boolean transitionState(ExecutionState currentState, ExecutionState targetState, Throwable error) {\n+\t\t// sanity check\n+\t\tif (currentState.isTerminal()) {\n+\t\t\tthrow new IllegalStateException(\"Cannot leave terminal state \" + currentState + \" to transition to \" + targetState + \".\");\n+\t\t}\n+\n \t\tif (STATE_UPDATER.compareAndSet(this, currentState, targetState)) {\n \t\t\tmarkTimestamp(targetState);\n \n",
        "project": "flink",
        "linesAdd": 6,
        "jira_id": "3260",
        "nb_skipped": 1,
        "commit": "6968a57a",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 243,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.streaming.runtime.tasks.StreamTaskTest"
        ],
        "patch": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\nindex 9ab6c10660..c9624fca22 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\n@@ -147,6 +147,9 @@\n \t * needs to be initialized to true, so that early cancel() before invoke() behaves correctly */\n \tprivate volatile boolean isRunning;\n \t\n+\t/** Flag to mark this task as canceled */\n+\tprivate volatile boolean canceled;\n+\n \tprivate long recoveryTimestamp;\n \n \t// ------------------------------------------------------------------------\n@@ -191,6 +194,11 @@ public final void invoke() throws Exception {\n \t\t\t// task specific initialization\n \t\t\tinit();\n \t\t\t\n+\t\t\t// save the work of reloadig state, etc, if the task is already canceled\n+\t\t\tif (canceled) {\n+\t\t\t\tthrow new CancelTaskException();\n+\t\t\t}\n+\t\t\t\n \t\t\t// -------- Invoke --------\n \t\t\tLOG.debug(\"Invoking {}\", getName());\n \t\t\t\n@@ -205,6 +213,11 @@ public final void invoke() throws Exception {\n \t\t\t\topenAllOperators();\n \t\t\t}\n \n+\t\t\t// final check to exit early before starting to run\n+\t\t\tif (canceled) {\n+\t\t\t\tthrow new CancelTaskException();\n+\t\t\t}\n+\n \t\t\t\t// let the task do its work\n \t\t\tisRunning = true;\n \t\t\trun();\n@@ -290,6 +303,7 @@ public final void invoke() throws Exception {\n \t@Override\n \tpublic final void cancel() throws Exception {\n \t\tisRunning = false;\n+\t\tcanceled = true;\n \t\tcancelTask();\n \t}\n \n@@ -297,6 +311,10 @@ public final boolean isRunning() {\n \t\treturn isRunning;\n \t}\n \t\n+\tpublic final boolean isCanceled() {\n+\t\treturn canceled;\n+\t}\n+\t\n \tprivate void openAllOperators() throws Exception {\n \t\tfor (StreamOperator<?> operator : operatorChain.getAllOperators()) {\n \t\t\tif (operator != null) {\n",
        "project": "flink",
        "linesAdd": 15,
        "jira_id": "3314",
        "nb_skipped": 5,
        "commit": "8fc7e7af",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 586,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.io.network.netty.PartitionRequestClientHandlerTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientHandler.java\nindex fef21ce34e..12ed14026c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientHandler.java\n@@ -133,9 +133,12 @@ private void notifyAllChannelsOfErrorAndClose(Throwable cause) {\n \t\t\t}\n \n \t\t\tinputChannels.clear();\n+\n+\t\t\tif (ctx != null) {\n \t\t\t\tctx.close();\n \t\t\t}\n \t\t}\n+\t}\n \n \t// ------------------------------------------------------------------------\n \n@@ -187,6 +190,13 @@ private boolean decodeBufferOrEvent(RemoteInputChannel inputChannel, NettyMessag\n \t\ttry {\n \t\t\tif (bufferOrEvent.isBuffer()) {\n \t\t\t\t// ---- Buffer ------------------------------------------------\n+\n+\t\t\t\t// Early return for empty buffers. Otherwise Netty's readBytes() throws an\n+\t\t\t\t// IndexOutOfBoundsException.\n+\t\t\t\tif (bufferOrEvent.getSize() == 0) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\n \t\t\t\tBufferProvider bufferProvider = inputChannel.getBufferProvider();\n \n \t\t\t\tif (bufferProvider == null) {\n",
        "project": "flink",
        "linesAdd": 8,
        "jira_id": "1761",
        "nb_skipped": 0,
        "commit": "380ef878",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 455,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "type.extractor.TypeExtractorTest"
        ],
        "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex d8e1aedfdf..d5f3619d84 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -201,7 +201,7 @@ private TypeExtractor() {\n \t\t\n \t\t// return type is a variable -> try to get the type info from the input directly\n \t\tif (returnType instanceof TypeVariable<?>) {\n-\t\t\ttypeInfo = (TypeInformation<OUT>) createTypeInfoFromInput((TypeVariable<?>) returnType, typeHierarchy, in1Type, in2Type);\n+\t\t\ttypeInfo = (TypeInformation<OUT>) createTypeInfoFromInputs((TypeVariable<?>) returnType, typeHierarchy, in1Type, in2Type);\n \t\t\t\n \t\t\tif (typeInfo != null) {\n \t\t\t\treturn typeInfo;\n@@ -280,7 +280,7 @@ private TypeExtractor() {\n \t\t\t\t// sub type could not be determined with materializing\n \t\t\t\t// try to derive the type info of the TypeVariable from the immediate base child input as a last attempt\n \t\t\t\tif (subtypes[i] instanceof TypeVariable<?>) {\n-\t\t\t\t\ttupleSubTypes[i] = createTypeInfoFromInput((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);\n+\t\t\t\t\ttupleSubTypes[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);\n \t\t\t\t\t\n \t\t\t\t\t// variable could not be determined\n \t\t\t\t\tif (tupleSubTypes[i] == null) {\n@@ -315,7 +315,7 @@ else if (t instanceof TypeVariable) {\n \t\t\t}\n \t\t\t// try to derive the type info of the TypeVariable from the immediate base child input as a last attempt\n \t\t\telse {\n-\t\t\t\tTypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInput((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);\n+\t\t\t\tTypeInformation<OUT> typeInfo = (TypeInformation<OUT>) createTypeInfoFromInputs((TypeVariable<?>) t, typeHierarchy, in1Type, in2Type);\n \t\t\t\tif (typeInfo != null) {\n \t\t\t\t\treturn typeInfo;\n \t\t\t\t} else {\n@@ -371,7 +371,7 @@ else if (t instanceof Class) {\n \t\tthrow new InvalidTypesException(\"Type Information could not be created.\");\n \t}\n \t\n-\tprivate <IN1, IN2> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> returnTypeHierarchy, \n+\tprivate <IN1, IN2> TypeInformation<?> createTypeInfoFromInputs(TypeVariable<?> returnTypeVar, ArrayList<Type> returnTypeHierarchy, \n \t\t\tTypeInformation<IN1> in1TypeInfo, TypeInformation<IN2> in2TypeInfo) {\n \n \t\tType matReturnTypeVar = materializeTypeVariable(returnTypeHierarchy, returnTypeVar);\n@@ -389,20 +389,16 @@ else if (t instanceof Class) {\n \t\t\t// find the deepest type variable that describes the type of input 1\n \t\t\tParameterizedType baseClass = (ParameterizedType) returnTypeHierarchy.get(returnTypeHierarchy.size() - 1);\n \t\t\tType in1Type = baseClass.getActualTypeArguments()[0];\n-\t\t\tif (in1Type instanceof TypeVariable) {\n-\t\t\t\tin1Type = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) in1Type);\n-\t\t\t\tinfo = findCorrespondingInfo(returnTypeVar, in1Type, in1TypeInfo);\n-\t\t\t}\n+\n+\t\t\tinfo = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in1Type, in1TypeInfo);\n \t\t}\n \n \t\tif (info == null && in2TypeInfo != null) {\n \t\t\t// find the deepest type variable that describes the type of input 2\n \t\t\tParameterizedType baseClass = (ParameterizedType) returnTypeHierarchy.get(returnTypeHierarchy.size() - 1);\n \t\t\tType in2Type = baseClass.getActualTypeArguments()[1];\n-\t\t\tif (in2Type instanceof TypeVariable) {\n-\t\t\t\tin2Type = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) in2Type);\n-\t\t\t\tinfo = findCorrespondingInfo(returnTypeVar, in2Type, in2TypeInfo);\n-\t\t\t}\n+\n+\t\t\tinfo = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in2Type, in2TypeInfo);\n \t\t}\n \n \t\tif (info != null) {\n@@ -412,6 +408,31 @@ else if (t instanceof Class) {\n \t\treturn null;\n \t}\n \t\n+\tprivate <IN1> TypeInformation<?> createTypeInfoFromInput(TypeVariable<?> returnTypeVar, ArrayList<Type> returnTypeHierarchy, \n+\t\t\tType inType, TypeInformation<IN1> inTypeInfo) {\n+\t\tTypeInformation<?> info = null;\n+\t\t// the input is a type variable\n+\t\tif (inType instanceof TypeVariable) {\n+\t\t\tinType = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) inType);\n+\t\t\tinfo = findCorrespondingInfo(returnTypeVar, inType, inTypeInfo);\n+\t\t}\n+\t\t// the input is a tuple that may contains type variables\n+\t\telse if (inType instanceof ParameterizedType && Tuple.class.isAssignableFrom(((Class<?>)((ParameterizedType) inType).getRawType()))) {\n+\t\t\tType[] tupleElements = ((ParameterizedType) inType).getActualTypeArguments();\n+\t\t\t// go thru all tuple elements and search for type variables\n+\t\t\tfor(int i = 0; i < tupleElements.length; i++) {\n+\t\t\t\tif(tupleElements[i] instanceof TypeVariable) {\n+\t\t\t\t\tinType = materializeTypeVariable(returnTypeHierarchy, (TypeVariable<?>) tupleElements[i]);\n+\t\t\t\t\tinfo = findCorrespondingInfo(returnTypeVar, inType, ((TupleTypeInfo<?>) inTypeInfo).getTypeAt(i));\n+\t\t\t\t\tif(info != null) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn info;\n+\t}\n+\t\n \t// --------------------------------------------------------------------------------------------\n \t//  Extract type parameters\n \t// --------------------------------------------------------------------------------------------\n",
        "project": "flink",
        "linesAdd": 30,
        "jira_id": "1133",
        "nb_skipped": 1,
        "commit": "27e40205",
        "nb_failure": 0,
        "linesRem": 12,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 163,
        "nb_error": 1,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.flink.streaming.api.state.StatefulOperatorTest"
        ],
        "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OutputHandler.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OutputHandler.java\nindex 2d2f29bf56..73f0a897a9 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OutputHandler.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OutputHandler.java\n@@ -274,6 +274,7 @@ public CopyingOperatorCollector(OneInputStreamOperator operator, TypeSerializer<\n \t\t@Override\n \t\tpublic void collect(T record) {\n \t\t\ttry {\n+\t\t\t\toperator.getRuntimeContext().setNextInput(record);\n \t\t\t\toperator.processElement(serializer.copy(record));\n \t\t\t} catch (Exception e) {\n \t\t\t\tif (LOG.isErrorEnabled()) {\n",
        "project": "flink",
        "linesAdd": 1,
        "jira_id": "2294",
        "nb_skipped": 1,
        "commit": "fef9f115",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 3,
        "nb_test": 275,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.streaming.util.keys.ArrayKeySelectorTest"
        ],
        "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/datastream/KeyedDataStream.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/datastream/KeyedDataStream.java\nindex 7628815150..100e5de264 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/datastream/KeyedDataStream.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/datastream/KeyedDataStream.java\n@@ -35,7 +35,8 @@\n  * @param <T> The type of the elements in the Keyed Stream\n  */\n public class KeyedDataStream<T> extends DataStream<T> {\n-\tKeySelector<T, ?> keySelector;\n+\t\n+\tprotected final KeySelector<T, ?> keySelector;\n \n \t/**\n \t * Creates a new {@link KeyedDataStream} using the given {@link KeySelector}\ndiff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java\nindex c50f23e917..d91afc9add 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java\n@@ -1228,8 +1228,7 @@ public static LocalStreamEnvironment createLocalEnvironment(int parallelism, Con\n \t */\n \tpublic static StreamExecutionEnvironment createRemoteEnvironment(String host, int port,\n \t\t\tString... jarFiles) {\n-\t\tRemoteStreamEnvironment env = new RemoteStreamEnvironment(host, port, jarFiles);\n-\t\treturn env;\n+\t\treturn new RemoteStreamEnvironment(host, port, jarFiles);\n \t}\n \n \t/**\n@@ -1298,8 +1297,7 @@ public StreamGraph getStreamGraph() {\n \t\tif (transformations.size() <= 0) {\n \t\t\tthrow new IllegalStateException(\"No operators defined in streaming topology. Cannot execute.\");\n \t\t}\n-\t\tStreamGraph result = StreamGraphGenerator.generate(this, transformations);\n-\t\treturn result;\n+\t\treturn StreamGraphGenerator.generate(this, transformations);\n \t}\n \n \t/**\ndiff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/util/keys/KeySelectorUtil.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/util/keys/KeySelectorUtil.java\nindex 89c6142232..cd325484ae 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/util/keys/KeySelectorUtil.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/util/keys/KeySelectorUtil.java\n@@ -27,41 +27,9 @@\n import org.apache.flink.api.java.functions.KeySelector;\n import org.apache.flink.api.java.operators.Keys;\n import org.apache.flink.api.java.tuple.Tuple;\n-import org.apache.flink.api.java.tuple.Tuple1;\n-import org.apache.flink.api.java.tuple.Tuple10;\n-import org.apache.flink.api.java.tuple.Tuple11;\n-import org.apache.flink.api.java.tuple.Tuple12;\n-import org.apache.flink.api.java.tuple.Tuple13;\n-import org.apache.flink.api.java.tuple.Tuple14;\n-import org.apache.flink.api.java.tuple.Tuple15;\n-import org.apache.flink.api.java.tuple.Tuple16;\n-import org.apache.flink.api.java.tuple.Tuple17;\n-import org.apache.flink.api.java.tuple.Tuple18;\n-import org.apache.flink.api.java.tuple.Tuple19;\n-import org.apache.flink.api.java.tuple.Tuple2;\n-import org.apache.flink.api.java.tuple.Tuple20;\n-import org.apache.flink.api.java.tuple.Tuple21;\n-import org.apache.flink.api.java.tuple.Tuple22;\n-import org.apache.flink.api.java.tuple.Tuple23;\n-import org.apache.flink.api.java.tuple.Tuple24;\n-import org.apache.flink.api.java.tuple.Tuple25;\n-import org.apache.flink.api.java.tuple.Tuple3;\n-import org.apache.flink.api.java.tuple.Tuple4;\n-import org.apache.flink.api.java.tuple.Tuple5;\n-import org.apache.flink.api.java.tuple.Tuple6;\n-import org.apache.flink.api.java.tuple.Tuple7;\n-import org.apache.flink.api.java.tuple.Tuple8;\n-import org.apache.flink.api.java.tuple.Tuple9;\n \n public class KeySelectorUtil {\n \n-\tpublic static Class<?>[] tupleClasses = new Class[] { Tuple1.class, Tuple2.class, Tuple3.class,\n-\t\t\tTuple4.class, Tuple5.class, Tuple6.class, Tuple7.class, Tuple8.class, Tuple9.class,\n-\t\t\tTuple10.class, Tuple11.class, Tuple12.class, Tuple13.class, Tuple14.class,\n-\t\t\tTuple15.class, Tuple16.class, Tuple17.class, Tuple18.class, Tuple19.class,\n-\t\t\tTuple20.class, Tuple21.class, Tuple22.class, Tuple23.class, Tuple24.class,\n-\t\t\tTuple25.class };\n-\n \tpublic static <X> KeySelector<X, ?> getSelectorForKeys(Keys<X> keys, TypeInformation<X> typeInfo, ExecutionConfig executionConfig) {\n \t\tint[] logicalKeyPositions = keys.computeLogicalKeyPositions();\n \t\tint keyLength = logicalKeyPositions.length;\n@@ -129,7 +97,7 @@ public ComparableKeySelector(TypeComparator<IN> comparator, int keyLength) {\n \n \t\t@Override\n \t\tpublic Tuple getKey(IN value) throws Exception {\n-\t\t\tkey = (Tuple) tupleClasses[keyLength - 1].newInstance();\n+\t\t\tkey = Tuple.getTupleClass(keyLength).newInstance();\n \t\t\tcomparator.extractKeys(value, keyArray, 0);\n \t\t\tfor (int i = 0; i < keyLength; i++) {\n \t\t\t\tkey.setField(keyArray[i], i);\n@@ -139,12 +107,11 @@ public Tuple getKey(IN value) throws Exception {\n \n \t}\n \n-\tpublic static class ArrayKeySelector<IN> implements KeySelector<IN, Tuple> {\n+\tpublic static final class ArrayKeySelector<IN> implements KeySelector<IN, Tuple> {\n \n \t\tprivate static final long serialVersionUID = 1L;\n \t\t\n-\t\tTuple key;\n-\t\tint[] fields;\n+\t\tprivate final int[] fields;\n \n \t\tpublic ArrayKeySelector(int... fields) {\n \t\t\tthis.fields = fields;\n@@ -152,10 +119,9 @@ public ArrayKeySelector(int... fields) {\n \n \t\t@Override\n \t\tpublic Tuple getKey(IN value) throws Exception {\n-\t\t\tkey = (Tuple) tupleClasses[fields.length - 1].newInstance();\n+\t\t\tTuple key = Tuple.getTupleClass(fields.length).newInstance();\n \t\t\tfor (int i = 0; i < fields.length; i++) {\n-\t\t\t\tint pos = fields[i];\n-\t\t\t\tkey.setField(Array.get(value, fields[pos]), i);\n+\t\t\t\tkey.setField(Array.get(value, fields[i]), i);\n \t\t\t}\n \t\t\treturn key;\n \t\t}\n",
        "project": "flink",
        "linesAdd": 9,
        "jira_id": "2734",
        "nb_skipped": 1,
        "commit": "8b40bb7a",
        "nb_failure": 2,
        "linesRem": 44,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 943,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.executiongraph.ExecutionGraphRestartTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\nindex 90854836b9..a03f0bf7a1 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\n@@ -51,6 +51,7 @@\n import org.apache.flink.runtime.jobgraph.JobVertexID;\n import org.apache.flink.runtime.jobgraph.ScheduleMode;\n import org.apache.flink.runtime.jobmanager.RecoveryMode;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroup;\n import org.apache.flink.runtime.jobmanager.scheduler.Scheduler;\n import org.apache.flink.runtime.messages.ExecutionGraphMessages;\n import org.apache.flink.runtime.taskmanager.TaskExecutionState;\n@@ -76,6 +77,8 @@\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.Collection;\n+import java.util.HashSet;\n import java.util.NoSuchElementException;\n import java.util.UUID;\n import java.util.concurrent.Callable;\n@@ -849,7 +852,16 @@ else if (current != JobStatus.RESTARTING) {\n \n \t\t\t\tthis.currentExecutions.clear();\n \n+\t\t\t\tCollection<CoLocationGroup> colGroups = new HashSet<>();\n+\t\t\t\t\n \t\t\t\tfor (ExecutionJobVertex jv : this.verticesInCreationOrder) {\n+\t\t\t\t\t\n+\t\t\t\t\tCoLocationGroup cgroup = jv.getCoLocationGroup();\n+\t\t\t\t\tif(cgroup != null && !colGroups.contains(cgroup)){\n+\t\t\t\t\t\tcgroup.resetConstraints();\n+\t\t\t\t\t\tcolGroups.add(cgroup);\n+\t\t\t\t\t}\n+\t\t\t\t\t\n \t\t\t\t\tjv.resetForNewExecution();\n \t\t\t\t}\n \ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java\nindex 93ae7c1ded..bc368abdaa 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java\n@@ -362,9 +362,6 @@ public void resetForNewExecution() {\n \t\t\tif (slotSharingGroup != null) {\n \t\t\t\tslotSharingGroup.clearTaskAssignment();\n \t\t\t}\n-\t\t\tif (coLocationGroup != null) {\n-\t\t\t\tcoLocationGroup.resetConstraints();\n-\t\t\t}\n \t\t\t\n \t\t\t// reset vertices one by one. if one reset fails, the \"vertices in final state\"\n \t\t\t// fields will be consistent to handle triggered cancel calls\n",
        "project": "flink",
        "linesAdd": 12,
        "jira_id": "3256",
        "nb_skipped": 1,
        "commit": "44061882",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 859,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.core.fs.PathTest"
        ],
        "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/core/fs/Path.java b/flink-core/src/main/java/org/apache/flink/core/fs/Path.java\nindex 75155eb08f..c47bc0de36 100644\n--- a/flink-core/src/main/java/org/apache/flink/core/fs/Path.java\n+++ b/flink-core/src/main/java/org/apache/flink/core/fs/Path.java\n@@ -260,7 +260,11 @@ private String normalizePath(String path) {\n \t\tpath = path.replaceAll(\"/+\", \"/\");\n \n \t\t// remove tailing separator\n-\t\tif(!path.equals(SEPARATOR) && path.endsWith(SEPARATOR)) {\n+\t\tif(!path.equals(SEPARATOR) &&         \t\t// UNIX root path\n+\t\t\t\t!path.matches(\"/\\\\p{Alpha}+:/\") &&  // Windows root path\n+\t\t\t\tpath.endsWith(SEPARATOR))\n+\t\t{\n+\t\t\t// remove tailing slash\n \t\t\tpath = path.substring(0, path.length() - SEPARATOR.length());\n \t\t}\n \ndiff --git a/flink-core/src/main/java/org/apache/flink/core/fs/local/LocalFileSystem.java b/flink-core/src/main/java/org/apache/flink/core/fs/local/LocalFileSystem.java\nindex 2313a41cca..9dd9e30b22 100644\n--- a/flink-core/src/main/java/org/apache/flink/core/fs/local/LocalFileSystem.java\n+++ b/flink-core/src/main/java/org/apache/flink/core/fs/local/LocalFileSystem.java\n@@ -228,8 +228,13 @@ private boolean delete(final File f) throws IOException {\n \t */\n \tpublic boolean mkdirs(final Path f) throws IOException {\n \n-\t\tfinal Path parent = f.getParent();\n \t\tfinal File p2f = pathToFile(f);\n+\n+\t\tif(p2f.isDirectory()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tfinal Path parent = f.getParent();\n \t\treturn (parent == null || mkdirs(parent)) && (p2f.mkdir() || p2f.isDirectory());\n \t}\n \n",
        "project": "flink",
        "linesAdd": 10,
        "jira_id": "1848",
        "nb_skipped": 0,
        "commit": "7164b2b6",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 173,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.compiler.java.IterationCompilerTest"
        ],
        "patch": "diff --git a/flink-compiler/src/main/java/org/apache/flink/compiler/PactCompiler.java b/flink-compiler/src/main/java/org/apache/flink/compiler/PactCompiler.java\nindex bec264d489..a63cfd107f 100644\n--- a/flink-compiler/src/main/java/org/apache/flink/compiler/PactCompiler.java\n+++ b/flink-compiler/src/main/java/org/apache/flink/compiler/PactCompiler.java\n@@ -837,10 +837,7 @@ public void postVisit(Operator<?> c) {\n \t\t\t\t\n \t\t\t\t// go over the contained data flow and mark the dynamic path nodes\n \t\t\t\tStaticDynamicPathIdentifier identifier = new StaticDynamicPathIdentifier(iterNode.getCostWeight());\n-\t\t\t\trootOfStepFunction.accept(identifier);\n-\t\t\t\tif(terminationCriterion != null){\n-\t\t\t\t\tterminationCriterion.accept(identifier);\n-\t\t\t\t}\n+\t\t\t\titerNode.acceptForStepFunction(identifier);\n \t\t\t}\n \t\t\telse if (n instanceof WorksetIterationNode) {\n \t\t\t\tfinal WorksetIterationNode iterNode = (WorksetIterationNode) n;\n@@ -919,8 +916,7 @@ else if (successor.getClass() == CoGroupNode.class) {\n \t\t\t\t\n \t\t\t\t// go over the contained data flow and mark the dynamic path nodes\n \t\t\t\tStaticDynamicPathIdentifier pathIdentifier = new StaticDynamicPathIdentifier(iterNode.getCostWeight());\n-\t\t\t\tnextWorksetNode.accept(pathIdentifier);\n-\t\t\t\titerNode.getSolutionSetDelta().accept(pathIdentifier);\n+\t\t\t\titerNode.acceptForStepFunction(pathIdentifier);\n \t\t\t}\n \t\t}\n \t};\n",
        "project": "flink",
        "linesAdd": 2,
        "jira_id": "1311",
        "nb_skipped": 0,
        "commit": "94c8e3fa",
        "nb_failure": 2,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 64,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "eu.stratosphere.pact.compiler.UnionReplacementTest"
        ],
        "patch": "diff --git a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/PactCompiler.java b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/PactCompiler.java\nindex bf3d6af9fe..5a0a3e1393 100644\n--- a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/PactCompiler.java\n+++ b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/PactCompiler.java\n@@ -1218,42 +1218,19 @@ public void postVisit(PlanNode visitable) {\n \t\t\t\n \t\t\t\tPlanNode newUnionNode;\n \n-\t\t\t\t// if any input is cached, we keep this as a binary union and do not collapse it into a\n-\t\t\t\t// n-ary union\n-//\t\t\t\tif (in1.getTempMode().isCached() || in2.getTempMode().isCached()) {\n-//\t\t\t\t\t// replace this node by an explicit operator\n-//\t\t\t\t\tChannel cached, pipelined;\n-//\t\t\t\t\tif (in1.getTempMode().isCached()) {\n-//\t\t\t\t\t\tcached = in1;\n-//\t\t\t\t\t\tpipelined = in2;\n-//\t\t\t\t\t} else {\n-//\t\t\t\t\t\tcached = in2;\n-//\t\t\t\t\t\tpipelined = in1;\n-//\t\t\t\t\t}\n-//\t\t\t\t\t\n-//\t\t\t\t\tnewUnionNode = new DualInputPlanNode(unionNode.getOriginalOptimizerNode(), cached, pipelined,\n-//\t\t\t\t\t\tDriverStrategy.UNION_WITH_CACHED);\n-//\t\t\t\t\tnewUnionNode.initProperties(unionNode.getGlobalProperties(), new LocalProperties());\n-//\t\t\t\t\t\n-//\t\t\t\t\tin1.setTarget(newUnionNode);\n-//\t\t\t\t\tin2.setTarget(newUnionNode);\n-//\t\t\t\t} else {\n-\t\t\t\t\t// collect the union inputs to collapse this operator with \n-\t\t\t\t\t// its collapsed predecessors. check whether an input is materialized to prevent\n-\t\t\t\t\t// collapsing\n \t\t\t\tList<Channel> inputs = new ArrayList<Channel>();\n \t\t\t\tcollect(in1, inputs);\n \t\t\t\tcollect(in2, inputs);\n \n \t\t\t\tnewUnionNode = new NAryUnionPlanNode(unionNode.getOptimizerNode(), inputs, unionNode.getGlobalProperties());\n \n-\t\t\t\t\t// adjust the input channels to have their target point to the new union node\n \t\t\t\tfor (Channel c : inputs) {\n \t\t\t\t\tc.setTarget(newUnionNode);\n \t\t\t\t}\n-//\t\t\t\t}\n \n-\t\t\t\tunionNode.getOutgoingChannels().get(0).swapUnionNodes(newUnionNode);\n+\t\t\t\tfor(Channel channel : unionNode.getOutgoingChannels()){\n+\t\t\t\t\tchannel.swapUnionNodes(newUnionNode);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n",
        "project": "flink",
        "linesAdd": 3,
        "jira_id": "996",
        "nb_skipped": 0,
        "commit": "32a003d5",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 237,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.streaming.api.state.StatefulOperatorTest"
        ],
        "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamingRuntimeContext.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamingRuntimeContext.java\nindex 2ca286260a..b82888e35b 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamingRuntimeContext.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamingRuntimeContext.java\n@@ -104,8 +104,8 @@ public Configuration getTaskStubParameters() {\n \t\t\tthrow new RuntimeException(\"Cannot set default state to null.\");\n \t\t}\n \t\tStreamOperatorState<S, C> state = (StreamOperatorState<S, C>) getState(name, partitioned);\n-\t\tstate.setDefaultState(defaultState);\n \t\tstate.setCheckpointer(checkpointer);\n+\t\tstate.setDefaultState(defaultState);\n \n \t\treturn (OperatorState<S>) state;\n \t}\n",
        "project": "flink",
        "linesAdd": 1,
        "jira_id": "2707",
        "nb_skipped": 1,
        "commit": "3e233a38",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 150,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.streaming.api.ChainedRuntimeContextTest"
        ],
        "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OutputHandler.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OutputHandler.java\nindex c953a9456d..38f12313b1 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OutputHandler.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OutputHandler.java\n@@ -150,7 +150,11 @@ public void broadcastBarrier(long id, long timestamp) throws IOException, Interr\n \t\t\t// operator which will be returned and set it up using the wrapper\n \t\t\tOneInputStreamOperator chainableOperator =\n \t\t\t\t\tchainedTaskConfig.getStreamOperator(vertex.getUserCodeClassLoader());\n-\t\t\tchainableOperator.setup(wrapper, vertex.context);\n+\t\t\t\n+\t\t\tStreamingRuntimeContext chainedContext = vertex.createRuntimeContext(chainedTaskConfig);\n+\t\t\tvertex.contexts.add(chainedContext);\n+\t\t\t\n+\t\t\tchainableOperator.setup(wrapper, chainedContext);\n \n \t\t\tchainedOperators.add(chainableOperator);\n \t\t\treturn new OperatorCollector<X>(chainableOperator);\ndiff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\nindex d6789229ae..1a3d44fa65 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\n@@ -62,7 +62,7 @@\n \n \tprotected volatile boolean isRunning = false;\n \n-\tprotected StreamingRuntimeContext context;\n+\tprotected List<StreamingRuntimeContext> contexts;\n \n \tprotected ClassLoader userClassLoader;\n \t\n@@ -73,21 +73,26 @@\n \tpublic StreamTask() {\n \t\tstreamOperator = null;\n \t\tsuperstepListener = new SuperstepEventListener();\n+\t\tcontexts = new ArrayList<StreamingRuntimeContext>();\n \t}\n \n \t@Override\n \tpublic void registerInputOutput() {\n \t\tthis.userClassLoader = getUserCodeClassLoader();\n \t\tthis.configuration = new StreamConfig(getTaskConfiguration());\n-\t\tthis.context = createRuntimeContext(getEnvironment().getTaskName());\n \t\tthis.stateHandleProvider = getStateHandleProvider();\n \n \t\toutputHandler = new OutputHandler<OUT>(this);\n \n \t\tstreamOperator = configuration.getStreamOperator(userClassLoader);\n+\t\t\n \t\tif (streamOperator != null) {\n+\t\t\t//Create context of the head operator\n+\t\t\tStreamingRuntimeContext headContext = createRuntimeContext(configuration);\n+\t\t\tthis.contexts.add(headContext);\n+\n \t\t\t// IterationHead and IterationTail don't have an Operator...\n-\t\t\tstreamOperator.setup(outputHandler.getOutput(), this.context);\n+\t\t\tstreamOperator.setup(outputHandler.getOutput(), headContext);\n \t\t}\n \n \t\thasChainedOperators = !outputHandler.getChainedOperators().isEmpty();\n@@ -97,10 +102,10 @@ public String getName() {\n \t\treturn getEnvironment().getTaskName();\n \t}\n \n-\tpublic StreamingRuntimeContext createRuntimeContext(String taskName) {\n+\tpublic StreamingRuntimeContext createRuntimeContext(StreamConfig conf) {\n \t\tEnvironment env = getEnvironment();\n-\t\treturn new StreamingRuntimeContext(taskName, env, getUserCodeClassLoader(),\n-\t\t\t\tgetExecutionConfig());\n+\t\treturn new StreamingRuntimeContext(conf.getStreamOperator(userClassLoader).getClass()\n+\t\t\t\t.getSimpleName(), env, getUserCodeClassLoader(), getExecutionConfig());\n \t}\n \t\n \tprivate StateHandleProvider<Serializable> getStateHandleProvider() {\n",
        "project": "flink",
        "linesAdd": 15,
        "jira_id": "2082",
        "nb_skipped": 1,
        "commit": "0cfa43d7",
        "nb_failure": 1,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 274,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.streaming.graph.StreamingJobGraphGeneratorNodeHashTest"
        ],
        "patch": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\nindex da46424309..e3e1ac612d 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n@@ -736,8 +736,6 @@ private void generateNodeLocalHash(StreamNode node, Hasher hasher, int id) {\n \n \t\thasher.putInt(node.getParallelism());\n \n-\t\thasher.putString(node.getOperatorName(), Charset.forName(\"UTF-8\"));\n-\n \t\tif (node.getOperator() instanceof AbstractUdfStreamOperator) {\n \t\t\tString udfClassName = ((AbstractUdfStreamOperator<?, ?>) node.getOperator())\n \t\t\t\t\t.getUserFunction().getClass().getName();\n",
        "project": "flink",
        "linesAdd": 0,
        "jira_id": "3513",
        "nb_skipped": 1,
        "commit": "d90672fd",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 170,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.compiler.custompartition.CoGroupCustomPartitioningTest",
            "org.apache.flink.compiler.custompartition.JoinCustomPartitioningTest"
        ],
        "patch": "diff --git a/flink-compiler/src/main/java/org/apache/flink/compiler/operators/AbstractJoinDescriptor.java b/flink-compiler/src/main/java/org/apache/flink/compiler/operators/AbstractJoinDescriptor.java\nindex cb0e61c308..d8f774669b 100644\n--- a/flink-compiler/src/main/java/org/apache/flink/compiler/operators/AbstractJoinDescriptor.java\n+++ b/flink-compiler/src/main/java/org/apache/flink/compiler/operators/AbstractJoinDescriptor.java\n@@ -19,6 +19,7 @@\n package org.apache.flink.compiler.operators;\n \n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n \n import org.apache.flink.api.common.functions.Partitioner;\n@@ -62,6 +63,33 @@ public void setCustomPartitioner(Partitioner<?> partitioner) {\n \t\t\n \t\tif (repartitionAllowed) {\n \t\t\t// partition both (hash or custom)\n+\t\t\tif (this.customPartitioner == null) {\n+\t\t\t\t\n+\t\t\t\t// we accept compatible partitionings of any type\n+\t\t\t\tRequestedGlobalProperties partitioned_left_any = new RequestedGlobalProperties();\n+\t\t\t\tRequestedGlobalProperties partitioned_right_any = new RequestedGlobalProperties();\n+\t\t\t\tpartitioned_left_any.setAnyPartitioning(this.keys1);\n+\t\t\t\tpartitioned_right_any.setAnyPartitioning(this.keys2);\n+\t\t\t\tpairs.add(new GlobalPropertiesPair(partitioned_left_any, partitioned_right_any));\n+\t\t\t\t\n+\t\t\t\t// we also explicitly add hash partitioning, as a fallback, if the any-pairs do not match\n+\t\t\t\tRequestedGlobalProperties partitioned_left_hash = new RequestedGlobalProperties();\n+\t\t\t\tRequestedGlobalProperties partitioned_right_hash = new RequestedGlobalProperties();\n+\t\t\t\tpartitioned_left_hash.setHashPartitioned(this.keys1);\n+\t\t\t\tpartitioned_right_hash.setHashPartitioned(this.keys2);\n+\t\t\t\tpairs.add(new GlobalPropertiesPair(partitioned_left_hash, partitioned_right_hash));\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tRequestedGlobalProperties partitioned_left = new RequestedGlobalProperties();\n+\t\t\t\tpartitioned_left.setCustomPartitioned(this.keys1, this.customPartitioner);\n+\t\t\t\t\n+\t\t\t\tRequestedGlobalProperties partitioned_right = new RequestedGlobalProperties();\n+\t\t\t\tpartitioned_right.setCustomPartitioned(this.keys2, this.customPartitioner);\n+\t\t\t\t\n+\t\t\t\treturn Collections.singletonList(new GlobalPropertiesPair(partitioned_left, partitioned_right));\n+\t\t\t}\n+\t\t\t\n+\t\t\t\n \t\t\tRequestedGlobalProperties partitioned1 = new RequestedGlobalProperties();\n \t\t\tif (customPartitioner == null) {\n \t\t\t\tpartitioned1.setAnyPartitioning(this.keys1);\ndiff --git a/flink-compiler/src/main/java/org/apache/flink/compiler/operators/CoGroupDescriptor.java b/flink-compiler/src/main/java/org/apache/flink/compiler/operators/CoGroupDescriptor.java\nindex 14f40f37d3..bc83c5174f 100644\n--- a/flink-compiler/src/main/java/org/apache/flink/compiler/operators/CoGroupDescriptor.java\n+++ b/flink-compiler/src/main/java/org/apache/flink/compiler/operators/CoGroupDescriptor.java\n@@ -18,6 +18,7 @@\n \n package org.apache.flink.compiler.operators;\n \n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n \n@@ -98,21 +99,29 @@ public DriverStrategy getStrategy() {\n \n \t@Override\n \tprotected List<GlobalPropertiesPair> createPossibleGlobalProperties() {\n-\t\tRequestedGlobalProperties partitioned1 = new RequestedGlobalProperties();\n \t\tif (this.customPartitioner == null) {\n-\t\t\tpartitioned1.setAnyPartitioning(this.keys1);\n-\t\t} else {\n-\t\t\tpartitioned1.setCustomPartitioned(this.keys1, this.customPartitioner);\n-\t\t}\n+\t\t\tRequestedGlobalProperties partitioned_left_any = new RequestedGlobalProperties();\n+\t\t\tRequestedGlobalProperties partitioned_left_hash = new RequestedGlobalProperties();\n+\t\t\tpartitioned_left_any.setAnyPartitioning(this.keys1);\n+\t\t\tpartitioned_left_hash.setHashPartitioned(this.keys1);\n \t\t\t\n-\t\tRequestedGlobalProperties partitioned2 = new RequestedGlobalProperties();\n-\t\tif (this.customPartitioner == null) {\n-\t\t\tpartitioned2.setAnyPartitioning(this.keys2);\n-\t\t} else {\n-\t\t\tpartitioned2.setCustomPartitioned(this.keys2, this.customPartitioner);\n+\t\t\tRequestedGlobalProperties partitioned_right_any = new RequestedGlobalProperties();\n+\t\t\tRequestedGlobalProperties partitioned_right_hash = new RequestedGlobalProperties();\n+\t\t\tpartitioned_right_any.setAnyPartitioning(this.keys2);\n+\t\t\tpartitioned_right_hash.setHashPartitioned(this.keys2);\n+\t\t\t\n+\t\t\treturn Arrays.asList(new GlobalPropertiesPair(partitioned_left_any, partitioned_right_any),\n+\t\t\t\t\tnew GlobalPropertiesPair(partitioned_left_hash, partitioned_right_hash));\n \t\t}\n+\t\telse {\n+\t\t\tRequestedGlobalProperties partitioned_left = new RequestedGlobalProperties();\n+\t\t\tpartitioned_left.setCustomPartitioned(this.keys1, this.customPartitioner);\n+\t\t\t\n+\t\t\tRequestedGlobalProperties partitioned_right = new RequestedGlobalProperties();\n+\t\t\tpartitioned_right.setCustomPartitioned(this.keys2, this.customPartitioner);\n \t\t\t\n-\t\treturn Collections.singletonList(new GlobalPropertiesPair(partitioned1, partitioned2));\n+\t\t\treturn Collections.singletonList(new GlobalPropertiesPair(partitioned_left, partitioned_right));\n+\t\t}\n \t}\n \t\n \t@Override\n",
        "project": "flink",
        "linesAdd": 46,
        "jira_id": "1290",
        "nb_skipped": 0,
        "commit": "45fb6d82",
        "nb_failure": 2,
        "linesRem": 11,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 782,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "typeutils.runtime.KryoGenericTypeSerializerTest"
        ],
        "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/KryoSerializer.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/KryoSerializer.java\nindex 133dd57635..d8411a02bd 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/KryoSerializer.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/KryoSerializer.java\n@@ -195,7 +195,18 @@ public T deserialize(DataInputView source) throws IOException {\n \t\t\tinput = new NoFetchingInput(inputStream);\n \t\t\tpreviousIn = source;\n \t\t}\n+\n+\t\ttry {\n \t\t\treturn (T) kryo.readClassAndObject(input);\n+\t\t} catch (KryoException ke) {\n+\t\t\tThrowable cause = ke.getCause();\n+\n+\t\t\tif(cause instanceof EOFException) {\n+\t\t\t\tthrow (EOFException) cause;\n+\t\t\t} else {\n+\t\t\t\tthrow ke;\n+\t\t\t}\n+\t\t}\n \t}\n \t\n \t@Override\ndiff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/NoFetchingInput.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/NoFetchingInput.java\nindex 524347c914..0f4fe94d84 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/NoFetchingInput.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/NoFetchingInput.java\n@@ -21,6 +21,7 @@\n import com.esotericsoftware.kryo.KryoException;\n import com.esotericsoftware.kryo.io.Input;\n \n+import java.io.EOFException;\n import java.io.IOException;\n import java.io.InputStream;\n \n@@ -73,7 +74,7 @@ protected int require(int required) throws KryoException {\n \t\t\tcount = fill(buffer, bytesRead, required - bytesRead);\n \n \t\t\tif(count == -1){\n-\t\t\t\tthrow new KryoException(\"Buffer underflow\");\n+\t\t\t\tthrow new KryoException(new EOFException(\"No more bytes left.\"));\n \t\t\t}\n \n \t\t\tbytesRead += count;\n@@ -121,7 +122,7 @@ public void readBytes(byte[] bytes, int offset, int count) throws KryoException\n \t\t\t\tc = inputStream.read(bytes, offset+bytesRead, count-bytesRead);\n \n \t\t\t\tif(c == -1){\n-\t\t\t\t\tthrow new KryoException(\"Buffer underflow\");\n+\t\t\t\t\tthrow new KryoException(new EOFException(\"No more bytes left.\"));\n \t\t\t\t}\n \n \t\t\t\tbytesRead += c;\n",
        "project": "flink",
        "linesAdd": 14,
        "jira_id": "1531",
        "nb_skipped": 0,
        "commit": "21f47d9c",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 966,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "type.extractor.TypeExtractorTest"
        ],
        "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex 1ae8d3d62f..2e4510708d 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -18,6 +18,7 @@\n \n package org.apache.flink.api.java.typeutils;\n \n+import java.lang.reflect.Constructor;\n import java.lang.reflect.Field;\n import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.Method;\n@@ -1298,10 +1299,10 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\t\treturn true;\n \t\t\t} else {\n \t\t\t\tif(!hasGetter) {\n-\t\t\t\t\tLOG.debug(\"Class \"+clazz+\" does not contain a getter for field \"+f.getName() );\n+\t\t\t\t\tLOG.debug(clazz+\" does not contain a getter for field \"+f.getName() );\n \t\t\t\t}\n \t\t\t\tif(!hasSetter) {\n-\t\t\t\t\tLOG.debug(\"Class \"+clazz+\" does not contain a setter for field \"+f.getName() );\n+\t\t\t\t\tLOG.debug(clazz+\" does not contain a setter for field \"+f.getName() );\n \t\t\t\t}\n \t\t\t\treturn false;\n \t\t\t}\n@@ -1323,7 +1324,7 @@ else if(typeHierarchy.size() <= 1) {\n \t\t\n \t\tList<Field> fields = getAllDeclaredFields(clazz);\n \t\tif(fields.size() == 0) {\n-\t\t\tLOG.info(\"No fields detected for class \" + clazz + \". Cannot be used as a PojoType. Will be handled as GenericType\");\n+\t\t\tLOG.info(\"No fields detected for \" + clazz + \". Cannot be used as a PojoType. Will be handled as GenericType\");\n \t\t\treturn new GenericTypeInfo<OUT>(clazz);\n \t\t}\n \n@@ -1331,7 +1332,7 @@ else if(typeHierarchy.size() <= 1) {\n \t\tfor (Field field : fields) {\n \t\t\tType fieldType = field.getGenericType();\n \t\t\tif(!isValidPojoField(field, clazz, typeHierarchy)) {\n-\t\t\t\tLOG.info(\"Class \" + clazz + \" is not a valid POJO type\");\n+\t\t\t\tLOG.info(clazz + \" is not a valid POJO type\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\ttry {\n@@ -1357,24 +1358,29 @@ else if(typeHierarchy.size() <= 1) {\n \t\tList<Method> methods = getAllDeclaredMethods(clazz);\n \t\tfor (Method method : methods) {\n \t\t\tif (method.getName().equals(\"readObject\") || method.getName().equals(\"writeObject\")) {\n-\t\t\t\tLOG.info(\"Class \"+clazz+\" contains custom serialization methods we do not call.\");\n+\t\t\t\tLOG.info(clazz+\" contains custom serialization methods we do not call.\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t}\n \n \t\t// Try retrieving the default constructor, if it does not have one\n \t\t// we cannot use this because the serializer uses it.\n+\t\tConstructor defaultConstructor = null;\n \t\ttry {\n-\t\t\tclazz.getDeclaredConstructor();\n+\t\t\tdefaultConstructor = clazz.getDeclaredConstructor();\n \t\t} catch (NoSuchMethodException e) {\n \t\t\tif (clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers())) {\n-\t\t\t\tLOG.info(\"Class \" + clazz + \" is abstract or an interface, having a concrete \" +\n+\t\t\t\tLOG.info(clazz + \" is abstract or an interface, having a concrete \" +\n \t\t\t\t\t\t\"type can increase performance.\");\n \t\t\t} else {\n-\t\t\t\tLOG.info(\"Class \" + clazz + \" must have a default constructor to be used as a POJO.\");\n+\t\t\t\tLOG.info(clazz + \" must have a default constructor to be used as a POJO.\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t}\n+\t\tif(defaultConstructor != null && !Modifier.isPublic(defaultConstructor.getModifiers())) {\n+\t\t\tLOG.info(\"The default constructor of \" + clazz + \" should be Public to be used as a POJO.\");\n+\t\t\treturn null;\n+\t\t}\n \t\t\n \t\t// everything is checked, we return the pojo\n \t\treturn pojoType;\n@@ -1394,7 +1400,7 @@ else if(typeHierarchy.size() <= 1) {\n \t\t\t\t\tcontinue; // we have no use for transient or static fields\n \t\t\t\t}\n \t\t\t\tif(hasFieldWithSameName(field.getName(), result)) {\n-\t\t\t\t\tthrow new RuntimeException(\"The field \"+field+\" is already contained in the hierarchy of the class \"+clazz+\".\"\n+\t\t\t\t\tthrow new RuntimeException(\"The field \"+field+\" is already contained in the hierarchy of the \"+clazz+\".\"\n \t\t\t\t\t\t\t+ \"Please use unique field names through your classes hierarchy\");\n \t\t\t\t}\n \t\t\t\tresult.add(field);\n",
        "project": "flink",
        "linesAdd": 15,
        "jira_id": "2437",
        "nb_skipped": 0,
        "commit": "a41bc8cc",
        "nb_failure": 1,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 638,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "typeutils.TypeInfoParserTest"
        ],
        "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeInfoParser.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeInfoParser.java\nindex e9d5dac52a..98373da3bc 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeInfoParser.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeInfoParser.java\n@@ -40,8 +40,9 @@\n \tprivate static final Pattern writablePattern = Pattern.compile(\"^((\" + WRITABLE_PACKAGE.replaceAll(\"\\\\.\", \"\\\\\\\\.\") + \"\\\\.)?Writable)<([^\\\\s,>]*)(,|>|$)\");\n \tprivate static final Pattern enumPattern = Pattern.compile(\"^((java\\\\.lang\\\\.)?Enum)<([^\\\\s,>]*)(,|>|$)\");\n \tprivate static final Pattern basicTypePattern = Pattern\n-\t\t\t.compile(\"^((java\\\\.lang\\\\.)?(String|Integer|Byte|Short|Character|Double|Float|Long|Boolean))(,|>|$)\");\n-\tprivate static final Pattern basicType2Pattern = Pattern.compile(\"^(int|byte|short|char|double|float|long|boolean)(,|>|$)\");\n+\t\t\t.compile(\"^((java\\\\.lang\\\\.)?(String|Integer|Byte|Short|Character|Double|Float|Long|Boolean|Void))(,|>|$)\");\n+\tprivate static final Pattern basicTypeDatePattern = Pattern.compile(\"^((java\\\\.util\\\\.)?Date)(,|>|$)\");\n+\tprivate static final Pattern basicType2Pattern = Pattern.compile(\"^(int|byte|short|char|double|float|long|boolean|void)(,|>|$)\");\n \tprivate static final Pattern valueTypePattern = Pattern.compile(\"^((\" + VALUE_PACKAGE.replaceAll(\"\\\\.\", \"\\\\\\\\.\")\n \t\t\t+ \"\\\\.)?(String|Int|Byte|Short|Char|Double|Float|Long|Boolean|List|Map|Null))Value(,|>|$)\");\n \tprivate static final Pattern basicArrayTypePattern = Pattern\n@@ -105,6 +106,7 @@\n \t\tfinal Matcher enumMatcher = enumPattern.matcher(infoString);\n \n \t\tfinal Matcher basicTypeMatcher = basicTypePattern.matcher(infoString);\n+\t\tfinal Matcher basicTypeDateMatcher = basicTypeDatePattern.matcher(infoString);\n \t\tfinal Matcher basicType2Matcher = basicType2Pattern.matcher(infoString);\n \n \t\tfinal Matcher valueTypeMatcher = valueTypePattern.matcher(infoString);\n@@ -194,6 +196,19 @@ else if (basicTypeMatcher.find()) {\n \t\t\t}\n \t\t\treturnType = BasicTypeInfo.getInfoFor(clazz);\n \t\t}\n+\t\t// special basic type \"Date\"\n+\t\telse if (basicTypeDateMatcher.find()) {\n+\t\t\tString className = basicTypeDateMatcher.group(1);\n+\t\t\tsb.delete(0, className.length());\n+\t\t\tClass<?> clazz;\n+\t\t\t// check if fully qualified\n+\t\t\tif (className.startsWith(\"java.util\")) {\n+\t\t\t\tclazz = Class.forName(className);\n+\t\t\t} else {\n+\t\t\t\tclazz = Class.forName(\"java.util.\" + className);\n+\t\t\t}\n+\t\t\treturnType = BasicTypeInfo.getInfoFor(clazz);\n+\t\t}\n \t\t// basic type of primitives\n \t\telse if (basicType2Matcher.find()) {\n \t\t\tString className = basicType2Matcher.group(1);\n@@ -216,6 +231,8 @@ else if (basicType2Matcher.find()) {\n \t\t\t\tclazz = Long.class;\n \t\t\t} else if (className.equals(\"boolean\")) {\n \t\t\t\tclazz = Boolean.class;\n+\t\t\t} else if (className.equals(\"void\")) {\n+\t\t\t\tclazz = Void.class;\n \t\t\t}\n \t\t\treturnType = BasicTypeInfo.getInfoFor(clazz);\n \t\t}\n",
        "project": "flink",
        "linesAdd": 17,
        "jira_id": "1382",
        "nb_skipped": 0,
        "commit": "9cd96df7",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 13,
        "nb_test": 835,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.types.parser.ByteValueParserTest",
            "org.apache.flink.types.parser.LongParserTest",
            "org.apache.flink.types.parser.IntParserTest",
            "org.apache.flink.types.parser.DoubleParserTest",
            "org.apache.flink.types.parser.ShortParserTest",
            "org.apache.flink.types.parser.FloatValueParserTest",
            "org.apache.flink.types.parser.FloatParserTest",
            "org.apache.flink.types.parser.DoubleValueParserTest",
            "org.apache.flink.types.parser.LongValueParserTest",
            "org.apache.flink.types.parser.ByteParserTest",
            "org.apache.flink.types.parser.ShortValueParserTest",
            "org.apache.flink.types.parser.IntValueParserTest"
        ],
        "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java\nindex 5858da2d1f..09e517a33f 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java\n@@ -36,7 +36,8 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, B\n \t\t\tstartPos++;\n \n \t\t\t// check for empty field with only the sign\n-\t\t\tif (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n+\t\t\tif (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, \n+\t\t\t\tdelimiter))) {\n \t\t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n \t\t\t\treturn -1;\n \t\t\t}\n@@ -44,6 +45,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, B\n \n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\tthis.result = (byte) (neg ? -val : val);\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n@@ -75,38 +80,35 @@ public Byte getLastResult() {\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type byte from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type byte from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes    The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n \t * @param length   The length of the byte sequence (counting from the offset).\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final byte parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type byte from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type byte from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes     The bytes containing the text data that should be parsed.\n \t * @param startPos  The offset to start the parsing.\n \t * @param length    The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final byte parseField(byte[] bytes, int startPos, int length, char delimiter) {\n-\t\tif (length <= 0) {\n-\t\t\tthrow new NumberFormatException(\"Invalid input: Empty string\");\n-\t\t}\n \t\tlong val = 0;\n \t\tboolean neg = false;\n \n@@ -121,7 +123,7 @@ public static final byte parseField(byte[] bytes, int startPos, int length, char\n \n \t\tfor (; length > 0; startPos++, length--) {\n \t\t\tif (bytes[startPos] == delimiter) {\n-\t\t\t\treturn (byte) (neg ? -val : val);\n+\t\t\t\tthrow new NumberFormatException(\"Empty field.\");\n \t\t\t}\n \t\t\tif (bytes[startPos] < 48 || bytes[startPos] > 57) {\n \t\t\t\tthrow new NumberFormatException(\"Invalid character.\");\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java\nindex f9b36e4131..612a1cb381 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java\n@@ -52,6 +52,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, B\n \t\tfor (int i = startPos; i < limit; i++) {\n \n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\treusable.setValue((byte) (neg ? -val : val));\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java\nindex 947fdfe656..086c1f5077 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java\n@@ -42,11 +42,15 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, D\n \t\t}\n \n \t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tint len = str.length();\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tsetErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);\n+\t\t\treturn -1;\n+\t\t}\n \t\ttry {\n \t\t\tthis.result = Double.parseDouble(str);\n \t\t\treturn (i == limit) ? limit : i + delimiter.length;\n-\t\t}\n-\t\tcatch (NumberFormatException e) {\n+\t\t} catch (NumberFormatException e) {\n \t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);\n \t\t\treturn -1;\n \t\t}\n@@ -63,33 +67,33 @@ public Double getLastResult() {\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type double from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type double from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes    The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n \t * @param length   The length of the byte sequence (counting from the offset).\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final double parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type double from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type double from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes     The bytes containing the text data that should be parsed.\n \t * @param startPos  The offset to start the parsing.\n \t * @param length    The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final double parseField(byte[] bytes, int startPos, int length, char delimiter) {\n \t\tif (length <= 0) {\n@@ -102,7 +106,12 @@ public static final double parseField(byte[] bytes, int startPos, int length, ch\n \t\t\ti++;\n \t\t}\n \n-\t\tString str = new String(bytes, startPos, i);\n+\t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tint len = str.length();\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tthrow new NumberFormatException(\"There is leading or trailing whitespace in the \" +\n+\t\t\t\t\"numeric field: \" + str);\n+\t\t}\n \t\treturn Double.parseDouble(str);\n \t}\n }\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java\nindex e225c1f583..7751831cbe 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java\n@@ -43,6 +43,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, D\n \t\t}\n \t\t\n \t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tsetErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);\n+\t\t\treturn -1;\n+\t\t}\n \t\ttry {\n \t\t\tdouble value = Double.parseDouble(str);\n \t\t\treusable.setValue(value);\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java\nindex 33697fda4c..55e991586b 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java\n@@ -64,7 +64,13 @@\n \t\tUNTERMINATED_QUOTED_STRING,\n \n \t\t/** The parser found characters between the end of the quoted string and the delimiter. */\n-\t\tUNQUOTED_CHARS_AFTER_QUOTED_STRING\n+\t\tUNQUOTED_CHARS_AFTER_QUOTED_STRING,\n+\t\t\n+\t\t/** The string is empty. */\n+\t\tEMPTY_STRING,\n+\n+\t\t/** There is whitespace in a numeric field. */\n+\t\tWHITESPACE_IN_NUMERIC_FIELD\n \t}\n \t\n \tprivate ParseErrorState errorState = ParseErrorState.NONE;\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java\nindex 7d166c7ebe..be98aa1a78 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java\n@@ -27,7 +27,8 @@\n \tprivate float result;\n \t\n \t@Override\n-\tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Float reusable) {\n+\tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Float \n+\t\treusable) {\n \n \t\tint i = startPos;\n \n@@ -40,12 +41,17 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, F\n \t\t\ti++;\n \t\t}\n \n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tsetErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);\n+\t\t\treturn -1;\n+\t\t}\n+\n \t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tint len = str.length();\n \t\ttry {\n \t\t\tthis.result = Float.parseFloat(str);\n \t\t\treturn (i == limit) ? limit : i + delimiter.length;\n-\t\t}\n-\t\tcatch (NumberFormatException e) {\n+\t\t} catch (NumberFormatException e) {\n \t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);\n \t\t\treturn -1;\n \t\t}\n@@ -62,33 +68,33 @@ public Float getLastResult() {\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type float from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type float from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes    The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n \t * @param length   The length of the byte sequence (counting from the offset).\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final float parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type float from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type float from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes     The bytes containing the text data that should be parsed.\n \t * @param startPos  The offset to start the parsing.\n \t * @param length    The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final float parseField(byte[] bytes, int startPos, int length, char delimiter) {\n \t\tif (length <= 0) {\n@@ -101,7 +107,12 @@ public static final float parseField(byte[] bytes, int startPos, int length, cha\n \t\t\ti++;\n \t\t}\n \t\t\n-\t\tString str = new String(bytes, startPos, i);\n+\t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tthrow new NumberFormatException(\"There is leading or trailing whitespace in the \" +\n+\t\t\t\t\"numeric field: \" + str);\n+\t\t}\n+\t\tint len = str.length();\n \t\treturn Float.parseFloat(str);\n \t}\n }\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java\nindex af16d4c106..e8caac2979 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java\n@@ -43,6 +43,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, F\n \t\t}\n \t\t\n \t\tString str = new String(bytes, startPos, i - startPos);\n+\t\tif (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {\n+\t\t\tsetErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);\n+\t\t\treturn -1;\n+\t\t}\n \t\ttry {\n \t\t\tfloat value = Float.parseFloat(str);\n \t\t\treusable.setValue(value);\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java\nindex c871f4a7cb..dcd2ec25c4 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java\n@@ -32,7 +32,8 @@\n \tprivate int result;\n \n \t@Override\n-\tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Integer reusable) {\n+\tpublic int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Integer \n+\t\treusable) {\n \t\tlong val = 0;\n \t\tboolean neg = false;\n \n@@ -43,7 +44,8 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, I\n \t\t\tstartPos++;\n \n \t\t\t// check for empty field with only the sign\n-\t\t\tif (startPos == limit || ( startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {\n+\t\t\tif (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, \n+\t\t\t\tdelimiter))) {\n \t\t\t\tsetErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);\n \t\t\t\treturn -1;\n \t\t\t}\n@@ -51,6 +53,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, I\n \n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\tthis.result = (int) (neg ? -val : val);\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n@@ -82,38 +88,35 @@ public Integer getLastResult() {\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type int from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type int from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes    The bytes containing the text data that should be parsed.\n \t * @param startPos The offset to start the parsing.\n \t * @param length   The length of the byte sequence (counting from the offset).\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final int parseField(byte[] bytes, int startPos, int length) {\n \t\treturn parseField(bytes, startPos, length, (char) 0xffff);\n \t}\n \n \t/**\n-\t * Static utility to parse a field of type int from a byte sequence that represents text characters\n+\t * Static utility to parse a field of type int from a byte sequence that represents text \n+\t * characters\n \t * (such as when read from a file stream).\n \t *\n \t * @param bytes     The bytes containing the text data that should be parsed.\n \t * @param startPos  The offset to start the parsing.\n \t * @param length    The length of the byte sequence (counting from the offset).\n \t * @param delimiter The delimiter that terminates the field.\n-\t * \n \t * @return The parsed value.\n-\t * \n-\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n+\t * @throws NumberFormatException Thrown when the value cannot be parsed because the text \n+\t * represents not a correct number.\n \t */\n \tpublic static final int parseField(byte[] bytes, int startPos, int length, char delimiter) {\n-\t\tif (length <= 0) {\n-\t\t\tthrow new NumberFormatException(\"Invalid input: Empty string\");\n-\t\t}\n \t\tlong val = 0;\n \t\tboolean neg = false;\n \n@@ -128,7 +131,7 @@ public static final int parseField(byte[] bytes, int startPos, int length, char\n \n \t\tfor (; length > 0; startPos++, length--) {\n \t\t\tif (bytes[startPos] == delimiter) {\n-\t\t\t\treturn (int) (neg ? -val : val);\n+\t\t\t\tthrow new NumberFormatException(\"Empty field.\");\n \t\t\t}\n \t\t\tif (bytes[startPos] < 48 || bytes[startPos] > 57) {\n \t\t\t\tthrow new NumberFormatException(\"Invalid character.\");\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java\nindex 8cb8176827..abd8615650 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java\n@@ -54,6 +54,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, I\n \t\t\n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\treusable.setValue((int) (neg ? -val : val));\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java\nindex af17f15578..bb6c7c9370 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java\n@@ -47,6 +47,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, L\n \n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\tthis.result = neg ? -val : val;\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n@@ -123,9 +127,6 @@ public static final long parseField(byte[] bytes, int startPos, int length) {\n \t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n \t */\n \tpublic static final long parseField(byte[] bytes, int startPos, int length, char delimiter) {\n-\t\tif (length <= 0) {\n-\t\t\tthrow new NumberFormatException(\"Invalid input: Empty string\");\n-\t\t}\n \t\tlong val = 0;\n \t\tboolean neg = false;\n \n@@ -140,7 +141,7 @@ public static final long parseField(byte[] bytes, int startPos, int length, char\n \n \t\tfor (; length > 0; startPos++, length--) {\n \t\t\tif (bytes[startPos] == delimiter) {\n-\t\t\t\treturn neg ? -val : val;\n+\t\t\t\tthrow new NumberFormatException(\"Empty field.\");\n \t\t\t}\n \t\t\tif (bytes[startPos] < 48 || bytes[startPos] > 57) {\n \t\t\t\tthrow new NumberFormatException(\"Invalid character.\");\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java\nindex 8b697ccbb7..a99a86e2ca 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java\n@@ -51,6 +51,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, L\n \t\t\n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\treusable.setValue(neg ? -val : val);\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java\nindex a6f98984fc..6e04d60a2d 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java\n@@ -51,6 +51,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, S\n \n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\tthis.result = (short) (neg ? -val : val);\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n@@ -111,9 +115,6 @@ public static final short parseField(byte[] bytes, int startPos, int length) {\n \t * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.\n \t */\n \tpublic static final short parseField(byte[] bytes, int startPos, int length, char delimiter) {\n-\t\tif (length <= 0) {\n-\t\t\tthrow new NumberFormatException(\"Invalid input: Empty string\");\n-\t\t}\n \t\tlong val = 0;\n \t\tboolean neg = false;\n \n@@ -128,7 +129,7 @@ public static final short parseField(byte[] bytes, int startPos, int length, cha\n \n \t\tfor (; length > 0; startPos++, length--) {\n \t\t\tif (bytes[startPos] == delimiter) {\n-\t\t\t\treturn (short) (neg ? -val : val);\n+\t\t\t\tthrow new NumberFormatException(\"Empty field.\");\n \t\t\t}\n \t\t\tif (bytes[startPos] < 48 || bytes[startPos] > 57) {\n \t\t\t\tthrow new NumberFormatException(\"Invalid character.\");\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java\nindex f5168cc402..4289d1a934 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java\n@@ -54,6 +54,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, S\n \t\t\n \t\tfor (int i = startPos; i < limit; i++) {\n \t\t\tif (i < delimLimit && delimiterNext(bytes, i, delimiter)) {\n+\t\t\t\tif (i == startPos) {\n+\t\t\t\t\tsetErrorState(ParseErrorState.EMPTY_STRING);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n \t\t\t\treusable.setValue((short) (neg ? -val : val));\n \t\t\t\treturn i + delimiter.length;\n \t\t\t}\n",
        "project": "flink",
        "linesAdd": 82,
        "jira_id": "1820",
        "nb_skipped": 0,
        "commit": "39d526e6",
        "nb_failure": 18,
        "linesRem": 27,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 962,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "operators.KeysTest"
        ],
        "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/operators/Keys.java b/flink-java/src/main/java/org/apache/flink/api/java/operators/Keys.java\nindex 69d306f891..09874e5d5e 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/operators/Keys.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/operators/Keys.java\n@@ -223,41 +223,41 @@ public ExpressionKeys(int[] groupingFields, TypeInformation<T> type, boolean all\n \t\t\t} else {\n \t\t\t\tgroupingFields = rangeCheckFields(groupingFields, type.getArity() -1);\n \t\t\t}\n-\t\t\tCompositeType<?> compositeType = (CompositeType<?>) type;\n \t\t\tPreconditions.checkArgument(groupingFields.length > 0, \"Grouping fields can not be empty at this point\");\n \t\t\t\n \t\t\tkeyFields = new ArrayList<FlatFieldDescriptor>(type.getTotalFields());\n \t\t\t// for each key, find the field:\n \t\t\tfor(int j = 0; j < groupingFields.length; j++) {\n+\t\t\t\tint keyPos = groupingFields[j];\n+\n+\t\t\t\tint offset = 0;\n \t\t\t\tfor(int i = 0; i < type.getArity(); i++) {\n-\t\t\t\t\tTypeInformation<?> fieldType = compositeType.getTypeAt(i);\n \n-\t\t\t\t\tif(groupingFields[j] == i) { // check if user set the key\n-\t\t\t\t\t\tint keyId = countNestedElementsBefore(compositeType, i) + i;\n-\t\t\t\t\t\tif(fieldType instanceof TupleTypeInfoBase) {\n-\t\t\t\t\t\t\tTupleTypeInfoBase<?> tupleFieldType = (TupleTypeInfoBase<?>) fieldType;\n-\t\t\t\t\t\t\ttupleFieldType.addAllFields(keyId, keyFields);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tPreconditions.checkArgument(fieldType instanceof AtomicType, \"Wrong field type\");\n-\t\t\t\t\t\t\tkeyFields.add(new FlatFieldDescriptor(keyId, fieldType));\n+\t\t\t\t\tTypeInformation fieldType = ((CompositeType<?>) type).getTypeAt(i);\n+\t\t\t\t\tif(i < keyPos) {\n+\t\t\t\t\t\t// not yet there, increment key offset\n+\t\t\t\t\t\toffset += fieldType.getTotalFields();\n \t\t\t\t\t}\n-\t\t\t\t\t\t\n+\t\t\t\t\telse {\n+\t\t\t\t\t\t// arrived at key position\n+\t\t\t\t\t\tif(fieldType instanceof CompositeType) {\n+\t\t\t\t\t\t\t// add all nested fields of composite type\n+\t\t\t\t\t\t\t((CompositeType) fieldType).getFlatFields(\"*\", offset, keyFields);\n \t\t\t\t\t\t}\n+\t\t\t\t\t\telse if(fieldType instanceof AtomicType) {\n+\t\t\t\t\t\t\t// add atomic type field\n+\t\t\t\t\t\t\tkeyFields.add(new FlatFieldDescriptor(offset, fieldType));\n \t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t// type should either be composite or atomic\n+\t\t\t\t\t\t\tthrow new InvalidProgramException(\"Field type is neither CompositeType nor AtomicType: \"+fieldType);\n \t\t\t\t\t\t}\n-\t\t\tkeyFields = removeNullElementsFromList(keyFields);\n+\t\t\t\t\t\t// go to next key\n+\t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n-\t\t\n-\t\tprivate static int countNestedElementsBefore(CompositeType<?> compositeType, int pos) {\n-\t\t\tif( pos == 0) {\n-\t\t\t\treturn 0;\n \t\t\t\t}\n-\t\t\tint ret = 0;\n-\t\t\tfor (int i = 0; i < pos; i++) {\n-\t\t\t\tTypeInformation<?> fieldType = compositeType.getTypeAt(i);\n-\t\t\t\tret += fieldType.getTotalFields() -1;\n \t\t\t}\n-\t\t\treturn ret;\n+\t\t\tkeyFields = removeNullElementsFromList(keyFields);\n \t\t}\n \n \t\tpublic static <R> List<R> removeNullElementsFromList(List<R> in) {\ndiff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TupleTypeInfoBase.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TupleTypeInfoBase.java\nindex 3314ca9ae4..881e690d5c 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TupleTypeInfoBase.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TupleTypeInfoBase.java\n@@ -23,7 +23,6 @@\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-import org.apache.flink.api.common.typeinfo.AtomicType;\n import org.apache.flink.api.common.typeinfo.TypeInformation;\n import org.apache.flink.api.common.typeutils.CompositeType;\n import org.apache.flink.api.java.operators.Keys.ExpressionKeys;\n@@ -88,25 +87,6 @@ public int getTotalFields() {\n \t\treturn tupleType;\n \t}\n \n-\t/**\n-\t * Recursively add all fields in this tuple type. We need this in particular to get all\n-\t * the types.\n-\t * @param startKeyId\n-\t * @param keyFields\n-\t */\n-\tpublic void addAllFields(int startKeyId, List<FlatFieldDescriptor> keyFields) {\n-\t\tfor(int i = 0; i < this.getArity(); i++) {\n-\t\t\tTypeInformation<?> type = this.types[i];\n-\t\t\tif(type instanceof AtomicType) {\n-\t\t\t\tkeyFields.add(new FlatFieldDescriptor(startKeyId, type));\n-\t\t\t} else if(type instanceof TupleTypeInfoBase<?>) {\n-\t\t\t\tTupleTypeInfoBase<?> ttb = (TupleTypeInfoBase<?>) type;\n-\t\t\t\tttb.addAllFields(startKeyId, keyFields);\n-\t\t\t}\n-\t\t\tstartKeyId += type.getTotalFields();\n-\t\t}\n-\t}\n-\n \t@Override\n \tpublic void getFlatFields(String fieldExpression, int offset, List<FlatFieldDescriptor> result) {\n \n",
        "project": "flink",
        "linesAdd": 15,
        "jira_id": "2442",
        "nb_skipped": 0,
        "commit": "30761572",
        "nb_failure": 0,
        "linesRem": 35,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 977,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.executiongraph.ExecutionGraphRestartTest",
            "org.apache.flink.runtime.executiongraph.ExecutionVertexCancelTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\nindex bc7566458c..6d5832b83f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n@@ -797,6 +797,11 @@ private boolean processFail(Throwable t, boolean isCallback) {\n \t\t\t\treturn false;\n \t\t\t}\n \n+\t\t\tif (current == CANCELING) {\n+\t\t\t\tcancelingComplete();\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n \t\t\tif (transitionState(current, FAILED, t)) {\n \t\t\t\t// success (in a manner of speaking)\n \t\t\t\tthis.failureCause = t;\ndiff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\nindex 0d6de98a5b..ed50bea8f0 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java\n@@ -809,7 +809,7 @@ public void stop() throws StoppingException {\n \tpublic void fail(Throwable t) {\n \t\twhile (true) {\n \t\t\tJobStatus current = state;\n-\t\t\tif (current == JobStatus.FAILED || current == JobStatus.FAILING) {\n+\t\t\tif (current == JobStatus.FAILING || current.isTerminalState()) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\telse if (transitionState(current, JobStatus.FAILING, t)) {\n",
        "project": "flink",
        "linesAdd": 6,
        "jira_id": "3534",
        "nb_skipped": 1,
        "commit": "734ba01d",
        "nb_failure": 3,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 964,
        "nb_error": 0,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.flink.runtime.checkpoint.SavepointCoordinatorTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SavepointCoordinator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SavepointCoordinator.java\nindex 6ce6502064..ea4b8aeac3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SavepointCoordinator.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SavepointCoordinator.java\n@@ -230,6 +230,7 @@ public ApplicationID restoreSavepoint(\n \n \t\t\t// Reset the checkpoint ID counter\n \t\t\tlong nextCheckpointId = checkpoint.getCheckpointID();\n+\t\t\tcheckpointIdCounter.start();\n \t\t\tcheckpointIdCounter.setCount(nextCheckpointId + 1);\n \t\t\tLOG.info(\"Reset the checkpoint ID to {}\", nextCheckpointId);\n \n",
        "project": "flink",
        "linesAdd": 1,
        "jira_id": "3107",
        "nb_skipped": 1,
        "commit": "937963e3",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": true,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 228,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.streaming.api.functions.source.FileMonitoringFunctionTest"
        ],
        "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/FileMonitoringFunction.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/FileMonitoringFunction.java\nindex 2c85650a72..a2179238c3 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/FileMonitoringFunction.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/functions/source/FileMonitoringFunction.java\n@@ -17,13 +17,6 @@\n \n package org.apache.flink.streaming.api.functions.source;\n \n-import java.io.IOException;\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n import org.apache.flink.api.java.tuple.Tuple3;\n import org.apache.flink.core.fs.FileStatus;\n import org.apache.flink.core.fs.FileSystem;\n@@ -31,6 +24,13 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n public class FileMonitoringFunction implements SourceFunction<Tuple3<String, Long, Long>> {\n \tprivate static final long serialVersionUID = 1L;\n \n@@ -95,6 +95,9 @@ public void run(SourceContext<Tuple3<String, Long, Long>> ctx) throws Exception\n \n \t\tFileStatus[] statuses = fileSystem.listStatus(new Path(path));\n \n+\t\tif (statuses == null) {\n+\t\t\tLOG.warn(\"Path does not exist: {}\", path);\n+\t\t} else {\n \t\t\tfor (FileStatus status : statuses) {\n \t\t\t\tPath filePath = status.getPath();\n \t\t\t\tString fileName = filePath.getName();\n@@ -105,6 +108,8 @@ public void run(SourceContext<Tuple3<String, Long, Long>> ctx) throws Exception\n \t\t\t\t\tmodificationTimes.put(fileName, modificationTime);\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n+\n \t\treturn files;\n \t}\n \n",
        "project": "flink",
        "linesAdd": 12,
        "jira_id": "2817",
        "nb_skipped": 4,
        "commit": "5dfc897b",
        "nb_failure": 0,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1774,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "typeutils.TypeExtractorTest"
        ],
        "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex 01afe14bec..dd4b1326c3 100644\n--- a/flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -890,8 +890,8 @@ private static void validateInfo(ArrayList<Type> typeHierarchy, Type type, TypeI\n \t\t}\n \t\t\n \t\tif (!(type instanceof TypeVariable<?>)) {\n-\t\t\t// check for basic type\n-\t\t\tif (typeInfo.isBasicType()) {\n+\t\t\t// check for Java Basic Types\n+\t\t\tif (typeInfo instanceof BasicTypeInfo) {\n \t\t\t\t\n \t\t\t\tTypeInformation<?> actual;\n \t\t\t\t// check if basic type at all\n@@ -904,8 +904,8 @@ private static void validateInfo(ArrayList<Type> typeHierarchy, Type type, TypeI\n \t\t\t\t}\n \t\t\t\t\n \t\t\t}\n-\t\t\t// check for tuple\n-\t\t\telse if (typeInfo.isTupleType()) {\n+\t\t\t// check for Java Tuples\n+\t\t\telse if (typeInfo instanceof TupleTypeInfo) {\n \t\t\t\t// check if tuple at all\n \t\t\t\tif (!(isClassType(type) && Tuple.class.isAssignableFrom(typeToClass(type)))) {\n \t\t\t\t\tthrow new InvalidTypesException(\"Tuple type expected.\");\n@@ -1079,9 +1079,9 @@ else if (typeInfo instanceof EnumTypeInfo) {\n \t\t\t// check for generic object\n \t\t\telse if (typeInfo instanceof GenericTypeInfo<?>) {\n \t\t\t\tClass<?> clazz = null;\n-\t\t\t\tif (!(isClassType(type) && ((GenericTypeInfo<?>) typeInfo).getTypeClass() == (clazz = typeToClass(type)))) {\n-\t\t\t\t\tthrow new InvalidTypesException(\"Generic object type '\"\n-\t\t\t\t\t\t\t+ ((GenericTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + \"' expected but was '\"\n+\t\t\t\tif (!(isClassType(type) && (clazz = typeToClass(type)).isAssignableFrom(((GenericTypeInfo<?>) typeInfo).getTypeClass()))) {\n+\t\t\t\t\tthrow new InvalidTypesException(\"Generic type '\"\n+\t\t\t\t\t\t\t+ ((GenericTypeInfo<?>) typeInfo).getTypeClass().getCanonicalName() + \"' or a subclass of it expected but was '\"\n \t\t\t\t\t\t\t+ clazz.getCanonicalName() + \"'.\");\n \t\t\t\t}\n \t\t\t}\n",
        "project": "flink",
        "linesAdd": 5,
        "jira_id": "3566",
        "nb_skipped": 0,
        "commit": "434e88fd",
        "nb_failure": 0,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1063,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "typeutils.runtime.kryo.KryoClearedBufferTest"
        ],
        "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\nindex f825fc6353..8549e26441 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/kryo/KryoSerializer.java\n@@ -182,11 +182,22 @@ public void serialize(T record, DataOutputView target) throws IOException {\n \t\t\tpreviousOut = target;\n \t\t}\n \n+\t\t// Sanity check: Make sure that the output is cleared/has been flushed by the last call\n+\t\t// otherwise data might be written multiple times in case of a previous EOFException\n+\t\tif (output.position() != 0) {\n+\t\t\tthrow new IllegalStateException(\"The Kryo Output still contains data from a previous \" +\n+\t\t\t\t\"serialize call. It has to be flushed or cleared at the end of the serialize call.\");\n+\t\t}\n+\n \t\ttry {\n \t\t\tkryo.writeClassAndObject(output, record);\n \t\t\toutput.flush();\n \t\t}\n \t\tcatch (KryoException ke) {\n+\t\t\t// make sure that the Kryo output buffer is cleared in case that we can recover from\n+\t\t\t// the exception (e.g. EOFException which denotes buffer full)\n+\t\t\toutput.clear();\n+\n \t\t\tThrowable cause = ke.getCause();\n \t\t\tif (cause instanceof EOFException) {\n \t\t\t\tthrow (EOFException) cause;\n",
        "project": "flink",
        "linesAdd": 7,
        "jira_id": "2800",
        "nb_skipped": 0,
        "commit": "b654e989",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 956,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.types.parser.QuotedStringParserTest",
            "org.apache.flink.api.common.io.GenericCsvInputFormatTest"
        ],
        "patch": "diff --git a/flink-core/src/main/java/org/apache/flink/api/common/io/GenericCsvInputFormat.java b/flink-core/src/main/java/org/apache/flink/api/common/io/GenericCsvInputFormat.java\nindex b132ca2db0..8d979bb29c 100644\n--- a/flink-core/src/main/java/org/apache/flink/api/common/io/GenericCsvInputFormat.java\n+++ b/flink-core/src/main/java/org/apache/flink/api/common/io/GenericCsvInputFormat.java\n@@ -53,6 +53,8 @@\n \t\n \tprivate static final byte[] DEFAULT_FIELD_DELIMITER = new byte[] {','};\n \n+\tprivate static final byte BACKSLASH = 92;\n+\n \t// --------------------------------------------------------------------------------------------\n \t//  Variables for internal operation.\n \t//  They are all transient, because we do not want them so be serialized \n@@ -443,9 +445,10 @@ protected int skipFields(byte[] bytes, int startPos, int limit, byte[] delim) {\n \t\tif(quotedStringParsing == true && bytes[i] == quoteCharacter) {\n \n \t\t\t// quoted string parsing enabled and field is quoted\n-\t\t\t// search for ending quote character\n+\t\t\t// search for ending quote character, continue when it is escaped\n \t\t\ti++;\n-\t\t\twhile(i < limit && bytes[i] != quoteCharacter) {\n+\n+\t\t\twhile (i < limit && (bytes[i] != quoteCharacter || bytes[i-1] == BACKSLASH)){\n \t\t\t\ti++;\n \t\t\t}\n \t\t\ti++;\ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/StringParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/StringParser.java\nindex 27e49f5be7..47e4494830 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/StringParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/StringParser.java\n@@ -27,6 +27,7 @@\n \n \tprivate boolean quotedStringParsing = false;\n \tprivate byte quoteCharacter;\n+\tprivate static final byte BACKSLASH = 92;\n \n \tprivate String result;\n \n@@ -46,8 +47,8 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, S\n \t\t\t// quoted string parsing enabled and first character Vis a quote\n \t\t\ti++;\n \n-\t\t\t// search for ending quote character\n-\t\t\twhile(i < limit && bytes[i] != quoteCharacter) {\n+\t\t\t// search for ending quote character, continue when it is escaped\n+\t\t\twhile (i < limit && (bytes[i] != quoteCharacter || bytes[i-1] == BACKSLASH)){\n \t\t\t\ti++;\n \t\t\t}\n \ndiff --git a/flink-core/src/main/java/org/apache/flink/types/parser/StringValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/StringValueParser.java\nindex 086e3e497a..bcb1042d88 100644\n--- a/flink-core/src/main/java/org/apache/flink/types/parser/StringValueParser.java\n+++ b/flink-core/src/main/java/org/apache/flink/types/parser/StringValueParser.java\n@@ -31,6 +31,7 @@\n \n \tprivate boolean quotedStringParsing = false;\n \tprivate byte quoteCharacter;\n+\tprivate static final byte BACKSLASH = 92;\n \n \tprivate StringValue result;\n \n@@ -51,8 +52,8 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, S\n \t\t\t// quoted string parsing enabled and first character is a quote\n \t\t\ti++;\n \n-\t\t\t// search for ending quote character\n-\t\t\twhile(i < limit && bytes[i] != quoteCharacter) {\n+\t\t\t// search for ending quote character, continue when it is escaped\n+\t\t\twhile (i < limit && (bytes[i] != quoteCharacter || bytes[i-1] == BACKSLASH)){\n \t\t\t\ti++;\n \t\t\t}\n \n",
        "project": "flink",
        "linesAdd": 8,
        "jira_id": "2567",
        "nb_skipped": 0,
        "commit": "948b6e05",
        "nb_failure": 6,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 136,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.streaming.api.IterateTest"
        ],
        "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/streamvertex/StreamIterationTail.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/streamvertex/StreamIterationTail.java\nindex 7b654be845..ab09aff6fe 100755\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/streamvertex/StreamIterationTail.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/streamvertex/StreamIterationTail.java\n@@ -49,7 +49,7 @@ public void setInputsOutputs() {\n \t\t\titerationId = configuration.getIterationId();\n \t\t\titerationWaitTime = configuration.getIterationWaitTime();\n \t\t\tshouldWait = iterationWaitTime > 0;\n-\t\t\tBlockingQueueBroker.instance().get(iterationId.toString()+\"-\"\n+\t\t\tdataChannel = BlockingQueueBroker.instance().get(iterationId.toString()+\"-\"\n \t\t\t\t\t+getEnvironment().getIndexInSubtaskGroup());\n \t\t} catch (Exception e) {\n \t\t\tthrow new StreamVertexException(String.format(\n",
        "project": "flink",
        "linesAdd": 1,
        "jira_id": "1686",
        "nb_skipped": 0,
        "commit": "1f726e48",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 966,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "type.extractor.PojoTypeExtractionTest"
        ],
        "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex 41644f9c16..1ae8d3d62f 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -26,9 +26,7 @@\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.util.ArrayList;\n-import java.util.HashSet;\n import java.util.List;\n-import java.util.Set;\n \n import org.apache.avro.specific.SpecificRecordBase;\n import org.apache.flink.api.common.functions.CoGroupFunction;\n@@ -67,14 +65,32 @@\n  */\n public class TypeExtractor {\n \n-\tprivate static final Logger LOG = LoggerFactory.getLogger(TypeExtractor.class);\n+\t/*\n+\t * NOTE: Most methods of the TypeExtractor work with a so-called \"typeHierarchy\".\n+\t * The type hierarchy describes all types (Classes, ParameterizedTypes, TypeVariables etc. ) and intermediate\n+\t * types from a given type of a function or type (e.g. MyMapper, Tuple2) until a current type\n+\t * (depends on the method, e.g. MyPojoFieldType).\n+\t *\n+\t * Thus, it fully qualifies types until tuple/POJO field level.\n+\t *\n+\t * A typical typeHierarchy could look like:\n+\t *\n+\t * UDF: MyMapFunction.class\n+\t * top-level UDF: MyMapFunctionBase.class\n+\t * RichMapFunction: RichMapFunction.class\n+\t * MapFunction: MapFunction.class\n+\t * Function's OUT: Tuple1<MyPojo>\n+\t * user-defined POJO: MyPojo.class\n+\t * user-defined top-level POJO: MyPojoBase.class\n+\t * POJO field: Tuple1<String>\n+\t * Field type: String.class\n+\t *\n+\t */\n \t\n-\t// We need this to detect recursive types and not get caught\n-\t// in an endless recursion\n-\tprivate Set<Class<?>> alreadySeen;\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(TypeExtractor.class);\n \n \tprotected TypeExtractor() {\n-\t\talreadySeen = new HashSet<Class<?>>();\n+\t\t// only create instances for special use cases\n \t}\n \n \t// --------------------------------------------------------------------------------------------\n@@ -416,10 +432,12 @@ protected TypeExtractor() {\n \t\t\t\n \t\t\tTypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];\n \t\t\tfor (int i = 0; i < subtypes.length; i++) {\n+\t\t\t\tArrayList<Type> subTypeHierarchy = new ArrayList<Type>(typeHierarchy);\n+\t\t\t\tsubTypeHierarchy.add(subtypes[i]);\n \t\t\t\t// sub type could not be determined with materializing\n \t\t\t\t// try to derive the type info of the TypeVariable from the immediate base child input as a last attempt\n \t\t\t\tif (subtypes[i] instanceof TypeVariable<?>) {\n-\t\t\t\t\ttupleSubTypes[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);\n+\t\t\t\t\ttupleSubTypes[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type);\n \t\t\t\t\t\n \t\t\t\t\t// variable could not be determined\n \t\t\t\t\tif (tupleSubTypes[i] == null) {\n@@ -430,7 +448,7 @@ protected TypeExtractor() {\n \t\t\t\t\t\t\t\t+ \"all variables in the return type can be deduced from the input type(s).\");\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\ttupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);\n+\t\t\t\t\ttupleSubTypes[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type);\n \t\t\t\t}\n \t\t\t}\n \t\t\t\n@@ -913,6 +931,19 @@ else if (typeInfo instanceof GenericTypeInfo<?>) {\n \t//  Utility methods\n \t// --------------------------------------------------------------------------------------------\n \n+\t/**\n+\t * @return number of items with equal type or same raw type\n+\t */\n+\tprivate static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {\n+\t\tint count = 0;\n+\t\tfor (Type t : typeHierarchy) {\n+\t\t\tif (t == type || (isClassType(type) && t == typeToClass(type))) {\n+\t\t\t\tcount++;\n+\t\t\t}\n+\t\t}\n+\t\treturn count;\n+\t}\n+\t\n \t/**\n \t * @param curT : start type\n \t * @return Type The immediate child of the top class\n@@ -1183,12 +1214,10 @@ private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeV\n \t\t\treturn (TypeInformation<OUT>) new AvroTypeInfo(clazz);\n \t\t}\n \n-\t\tif (alreadySeen.contains(clazz)) {\n+\t\tif (countTypeInHierarchy(typeHierarchy, clazz) > 1) {\n \t\t\treturn new GenericTypeInfo<OUT>(clazz);\n \t\t}\n \n-\t\talreadySeen.add(clazz);\n-\n \t\tif (Modifier.isInterface(clazz.getModifiers())) {\n \t\t\t// Interface has no members and is therefore not handled as POJO\n \t\t\treturn new GenericTypeInfo<OUT>(clazz);\n",
        "project": "flink",
        "linesAdd": 16,
        "jira_id": "2447",
        "nb_skipped": 0,
        "commit": "5546a1ef",
        "nb_failure": 1,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 562,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.instance.InstanceConnectionInfoTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/instance/InstanceConnectionInfo.java b/flink-runtime/src/main/java/org/apache/flink/runtime/instance/InstanceConnectionInfo.java\nindex a1eec4d146..ee79c238c0 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/instance/InstanceConnectionInfo.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/instance/InstanceConnectionInfo.java\n@@ -31,7 +31,10 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * This class encapsulates all connection information necessary to connect to the instance's task manager.\n+ * This class encapsulates the connection information of a TaskManager.\n+ * It describes the host where the TaskManager operates and its server port\n+ * for data exchange. This class also contains utilities to work with the\n+ * TaskManager's host name, which is used to localize work assignments.\n  */\n public class InstanceConnectionInfo implements IOReadableWritable, Comparable<InstanceConnectionInfo>, java.io.Serializable {\n \n@@ -56,16 +59,10 @@\n \tprivate String fqdnHostName;\n \t\n \t/**\n-\t * The hostname\n+\t * The hostname, derived from the fully qualified host name.\n \t */\n \tprivate String hostName;\n \n-\t/**\n-\t * This flag indicates if the FQDN hostname cound not be resolved and is represented\n-\t * as an IP address (string).\n-\t */\n-\tprivate boolean fqdnHostNameIsIP = false;\n-\n \n \t/**\n \t * Constructs a new instance connection info object. The constructor will attempt to retrieve the instance's\n@@ -90,14 +87,24 @@ public InstanceConnectionInfo(InetAddress inetAddress, int dataPort) {\n \t\t// get FQDN hostname on this TaskManager.\n \t\ttry {\n \t\t\tthis.fqdnHostName = this.inetAddress.getCanonicalHostName();\n-\t\t} catch (Throwable t) {\n-\t\t\tLOG.warn(\"Unable to determine hostname for TaskManager. The performance might be degraded since HDFS input split assignment is not possible\");\n-\t\t\tif(LOG.isDebugEnabled()) {\n-\t\t\t\tLOG.debug(\"getCanonicalHostName() Exception\", t);\n \t\t}\n-\t\t\t// could not determine host name, so take IP textual representation\n-\t\t\tthis.fqdnHostName = inetAddress.getHostAddress();\n-\t\t\tthis.fqdnHostNameIsIP = true;\n+\t\tcatch (Throwable t) {\n+\t\t\tLOG.warn(\"Unable to determine the canonical hostname. Input split assignment (such as \" +\n+\t\t\t\t\t\"for HDFS files) may be non-local when the canonical hostname is missing.\");\n+\t\t\tLOG.debug(\"getCanonicalHostName() Exception:\", t);\n+\t\t\tthis.fqdnHostName = this.inetAddress.getHostAddress();\n+\t\t}\n+\n+\t\tif (this.fqdnHostName.equals(this.inetAddress.getHostAddress())) {\n+\t\t\t// this happens when the name lookup fails, either due to an exception,\n+\t\t\t// or because no hostname can be found for the address\n+\t\t\t// take IP textual representation\n+\t\t\tthis.hostName = this.fqdnHostName;\n+\t\t\tLOG.warn(\"No hostname could be resolved for the IP address {}, using IP address as host name. \"\n+\t\t\t\t\t+ \"Local input split assignment (such as for HDFS files) may be impacted.\");\n+\t\t}\n+\t\telse {\n+\t\t\tthis.hostName = NetUtils.getHostnameFromFQDN(this.fqdnHostName);\n \t\t}\n \t}\n \n@@ -126,27 +133,37 @@ public InetAddress address() {\n \t}\n \n \t/**\n-\t * Returns the host name of the instance. If the host name could not be determined, the return value will be a\n-\t * textual representation of the instance's IP address.\n+\t * Returns the fully-qualified domain name the TaskManager. If the name could not be\n+\t * determined, the return value will be a textual representation of the TaskManager's IP address.\n \t * \n-\t * @return the host name of the instance\n+\t * @return The fully-qualified domain name of the TaskManager.\n \t */\n \tpublic String getFQDNHostname() {\n \t\treturn this.fqdnHostName;\n \t}\n \n+\t/**\n+\t * Gets the hostname of the TaskManager. The hostname derives from the fully qualified\n+\t * domain name (FQDN, see {@link #getFQDNHostname()}):\n+\t * <ul>\n+\t *     <li>If the FQDN is the textual IP address, then the hostname is also the IP address</li>\n+\t *     <li>If the FQDN has only one segment (such as \"localhost\", or \"host17\"), then this is\n+\t *         used as the hostname.</li>\n+\t *     <li>If the FQDN has multiple segments (such as \"worker3.subgroup.company.net\"), then the first\n+\t *         segment (here \"worker3\") will be used as the hostname.</li>\n+\t * </ul>\n+\t *\n+\t * @return The hostname of the TaskManager.\n+\t */\n \tpublic String getHostname() {\n-\t\tif(hostName == null) {\n-\t\t\tString fqdn = getFQDNHostname();\n-\t\t\tif(this.fqdnHostNameIsIP) { // fqdn to hostname translation is pointless if FQDN is an ip address.\n-\t\t\t\thostName = fqdn;\n-\t\t\t} else {\n-\t\t\t\thostName = NetUtils.getHostnameFromFQDN(fqdn);\n-\t\t\t}\n-\t\t}\n \t\treturn hostName;\n \t}\n \n+\t/**\n+\t * Gets the IP address where the TaskManager operates.\n+\t *\n+\t * @return The IP address.\n+\t */\n \tpublic String getInetAdress() {\n \t\treturn this.inetAddress.toString();\n \t}\n@@ -166,7 +183,6 @@ public void read(DataInputView in) throws IOException {\n \t\t\n \t\tthis.fqdnHostName = StringUtils.readNullableString(in);\n \t\tthis.hostName = StringUtils.readNullableString(in);\n-\t\tthis.fqdnHostNameIsIP = in.readBoolean();\n \n \t\ttry {\n \t\t\tthis.inetAddress = InetAddress.getByAddress(address);\n@@ -185,7 +201,6 @@ public void write(final DataOutputView out) throws IOException {\n \t\t\n \t\tStringUtils.writeNullableString(fqdnHostName, out);\n \t\tStringUtils.writeNullableString(hostName, out);\n-\t\tout.writeBoolean(fqdnHostNameIsIP);\n \t}\n \n \t// --------------------------------------------------------------------------------------------\n",
        "project": "flink",
        "linesAdd": 14,
        "jira_id": "1705",
        "nb_skipped": 0,
        "commit": "5308ac83",
        "nb_failure": 1,
        "linesRem": 18,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 738,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "typeutils.runtime.PojoSerializerTest"
        ],
        "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java\nindex 99b9f65512..1e58b9ddcf 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java\n@@ -142,9 +142,15 @@ public T copy(T from) {\n \t\t\n \t\ttry {\n \t\t\tfor (int i = 0; i < numFields; i++) {\n-\t\t\t\tObject copy = fieldSerializers[i].copy(fields[i].get(from));\n+\t\t\t\tObject value = fields[i].get(from);\n+\t\t\t\tif (value != null) {\n+\t\t\t\t\tObject copy = fieldSerializers[i].copy(value);\n \t\t\t\t\tfields[i].set(target, copy);\n \t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tfields[i].set(target, null);\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\tcatch (IllegalAccessException e) {\n \t\t\tthrow new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields before.\");\n@@ -156,9 +162,15 @@ public T copy(T from) {\n \tpublic T copy(T from, T reuse) {\n \t\ttry {\n \t\t\tfor (int i = 0; i < numFields; i++) {\n+\t\t\t\tObject value = fields[i].get(from);\n+\t\t\t\tif (value != null) {\n \t\t\t\t\tObject copy = fieldSerializers[i].copy(fields[i].get(from), fields[i].get(reuse));\n \t\t\t\t\tfields[i].set(reuse, copy);\n \t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tfields[i].set(reuse, null);\n+\t\t\t\t}\n+\t\t\t}\n \t\t} catch (IllegalAccessException e) {\n \t\t\tthrow new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" +\n \t\t\t\t\t\"before.\");\n@@ -257,10 +269,13 @@ public void copy(DataInputView source, DataOutputView target) throws IOException\n \t\t// copy the Non-Null/Null tag\n \t\ttarget.writeBoolean(source.readBoolean());\n \t\tfor (int i = 0; i < numFields; i++) {\n-\t\t\ttarget.writeBoolean(source.readBoolean());\n+\t\t\tboolean isNull = source.readBoolean();\n+\t\t\ttarget.writeBoolean(isNull);\n+\t\t\tif (!isNull) {\n \t\t\t\tfieldSerializers[i].copy(source, target);\n \t\t\t}\n \t\t}\n+\t}\n \t\n \t@Override\n \tpublic int hashCode() {\n",
        "project": "flink",
        "linesAdd": 17,
        "jira_id": "1437",
        "nb_skipped": 0,
        "commit": "fb7ce0e3",
        "nb_failure": 5,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 150,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.streaming.api.windowing.windowbuffer.SlidingTimeGroupedPreReducerTest",
            "org.apache.flink.streaming.api.windowing.windowbuffer.SlidingTimePreReducerTest"
        ],
        "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/windowing/windowbuffer/SlidingGroupedPreReducer.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/windowing/windowbuffer/SlidingGroupedPreReducer.java\nindex 0872c6e04a..09fadf9b0e 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/windowing/windowbuffer/SlidingGroupedPreReducer.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/windowing/windowbuffer/SlidingGroupedPreReducer.java\n@@ -143,6 +143,7 @@ protected void addCurrentToBuffer(T element) throws Exception {\n \t@Override\n \tprotected void resetCurrent() {\n \t\tcurrentReducedMap = null;\n+\t\telementsSinceLastPreAggregate = 0;\n \t}\n \n \t@Override\ndiff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/windowing/windowbuffer/SlidingTimePreReducer.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/windowing/windowbuffer/SlidingTimePreReducer.java\nindex 7652d810c2..d84505c4a2 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/windowing/windowbuffer/SlidingTimePreReducer.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/windowing/windowbuffer/SlidingTimePreReducer.java\n@@ -89,6 +89,7 @@ public void evict(int n) {\n \n \t\tif (toRemove > 0 && lastPreAggregateSize == null) {\n \t\t\tcurrentReduced = null;\n+\t\t\telementsSinceLastPreAggregate = 0;\n \t\t\ttoRemove = 0;\n \t\t}\n \t}\n",
        "project": "flink",
        "linesAdd": 2,
        "jira_id": "2074",
        "nb_skipped": 1,
        "commit": "6bc6dbec",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 535,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.io.network.api.reader.BufferReaderTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/reader/BufferReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/reader/BufferReader.java\nindex 91784f6771..fca27faede 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/reader/BufferReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/reader/BufferReader.java\n@@ -49,6 +49,8 @@\n import org.slf4j.LoggerFactory;\n \n import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.Map;\n import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.LinkedBlockingQueue;\n@@ -91,6 +93,10 @@\n \n \tprivate final AtomicReference<EventListener<BufferReaderBase>> readerListener = new AtomicReference<EventListener<BufferReaderBase>>(null);\n \n+\tprivate final List<TaskEvent> pendingEvents = new ArrayList<TaskEvent>();\n+\n+\tprivate int numberOfUninitializedChannels;\n+\n \t// ------------------------------------------------------------------------\n \n \tprivate boolean isIterativeReader;\n@@ -149,17 +155,13 @@ public ConnectionManager getConnectionManager() {\n \t\treturn networkEnvironment.getConnectionManager();\n \t}\n \n-\t// TODO This is a work-around for the union reader\n-\tboolean hasInputChannelWithData() {\n-\t\treturn !inputChannelsWithData.isEmpty();\n-\t}\n-\n \t/**\n \t * Returns the total number of input channels for this reader.\n \t * <p>\n \t * Note: This number might be smaller the current number of input channels\n \t * of the reader as channels are possibly updated during runtime.\n \t */\n+\t@Override\n \tpublic int getNumberOfInputChannels() {\n \t\treturn totalNumberOfInputChannels;\n \t}\n@@ -170,7 +172,11 @@ public BufferProvider getBufferProvider() {\n \n \tpublic void setInputChannel(IntermediateResultPartitionID partitionId, InputChannel inputChannel) {\n \t\tsynchronized (requestLock) {\n-\t\t\tinputChannels.put(checkNotNull(partitionId), checkNotNull(inputChannel));\n+\t\t\tif (inputChannels.put(checkNotNull(partitionId), checkNotNull(inputChannel)) == null &&\n+\t\t\t\t\tinputChannel.getClass() == UnknownInputChannel.class) {\n+\n+\t\t\t\tnumberOfUninitializedChannels++;\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -202,7 +208,16 @@ else if (partitionInfo.getProducerLocation() == PartitionLocation.LOCAL) {\n \n \t\t\t\tinputChannels.put(partitionId, newChannel);\n \n+\n \t\t\t\tnewChannel.requestIntermediateResultPartition(queueToRequest);\n+\n+\t\t\t\tfor (TaskEvent event : pendingEvents) {\n+\t\t\t\t\tnewChannel.sendTaskEvent(event);\n+\t\t\t\t}\n+\n+\t\t\t\tif (--numberOfUninitializedChannels == 0) {\n+\t\t\t\t\tpendingEvents.clear();\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n@@ -387,6 +402,10 @@ public void sendTaskEvent(TaskEvent event) throws IOException, InterruptedExcept\n \t\t\tfor (InputChannel inputChannel : inputChannels.values()) {\n \t\t\t\tinputChannel.sendTaskEvent(event);\n \t\t\t}\n+\n+\t\t\tif (numberOfUninitializedChannels > 0) {\n+\t\t\t\tpendingEvents.add(event);\n+\t\t\t}\n \t\t}\n \t}\n \n",
        "project": "flink",
        "linesAdd": 25,
        "jira_id": "1496",
        "nb_skipped": 0,
        "commit": "0a4c7694",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 716,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.runtime.checkpoint.CheckpointCoordinatorTest"
        ],
        "patch": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java\nindex 96941321b9..de83ad9f15 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java\n@@ -23,6 +23,7 @@\n import akka.actor.Props;\n \n import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.execution.ExecutionState;\n import org.apache.flink.runtime.executiongraph.Execution;\n import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n import org.apache.flink.runtime.executiongraph.ExecutionJobVertex;\n@@ -224,7 +225,7 @@ public boolean triggerCheckpoint(final long timestamp) {\n \t\t\tExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length];\n \t\t\tfor (int i = 0; i < tasksToTrigger.length; i++) {\n \t\t\t\tExecution ee = tasksToTrigger[i].getCurrentExecutionAttempt();\n-\t\t\t\tif (ee != null) {\n+\t\t\t\tif (ee != null && ee.getState() == ExecutionState.RUNNING) {\n \t\t\t\t\ttriggerIDs[i] = ee.getAttemptId();\n \t\t\t\t} else {\n \t\t\t\t\tLOG.info(\"Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.\",\n",
        "project": "flink",
        "linesAdd": 2,
        "jira_id": "2515",
        "nb_skipped": 0,
        "commit": "06e2da35",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 149,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.streaming.api.graph.StreamingJobGraphGeneratorTest"
        ],
        "patch": "diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\nindex 6bad4c802b..d16ee58633 100644\n--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n@@ -17,6 +17,7 @@\n \n package org.apache.flink.streaming.api.graph;\n \n+import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n@@ -26,6 +27,7 @@\n import java.util.Map.Entry;\n \n import org.apache.commons.lang.StringUtils;\n+import org.apache.flink.api.common.ExecutionConfig;\n import org.apache.flink.configuration.Configuration;\n import org.apache.flink.runtime.jobgraph.AbstractJobVertex;\n import org.apache.flink.runtime.jobgraph.DistributionPattern;\n@@ -43,6 +45,7 @@\n import org.apache.flink.streaming.runtime.partitioner.StreamPartitioner.PartitioningStrategy;\n import org.apache.flink.streaming.runtime.tasks.StreamIterationHead;\n import org.apache.flink.streaming.runtime.tasks.StreamIterationTail;\n+import org.apache.flink.util.InstantiationUtil;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -93,6 +96,12 @@ public JobGraph createJobGraph(String jobName) {\n \t\t\n \t\tconfigureCheckpointing();\n \n+\t\ttry {\n+\t\t\tInstantiationUtil.writeObjectToConfig(this.streamGraph.getExecutionConfig(), this.jobGraph.getJobConfiguration(), ExecutionConfig.CONFIG_KEY);\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeException(\"Config object could not be written to Job Configuration: \", e);\n+\t\t}\n+\t\t\n \t\treturn jobGraph;\n \t}\n \n",
        "project": "flink",
        "linesAdd": 9,
        "jira_id": "1985",
        "nb_skipped": 1,
        "commit": "495a5c3c",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 96,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.compiler.PartitionPushdownTest"
        ],
        "patch": "diff --git a/flink-compiler/src/main/java/org/apache/flink/compiler/dag/SingleInputNode.java b/flink-compiler/src/main/java/org/apache/flink/compiler/dag/SingleInputNode.java\nindex b3d639bd44..730c1bb0bb 100644\n--- a/flink-compiler/src/main/java/org/apache/flink/compiler/dag/SingleInputNode.java\n+++ b/flink-compiler/src/main/java/org/apache/flink/compiler/dag/SingleInputNode.java\n@@ -220,8 +220,21 @@ public void computeInterestingPropertiesForInputs(CostEstimator estimator) {\n \t\t// add all properties relevant to this node\n \t\tfor (OperatorDescriptorSingle dps : getPossibleProperties()) {\n \t\t\tfor (RequestedGlobalProperties gp : dps.getPossibleGlobalProperties()) {\n+\t\t\t\t\n+\t\t\t\tif (gp.getPartitioning().isPartitionedOnKey()) {\n+\t\t\t\t\t// make sure that among the same partitioning types, we do not push anything down that has fewer key fields\n+\t\t\t\t\t\n+\t\t\t\t\tfor (RequestedGlobalProperties contained : props.getGlobalProperties()) {\n+\t\t\t\t\t\tif (contained.getPartitioning() == gp.getPartitioning() && gp.getPartitionedFields().isValidSubset(contained.getPartitionedFields())) {\n+\t\t\t\t\t\t\tprops.getGlobalProperties().remove(contained);\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t\n \t\t\t\tprops.addGlobalProperties(gp);\n \t\t\t}\n+\t\t\t\n \t\t\tfor (RequestedLocalProperties lp : dps.getPossibleLocalProperties()) {\n \t\t\t\tprops.addLocalProperties(lp);\n \t\t\t}\n",
        "project": "flink",
        "linesAdd": 12,
        "jira_id": "1214",
        "nb_skipped": 0,
        "commit": "6ecd0f82",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 634,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "type.extractor.PojoTypeExtractionTest"
        ],
        "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex e52e2af1b6..b528d00d95 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -989,12 +989,12 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\t}\n \t\t\tfor(Method m : clazz.getMethods()) {\n \t\t\t\t// check for getter\n-\t\t\t\tif(\t// The name should be \"get<FieldName>\" or \"<fieldName>\" (for scala).\n-\t\t\t\t\t(m.getName().toLowerCase().equals(\"get\"+fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&\n+\t\t\t\tif(\t// The name should be \"get<FieldName>\" or \"<fieldName>\" (for scala) or \"is<fieldName>\" for boolean fields.\n+\t\t\t\t\t(m.getName().toLowerCase().equals(\"get\"+fieldNameLow) || m.getName().toLowerCase().equals(\"is\"+fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow)) &&\n \t\t\t\t\t// no arguments for the getter\n \t\t\t\t\tm.getParameterTypes().length == 0 &&\n \t\t\t\t\t// return type is same as field type (or the generic variant of it)\n-\t\t\t\t\t(m.getReturnType().equals( fieldType ) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )\n+\t\t\t\t\t(m.getGenericReturnType().equals( fieldType ) || (fieldTypeGeneric != null && m.getGenericReturnType().equals(fieldTypeGeneric)) )\n \t\t\t\t) {\n \t\t\t\t\tif(hasGetter) {\n \t\t\t\t\t\tthrow new IllegalStateException(\"Detected more than one getter\");\n@@ -1004,7 +1004,7 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\t\t// check for setters (<FieldName>_$eq for scala)\n \t\t\t\tif((m.getName().toLowerCase().equals(\"set\"+fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow+\"_$eq\")) &&\n \t\t\t\t\tm.getParameterTypes().length == 1 && // one parameter of the field's type\n-\t\t\t\t\t( m.getParameterTypes()[0].equals( fieldType ) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&\n+\t\t\t\t\t( m.getGenericParameterTypes()[0].equals( fieldType ) || (fieldTypeGeneric != null && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric) ) )&&\n \t\t\t\t\t// return type is void.\n \t\t\t\t\tm.getReturnType().equals(Void.TYPE)\n \t\t\t\t) {\n",
        "project": "flink",
        "linesAdd": 4,
        "jira_id": "1333",
        "nb_skipped": 0,
        "commit": "63ef8e86",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 15,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.cep.operator.CEPOperatorTest"
        ],
        "patch": "diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/CEPPatternOperator.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/CEPPatternOperator.java\nindex 153c9c9554..77608177b2 100644\n--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/CEPPatternOperator.java\n+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/CEPPatternOperator.java\n@@ -87,6 +87,8 @@ public void processWatermark(Watermark mark) throws Exception {\n \n \t\t\tprocessEvent(nfa, streamRecord.getValue(), streamRecord.getTimestamp());\n \t\t}\n+\n+\t\toutput.emitWatermark(mark);\n \t}\n \n \t@Override\ndiff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/KeyedCEPPatternOperator.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/KeyedCEPPatternOperator.java\nindex 5d754cea52..5db8ef25a6 100644\n--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/KeyedCEPPatternOperator.java\n+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/KeyedCEPPatternOperator.java\n@@ -163,6 +163,8 @@ public void processWatermark(Watermark mark) throws Exception {\n \t\t\t\tprocessEvent(nfa, streamRecord.getValue(), streamRecord.getTimestamp());\n \t\t\t}\n \t\t}\n+\n+\t\toutput.emitWatermark(mark);\n \t}\n \n \t@Override\n",
        "project": "flink",
        "linesAdd": 4,
        "jira_id": "3684",
        "nb_skipped": 0,
        "commit": "e3759a5e",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 232,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.flink.streaming.api.operators.FoldWindowFunctionTest"
        ],
        "patch": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractUdfStreamOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractUdfStreamOperator.java\nindex 17bd08d87d..32be2ba49e 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractUdfStreamOperator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractUdfStreamOperator.java\n@@ -20,8 +20,10 @@\n \n import java.io.Serializable;\n \n+import org.apache.flink.api.common.ExecutionConfig;\n import org.apache.flink.api.common.functions.Function;\n import org.apache.flink.api.common.functions.util.FunctionUtils;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n import org.apache.flink.configuration.Configuration;\n import org.apache.flink.runtime.state.StateHandle;\n import org.apache.flink.streaming.api.checkpoint.CheckpointNotifier;\n@@ -44,7 +46,7 @@\n  * @param <F>\n  *            The type of the user function\n  */\n-public abstract class AbstractUdfStreamOperator<OUT, F extends Function> extends AbstractStreamOperator<OUT> {\n+public abstract class AbstractUdfStreamOperator<OUT, F extends Function> extends AbstractStreamOperator<OUT> implements OutputTypeConfigurable<OUT> {\n \n \tprivate static final long serialVersionUID = 1L;\n \t\n@@ -175,6 +177,20 @@ public void notifyOfCompletedCheckpoint(long checkpointId) throws Exception {\n \t\t}\n \t}\n \n+\t// ------------------------------------------------------------------------\n+\t//  Output type configuration\n+\t// ------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic void setOutputType(TypeInformation<OUT> outTypeInfo, ExecutionConfig executionConfig) {\n+\t\tif (userFunction instanceof OutputTypeConfigurable) {\n+\t\t\tOutputTypeConfigurable<OUT> outputTypeConfigurable = (OutputTypeConfigurable<OUT>) userFunction;\n+\n+\t\t\toutputTypeConfigurable.setOutputType(outTypeInfo, executionConfig);\n+\t\t}\n+\t}\n+\n+\n \t// ------------------------------------------------------------------------\n \t//  Utilities\n \t// ------------------------------------------------------------------------\ndiff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/NonKeyedWindowOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/NonKeyedWindowOperator.java\nindex d12a930ed9..cf90cf2bc3 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/NonKeyedWindowOperator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/NonKeyedWindowOperator.java\n@@ -31,7 +31,6 @@\n import org.apache.flink.streaming.api.operators.AbstractUdfStreamOperator;\n import org.apache.flink.streaming.api.operators.ChainingStrategy;\n import org.apache.flink.streaming.api.operators.OneInputStreamOperator;\n-import org.apache.flink.streaming.api.operators.OutputTypeConfigurable;\n import org.apache.flink.streaming.api.operators.TimestampedCollector;\n import org.apache.flink.streaming.api.watermark.Watermark;\n import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;\n@@ -70,7 +69,7 @@\n  */\n public class NonKeyedWindowOperator<IN, OUT, W extends Window>\n \t\textends AbstractUdfStreamOperator<OUT, AllWindowFunction<IN, OUT, W>>\n-\t\timplements OneInputStreamOperator<IN, OUT>, Triggerable, InputTypeConfigurable, OutputTypeConfigurable<OUT> {\n+\t\timplements OneInputStreamOperator<IN, OUT>, Triggerable, InputTypeConfigurable {\n \n \tprivate static final long serialVersionUID = 1L;\n \n@@ -510,15 +509,6 @@ public void registerEventTimeTimer(long time) {\n \t\treturn this;\n \t}\n \n-\t@Override\n-\tpublic final void setOutputType(TypeInformation<OUT> outTypeInfo, ExecutionConfig executionConfig) {\n-\t\tif (userFunction instanceof OutputTypeConfigurable) {\n-\t\t\t@SuppressWarnings(\"unchecked\")\n-\t\t\tOutputTypeConfigurable<OUT> typeConfigurable = (OutputTypeConfigurable<OUT>) userFunction;\n-\t\t\ttypeConfigurable.setOutputType(outTypeInfo, executionConfig);\n-\t\t}\n-\t}\n-\n \t// ------------------------------------------------------------------------\n \t//  Checkpointing\n \t// ------------------------------------------------------------------------\ndiff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java\nindex c39679f233..6764186da6 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java\n@@ -32,7 +32,6 @@\n import org.apache.flink.streaming.api.operators.AbstractUdfStreamOperator;\n import org.apache.flink.streaming.api.operators.ChainingStrategy;\n import org.apache.flink.streaming.api.operators.OneInputStreamOperator;\n-import org.apache.flink.streaming.api.operators.OutputTypeConfigurable;\n import org.apache.flink.streaming.api.operators.TimestampedCollector;\n import org.apache.flink.streaming.api.watermark.Watermark;\n import org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;\n@@ -88,7 +87,7 @@\n  */\n public class WindowOperator<K, IN, OUT, W extends Window>\n \t\textends AbstractUdfStreamOperator<OUT, WindowFunction<IN, OUT, K, W>>\n-\t\timplements OneInputStreamOperator<IN, OUT>, Triggerable, InputTypeConfigurable, OutputTypeConfigurable<OUT> {\n+\t\timplements OneInputStreamOperator<IN, OUT>, Triggerable, InputTypeConfigurable {\n \n \tprivate static final long serialVersionUID = 1L;\n \n@@ -579,15 +578,6 @@ public void registerEventTimeTimer(long time) {\n \t\treturn this;\n \t}\n \n-\t@Override\n-\tpublic final void setOutputType(TypeInformation<OUT> outTypeInfo, ExecutionConfig executionConfig) {\n-\t\tif (userFunction instanceof OutputTypeConfigurable) {\n-\t\t\t@SuppressWarnings(\"unchecked\")\n-\t\t\tOutputTypeConfigurable<OUT> typeConfigurable = (OutputTypeConfigurable<OUT>) userFunction;\n-\t\t\ttypeConfigurable.setOutputType(outTypeInfo, executionConfig);\n-\t\t}\n-\t}\n-\n \t// ------------------------------------------------------------------------\n \t//  Checkpointing\n \t// ------------------------------------------------------------------------\n",
        "project": "flink",
        "linesAdd": 16,
        "jira_id": "2968",
        "nb_skipped": 4,
        "commit": "59685903",
        "nb_failure": 0,
        "linesRem": 23,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 581,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilderTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex e514790f18..fac27d237e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -188,20 +188,19 @@ private MutableNodeState getWriteState(String name) {\n     }\n \n     /**\n-     * Determine whether this child has been removed.\n+     * Determine whether this child exists.\n      * Assumes {@code read()}, {@code write()} needs not be called.\n-     * @return  {@code true} iff this child has been removed\n+     * @return  {@code true} iff this child exists\n      */\n-    private boolean removed() {\n-        return !isRoot() && parent.writeState != null &&\n-                parent.hasBaseState(name) && !parent.writeState.hasChildNode(name);\n+    private boolean exists() {\n+        return isRoot() || parent.writeState == null || parent.writeState.hasChildNode(name);\n     }\n \n     @Nonnull\n     private NodeState read() {\n         if (revision != root.revision) {\n             assert(!isRoot()); // root never gets here since revision == root.revision\n-            checkState(!removed(), \"This node has already been removed\");\n+            checkState(exists(), \"This node has already been removed\");\n             parent.read();\n \n             // The builder could have been reset, need to re-get base state\n@@ -231,7 +230,7 @@ private MutableNodeState write() {\n     private MutableNodeState write(long newRevision, boolean skipRemovedCheck) {\n         // make sure that all revision numbers up to the root gets updated\n         if (!isRoot()) {\n-            checkState(skipRemovedCheck || !removed());\n+            checkState(skipRemovedCheck || exists());\n             parent.write(newRevision, skipRemovedCheck);\n         }\n \n@@ -243,7 +242,7 @@ private MutableNodeState write(long newRevision, boolean skipRemovedCheck) {\n \n             writeState = parent.getWriteState(name);\n             if (writeState == null) {\n-                if (removed()) {\n+                if (!exists()) {\n                     writeState = new MutableNodeState(null);\n                 }\n                 else {\n@@ -385,7 +384,7 @@ public NodeBuilder setNode(String name, NodeState state) {\n         MutableNodeState childState = getWriteState(name);\n         if (childState == null) {\n             writeState.nodes.remove(name);\n-            childState = createChildBuilder(name).write();\n+            childState = createChildBuilder(name).write(root.revision + 1, true);\n         }\n         childState.reset(state);\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 6,
        "jira_id": "614",
        "nb_skipped": 8,
        "commit": "6feacf6b",
        "nb_failure": 2,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1839,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdateTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\nindex b509e1e7f1..ea8d9277c7 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n@@ -148,7 +148,7 @@ public synchronized void run() {\n             return;\n         }\n \n-        NodeBuilder builder = store.getRoot().builder();\n+        NodeBuilder builder = after.builder();\n         NodeBuilder async = builder.child(ASYNC);\n \n         NodeState before = null;\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "1749",
        "nb_skipped": 8,
        "commit": "591e4d4a",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1444,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.segment.RecordTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/ListRecord.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/ListRecord.java\nindex cc591633a5..fd6e50b3c6 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/ListRecord.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/ListRecord.java\n@@ -21,7 +21,7 @@\n \r\n class ListRecord extends Record {\r\n \r\n-    static final int LEVEL_SIZE = 1 << 8; // 256\r\n+    static final int LEVEL_SIZE = Segment.SEGMENT_REFERENCE_LIMIT;\r\n \r\n     private final int size;\r\n \r\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "1184",
        "nb_skipped": 6,
        "commit": "f72dd8d1",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1589,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.security.authorization.ReadTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/NodeDelegate.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/NodeDelegate.java\nindex 16c315009c..9cbfaf08f4 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/NodeDelegate.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/NodeDelegate.java\n@@ -338,7 +338,7 @@ public NodeDelegate getChild(String relPath) throws RepositoryException {\n                 filter(iterator, new Predicate<Tree>() {\n                     @Override\n                     public boolean apply(Tree tree) {\n-                        return !tree.getName().startsWith(\":\");\n+                        return tree.exists();\n                     }\n                 }),\n                 new Function<Tree, NodeDelegate>() {\n@@ -447,7 +447,6 @@ public void removeMixin(String typeName) throws RepositoryException {\n     /**\n      * Set a property\n      *\n-     * @param propertyState\n      * @return the set property\n      */\n     @Nonnull\n@@ -824,7 +823,7 @@ private Tree internalAddChild(\n     @Nonnull // FIXME this should be package private. OAK-672\n     public Tree getTree() throws InvalidItemStateException {\n         if (!tree.exists()) {\n-            throw new InvalidItemStateException(\"Item is stale\");\n+            throw new InvalidItemStateException(\"Item is stale \" + tree.getPath());\n         }\n         return tree;\n     }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "1081",
        "nb_skipped": 3,
        "commit": "4ce4e3c9",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1811,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.segment.RecordTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeState.java\nindex fe5221b005..9eb6cd9ef4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeState.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeState.java\n@@ -116,10 +116,14 @@ public boolean hasProperty(String name) {\n     public PropertyState getProperty(String name) {\n         checkNotNull(name);\n         Template template = getTemplate();\n+        PropertyState property = null;\n         if (JCR_PRIMARYTYPE.equals(name)) {\n-            return template.getPrimaryType();\n+            property = template.getPrimaryType();\n         } else if (JCR_MIXINTYPES.equals(name)) {\n-            return template.getMixinTypes();\n+            property = template.getMixinTypes();\n+        }\n+        if (property != null) {\n+            return property;\n         }\n \n         PropertyTemplate propertyTemplate =\n",
        "project": "jackrabbit-oak",
        "linesAdd": 6,
        "jira_id": "1916",
        "nb_skipped": 9,
        "commit": "705ce1d1",
        "nb_failure": 2,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 424,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.nodetype.NodeTypeTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemImpl.java\nindex a584c106be..efde490678 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemImpl.java\n@@ -169,7 +169,14 @@ void checkStatus() throws RepositoryException {\n     }\n \n     void checkProtected() throws RepositoryException {\n-        ItemDefinition definition = (isNode()) ? ((Node) this).getDefinition() : ((Property) this).getDefinition();\n+        ItemDefinition definition;\n+        try {\n+            definition = (isNode()) ? ((Node) this).getDefinition() : ((Property) this).getDefinition();\n+        }\n+        catch (RepositoryException ignore) {\n+            // No definition -> not protected but a different error which should be handled else where\n+            return;\n+        }\n         checkProtected(definition);\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 7,
        "jira_id": "479",
        "nb_skipped": 4,
        "commit": "3270e761",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 206,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.segment.CheckpointTest"
        ],
        "patch": "diff --git a/oak-segment/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java b/oak-segment/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java\nindex 2191a61d95..c5efa1aab1 100644\n--- a/oak-segment/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java\n+++ b/oak-segment/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java\n@@ -416,7 +416,11 @@ public Boolean call() {\n             }\n \n             NodeBuilder cp = checkpoints.child(name);\n+            if (Long.MAX_VALUE - now > lifetime) {\n                 cp.setProperty(\"timestamp\", now + lifetime);\n+            } else {\n+                cp.setProperty(\"timestamp\", Long.MAX_VALUE);\n+            }\n             cp.setProperty(\"created\", now);\n \n             NodeBuilder props = cp.setChildNode(\"properties\");\n",
        "project": "jackrabbit-oak",
        "linesAdd": 4,
        "jira_id": "4423",
        "nb_skipped": 7,
        "commit": "275eca83",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 144,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.segment.SegmentBufferWriterPoolTest"
        ],
        "patch": "diff --git a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentBufferWriterPool.java b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentBufferWriterPool.java\nindex c035323e22..610b3ca55a 100644\n--- a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentBufferWriterPool.java\n+++ b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentBufferWriterPool.java\n@@ -34,6 +34,8 @@\n import javax.annotation.Nonnull;\n \n import com.google.common.base.Supplier;\n+import com.google.common.util.concurrent.Monitor;\n+import com.google.common.util.concurrent.Monitor.Guard;\n \n /**\n  * This {@link WriteOperationHandler} uses a pool of {@link SegmentBufferWriter}s,\n@@ -43,8 +45,27 @@\n  * {@link SegmentWriter}.\n  */\n public class SegmentBufferWriterPool implements WriteOperationHandler {\n+\n+    /**\n+     * Monitor protecting the state of this pool. Neither of {@link #writers},\n+     * {@link #borrowed} and {@link #disposed} must be modified without owning\n+     * this monitor.\n+     */\n+    private final Monitor poolMonitor = new Monitor(true);\n+\n+    /**\n+     * Pool of current writers that are not in use\n+     */\n     private final Map<Object, SegmentBufferWriter> writers = newHashMap();\n+\n+    /**\n+     * Writers that are currently in use\n+     */\n     private final Set<SegmentBufferWriter> borrowed = newHashSet();\n+\n+    /**\n+     * Retired writers that have not yet been flushed\n+     */\n     private final Set<SegmentBufferWriter> disposed = newHashSet();\n \n     @Nonnull\n@@ -95,21 +116,82 @@ public RecordId execute(WriteOperation writeOperation) throws IOException {\n     @Override\n     public void flush() throws IOException {\n         List<SegmentBufferWriter> toFlush = newArrayList();\n-        synchronized (this) {\n+        List<SegmentBufferWriter> toReturn = newArrayList();\n+\n+        poolMonitor.enter();\n+        try {\n+            // Collect all writers that are not currently in use and clear\n+            // the list so they won't get re-used anymore.\n             toFlush.addAll(writers.values());\n-            toFlush.addAll(disposed);\n             writers.clear();\n-            disposed.clear();\n+\n+            // Collect all borrowed writers, which we need to wait for.\n+            // Clear the list so they will get disposed once returned.\n+            toReturn.addAll(borrowed);\n             borrowed.clear();\n+        } finally {\n+            poolMonitor.leave();\n+        }\n+\n+        // Wait for the return of the borrowed writers. This is the\n+        // case once all of them appear in the disposed set.\n+        if (safeEnterWhen(poolMonitor, allReturned(toReturn))) {\n+            try {\n+                // Collect all disposed writers and clear the list to mark them\n+                // as flushed.\n+                toFlush.addAll(toReturn);\n+                disposed.removeAll(toReturn);\n+            } finally {\n+                poolMonitor.leave();\n+            }\n         }\n-        // Call flush from outside a synchronized context to avoid\n+\n+        // Call flush from outside the pool monitor to avoid potential\n         // deadlocks of that method calling SegmentStore.writeSegment\n         for (SegmentBufferWriter writer : toFlush) {\n             writer.flush();\n         }\n     }\n \n-    private synchronized SegmentBufferWriter borrowWriter(Object key) {\n+    /**\n+     * Create a {@code Guard} that is satisfied if and only if {@link #disposed}\n+     * contains all items in {@code toReturn}\n+     */\n+    @Nonnull\n+    private Guard allReturned(final List<SegmentBufferWriter> toReturn) {\n+        return new Guard(poolMonitor) {\n+\n+            @Override\n+            public boolean isSatisfied() {\n+                return disposed.containsAll(toReturn);\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Same as {@code monitor.enterWhen(guard)} but copes with that pesky {@code\n+     * InterruptedException} by catching it and setting this thread's\n+     * interrupted flag.\n+     */\n+    private static boolean safeEnterWhen(Monitor monitor, Guard guard) {\n+        try {\n+            monitor.enterWhen(guard);\n+            return true;\n+        } catch (InterruptedException ignore) {\n+            Thread.currentThread().interrupt();\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Return a writer from the pool by its {@code key}. This method may return\n+     * a fresh writer at any time. Callers need to return a writer before\n+     * borrowing it again. Failing to do so leads to undefined behaviour.\n+     */\n+    private SegmentBufferWriter borrowWriter(Object key) {\n+        poolMonitor.enter();\n+        try {\n             SegmentBufferWriter writer = writers.remove(key);\n             if (writer == null) {\n                 writer = new SegmentBufferWriter(store, tracker, reader, version, getWriterId(wid), gcGeneration.get());\n@@ -119,15 +201,27 @@ private synchronized SegmentBufferWriter borrowWriter(Object key) {\n             }\n             borrowed.add(writer);\n             return writer;\n+        } finally {\n+            poolMonitor.leave();\n+        }\n     }\n \n-    private synchronized void returnWriter(Object key, SegmentBufferWriter writer) {\n+    /**\n+     * Return a writer to the pool using the {@code key} that was used to borrow\n+     * it.\n+     */\n+    private void returnWriter(Object key, SegmentBufferWriter writer) {\n+        poolMonitor.enter();\n+        try {\n             if (borrowed.remove(writer)) {\n                 checkState(writers.put(key, writer) == null);\n             } else {\n                 // Defer flush this writer as it was borrowed while flush() was called.\n                 disposed.add(writer);\n             }\n+        } finally {\n+            poolMonitor.leave();\n+        }\n     }\n \n     private String getWriterId(String wid) {\ndiff --git a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/WriteOperationHandler.java b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/WriteOperationHandler.java\nindex 1a585c09a2..b122a0a6d5 100644\n--- a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/WriteOperationHandler.java\n+++ b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/WriteOperationHandler.java\n@@ -58,9 +58,6 @@\n \n     /**\n      * Flush any pending changes on any {@link SegmentBufferWriter} managed by this instance.\n-     * This method <em>does not block</em> to wait for concurrent write operations. However, if\n-     * a write operation is currently in progress a call to this method ensures the respective\n-     * changes are properly flushed at the end of that call.\n      * @throws IOException\n      */\n     void flush() throws IOException;\n",
        "project": "jackrabbit-oak",
        "linesAdd": 59,
        "jira_id": "4291",
        "nb_skipped": 1,
        "commit": "cdb34ffc",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 326,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.OakDirectoryTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\nindex 50c7f9e51e..2e137d5158 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\n@@ -91,7 +91,7 @@ public OakDirectory(NodeBuilder builder, IndexDefinition definition, boolean rea\n     public OakDirectory(NodeBuilder builder, String dataNodeName, IndexDefinition definition, boolean readOnly) {\n         this.lockFactory = NoLockFactory.getNoLockFactory();\n         this.builder = builder;\n-        this.directoryBuilder = builder.child(dataNodeName);\n+        this.directoryBuilder = readOnly ? builder.getChildNode(dataNodeName) : builder.child(dataNodeName);\n         this.definition = definition;\n         this.readOnly = readOnly;\n         this.fileNames.addAll(getListing());\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "3920",
        "nb_skipped": 3,
        "commit": "99996c25",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 379,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.mk.index.IndexTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/Indexer.java b/oak-core/src/main/java/org/apache/jackrabbit/mk/index/Indexer.java\nindex 6b2a935dc0..be48a2818f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/Indexer.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/mk/index/Indexer.java\n@@ -299,6 +299,7 @@ public String updateEnd(String toRevision) {\n     /**\n      * Update the index with the given changes.\n      *\n+     * @param rootPath the root path\n      * @param t the changes\n      * @param lastRevision\n      */\n@@ -309,6 +310,7 @@ public void updateIndex(String rootPath, JsopReader t, String lastRevision) {\n                 break;\n             }\n             String path = PathUtils.concat(rootPath, t.readString());\n+            String target;\n             switch (r) {\n             case '+': {\n                 t.read(':');\n@@ -327,8 +329,16 @@ public void updateIndex(String rootPath, JsopReader t, String lastRevision) {\n                 }\n                 break;\n             }\n+            case '*':\n+                // TODO support and test copy operation (\"*\"),\n+                // specially in combination with other operations\n+                // possibly split up the commit in this case\n+                t.read(':');\n+                target = t.readString();\n+                moveOrCopyNode(path, false, target, lastRevision);\n+                break;\n             case '-':\n-                moveNode(path, null, lastRevision);\n+                moveOrCopyNode(path, true, null, lastRevision);\n                 break;\n             case '^': {\n                 removeProperty(path, lastRevision);\n@@ -342,9 +352,12 @@ public void updateIndex(String rootPath, JsopReader t, String lastRevision) {\n                 break;\n             }\n             case '>':\n+                // TODO does move work correctly\n+                // in combination with other operations?\n+                // possibly split up the commit in this case\n                 t.read(':');\n                 String name = PathUtils.getName(path);\n-                String target, position;\n+                String position;\n                 if (t.matches('{')) {\n                     position = t.readString();\n                     t.read(':');\n@@ -364,7 +377,7 @@ public void updateIndex(String rootPath, JsopReader t, String lastRevision) {\n                 } else {\n                     throw ExceptionFactory.get(\"position: \" + position);\n                 }\n-                moveNode(path, target, lastRevision);\n+                moveOrCopyNode(path, true, target, lastRevision);\n                 break;\n             default:\n                 throw new AssertionError(\"token: \" + (char) t.getTokenType());\n@@ -430,7 +443,7 @@ private void addProperty(String path, String value) {\n         }\n     }\n \n-    private void moveNode(String sourcePath, String targetPath, String lastRevision) {\n+    private void moveOrCopyNode(String sourcePath, boolean remove, String targetPath, String lastRevision) {\n         if (isInIndex(sourcePath)) {\n             // don't index the index\n             return;\n@@ -444,7 +457,9 @@ private void moveNode(String sourcePath, String targetPath, String lastRevision)\n         NodeMap map = new NodeMap();\n         t.read('{');\n         NodeImpl n = NodeImpl.parse(map, t, 0, sourcePath);\n+        if (remove) {\n             addOrRemoveRecursive(n, true, false);\n+        }\n         if (targetPath != null) {\n             t = new JsopTokenizer(node);\n             map = new NodeMap();\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/mk/simple/SimpleKernelImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/mk/simple/SimpleKernelImpl.java\nindex 87c2a96ea0..185731e6a3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/mk/simple/SimpleKernelImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/mk/simple/SimpleKernelImpl.java\n@@ -278,18 +278,20 @@ private String doCommit(String rootPath, JsopReader t, String revisionId, String\n                 break;\n             }\n             case '*': {\n-                // TODO is it really required?\n                 // TODO possibly support target position notation\n-                // TODO support copy in wrappers, index,...\n                 t.read(':');\n                 String target = t.readString();\n-                diff.tag('*').key(path).value(target);\n                 if (!PathUtils.isAbsolute(target)) {\n                     target = PathUtils.concat(rootPath, target);\n                 }\n-                NodeImpl node = data.getNode(from);\n+                diff.tag('*').key(path).value(target);\n                 String to = PathUtils.relativize(\"/\", target);\n-                data = data.cloneAndAddChildNode(to, false, null, node, rev);\n+                NodeImpl node = data.getNode(from);\n+                JsopStream json = new JsopStream();\n+                node.append(json, Integer.MAX_VALUE, 0, Integer.MAX_VALUE, false);\n+                json.read('{');\n+                NodeImpl n2 = NodeImpl.parse(nodeMap, json, rev);\n+                data = data.cloneAndAddChildNode(to, false, null, n2, rev);\n                 break;\n             }\n             default:\n@@ -555,6 +557,7 @@ public synchronized void dispose() {\n         }\n     }\n \n+    @Override\n     public String toString() {\n         return \"simple:\" + name;\n     }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 20,
        "jira_id": "47",
        "nb_skipped": 0,
        "commit": "b62f1c26",
        "nb_failure": 2,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2209,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.segment.file.ExternalBlobReferenceTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\nindex abab3d489f..ab762f7bd4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n@@ -595,7 +595,12 @@ private synchronized RecordId writeValueRecord(String reference) {\n         byte[] data = reference.getBytes(Charsets.UTF_8);\n         int length = data.length;\n \n-        checkArgument(length < 8192);\n+        // When writing a binary ID, the four most significant bits of the\n+        // length field should be \"1110\", leaving 12 other bits to store the\n+        // length itself. This means that the values of the length field can\n+        // only range between 0 and 2^12 - 1.\n+\n+        checkArgument(length < 4096);\n \n         RecordId id = prepare(RecordType.VALUE, 2 + length);\n         int len = length | 0xE000;\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "3105",
        "nb_skipped": 1,
        "commit": "311e8b33",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1932,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.strategy.OrderedContentMirrorStorageStrategyTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedIndex.java\nindex ba92511621..96f4cd3e8d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedIndex.java\n@@ -136,12 +136,12 @@ public static boolean isAscending(NodeState indexMeta) {\n      *  <dt>lane 3:</dt> <dd>0.1%</dd>\n      * </dl>\n      */\n-    double DEFAULT_PROBABILITY = 0.1;\n+    double DEFAULT_PROBABILITY = Integer.getInteger(\"oak.orderedIndex.prob\", 3) / 10.0;\n     \n     /**\n      * the number of lanes used in the SkipList \n      */\n-    int LANES = 4;\n+    int LANES = Integer.getInteger(\"oak.orderedIndex.lanes\", 15);\n     \n     /**\n      * Convenience Predicate that will force the implementor to expose what we're searching for\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\nindex e039c0d4de..ce158a218f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n@@ -23,6 +23,7 @@\n \n import java.io.UnsupportedEncodingException;\n import java.net.URLEncoder;\n+import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Deque;\n import java.util.Iterator;\n@@ -51,7 +52,6 @@\n \n import com.google.common.base.Charsets;\n import com.google.common.base.Strings;\n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n \n@@ -867,10 +867,13 @@ String seek(@Nonnull final NodeBuilder index,\n             LOG.debug(\"seek() - plain case\");\n             \n             lane = OrderedIndex.LANES - 1;\n-            \n+            NodeBuilder currentNode = null;\n             do {\n                 stillLaning = lane > 0;\n-                nextkey = getPropertyNext(index.getChildNode(currentKey), lane);\n+                if (currentNode == null) {\n+                    currentNode = index.getChildNode(currentKey);\n+                }\n+                nextkey = getPropertyNext(currentNode, lane);\n                 if ((Strings.isNullOrEmpty(nextkey) || !walkingPredicate.apply(nextkey)) && lane > 0) {\n                     // if we're currently pointing to NIL or the next element does not fit the search\n                     // but we still have lanes left, let's lower the lane;\n@@ -880,6 +883,7 @@ String seek(@Nonnull final NodeBuilder index,\n                         found = nextkey;\n                     } else {\n                         currentKey = nextkey;\n+                        currentNode = null;\n                         if (keepWalked && !Strings.isNullOrEmpty(currentKey)) {\n                             for (int l = lane; l >= 0; l--) {\n                                 walkedLanes[l] = currentKey;\n@@ -1072,12 +1076,18 @@ public boolean hasNext() {\n      */\n     static void setPropertyNext(@Nonnull final NodeBuilder node, final String... next) {\n         if (node != null && next != null) {\n-            String n1 = (next.length > 0) ? next[0] : \"\";\n-            String n2 = (next.length > 1) ? next[1] : \"\";\n-            String n3 = (next.length > 2) ? next[2] : \"\";\n-            String n4 = (next.length > 3) ? next[3] : \"\";\n-            \n-            node.setProperty(NEXT, ImmutableList.of(n1, n2, n3, n4), Type.STRINGS);\n+            int len = next.length - 1;\n+            for (; len >= 0; len--) {\n+                if (next[len].length() != 0) {\n+               \t    break;\n+                }\n+            }\n+            len++;\n+            List<String> list = new ArrayList<String>(len);\n+            for (int i = 0; i < len; i++) {\n+                list.add(next[i]);\n+            }\n+            node.setProperty(NEXT, list, Type.STRINGS);\n         }\n     }\n     \n@@ -1102,7 +1112,7 @@ static void setPropertyNext(@Nonnull final NodeBuilder node,\n                         // content\n                         LOG.debug(\"topping-up the number of lanes.\");\n                         List<String> vv = Lists.newArrayList(values);\n-                        for (int i = vv.size(); i <= OrderedIndex.LANES; i++) {\n+                        for (int i = vv.size(); i < OrderedIndex.LANES; i++) {\n                             vv.add(\"\");\n                         }\n                         values = vv.toArray(new String[vv.size()]);\n@@ -1151,7 +1161,10 @@ static String getPropertyNext(@Nonnull final NodeBuilder node, final int lane) {\n         PropertyState ps = node.getProperty(NEXT);\n         if (ps != null) {\n             if (ps.isArray()) {\n-                next = ps.getValue(Type.STRING, Math.min(ps.count() - 1, lane));\n+                int count = ps.count();\n+                if (count > 0 && count > lane) {\n+                    next = ps.getValue(Type.STRING, lane);\n+                }\n             } else {\n                 next = ps.getValue(Type.STRING);\n             }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 26,
        "jira_id": "2147",
        "nb_skipped": 1,
        "commit": "a1556c30",
        "nb_failure": 9,
        "linesRem": 13,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 354,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.SuggestionIntervalTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\nindex c49902cdb2..fb79cc774e 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\n@@ -245,6 +245,12 @@ void closeWriter() throws IOException {\n             getWriter();\n         }\n \n+        boolean updateSuggestions = shouldUpdateSuggestions();\n+        if (writer == null && updateSuggestions) {\n+            log.debug(\"Would update suggester dictionary although no index changes were detected in current cycle\");\n+            getWriter();\n+        }\n+\n         if (writer != null) {\n             if (log.isTraceEnabled()) {\n                 trackIndexSizeInfo(writer, definition, directory);\n@@ -252,8 +258,14 @@ void closeWriter() throws IOException {\n \n             final long start = PERF_LOGGER.start();\n \n-            updateSuggester(writer.getAnalyzer());\n+            Calendar lastUpdated = null;\n+            if (updateSuggestions) {\n+                lastUpdated = updateSuggester(writer.getAnalyzer());\n                 PERF_LOGGER.end(start, -1, \"Completed suggester for directory {}\", definition);\n+            }\n+            if (lastUpdated == null) {\n+                lastUpdated = getCalendar();\n+            }\n \n             writer.close();\n             PERF_LOGGER.end(start, -1, \"Closed writer for directory {}\", definition);\n@@ -265,8 +277,9 @@ void closeWriter() throws IOException {\n             //as to make IndexTracker detect changes when index\n             //is stored in file system\n             NodeBuilder status = definitionBuilder.child(\":status\");\n-            status.setProperty(\"lastUpdated\", ISO8601.format(getCalendar()), Type.DATE);\n+            status.setProperty(\"lastUpdated\", ISO8601.format(lastUpdated), Type.DATE);\n             status.setProperty(\"indexedNodes\", indexedNodes);\n+\n             PERF_LOGGER.end(start, -1, \"Overall Closed IndexWriter for directory {}\", definition);\n \n             textExtractionStats.log(reindex);\n@@ -278,38 +291,69 @@ void closeWriter() throws IOException {\n      * eventually update suggest dictionary\n      * @throws IOException if suggest dictionary update fails\n      * @param analyzer the analyzer used to update the suggester\n+     * @return {@link Calendar} object representing the lastUpdated value written by suggestions\n      */\n-    private void updateSuggester(Analyzer analyzer) throws IOException {\n-\n-        if (definition.isSuggestEnabled()) {\n-\n-            boolean updateSuggester = false;\n+    private Calendar updateSuggester(Analyzer analyzer) throws IOException {\n+        Calendar ret = null;\n         NodeBuilder suggesterStatus = definitionBuilder.child(\":suggesterStatus\");\n-            if (suggesterStatus.hasProperty(\"lastUpdated\")) {\n-                PropertyState suggesterLastUpdatedValue = suggesterStatus.getProperty(\"lastUpdated\");\n-                Calendar suggesterLastUpdatedTime = ISO8601.parse(suggesterLastUpdatedValue.getValue(Type.DATE));\n-                int updateFrequency = definition.getSuggesterUpdateFrequencyMinutes();\n-                suggesterLastUpdatedTime.add(Calendar.MINUTE, updateFrequency);\n-                if (getCalendar().after(suggesterLastUpdatedTime)) {\n-                    updateSuggester = true;\n-                }\n-            } else {\n-                updateSuggester = true;\n-            }\n-\n-            if (updateSuggester) {\n         DirectoryReader reader = DirectoryReader.open(writer, false);\n         final OakDirectory suggestDirectory = new OakDirectory(definitionBuilder, \":suggest-data\", definition, false);\n         try {\n             SuggestHelper.updateSuggester(suggestDirectory, analyzer, reader);\n-                    suggesterStatus.setProperty(\"lastUpdated\", ISO8601.format(getCalendar()), Type.DATE);\n+            ret = getCalendar();\n+            suggesterStatus.setProperty(\"lastUpdated\", ISO8601.format(ret), Type.DATE);\n         } catch (Throwable e) {\n             log.warn(\"could not update suggester\", e);\n         } finally {\n             suggestDirectory.close();\n             reader.close();\n         }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * Checks if last suggestion build time was done sufficiently in the past AND that there were non-zero indexedNodes\n+     * stored in the last run. Note, if index is updated only to rebuild suggestions, even then we update indexedNodes,\n+     * which would be zero in case it was a forced update of suggestions.\n+     * @return is suggest dict should be updated\n+     */\n+    private boolean shouldUpdateSuggestions() {\n+        boolean updateSuggestions = false;\n+\n+        if (definition.isSuggestEnabled()) {\n+            NodeBuilder suggesterStatus = definitionBuilder.child(\":suggesterStatus\");\n+\n+            PropertyState suggesterLastUpdatedValue = suggesterStatus.getProperty(\"lastUpdated\");\n+\n+            if (suggesterLastUpdatedValue != null) {\n+                Calendar suggesterLastUpdatedTime = ISO8601.parse(suggesterLastUpdatedValue.getValue(Type.DATE));\n+\n+                int updateFrequency = definition.getSuggesterUpdateFrequencyMinutes();\n+                Calendar nextSuggestUpdateTime = (Calendar)suggesterLastUpdatedTime.clone();\n+                nextSuggestUpdateTime.add(Calendar.MINUTE, updateFrequency);\n+                if (getCalendar().after(nextSuggestUpdateTime)) {\n+                    updateSuggestions = (writer != null || isIndexUpdatedAfter(suggesterLastUpdatedTime));\n+                }\n+            } else {\n+                updateSuggestions = true;\n+            }\n+        }\n+\n+        return updateSuggestions;\n     }\n+\n+    /**\n+     * @return {@code false} if persisted lastUpdated time for index is after {@code calendar}. {@code true} otherwise\n+     */\n+    private boolean isIndexUpdatedAfter(Calendar calendar) {\n+        NodeBuilder indexStats = definitionBuilder.child(\":status\");\n+        PropertyState indexLastUpdatedValue = indexStats.getProperty(\"lastUpdated\");\n+        if (indexLastUpdatedValue != null) {\n+            Calendar indexLastUpdatedTime = ISO8601.parse(indexLastUpdatedValue.getValue(Type.DATE));\n+            return indexLastUpdatedTime.after(calendar);\n+        } else {\n+            return true;\n         }\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 55,
        "jira_id": "4066",
        "nb_skipped": 6,
        "commit": "9a109aa3",
        "nb_failure": 1,
        "linesRem": 21,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3097,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.CommitTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\nindex fc7cd5adb4..d24876f52b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n@@ -523,7 +523,8 @@ private void checkConflicts(@Nonnull UpdateOp op,\n             String conflictMessage = null;\n             Revision conflictRevision = newestRev;\n             if (newestRev == null) {\n-                if ((op.isDelete() || !op.isNew()) && isConflicting(before, op)) {\n+                if ((op.isDelete() || !op.isNew())\n+                        && !allowConcurrentAddRemove(before, op)) {\n                     conflictMessage = \"The node \" +\n                             op.getId() + \" does not exist or is already deleted\";\n                     if (before != null && !before.getLocalDeleted().isEmpty()) {\n@@ -531,7 +532,7 @@ private void checkConflicts(@Nonnull UpdateOp op,\n                     }\n                 }\n             } else {\n-                if (op.isNew() && isConflicting(before, op)) {\n+                if (op.isNew() && !allowConcurrentAddRemove(before, op)) {\n                     conflictMessage = \"The node \" +\n                             op.getId() + \" was already added in revision\\n\" +\n                             formatConflictRevision(newestRev);\n@@ -615,6 +616,25 @@ private boolean isConflicting(@Nullable NodeDocument doc,\n                 nodeStore.getEnableConcurrentAddRemove());\n     }\n \n+    /**\n+     * Checks whether a concurrent add/remove operation is allowed with the\n+     * given before document and update operation. This method will first check\n+     * if the concurrent add/remove feature is enable and return {@code false}\n+     * immediately if it is disabled. Only when enabled will this method check\n+     * if there is a conflict based on the given document and update operation.\n+     * See also {@link #isConflicting(NodeDocument, UpdateOp)}.\n+     *\n+     * @param before the contents of the document before the update.\n+     * @param op the update to perform.\n+     * @return {@code true} is a concurrent add/remove update is allowed;\n+     *      {@code false} otherwise.\n+     */\n+    private boolean allowConcurrentAddRemove(@Nullable NodeDocument before,\n+                                             @Nonnull UpdateOp op) {\n+        return nodeStore.getEnableConcurrentAddRemove()\n+                && !isConflicting(before, op);\n+    }\n+\n     /**\n      * @return the branch if this is a branch commit, otherwise {@code null}.\n      */\n",
        "project": "jackrabbit-oak",
        "linesAdd": 9,
        "jira_id": "3733",
        "nb_skipped": 1,
        "commit": "a5ff019e",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1870,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.ValueMapTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java\nindex 7b1bec62ac..259474ded0 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java\n@@ -18,9 +18,12 @@\n \n import java.util.AbstractMap;\n import java.util.AbstractSet;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.SortedMap;\n@@ -32,6 +35,7 @@\n \n import com.google.common.base.Objects;\n import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n \n /**\n  * A value map contains the versioned values of a property. The key into this\n@@ -61,9 +65,32 @@\n                 if (map.isEmpty()) {\n                     docs = doc.getPreviousDocs(property, null).iterator();\n                 } else {\n-                    docs = Iterators.concat(\n-                            Iterators.singletonIterator(doc),\n-                            doc.getPreviousDocs(property, null).iterator());\n+                    // merge sort local map into maps of previous documents\n+                    List<Iterator<NodeDocument>> iterators = \n+                            new ArrayList<Iterator<NodeDocument>>(2);\n+                    iterators.add(Iterators.singletonIterator(doc));\n+                    iterators.add(doc.getPreviousDocs(property, null).iterator());                            \n+                    docs = Iterators.mergeSorted(iterators, new Comparator<NodeDocument>() {\n+                                @Override\n+                                public int compare(NodeDocument o1,\n+                                                   NodeDocument o2) {\n+                                    Revision r1 = getFirstRevision(o1);\n+                                    Revision r2 = getFirstRevision(o2);\n+                                    return c.compare(r1, r2);\n+                                }\n+                            \n+                                private Revision getFirstRevision(NodeDocument d) {\n+                                    Map<Revision, String> values;\n+                                    if (Objects.equal(d.getId(), doc.getId())) {\n+                                        // return local map for main document\n+                                        values = d.getLocalMap(property);\n+                                    } else {\n+                                        values = d.getValueMap(property);\n+                                    }\n+                                    return values.keySet().iterator().next();\n+                                }\n+                        \n+                            });\n                 }\n \n                 return new MergeSortedIterators<Map.Entry<Revision, String>>(\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MergeSortedIterators.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MergeSortedIterators.java\nindex 48bed082ee..3cb3dc5093 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MergeSortedIterators.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MergeSortedIterators.java\n@@ -100,7 +100,9 @@ private void fetchNextIterator() {\n             PeekingIterator<T> pIt = Iterators.peekingIterator(it);\n             if (!iterators.isEmpty()\n                     &&  comparator.compare(pIt.peek(), lastPeek) < 0) {\n-                throw new IllegalStateException(description() + \" First element of next iterator must be greater than previous iterator\");\n+                throw new IllegalStateException(description() + \n+                        \" First element of next iterator (\" + pIt.peek() + \")\" +\n+                        \" must be after previous iterator (\" + lastPeek + \")\");\n             }\n             lastPeek = pIt.peek();\n             iterators.add(pIt);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 31,
        "jira_id": "2433",
        "nb_skipped": 9,
        "commit": "7fca85bf",
        "nb_failure": 0,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 257,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexExclusionQueryTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\nindex 6d8e111a69..c589260f6f 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n@@ -28,6 +28,8 @@\n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.TYPE_PROPERTY_NAME;\n import static org.apache.jackrabbit.oak.plugins.index.lucene.FieldNames.PATH;\n import static org.apache.jackrabbit.oak.plugins.index.lucene.FieldNames.PATH_SELECTOR;\n+import static org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.EXCLUDE_PROPERTY_NAMES;\n+import static org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.INCLUDE_PROPERTY_TYPES;\n import static org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.INDEX_DATA_CHILD_NAME;\n import static org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.PERSISTENCE_FILE;\n import static org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.PERSISTENCE_NAME;\n@@ -56,6 +58,8 @@\n import java.util.Set;\n import java.util.concurrent.atomic.AtomicReference;\n \n+import javax.jcr.PropertyType;\n+\n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.plugins.index.aggregate.NodeAggregator;\n import org.apache.jackrabbit.oak.plugins.index.lucene.util.MoreLikeThisHelper;\n@@ -67,11 +71,11 @@\n import org.apache.jackrabbit.oak.query.fulltext.FullTextTerm;\n import org.apache.jackrabbit.oak.query.fulltext.FullTextVisitor;\n import org.apache.jackrabbit.oak.spi.query.Cursor;\n-import org.apache.jackrabbit.oak.spi.query.Filter;\n-import org.apache.jackrabbit.oak.spi.query.PropertyValues;\n import org.apache.jackrabbit.oak.spi.query.Cursors.PathCursor;\n+import org.apache.jackrabbit.oak.spi.query.Filter;\n import org.apache.jackrabbit.oak.spi.query.Filter.PropertyRestriction;\n import org.apache.jackrabbit.oak.spi.query.IndexRow;\n+import org.apache.jackrabbit.oak.spi.query.PropertyValues;\n import org.apache.jackrabbit.oak.spi.query.QueryIndex;\n import org.apache.jackrabbit.oak.spi.query.QueryIndex.FulltextQueryIndex;\n import org.apache.jackrabbit.oak.spi.state.ChildNodeEntry;\n@@ -329,7 +333,7 @@ public String getPlan(Filter filter, NodeState root) {\n         // we only restrict non-full-text conditions if there is\n         // no relative property in the full-text constraint\n         boolean nonFullTextConstraints = parent.isEmpty();\n-        String plan = getQuery(filter, null, nonFullTextConstraints, analyzer) + \" ft:(\" + ft + \")\";\n+        String plan = getQuery(filter, null, nonFullTextConstraints, analyzer, getIndexDef(root)) + \" ft:(\" + ft + \")\";\n         if (!parent.isEmpty()) {\n             plan += \" parent:\" + parent;\n         }\n@@ -363,7 +367,7 @@ public Cursor query(Filter filter, NodeState root) {\n                     IndexSearcher searcher = new IndexSearcher(reader);\n                     List<LuceneResultRow> rows = new ArrayList<LuceneResultRow>();\n                     Query query = getQuery(filter, reader,\n-                            nonFullTextConstraints, analyzer);\n+                            nonFullTextConstraints, analyzer, getIndexDef(root));\n \n                     // TODO OAK-828\n                     HashSet<String> seenPaths = new HashSet<String>();\n@@ -428,10 +432,11 @@ public Cursor query(Filter filter, NodeState root) {\n      *            path, node type, and so on) should be added to the Lucene\n      *            query\n      * @param analyzer the Lucene analyzer used for building the fulltext query\n+     * @param indexDefinition nodestate that contains the index definition\n      * @return the Lucene query\n      */\n     private static Query getQuery(Filter filter, IndexReader reader,\n-            boolean nonFullTextConstraints, Analyzer analyzer) {\n+            boolean nonFullTextConstraints, Analyzer analyzer, NodeState indexDefinition) {\n         List<Query> qs = new ArrayList<Query>();\n         FullTextExpression ft = filter.getFullTextConstraint();\n         if (ft == null) {\n@@ -461,9 +466,9 @@ private static Query getQuery(Filter filter, IndexReader reader,\n                     throw new RuntimeException(e);\n                 }\n             }\n-        }\n-        else if (nonFullTextConstraints) {\n-            addNonFullTextConstraints(qs, filter, reader, analyzer);\n+        } else if (nonFullTextConstraints) {\n+            addNonFullTextConstraints(qs, filter, reader, analyzer,\n+                    indexDefinition);\n         }\n         if (qs.size() == 0) {\n             return new MatchAllDocsQuery();\n@@ -479,7 +484,7 @@ else if (nonFullTextConstraints) {\n     }\n \n     private static void addNonFullTextConstraints(List<Query> qs,\n-            Filter filter, IndexReader reader, Analyzer analyzer) {\n+            Filter filter, IndexReader reader, Analyzer analyzer, NodeState indexDefinition) {\n         if (!filter.matchesAllTypes()) {\n             addNodeTypeConstraints(qs, filter);\n         }\n@@ -526,11 +531,12 @@ private static void addNonFullTextConstraints(List<Query> qs,\n                 continue;\n             }\n \n-            String name = pr.propertyName;\n-            if (name.contains(\"/\")) {\n-                // lucene cannot handle child-level property restrictions\n+            // check excluded properties and types\n+            if (isExcludedProperty(pr, indexDefinition)) {\n                 continue;\n             }\n+\n+            String name = pr.propertyName;\n             if (\"rep:excerpt\".equals(name)) {\n                 continue;\n             }\n@@ -617,6 +623,44 @@ private static String tokenizeAndPoll(String token, Analyzer analyzer){\n         return token;\n     }\n \n+    private static boolean isExcludedProperty(PropertyRestriction pr,\n+            NodeState definition) {\n+        String name = pr.propertyName;\n+        if (name.contains(\"/\")) {\n+            // lucene cannot handle child-level property restrictions\n+            return true;\n+        }\n+\n+        // check name\n+        for (String e : definition.getStrings(EXCLUDE_PROPERTY_NAMES)) {\n+            if (e.equalsIgnoreCase(name)) {\n+                return true;\n+            }\n+        }\n+\n+        // check type\n+        Integer type = null;\n+        if (pr.first != null) {\n+            type = pr.first.getType().tag();\n+        } else if (pr.last != null) {\n+            type = pr.last.getType().tag();\n+        } else if (pr.list != null && !pr.list.isEmpty()) {\n+            type = pr.list.get(0).getType().tag();\n+        }\n+        if (type != null) {\n+            boolean isIn = false;\n+            for (String e : definition.getStrings(INCLUDE_PROPERTY_TYPES)) {\n+                if (PropertyType.valueFromName(e) == type) {\n+                    isIn = true;\n+                }\n+            }\n+            if (!isIn) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     private static void addReferenceConstraint(String uuid, List<Query> qs,\n             IndexReader reader) {\n         if (reader == null) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 51,
        "jira_id": "1668",
        "nb_skipped": 0,
        "commit": "63070cf9",
        "nb_failure": 2,
        "linesRem": 11,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 467,
        "nb_error": 146,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.principal.PrincipalProviderImplTest",
            "org.apache.jackrabbit.oak.security.authentication.token.TokenAuthenticationTest",
            "org.apache.jackrabbit.oak.security.user.OakAuthorizablePropertyTest",
            "org.apache.jackrabbit.oak.security.authentication.TokenDefaultLoginModuleTest",
            "org.apache.jackrabbit.oak.security.authentication.token.TokenInfoTest",
            "org.apache.jackrabbit.oak.security.authentication.user.UserAuthenticationTest",
            "org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest",
            "org.apache.jackrabbit.oak.spi.security.authentication.external.ExternalLoginModuleTest",
            "org.apache.jackrabbit.oak.security.authentication.DefaultLoginModuleTest",
            "org.apache.jackrabbit.oak.security.authentication.TokenLoginModuleTest",
            "org.apache.jackrabbit.oak.spi.security.user.action.PasswordValidationActionTest",
            "org.apache.jackrabbit.oak.security.user.UserValidatorTest",
            "org.apache.jackrabbit.oak.security.user.UserManagerImplTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/commit/ValidatingHook.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/commit/ValidatingHook.java\nindex b3d10b30d4..7840ecab81 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/commit/ValidatingHook.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/commit/ValidatingHook.java\n@@ -151,7 +151,19 @@ public void propertyDeleted(PropertyState before) {\n \n         @Override\n         public void childNodeAdded(String name, NodeState after) {\n-            childNodeChanged(name, EMPTY_NODE, after);\n+            if (NodeStateUtils.isHidden(name)) {\n+                return;\n+            }\n+            if (exception == null) {\n+                try {\n+                    Validator v = validator.childNodeAdded(name, after);\n+                    if (v != null) {\n+                        validate(v, EMPTY_NODE, after);\n+                    }\n+                } catch (CommitFailedException e) {\n+                    exception = e;\n+                }\n+            }\n         }\n \n         @Override\n@@ -175,7 +187,19 @@ public void childNodeChanged(\n \n         @Override\n         public void childNodeDeleted(String name, NodeState before) {\n-            childNodeChanged(name, before, EMPTY_NODE);\n+            if (NodeStateUtils.isHidden(name)) {\n+                return;\n+            }\n+            if (exception == null) {\n+                try {\n+                    Validator v = validator.childNodeDeleted(name, before);\n+                    if (v != null) {\n+                        validate(v, before, EMPTY_NODE);\n+                    }\n+                } catch (CommitFailedException e) {\n+                    exception = e;\n+                }\n+            }\n         }\n \n     }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 26,
        "jira_id": "478",
        "nb_skipped": 0,
        "commit": "a7f0e808",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1314,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.RepositoryTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/SessionDelegate.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/SessionDelegate.java\nindex 5fd1988431..2cab01a5bd 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/SessionDelegate.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/SessionDelegate.java\n@@ -426,12 +426,12 @@ public ItemDelegate getItem(String path) {\n             return getRootNode();\n         } else {\n             Tree parent = root.getTree(PathUtils.getParentPath(path));\n-            if (parent.hasProperty(name)) {\n-                return new PropertyDelegate(this, parent, name);\n-            }\n+\n             Tree child = parent.getChild(name);\n             if (child.exists()) {\n                 return new NodeDelegate(this, child);\n+            } else if (parent.hasProperty(name)) {\n+                return new PropertyDelegate(this, parent, name);\n             } else {\n                 return null;\n             }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "2238",
        "nb_skipped": 1,
        "commit": "a28098fd",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1445,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.query.FilterTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\nindex 14d8639a81..6eb282ee9b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n@@ -251,6 +251,13 @@ public void restrictProperty(String propertyName, Operator op, PropertyValue v)\n         PropertyValue oldLast = x.last;\n         switch (op) {\n         case EQUAL:\n+            if (x.first != null && x.last == x.first && x.firstIncluding && x.lastIncluding) {\n+                // there is already an equality condition on this property\n+                // we will keep this, as it could be a multi-valued property\n+                // (unlike in databases, \"x = 1 and x = 2\" can match a node\n+                // if x is a multi-valued property with value \"{1, 2}\")\n+                return;\n+            }\n             x.first = maxValue(oldFirst, v);\n             x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\n             x.last = minValue(oldLast, v);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "1108",
        "nb_skipped": 6,
        "commit": "a8c925e0",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 2886,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.NodeDocumentTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex cdff3e131c..e36d1adffa 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -19,6 +19,7 @@\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.NavigableMap;\n@@ -39,6 +40,7 @@\n import com.google.common.collect.AbstractIterator;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Queues;\n import org.apache.jackrabbit.oak.cache.CacheValue;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n@@ -54,7 +56,6 @@\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n-import com.google.common.primitives.Longs;\n \n import static com.google.common.base.Objects.equal;\n import static com.google.common.base.Preconditions.checkArgument;\n@@ -65,6 +66,7 @@\n import static org.apache.jackrabbit.oak.plugins.document.StableRevisionComparator.REVERSE;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation;\n+import static org.apache.jackrabbit.oak.plugins.document.util.Utils.abortingIterable;\n import static org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision;\n \n /**\n@@ -759,18 +761,24 @@ Revision getNewestRevision(final RevisionContext context,\n         }\n         // if we don't have clusterIds, we can use the local changes only\n         boolean fullScan = true;\n-        Iterable<Revision> changes;\n-        if (clusterIds.isEmpty()) {\n-            // baseRev is newer than all previous documents\n-            changes = Iterables.mergeSorted(\n+        Iterable<Revision> changes = Iterables.mergeSorted(\n                 ImmutableList.of(\n                         getLocalRevisions().keySet(),\n                         getLocalCommitRoot().keySet()),\n-                    getLocalRevisions().comparator());\n-        } else {\n+                getLocalRevisions().comparator()\n+        );\n+        if (!clusterIds.isEmpty()) {\n+            // there are some previous documents that potentially\n+            // contain changes after 'lower' revision vector\n             // include previous documents as well (only needed in rare cases)\n             fullScan = false;\n-            changes = getAllChanges();\n+            changes = Iterables.mergeSorted(\n+                    ImmutableList.of(\n+                            changes,\n+                            getChanges(REVISIONS, lower),\n+                            getChanges(COMMIT_ROOT, lower)\n+                    ), getLocalRevisions().comparator()\n+            );\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"getNewestRevision() with changeRev {} on {}, \" +\n                                 \"_revisions {}, _commitRoot {}\",\n@@ -1453,90 +1461,18 @@ NodeDocument findPrevReferencingDoc(Revision revision, int height) {\n      * @return revisions of all changes performed on this document.\n      */\n     Iterable<Revision> getAllChanges() {\n-        final SortedSet<Revision> stack = Sets.newTreeSet(REVERSE);\n-        // initialize with local revisions and commitRoot entries\n-        stack.addAll(getLocalCommitRoot().keySet());\n-        stack.addAll(getLocalRevisions().keySet());\n-        if (getPreviousRanges().isEmpty()) {\n-            return stack;\n-        }\n-        return new Iterable<Revision>() {\n-            @Override\n-            public Iterator<Revision> iterator() {\n-                final Iterator<NodeDocument> previousDocs = getPreviousDocLeaves();\n-                return new AbstractIterator<Revision>() {\n-                    private NodeDocument nextDoc;\n-                    private Revision nextRevision;\n-                    @Override\n-                    protected Revision computeNext() {\n-                        if (stack.isEmpty()) {\n-                            return endOfData();\n-                        }\n-                        Revision next = stack.first();\n-                        stack.remove(next);\n-                        fillStackIfNeeded();\n-                        return next;\n-                    }\n-\n-                    private void fillStackIfNeeded() {\n-                        for (;;) {\n-                            fetchNextDoc();\n-\n-                            // no more changes to compare with\n-                            if (nextDoc == null) {\n-                                return;\n-                            }\n-\n-                            // check if current top revision is still newer than\n-                            // most recent revision of next document\n-                            if (!stack.isEmpty()) {\n-                                Revision top = stack.first();\n-                                if (top.compareRevisionTimeThenClusterId(nextRevision) > 0) {\n-                                    return;\n-                                }\n-                            }\n-\n-                            // if we get here, we need to pull in changes\n-                            // from nextDoc\n-                            Iterables.addAll(stack, nextDoc.getAllChanges());\n-                            nextDoc = null;\n-                            nextRevision = null;\n-                        }\n-                    }\n-\n-                    /**\n-                     * Fetch the next document if {@code nextDoc} is\n-                     * {@code null} and there are more documents.\n-                     */\n-                    private void fetchNextDoc() {\n-                        for (;;) {\n-                            if (nextDoc != null) {\n-                                break;\n-                            }\n-                            if (!previousDocs.hasNext()) {\n-                                // no more previous docs\n-                                break;\n-                            }\n-                            nextDoc = previousDocs.next();\n-                            Iterator<Revision> changes = nextDoc.getAllChanges().iterator();\n-                            if (changes.hasNext()) {\n-                                nextRevision = changes.next();\n-                                break;\n-                            } else {\n-                                // empty document, try next\n-                                nextDoc = null;\n-                            }\n-                        }\n-                    }\n-                };\n-            }\n-        };\n+        RevisionVector empty = new RevisionVector();\n+        return Iterables.mergeSorted(ImmutableList.of(\n+                getChanges(REVISIONS, empty),\n+                getChanges(COMMIT_ROOT, empty)\n+        ), StableRevisionComparator.REVERSE);\n     }\n \n     /**\n      * Returns all changes for the given property back to {@code min} revision\n      * (exclusive). The revisions include committed as well as uncommitted\n-     * changes.\n+     * changes. The returned revisions are sorted in reverse order (newest\n+     * first).\n      *\n      * @param property the name of the property.\n      * @param min the lower bound revision (exclusive).\n@@ -1545,43 +1481,27 @@ private void fetchNextDoc() {\n     @Nonnull\n     Iterable<Revision> getChanges(@Nonnull final String property,\n                                   @Nonnull final RevisionVector min) {\n-        return new Iterable<Revision>() {\n-            @Override\n-            public Iterator<Revision> iterator() {\n-                final Set<Revision> changes = getValueMap(property).keySet();\n-                final Set<Integer> clusterIds = Sets.newHashSet();\n-                for (Revision r : getLocalMap(property).keySet()) {\n-                    clusterIds.add(r.getClusterId());\n-                }\n-                for (Range r : getPreviousRanges().values()) {\n-                    if (min.isRevisionNewer(r.high)) {\n-                        clusterIds.add(r.high.getClusterId());\n-                    }\n-                }\n-                final Iterator<Revision> unfiltered = changes.iterator();\n-                return new AbstractIterator<Revision>() {\n+        Predicate<Revision> p = new Predicate<Revision>() {\n             @Override\n-                    protected Revision computeNext() {\n-                        while (unfiltered.hasNext()) {\n-                            Revision next = unfiltered.next();\n-                            if (min.isRevisionNewer(next)) {\n-                                return next;\n-                            } else {\n-                                // further revisions with this clusterId\n-                                // are older than min revision\n-                                clusterIds.remove(next.getClusterId());\n-                                // no more revisions to check\n-                                if (clusterIds.isEmpty()) {\n-                                    return endOfData();\n+            public boolean apply(Revision input) {\n+                return min.isRevisionNewer(input);\n             }\n+        };\n+        List<Iterable<Revision>> changes = Lists.newArrayList();\n+        changes.add(abortingIterable(getLocalMap(property).keySet(), p));\n+        for (Map.Entry<Revision, Range> e : getPreviousRanges().entrySet()) {\n+            if (min.isRevisionNewer(e.getKey())) {\n+                final NodeDocument prev = getPreviousDoc(e.getKey(), e.getValue());\n+                if (prev != null) {\n+                    changes.add(abortingIterable(prev.getValueMap(property).keySet(), p));\n                 }\n             }\n-                        return endOfData();\n         }\n-                };\n+        if (changes.size() == 1) {\n+            return changes.get(0);\n+        } else {\n+            return Iterables.mergeSorted(changes, StableRevisionComparator.REVERSE);\n         }\n-        };\n-\n     }\n \n     /**\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java\nindex c7a4253749..40ad9bbbab 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java\n@@ -758,4 +758,36 @@ public static long getMinTimestampForDiff(@Nonnull RevisionVector fromRev,\n         }\n         return min;\n     }\n+\n+    /**\n+     * Wraps the given iterable and aborts iteration over elements when the\n+     * predicate on an element evaluates to {@code false}.\n+     *\n+     * @param iterable the iterable to wrap.\n+     * @param p the predicate.\n+     * @return the aborting iterable.\n+     */\n+    public static <T> Iterable<T> abortingIterable(final Iterable<T> iterable,\n+                                                   final Predicate<T> p) {\n+        checkNotNull(iterable);\n+        checkNotNull(p);\n+        return new Iterable<T>() {\n+            @Override\n+            public Iterator<T> iterator() {\n+                final Iterator<T> it = iterable.iterator();\n+                return new AbstractIterator<T>() {\n+                    @Override\n+                    protected T computeNext() {\n+                        if (it.hasNext()) {\n+                            T next = it.next();\n+                            if (p.apply(next)) {\n+                                return next;\n+                            }\n+                        }\n+                        return endOfData();\n+                    }\n+                };\n+            }\n+        };\n+    }\n }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 58,
        "jira_id": "4358",
        "nb_skipped": 1,
        "commit": "74cbba24",
        "nb_failure": 1,
        "linesRem": 101,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1485,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.nodetype.NodeTypeIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndex.java\nindex 8ffa57bc8f..f4f8dfb648 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndex.java\n@@ -48,7 +48,7 @@ public double getCost(Filter filter, NodeState root) {\n             return Double.POSITIVE_INFINITY;\n         }\n         NodeTypeIndexLookup lookup = new NodeTypeIndexLookup(root);\n-        if (lookup.isIndexed(filter.getPath())) {\n+        if (lookup.isIndexed(filter.getPath(), filter)) {\n             return lookup.getCost(filter);\n         } else {\n             return Double.POSITIVE_INFINITY;\n@@ -58,7 +58,7 @@ public double getCost(Filter filter, NodeState root) {\n     @Override\n     public Cursor query(Filter filter, NodeState root) {\n         NodeTypeIndexLookup lookup = new NodeTypeIndexLookup(root);\n-        if (!hasNodeTypeRestriction(filter) || !lookup.isIndexed(filter.getPath())) {\n+        if (!hasNodeTypeRestriction(filter) || !lookup.isIndexed(filter.getPath(), filter)) {\n             throw new IllegalStateException(\n                     \"NodeType index is used even when no index is available for filter \" + filter);\n         }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndexLookup.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndexLookup.java\nindex 9a9316bcd2..e4a61bb21f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndexLookup.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndexLookup.java\n@@ -45,10 +45,10 @@ public NodeTypeIndexLookup(NodeState root) {\n      * @return <code>true</code> if a node type index exists; <code>false</code>\n      *         otherwise.\n      */\n-    public boolean isIndexed(String path) {\n+    public boolean isIndexed(String path, Filter f) {\n         PropertyIndexLookup lookup = new PropertyIndexLookup(root);\n-        if (lookup.isIndexed(JCR_PRIMARYTYPE, path, null)\n-                && lookup.isIndexed(JCR_MIXINTYPES, path, null)) {\n+        if (lookup.isIndexed(JCR_PRIMARYTYPE, path, f)\n+                && lookup.isIndexed(JCR_MIXINTYPES, path, f)) {\n             return true;\n         }\n \n@@ -62,13 +62,13 @@ public boolean isIndexed(String path) {\n \n         NodeState child = root.getChildNode(path.substring(0, slash));\n         return new NodeTypeIndexLookup(child).isIndexed(\n-                path.substring(slash));\n+                path.substring(slash), f);\n     }\n \n     public double getCost(Filter filter) {\n         PropertyIndexLookup lookup = new PropertyIndexLookup(root);\n-        return lookup.getCost(null, JCR_PRIMARYTYPE, newName(filter.getPrimaryTypes()))\n-                + lookup.getCost(null, JCR_MIXINTYPES, newName(filter.getMixinTypes()));\n+        return lookup.getCost(filter, JCR_PRIMARYTYPE, newName(filter.getPrimaryTypes()))\n+                + lookup.getCost(filter, JCR_MIXINTYPES, newName(filter.getMixinTypes()));\n     }\n \n     /**\n",
        "project": "jackrabbit-oak",
        "linesAdd": 8,
        "jira_id": "1269",
        "nb_skipped": 6,
        "commit": "b8fe2ded",
        "nb_failure": 1,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 262,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\nindex b01ff99bf5..1c84164207 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n@@ -206,8 +206,8 @@ public String getIndexName() {\n     public List<IndexPlan> getPlans(Filter filter, List<OrderEntry> sortOrder, NodeState rootState) {\n         Collection<String> indexPaths = new LuceneIndexLookup(rootState).collectIndexNodePaths(filter);\n         List<IndexPlan> plans = Lists.newArrayListWithCapacity(indexPaths.size());\n-        IndexNode indexNode = null;\n         for (String path : indexPaths) {\n+            IndexNode indexNode = null;\n             try {\n                 indexNode = tracker.acquireIndexNode(path);\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "3442",
        "nb_skipped": 4,
        "commit": "17032c50",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2200,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.authorization.accesscontrol.AccessControlManagerImplTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/AccessControlManagerImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/AccessControlManagerImpl.java\nindex 806e992901..0bad785d3d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/AccessControlManagerImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/AccessControlManagerImpl.java\n@@ -22,6 +22,7 @@\n import java.text.ParseException;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.Comparator;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Iterator;\n@@ -47,6 +48,8 @@\n import com.google.common.base.Objects;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.common.primitives.Ints;\n import org.apache.jackrabbit.JcrConstants;\n import org.apache.jackrabbit.api.security.JackrabbitAccessControlList;\n import org.apache.jackrabbit.api.security.JackrabbitAccessControlPolicy;\n@@ -361,7 +364,30 @@ public void removePolicy(@Nullable String absPath, @Nonnull AccessControlPolicy\n         Root r = getLatestRoot();\n \n         Result aceResult = searchAces(principals, r);\n-        List<AccessControlPolicy> effective = new ArrayList<AccessControlPolicy>();\n+        Set<JackrabbitAccessControlList> effective = Sets.newTreeSet(new Comparator<JackrabbitAccessControlList>() {\n+            @Override\n+            public int compare(JackrabbitAccessControlList list1, JackrabbitAccessControlList list2) {\n+                if (list1.equals(list2)) {\n+                    return 0;\n+                } else {\n+                    String p1 = list1.getPath();\n+                    String p2 = list2.getPath();\n+\n+                    if (p1 == null) {\n+                        return -1;\n+                    } else if (p2 == null) {\n+                        return 1;\n+                    } else {\n+                        int depth1 = PathUtils.getDepth(p1);\n+                        int depth2 = PathUtils.getDepth(p2);\n+                        return (depth1 == depth2) ? p1.compareTo(p2) : Ints.compare(depth1, depth2);\n+                    }\n+\n+                }\n+            }\n+        });\n+\n+        Set<String> paths = Sets.newHashSet();\n         for (ResultRow row : aceResult.getRows()) {\n             String acePath = row.getPath();\n             String aclName = Text.getName(Text.getRelativeParent(acePath, 1));\n@@ -373,9 +399,13 @@ public void removePolicy(@Nullable String absPath, @Nonnull AccessControlPolicy\n             }\n \n             String path = (REP_REPO_POLICY.equals(aclName)) ? null : accessControlledTree.getPath();\n-            AccessControlPolicy policy = createACL(path, accessControlledTree, true);\n+            if (paths.contains(path)) {\n+                continue;\n+            }\n+            JackrabbitAccessControlList policy = createACL(path, accessControlledTree, true);\n             if (policy != null) {\n                 effective.add(policy);\n+                paths.add(path);\n             }\n         }\n         return effective.toArray(new AccessControlPolicy[effective.size()]);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 32,
        "jira_id": "3082",
        "nb_skipped": 1,
        "commit": "29e5b734",
        "nb_failure": 2,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 377,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilderTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex e96c9f3483..1facf64de9 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -265,7 +265,7 @@ public void reset(NodeState newBase) {\n         if (this == root) {\n             baseState = checkNotNull(newBase);\n             writeState = new MutableNodeState(baseState);\n-            revision++;\n+            revision = 0;\n         } else {\n             throw new IllegalStateException(\"Cannot reset a non-root builder\");\n         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "421",
        "nb_skipped": 3,
        "commit": "36e70bd7",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 2232,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.segment.RecordIdMapTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/RecordIdMap.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/RecordIdMap.java\nindex 0b6660cac4..fe62ffdc3c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/RecordIdMap.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/RecordIdMap.java\n@@ -29,8 +29,11 @@\n  * A memory optimised map of {@code short} key to {@link RecordId} values.\n  */\n public class RecordIdMap {\n-    private short[] keys;\n-    private RecordId[] values;\n+    private static final short[] NO_KEYS = new short[0];\n+    private static final RecordId[] NO_VALUES = new RecordId[0];\n+\n+    private short[] keys = NO_KEYS;\n+    private RecordId[] values = NO_VALUES;\n \n     /**\n      * Associates {@code key} with {@code value} if not already present\n@@ -39,7 +42,7 @@\n      * @return  {@code true} if added, {@code false} if already present\n      */\n     public boolean put(short key, @Nonnull RecordId value) {\n-        if (keys == null) {\n+        if (keys.length == 0) {\n             keys = new short[1];\n             values = new RecordId[1];\n             keys[0] = key;\n@@ -90,7 +93,7 @@ public RecordId get(short key) {\n      * @return  {@code true} iff {@code key} is present.\n      */\n     public boolean containsKey(short key) {\n-        return keys != null && binarySearch(keys, key) >= 0;\n+        return binarySearch(keys, key) >= 0;\n     }\n \n     /**\n@@ -105,6 +108,7 @@ public int size() {\n      * the natural ordering of shorts.\n      * @param index\n      * @return the key at {@code index}\n+     * @throws ArrayIndexOutOfBoundsException if not {@code 0 <= index < size()}\n      */\n     public short getKey(int index) {\n         return keys[index];\n@@ -115,6 +119,7 @@ public short getKey(int index) {\n      * the natural ordering of shorts.\n      * @param index\n      * @return the value at {@code index}\n+     * @throws ArrayIndexOutOfBoundsException if not {@code 0 <= index < size()}\n      */\n     @Nonnull\n     public RecordId getRecordId(int index) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 7,
        "jira_id": "3123",
        "nb_skipped": 1,
        "commit": "f3c9c818",
        "nb_failure": 0,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 249,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexQueryTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\nindex a16d43763d..467b64dd11 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n@@ -707,7 +707,7 @@ static Query tokenToQuery(String text, String fieldName, Analyzer analyzer, Inde\n                 MultiPhraseQuery mpq = new MultiPhraseQuery();\n                 for(String token: tokens){\n                     if (hasFulltextToken(token)) {\n-                        Term[] terms = extractMatchingTokens(reader, token);\n+                        Term[] terms = extractMatchingTokens(reader, fieldName, token);\n                         if (terms != null && terms.length > 0) {\n                             mpq.add(terms);\n                         }\n@@ -726,7 +726,7 @@ static Query tokenToQuery(String text, String fieldName, Analyzer analyzer, Inde\n         }\n     }\n \n-    private static Term[] extractMatchingTokens(IndexReader reader, String token) {\n+    private static Term[] extractMatchingTokens(IndexReader reader, String fieldName, String token) {\n         if (reader == null) {\n             // getPlan call\n             return null;\n@@ -734,13 +734,14 @@ static Query tokenToQuery(String text, String fieldName, Analyzer analyzer, Inde\n \n         try {\n             List<Term> terms = new ArrayList<Term>();\n-            Terms t = MultiFields.getTerms(reader, FieldNames.FULLTEXT);\n-            Automaton a = WildcardQuery.toAutomaton(newFulltextTerm(token));\n+            Term onTerm = newFulltextTerm(token, fieldName);\n+            Terms t = MultiFields.getTerms(reader, onTerm.field());\n+            Automaton a = WildcardQuery.toAutomaton(onTerm);\n             CompiledAutomaton ca = new CompiledAutomaton(a);\n             TermsEnum te = ca.getTermsEnum(t);\n             BytesRef text;\n             while ((text = te.next()) != null) {\n-                terms.add(newFulltextTerm(text.utf8ToString()));\n+                terms.add(newFulltextTerm(text.utf8ToString(), fieldName));\n             }\n             return terms.toArray(new Term[terms.size()]);\n         } catch (IOException e) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 6,
        "jira_id": "1516",
        "nb_skipped": 1,
        "commit": "7c62bd81",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 326,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\nindex cd4d2c3508..fb69de7418 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n@@ -39,6 +39,7 @@\n import com.google.common.collect.Lists;\n import com.google.common.collect.Queues;\n import com.google.common.collect.Sets;\n+import com.google.common.primitives.Chars;\n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.api.Result.SizePrecision;\n import org.apache.jackrabbit.oak.api.Type;\n@@ -1336,6 +1337,11 @@ static Query tokenToQuery(String text, String fieldName, Analyzer analyzer) {\n         }\n     }\n \n+    /**\n+     * Following chars are used as operators in Lucene Query and should be escaped\n+     */\n+    private static final char[] LUCENE_QUERY_OPERATORS = {':' , '/', '!', '&', '|', '[', ']', '{', '}'};\n+\n     /**\n      * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)\n      */\n@@ -1361,10 +1367,7 @@ static String rewriteQueryText(String textsearch) {\n                     escaped = false;\n                 }\n                 rewritten.append(c);\n-            } else if (c == ':' || c == '/') {\n-                //TODO Some other chars are also considered special See OAK-3769 for details\n-                //':' fields as known in lucene are not supported\n-                //'/' its a special char used for regex search in Lucene\n+            } else if (Chars.contains(LUCENE_QUERY_OPERATORS, c)) {\n                 rewritten.append('\\\\').append(c);\n             } else {\n                 if (escaped) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 4,
        "jira_id": "3879",
        "nb_skipped": 3,
        "commit": "4faf31e3",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 265,
        "nb_error": 16,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest",
            "org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest",
            "org.apache.jackrabbit.oak.plugins.index.old.QueryTest",
            "org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/SecurityProviderImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/SecurityProviderImpl.java\nindex 5e199bf464..6d6487bb54 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/SecurityProviderImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/SecurityProviderImpl.java\n@@ -77,6 +77,11 @@ public LoginContextProvider getLoginContextProvider(NodeStore nodeStore) {\n             loginConfig = new OakConfiguration();\n             Configuration.setConfiguration(loginConfig);\n         }\n+        if (loginConfig.getAppConfigurationEntry(appName) == null) {\n+            log.warn(\"Failed to retrieve login configuration for {}: using default configuration.\", appName);\n+            loginConfig = new OakConfiguration();\n+            Configuration.setConfiguration(loginConfig);\n+        }\n         return new LoginContextProviderImpl(appName, loginConfig, nodeStore, this);\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 5,
        "jira_id": "379",
        "nb_skipped": 7,
        "commit": "621a5101",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 463,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexQueryTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\nindex 2023f2dfc6..0f96b8a6e0 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n@@ -100,6 +100,8 @@\n \n     private boolean propertiesChanged = false;\n \n+    private List<PropertyState> propertiesModified = Lists.newArrayList();\n+\n     private final NodeState root;\n \n     /**\n@@ -222,12 +224,14 @@ public void propertyAdded(PropertyState after) {\n     @Override\n     public void propertyChanged(PropertyState before, PropertyState after) {\n         markPropertyChanged(before.getName());\n+        propertiesModified.add(before);\n         checkAggregates(before.getName());\n     }\n \n     @Override\n     public void propertyDeleted(PropertyState before) {\n         markPropertyChanged(before.getName());\n+        propertiesModified.add(before);\n         checkAggregates(before.getName());\n     }\n \n@@ -333,6 +337,11 @@ private Document makeDocument(String path, NodeState state, boolean isUpdate) {\n         dirty |= indexNullCheckEnabledProps(path, fields, state);\n         dirty |= indexNotNullCheckEnabledProps(path, fields, state);\n         \n+        // Check if a node having a single property was modified/deleted\n+        if (!dirty) {\n+            dirty = indexIfSinglePropertyRemoved();\n+        }\n+\n         if (isUpdate && !dirty) {\n             // updated the state but had no relevant changes\n             return null;\n@@ -579,6 +588,21 @@ private boolean indexNullCheckEnabledProps(String path, List<Field> fields, Node\n         return fieldAdded;\n     }\n     \n+    private boolean indexIfSinglePropertyRemoved() {\n+        boolean dirty = false;\n+        for (PropertyState ps : propertiesModified) {\n+            PropertyDefinition pd = indexingRule.getConfig(ps.getName());\n+            if (pd != null \n+                    && pd.index \n+                    && (pd.includePropertyType(ps.getType().tag()) \n+                            || indexingRule.includePropertyType(ps.getType().tag()))) {\n+                dirty = true;\n+                break;\n+            }\n+        }\n+        return dirty;\n+    }\n+    \n     /**\n      * Determine if the property as defined by PropertyDefinition exists or not.\n      *\n",
        "project": "jackrabbit-oak",
        "linesAdd": 23,
        "jira_id": "2999",
        "nb_skipped": 3,
        "commit": "3bf07779",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 359,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinitionTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\nindex 99018c5490..ed96808591 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n@@ -270,7 +270,7 @@ public IndexDefinition(NodeState root, NodeState defn, @Nullable NodeBuilder def\n         }\n \n         this.maxFieldLength = getOptionalValue(defn, LuceneIndexConstants.MAX_FIELD_LENGTH, DEFAULT_MAX_FIELD_LENGTH);\n-        this.costPerEntry = getOptionalValue(defn, LuceneIndexConstants.COST_PER_ENTRY, 1.0);\n+        this.costPerEntry = getOptionalValue(defn, LuceneIndexConstants.COST_PER_ENTRY, getDefaultCostPerEntry(version));\n         this.costPerExecution = getOptionalValue(defn, LuceneIndexConstants.COST_PER_EXECUTION, 1.0);\n         this.indexesAllTypes = areAllTypesIndexed();\n         this.analyzers = collectAnalyzers(defn);\n@@ -1512,4 +1512,10 @@ public boolean getActiveDeleteEnabled() {\n         return activeDelete >= 0;\n     }\n \n+    private static double getDefaultCostPerEntry(IndexFormatVersion version) {\n+        //For older format cost per entry would be higher as it does a runtime\n+        //aggregation\n+        return version == IndexFormatVersion.V1 ?  1.5 : 1.0;\n+    }\n+\n }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 5,
        "jira_id": "4300",
        "nb_skipped": 6,
        "commit": "06c367af",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2894,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.query.FilterTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\nindex 2e0505fc96..f3d11de3bc 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\n@@ -273,16 +273,6 @@ public void bindSelector(SourceImpl source) {\n \n     @Override\n     public void restrict(FilterImpl f) {\n-        if (propertyName != null) {\n-            if (f.getSelector().equals(selector)) {\n-                String p = propertyName;\n-                if (relativePath != null) {\n-                    p = PathUtils.concat(relativePath, p);\n-                }\n-                p = normalizePropertyName(p);\n-                restrictPropertyOnFilter(p, f);\n-            }\n-        }\n         f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 0,
        "jira_id": "4170",
        "nb_skipped": 1,
        "commit": "2a489d05",
        "nb_failure": 1,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 315,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\nindex e7cec2622b..e7f29cd7d6 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n@@ -1337,7 +1337,7 @@ static Query tokenToQuery(String text, String fieldName, Analyzer analyzer) {\n     /**\n      * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)\n      */\n-    private static String rewriteQueryText(String textsearch) {\n+    static String rewriteQueryText(String textsearch) {\n         // replace escaped ' with just '\n         StringBuilder rewritten = new StringBuilder();\n         // the default lucene query parser recognizes 'AND' and 'NOT' as\n@@ -1346,27 +1346,30 @@ private static String rewriteQueryText(String textsearch) {\n         textsearch = textsearch.replaceAll(\"NOT\", \"not\");\n         boolean escaped = false;\n         for (int i = 0; i < textsearch.length(); i++) {\n-            if (textsearch.charAt(i) == '\\\\') {\n+            char c = textsearch.charAt(i);\n+            if (c == '\\\\') {\n                 if (escaped) {\n                     rewritten.append(\"\\\\\\\\\");\n                     escaped = false;\n                 } else {\n                     escaped = true;\n                 }\n-            } else if (textsearch.charAt(i) == '\\'') {\n+            } else if (c == '\\'') {\n                 if (escaped) {\n                     escaped = false;\n                 }\n-                rewritten.append(textsearch.charAt(i));\n-            } else if (textsearch.charAt(i) == ':') {\n-                // fields as known in lucene are not supported\n-                rewritten.append(\"\\\\:\");\n+                rewritten.append(c);\n+            } else if (c == ':' || c == '/') {\n+                //TODO Some other chars are also considered special See OAK-3769 for details\n+                //':' fields as known in lucene are not supported\n+                //'/' its a special char used for regex search in Lucene\n+                rewritten.append('\\\\').append(c);\n             } else {\n                 if (escaped) {\n                     rewritten.append('\\\\');\n                     escaped = false;\n                 }\n-                rewritten.append(textsearch.charAt(i));\n+                rewritten.append(c);\n             }\n         }\n         return rewritten.toString();\n",
        "project": "jackrabbit-oak",
        "linesAdd": 8,
        "jira_id": "3769",
        "nb_skipped": 3,
        "commit": "306a9e00",
        "nb_failure": 0,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2421,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 420ba29bc3..021cfa27a2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -37,7 +37,6 @@\n import com.google.common.base.Function;\n import com.google.common.base.Predicate;\n import com.google.common.collect.AbstractIterator;\n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterators;\n import com.google.common.collect.Queues;\n import org.apache.jackrabbit.oak.cache.CacheValue;\n@@ -58,6 +57,7 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.collect.Iterables.filter;\n import static com.google.common.collect.Iterables.transform;\n+import static java.util.Collections.reverseOrder;\n import static org.apache.jackrabbit.oak.plugins.document.Collection.NODES;\n import static org.apache.jackrabbit.oak.plugins.document.StableRevisionComparator.REVERSE;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key;\n@@ -740,11 +740,11 @@ public boolean apply(Revision input) {\n \n         Revision newestRev = null;\n         // check local commits first\n-        SortedMap<Revision, String> revisions = getLocalRevisions();\n-        SortedMap<Revision, String> commitRoots = getLocalCommitRoot();\n-        Iterator<Revision> it = filter(Iterables.mergeSorted(\n-                ImmutableList.of(revisions.keySet(), commitRoots.keySet()),\n-                revisions.comparator()), predicate).iterator();\n+        Comparator<Revision> comp = reverseOrder(context.getRevisionComparator());\n+        SortedSet<Revision> revisions = Sets.newTreeSet(comp);\n+        revisions.addAll(getLocalRevisions().keySet());\n+        revisions.addAll(getLocalCommitRoot().keySet());\n+        Iterator<Revision> it = filter(revisions, predicate).iterator();\n         if (it.hasNext()) {\n             newestRev = it.next();\n         } else {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 6,
        "jira_id": "2929",
        "nb_skipped": 1,
        "commit": "a2950285",
        "nb_failure": 2,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2895,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.authorization.permission.TreeTypeProviderTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/TreeTypeProvider.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/TreeTypeProvider.java\nindex 1b1c336373..2aadfd8866 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/TreeTypeProvider.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/TreeTypeProvider.java\n@@ -18,6 +18,7 @@\n \n import javax.annotation.Nonnull;\n \n+import org.apache.jackrabbit.JcrConstants;\n import org.apache.jackrabbit.oak.api.Tree;\n import org.apache.jackrabbit.oak.plugins.version.VersionConstants;\n import org.apache.jackrabbit.oak.spi.security.Context;\n@@ -26,9 +27,8 @@\n \n /**\n  * <h3>TreeTypeProvider</h3>\n-  * For optimization purpose an Immutable tree will be associated with a\n-  * {@code TreeTypeProvider} that allows for fast detection of the following types\n-  * of Trees:\n+ * Allows to distinguish different types of trees based on their name, ancestry\n+ * or primary type. Currently the following types are supported:\n  *\n  * <ul>\n  *     <li>{@link #TYPE_HIDDEN}: a hidden tree whose name starts with \":\".\n@@ -38,6 +38,7 @@\n  *     <li>{@link #TYPE_VERSION}: if a given tree is located within\n  *     any of the version related stores defined by JSR 283. Depending on the\n  *     permission evaluation implementation those items require special treatment.</li>\n+ *     <li>{@link #TYPE_INTERNAL}: repository internal content that is not hidden (e.g. permission store)</li>\n  *     <li>{@link #TYPE_DEFAULT}: the default type for trees that don't\n  *     match any of the upper types.</li>\n  * </ul>\n@@ -55,21 +56,30 @@\n     // hidden trees\n     public static final int TYPE_HIDDEN = 16;\n \n-    private final Context contextInfo;\n+    private final Context authorizationContext;\n \n-    public TreeTypeProvider(@Nonnull Context contextInfo) {\n-        this.contextInfo = contextInfo;\n+    public TreeTypeProvider(@Nonnull Context authorizationContext) {\n+        this.authorizationContext = authorizationContext;\n     }\n \n-    public int getType(Tree tree) {\n+    public int getType(@Nonnull Tree tree) {\n         if (tree.isRoot()) {\n             return TYPE_DEFAULT;\n         } else {\n-            return getType(tree, getType(tree.getParent()));\n+            Tree t = tree;\n+            while (!t.isRoot()) {\n+                int type = getType(t.getName(), t);\n+                // stop walking up the hierarchy as soon as a special type is found\n+                if (TYPE_DEFAULT != type) {\n+                    return type;\n+                }\n+                t = t.getParent();\n+            }\n+            return TYPE_DEFAULT;\n         }\n     }\n \n-    public int getType(Tree tree, int parentType) {\n+    public int getType(@Nonnull Tree tree, int parentType) {\n         if (tree.isRoot()) {\n             return TYPE_DEFAULT;\n         }\n@@ -89,19 +99,24 @@ public int getType(Tree tree, int parentType) {\n                 type = TYPE_AC;\n                 break;\n             default:\n-                    String name = tree.getName();\n+                type = getType(tree.getName(), tree);\n+        }\n+        return type;\n+    }\n+\n+    private int getType(@Nonnull String name, @Nonnull Tree tree) {\n+        int type;\n         if (NodeStateUtils.isHidden(name)) {\n             type = TYPE_HIDDEN;\n         } else if (VersionConstants.VERSION_STORE_ROOT_NAMES.contains(name)) {\n-                        type = TYPE_VERSION;\n+            type = (JcrConstants.JCR_SYSTEM.equals(tree.getParent().getName())) ?  TYPE_VERSION : TYPE_DEFAULT;\n         } else if (PermissionConstants.REP_PERMISSION_STORE.equals(name)) {\n             type = TYPE_INTERNAL;\n-                    } else if (contextInfo.definesContextRoot(tree)) {\n+        } else if (authorizationContext.definesContextRoot(tree)) {\n             type = TYPE_AC;\n         } else {\n             type = TYPE_DEFAULT;\n         }\n-            }\n         return type;\n     }\n }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 24,
        "jira_id": "3530",
        "nb_skipped": 1,
        "commit": "4d231938",
        "nb_failure": 3,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 4,
        "nb_test": 2801,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.MultiPropertyOrTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\nindex 40eca042f3..3ec211f98b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\n@@ -192,7 +192,7 @@ public double getCost(Filter filter, NodeState root) {\n             // not an appropriate index for native search\n             return Double.POSITIVE_INFINITY;\n         }\n-        if (filter.getPropertyRestrictions().isEmpty() && filter.getSelector().getSelectorConstraints().isEmpty()) {\n+        if (filter.getPropertyRestrictions().isEmpty()) {\n             // not an appropriate index for no property restrictions & selector constraints\n             return Double.POSITIVE_INFINITY;\n         }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\nindex b1123a0043..d15c273836 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\n@@ -35,14 +35,6 @@\n import org.apache.jackrabbit.oak.plugins.index.property.strategy.IndexStoreStrategy;\n import org.apache.jackrabbit.oak.plugins.index.property.strategy.UniqueEntryStoreStrategy;\n import org.apache.jackrabbit.oak.query.QueryEngineSettings;\n-import org.apache.jackrabbit.oak.query.ast.ComparisonImpl;\n-import org.apache.jackrabbit.oak.query.ast.ConstraintImpl;\n-import org.apache.jackrabbit.oak.query.ast.DynamicOperandImpl;\n-import org.apache.jackrabbit.oak.query.ast.InImpl;\n-import org.apache.jackrabbit.oak.query.ast.Operator;\n-import org.apache.jackrabbit.oak.query.ast.OrImpl;\n-import org.apache.jackrabbit.oak.query.ast.PropertyValueImpl;\n-import org.apache.jackrabbit.oak.query.ast.StaticOperandImpl;\n import org.apache.jackrabbit.oak.spi.query.Cursor;\n import org.apache.jackrabbit.oak.spi.query.Cursors;\n import org.apache.jackrabbit.oak.spi.query.Filter;\n@@ -72,8 +64,6 @@\n     private static final IndexStoreStrategy UNIQUE =\n             new UniqueEntryStoreStrategy();\n \n-    private final NodeState root;\n-\n     private final NodeState definition;\n \n     private final String name;\n@@ -98,7 +88,6 @@\n \n     PropertyIndexPlan(String name, NodeState root, NodeState definition, Filter filter) {\n         this.name = name;\n-        this.root = root;\n         this.definition = definition;\n         this.properties = newHashSet(definition.getNames(PROPERTY_NAMES));\n         pathFilter = PathFilter.from(definition.builder());\n@@ -162,24 +151,6 @@\n                     }\n                 }\n             }\n-\n-            // OAK-1965: let's see if we can find a (x='...' OR y='...')\n-            // constraint where both x and y are covered by this index\n-            // TODO: avoid repeated scans through the constraints\n-            for (ConstraintImpl constraint\n-                    : filter.getSelector().getSelectorConstraints()) {\n-                if (constraint instanceof OrImpl) {\n-                    Set<String> values = findMultiProperty((OrImpl) constraint);\n-                    if (values != null) {\n-                        double cost = strategy.count(filter, root, definition, values, MAX_COST);\n-                        if (cost < bestCost) {\n-                            bestDepth = 1;\n-                            bestValues = values;\n-                            bestCost = cost;\n-                        }\n-                    }\n-                }\n-            }\n         }\n \n         this.depth = bestDepth;\n@@ -187,46 +158,6 @@\n         this.cost = COST_OVERHEAD + bestCost;\n     }\n \n-    private Set<String> findMultiProperty(OrImpl or) {\n-        Set<String> values = newLinkedHashSet();\n-        for (ConstraintImpl constraint : or.getConstraints()) {\n-            if (constraint instanceof ComparisonImpl) {\n-                ComparisonImpl comparison = (ComparisonImpl) constraint;\n-                if (isIndexed(comparison.getOperand1())\n-                        && comparison.getOperator() == Operator.EQUAL) {\n-                    values.addAll(encode(comparison.getOperand2().currentValue()));\n-                } else {\n-                    return null;\n-                }\n-            } else if (constraint instanceof InImpl) {\n-                InImpl in = (InImpl) constraint;\n-                if (isIndexed(in.getOperand1())) {\n-                    for (StaticOperandImpl operand : in.getOperand2()) {\n-                        values.addAll(encode(operand.currentValue()));\n-                    }\n-                } else {\n-                    return null;\n-                }\n-            } else {\n-                return null;\n-            }\n-        }\n-        return values;\n-    }\n-\n-    /**\n-     * Checks whether the given dynamic operand is a property\n-     * covered by this index.\n-     */\n-    private boolean isIndexed(DynamicOperandImpl operand) {\n-        if (operand instanceof PropertyValueImpl) {\n-            PropertyValueImpl property = (PropertyValueImpl) operand;\n-            return properties.contains(property.getPropertyName());\n-        } else {\n-            return false;\n-        }\n-    }\n-\n     private static Set<String> getValues(PropertyRestriction restriction) {\n         if (restriction.firstIncluding\n                 && restriction.lastIncluding\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\nindex 6908950dcf..0f851b14de 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n@@ -218,7 +218,6 @@ public boolean isAlwaysFalse() {\n         return alwaysFalse;\n     }\n \n-    @Override\n     public SelectorImpl getSelector() {\n         return selector;\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Filter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Filter.java\nindex f2e55fd1e3..9aabf1a77b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Filter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Filter.java\n@@ -28,7 +28,6 @@\n \n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.query.QueryEngineSettings;\n-import org.apache.jackrabbit.oak.query.ast.SelectorImpl;\n import org.apache.jackrabbit.oak.query.fulltext.FullTextExpression;\n \n /**\n@@ -44,13 +43,6 @@\n  */\n public interface Filter {\n \n-    /**\n-     * Get the selector associated with this filter.\n-     *\n-     * @return selector\n-     */\n-    SelectorImpl getSelector();\n-\n     /**\n      * Get the list of property restrictions, if any. Each property may contain\n      * multiple restrictions, for example x=1 and x=2. For this case, only\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "4038",
        "nb_skipped": 1,
        "commit": "557eec4f",
        "nb_failure": 1,
        "linesRem": 67,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 3014,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.MultiDocumentStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\nindex 63304e7c18..ced74dbf20 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\n@@ -21,7 +21,6 @@\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Date;\n-import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n@@ -83,6 +82,8 @@\n import com.mongodb.WriteResult;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Predicates.notNull;\n+import static com.google.common.collect.Maps.filterValues;\n \n /**\n  * A document store that uses MongoDB as the backend.\n@@ -285,22 +286,9 @@ public CacheInvalidationStats invalidateCache(Iterable<String> keys) {\n                         ids.size(), size);\n             }\n \n-            QueryBuilder query = QueryBuilder.start(Document.ID).in(ids);\n-            // Fetch only the modCount and id\n-            final BasicDBObject fields = new BasicDBObject(Document.ID, 1);\n-            fields.put(Document.MOD_COUNT, 1);\n-            \n-            DBCursor cursor = nodes.find(query.get(), fields);\n-            cursor.setReadPreference(ReadPreference.primary());\n+            Map<String, Number> modCounts = getModCounts(ids);\n             result.queryCount++;\n \n-            Map<String, Number> modCounts = new HashMap<String, Number>();\n-            for (DBObject obj : cursor) {\n-                String id = (String) obj.get(Document.ID);\n-                Number modCount = (Number) obj.get(Document.MOD_COUNT);\n-                modCounts.put(id, modCount);\n-            }\n-\n             int invalidated = nodesCache.invalidateOutdated(modCounts);\n             result.cacheEntriesProcessedCount += modCounts.size();\n             result.invalidationCount += invalidated;\n@@ -906,18 +894,26 @@ boolean canUseModifiedTimeIdx(long modifiedTimeInSecs) {\n             try {\n                 dbCollection.update(query.get(), update, false, true);\n                 if (collection == Collection.NODES) {\n+                    Map<String, Number> modCounts = getModCounts(filterValues(cachedDocs, notNull()).keySet());\n                     // update cache\n                     for (Entry<String, NodeDocument> entry : cachedDocs.entrySet()) {\n                         // the cachedDocs is not empty, so the collection = NODES\n                         Lock lock = nodeLocks.acquire(entry.getKey());\n                         try {\n-                            if (entry.getValue() == null || entry.getValue() == NodeDocument.NULL) {\n+                            Number postUpdateModCount = modCounts.get(entry.getKey());\n+                            if (postUpdateModCount != null\n+                                    && entry.getValue() != null\n+                                    && entry.getValue() != NodeDocument.NULL\n+                                    && (postUpdateModCount.longValue() - 1) == entry.getValue().getModCount()) {\n+                                // post update modCount is one higher than\n+                                // what we currently see in the cache. we can\n+                                // replace the cached document\n+                                NodeDocument newDoc = applyChanges(Collection.NODES, entry.getValue(), updateOp.shallowCopy(entry.getKey()));\n+                                nodesCache.replaceCachedDocument(entry.getValue(), newDoc);\n+                            } else {\n                                 // make sure concurrently loaded document is\n                                 // invalidated\n                                 nodesCache.invalidate(entry.getKey());\n-                            } else {\n-                                NodeDocument newDoc = applyChanges(Collection.NODES, entry.getValue(), updateOp.shallowCopy(entry.getKey()));\n-                                nodesCache.replaceCachedDocument(entry.getValue(), newDoc);\n                             }\n                         } finally {\n                             lock.unlock();\n@@ -925,6 +921,11 @@ boolean canUseModifiedTimeIdx(long modifiedTimeInSecs) {\n                     }\n                 }\n             } catch (MongoException e) {\n+                // some documents may still have been updated\n+                // invalidate all documents affected by this update call\n+                for (String k : keys) {\n+                    nodesCache.invalidate(k);\n+                }\n                 throw DocumentStoreException.convert(e);\n             }\n         } finally {\n@@ -932,6 +933,35 @@ boolean canUseModifiedTimeIdx(long modifiedTimeInSecs) {\n         }\n     }\n \n+    /**\n+     * Returns the {@link Document#MOD_COUNT} value of the documents with the\n+     * given {@code keys}. The returned map will only contain entries for\n+     * existing documents.\n+     *\n+     * @param keys the keys of the documents.\n+     * @return map with key to {@link Document#MOD_COUNT} value mapping.\n+     * @throws MongoException if the call fails\n+     */\n+    @Nonnull\n+    private Map<String, Number> getModCounts(Iterable<String> keys)\n+            throws MongoException {\n+        QueryBuilder query = QueryBuilder.start(Document.ID).in(keys);\n+        // Fetch only the modCount and id\n+        final BasicDBObject fields = new BasicDBObject(Document.ID, 1);\n+        fields.put(Document.MOD_COUNT, 1);\n+\n+        DBCursor cursor = nodes.find(query.get(), fields);\n+        cursor.setReadPreference(ReadPreference.primary());\n+\n+        Map<String, Number> modCounts = Maps.newHashMap();\n+        for (DBObject obj : cursor) {\n+            String id = (String) obj.get(Document.ID);\n+            Number modCount = (Number) obj.get(Document.MOD_COUNT);\n+            modCounts.put(id, modCount);\n+        }\n+        return modCounts;\n+    }\n+\n     DocumentReadPreference getReadPreference(int maxCacheAge){\n         if(maxCacheAge >= 0 && maxCacheAge < maxReplicationLagMillis) {\n             return DocumentReadPreference.PRIMARY;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentStore.java\nindex f81e1552da..f07a82701d 100755\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentStore.java\n@@ -1261,6 +1261,9 @@ private static void addUpdateCounters(UpdateOp update) {\n                         qc.addKeys(chunkedIds);\n                         seenQueryContext.add(qc);\n                     }\n+                    for (String id : chunkedIds) {\n+                        nodesCache.invalidate(id);\n+                    }\n                 }\n \n                 Connection connection = null;\n@@ -1285,23 +1288,8 @@ private static void addUpdateCounters(UpdateOp update) {\n                                 qc.addKeys(chunkedIds);\n                             }\n                         }\n-                    }\n-                    for (Entry<String, NodeDocument> entry : cachedDocs.entrySet()) {\n-                        T oldDoc = castAsT(entry.getValue());\n-                        String id = entry.getKey();\n-                        Lock lock = locks.acquire(id);\n-                        try {\n-                            if (oldDoc == null) {\n-                                // make sure concurrently loaded document is\n-                                // invalidated\n+                        for (String id : chunkedIds) {\n                             nodesCache.invalidate(id);\n-                            } else {\n-                                addUpdateCounters(update);\n-                                T newDoc = createNewDocument(collection, oldDoc, update);\n-                                nodesCache.replaceCachedDocument((NodeDocument) oldDoc, (NodeDocument) newDoc);\n-                            }\n-                        } finally {\n-                            lock.unlock();\n                         }\n                     }\n                 } else {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 38,
        "jira_id": "3634",
        "nb_skipped": 1,
        "commit": "90ad50da",
        "nb_failure": 1,
        "linesRem": 32,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 231,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.core.TreeImplTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\nindex a3d3536fc6..abc942a48c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n@@ -50,9 +50,12 @@\n     /** Underlying {@code Root} of this {@code Tree} instance */\n     private final RootImpl root;\n \n-    /** Parent of this tree. Null for the root and this for removed trees. */\n+    /** Parent of this tree. Null for the root. */\n     private TreeImpl parent;\n \n+    /** Marker for removed trees */\n+    private boolean removed;\n+\n     /** Name of this tree */\n     private String name;\n \n@@ -254,7 +257,7 @@ public boolean remove() {\n             NodeBuilder builder = parent.getNodeBuilder();\n             builder.removeNode(name);\n             parent.children.remove(name);\n-            parent = this;\n+            removed = true;\n             root.purge();\n             return true;\n         } else {\n@@ -390,6 +393,10 @@ private PropertyState internalGetProperty(String propertyName) {\n     }\n \n     private Status internalGetPropertyStatus(String name) {\n+        if (isRemoved()) {\n+            return Status.REMOVED;\n+        }\n+\n         NodeState baseState = getBaseState();\n         boolean exists = internalGetProperty(name) != null;\n         if (baseState == null) {\n@@ -433,14 +440,10 @@ private Status internalGetPropertyStatus(String name) {\n     }\n \n     private boolean isRemoved() {\n-        return parent == this;\n+        return removed || (parent != null && parent.isRemoved());\n     }\n \n     private void buildPath(StringBuilder sb) {\n-        if (isRemoved()) {\n-            throw new IllegalStateException(\"Cannot build the path of a removed tree\");\n-        }\n-\n         if (!isRoot()) {\n             parent.buildPath(sb);\n             sb.append('/').append(name);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 8,
        "jira_id": "278",
        "nb_skipped": 1,
        "commit": "db19e70f",
        "nb_failure": 0,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1559,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.authorization.accesscontrol.ACLTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/ACL.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/ACL.java\nindex a868b62890..9b0afaad4a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/ACL.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/ACL.java\n@@ -190,7 +190,7 @@ private boolean internalAddEntry(@Nonnull ACE entry) throws RepositoryException\n         List<ACE> subList = Lists.newArrayList(Iterables.filter(entries, new Predicate<ACE>() {\n             @Override\n             public boolean apply(@Nullable ACE ace) {\n-                return (ace != null) && ace.getPrincipal().equals(principal);\n+                return (ace != null) && ace.getPrincipal().getName().equals(principal.getName());\n             }\n         }));\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "1348",
        "nb_skipped": 6,
        "commit": "bc7b7e8c",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 1461,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest",
            "org.apache.jackrabbit.oak.query.index.FilterTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java\nindex 75e48bc7e2..26a3a43800 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java\n@@ -118,7 +118,7 @@ private boolean evaluate(PropertyValue p1, PropertyValue p2) {\n         case EQUAL:\n             return PropertyValues.match(p1, p2);\n         case NOT_EQUAL:\n-            return !PropertyValues.match(p1, p2);\n+            return PropertyValues.notMatch(p1, p2);\n         case GREATER_OR_EQUAL:\n             return p1.compareTo(p2) >= 0;\n         case GREATER_THAN:\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\nindex 6eb282ee9b..b31e74034c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n@@ -252,16 +252,17 @@ public void restrictProperty(String propertyName, Operator op, PropertyValue v)\n         switch (op) {\n         case EQUAL:\n             if (x.first != null && x.last == x.first && x.firstIncluding && x.lastIncluding) {\n-                // there is already an equality condition on this property\n-                // we will keep this, as it could be a multi-valued property\n-                // (unlike in databases, \"x = 1 and x = 2\" can match a node\n-                // if x is a multi-valued property with value \"{1, 2}\")\n-                return;\n+                // we keep the old equality condition if there is one;\n+                // we can not use setAlwaysFalse, as this would not be correct\n+                // for multi-valued properties:\n+                // unlike in databases, \"x = 1 and x = 2\" can match a node\n+                // if x is a multi-valued property with value {1, 2}\n+            } else {\n+                // all other conditions (range conditions) are replaced with this one\n+                // (we can not use setAlwaysFalse for the same reason as above)\n+                x.first = x.last = v;\n+                x.firstIncluding = x.lastIncluding = true;\n             }\n-            x.first = maxValue(oldFirst, v);\n-            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\n-            x.last = minValue(oldLast, v);\n-            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\n             break;\n         case NOT_EQUAL:\n             if (v != null) {\n@@ -269,25 +270,40 @@ public void restrictProperty(String propertyName, Operator op, PropertyValue v)\n             }\n             break;\n         case GREATER_THAN:\n+            // we don't narrow the range because of multi-valued properties\n+            if (x.first == null) {\n                 x.first = maxValue(oldFirst, v);\n                 x.firstIncluding = false;\n+            }\n             break;\n         case GREATER_OR_EQUAL:\n+            // we don't narrow the range because of multi-valued properties\n+            if (x.first == null) {\n                 x.first = maxValue(oldFirst, v);\n                 x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\n+            }\n             break;\n         case LESS_THAN:\n+            // we don't narrow the range because of multi-valued properties\n+            if (x.last == null) {\n                 x.last = minValue(oldLast, v);\n                 x.lastIncluding = false;\n+            }\n             break;\n         case LESS_OR_EQUAL:\n+            // we don't narrow the range because of multi-valued properties\n+            if (x.last == null) {\n                 x.last = minValue(oldLast, v);\n                 x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\n+            }\n             break;\n         case LIKE:\n+            // we don't narrow the range because of multi-valued properties\n+            if (x.first == null) {\n                 // LIKE is handled in the fulltext index\n                 x.isLike = true;\n                 x.first = v;\n+            }\n             break;\n         case IN:\n             \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/PropertyValues.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/PropertyValues.java\nindex 67e9cdb133..5320a4fc91 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/PropertyValues.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/PropertyValues.java\n@@ -167,7 +167,7 @@ public static boolean match(PropertyValue p1, PropertyValue p2) {\n             }\n             if (!p1.isArray() && p2.isArray()) {\n                 return contains(p2.getValue(Type.BINARIES),\n-                        p2.getValue(Type.BINARY));\n+                        p1.getValue(Type.BINARY));\n             }\n             break;\n         default:\n@@ -185,6 +185,53 @@ public static boolean match(PropertyValue p1, PropertyValue p2) {\n \n     }\n \n+    public static boolean notMatch(PropertyValue p1, PropertyValue p2) {\n+        if (p1.getType().tag() != p2.getType().tag()) {\n+            return true;\n+        }\n+\n+        switch (p1.getType().tag()) {\n+        case PropertyType.BINARY:\n+            if (p1.isArray() && !p2.isArray()) {\n+                if (p1.count() > 1) {\n+                    // a value can not possibly match multiple distinct values\n+                    return true;\n+                }\n+                return !contains(p1.getValue(Type.BINARIES),\n+                        p2.getValue(Type.BINARY));\n+            }\n+            if (!p1.isArray() && p2.isArray()) {\n+                if (p2.count() > 1) {\n+                    // a value can not possibly match multiple distinct values\n+                    return true;\n+                }\n+                return !contains(p2.getValue(Type.BINARIES),\n+                        p1.getValue(Type.BINARY));\n+            }\n+            break;\n+        default:\n+            if (p1.isArray() && !p2.isArray()) {\n+                if (p1.count() > 1) {\n+                    // a value can not possibly match multiple distinct values\n+                    return true;\n+                }\n+                return !contains(p1.getValue(Type.STRINGS),\n+                        p2.getValue(Type.STRING));\n+            }\n+            if (!p1.isArray() && p2.isArray()) {\n+                if (p2.count() > 1) {\n+                    // a value can not possibly match multiple distinct values\n+                    return true;\n+                }\n+                return !contains(p2.getValue(Type.STRINGS),\n+                        p1.getValue(Type.STRING));\n+            }\n+        }\n+        // both arrays or both single values\n+        return p1.compareTo(p2) != 0;\n+\n+    }\n+\n     // --\n \n     /**\n",
        "project": "jackrabbit-oak",
        "linesAdd": 57,
        "jira_id": "1075",
        "nb_skipped": 6,
        "commit": "79467350",
        "nb_failure": 4,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 360,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\nindex 42a78041ec..5079088cc4 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n@@ -1528,6 +1528,8 @@ public String getPath() {\n                     String sub = pathRow.getPath();\n                     if (isVirtualRow()) {\n                         return sub;\n+                    } else if (!\"\".equals(pathPrefix) && PathUtils.denotesRoot(sub)) {\n+                        return pathPrefix;\n                     } else if (PathUtils.isAbsolute(sub)) {\n                         return pathPrefix + sub;\n                     } else {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "4351",
        "nb_skipped": 6,
        "commit": "59a83d23",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1720,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.namepath.NamePathMapperImplTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\nindex a257e6904a..910896626d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\n@@ -256,6 +256,9 @@ private boolean needsFullMapping(String path) {\n             switch (path.charAt(i)) {\n                 case '{': // possibly an expanded name\n                 case '[': // possibly an index\n+                case ']': // illegal character if not part of index\n+                case '|': // illegal character\n+                case '*': // illegal character\n                     return true;\n                 case '.':\n                     if (i == slash + 1) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "1168",
        "nb_skipped": 8,
        "commit": "c05cec12",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1802,
        "nb_error": 0,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryAgentTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MissingLastRevSeeker.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MissingLastRevSeeker.java\nindex eef7c8234b..7659ec4bad 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MissingLastRevSeeker.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MissingLastRevSeeker.java\n@@ -94,6 +94,7 @@ public boolean acquireRecoveryLock(int clusterId){\n     public void releaseRecoveryLock(int clusterId){\n         UpdateOp update = new UpdateOp(Integer.toString(clusterId), true);\n         update.set(ClusterNodeInfo.REV_RECOVERY_LOCK, null);\n+        update.set(ClusterNodeInfo.STATE, null);\n         store.createOrUpdate(Collection.CLUSTER_NODES, update);\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "1883",
        "nb_skipped": 9,
        "commit": "9c2421ed",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 1,
        "nb_test": 57,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.mongomk.impl.model.MongoNodeTest"
        ],
        "patch": "diff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/impl/model/MongoNode.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/impl/model/MongoNode.java\nindex f58a597051..4bbd8dc65d 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/impl/model/MongoNode.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/impl/model/MongoNode.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.jackrabbit.mongomk.impl.model;\n \n+import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.LinkedList;\n import java.util.List;\n@@ -148,6 +149,11 @@ public void setRevisionId(long revisionId) {\n     public MongoNode copy() {\n         MongoNode copy = new MongoNode();\n         copy.putAll((Map) super.copy());\n+        List<String> children = getChildren();\n+        if (children != null) {\n+            copy.put(KEY_CHILDREN, new ArrayList<String>(children));\n+        }\n+        copy.put(KEY_PROPERTIES, new HashMap<String, Object>(getProperties()));\n         return copy;\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 6,
        "jira_id": "596",
        "nb_skipped": 3,
        "commit": "9b268da0",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 252,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexQueryTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexConstants.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexConstants.java\nindex cfdf7c4e17..fb0d8f3601 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexConstants.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexConstants.java\n@@ -25,7 +25,7 @@\n \n     String INDEX_DATA_CHILD_NAME = \":data\";\n \n-    Version VERSION = Version.LUCENE_46;\n+    Version VERSION = Version.LUCENE_47;\n \n     Analyzer ANALYZER = new OakAnalyzer(VERSION);\n \ndiff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakAnalyzer.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakAnalyzer.java\nindex 3fbc602e83..6368a8569f 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakAnalyzer.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakAnalyzer.java\n@@ -21,8 +21,8 @@\n import org.apache.lucene.analysis.Analyzer;\n import org.apache.lucene.analysis.TokenStream;\n import org.apache.lucene.analysis.core.LowerCaseFilter;\n-import org.apache.lucene.analysis.core.WhitespaceTokenizer;\n import org.apache.lucene.analysis.miscellaneous.WordDelimiterFilter;\n+import org.apache.lucene.analysis.standard.ClassicTokenizer;\n import org.apache.lucene.util.Version;\n \n public class OakAnalyzer extends Analyzer {\n@@ -43,7 +43,7 @@ public OakAnalyzer(Version matchVersion) {\n     @Override\n     protected TokenStreamComponents createComponents(final String fieldName,\n             final Reader reader) {\n-        WhitespaceTokenizer src = new WhitespaceTokenizer(matchVersion, reader);\n+        ClassicTokenizer src = new ClassicTokenizer(matchVersion, reader);\n         TokenStream tok = new LowerCaseFilter(matchVersion, src);\n         tok = new WordDelimiterFilter(tok,\n                 WordDelimiterFilter.GENERATE_WORD_PARTS\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "1614",
        "nb_skipped": 1,
        "commit": "86edbffb",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 14,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest"
        ],
        "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\nindex ffe9e8eb07..bc60aa8a84 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\n@@ -18,16 +18,25 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.collect.Iterables.addAll;\n import static com.google.common.collect.Lists.newArrayList;\n import static com.google.common.collect.Lists.newArrayListWithCapacity;\n import static com.google.common.collect.Maps.newHashMap;\n import static com.google.common.collect.Maps.newLinkedHashMap;\n+import static com.google.common.collect.Sets.newHashSet;\n import static com.google.common.collect.Sets.newLinkedHashSet;\n+import static org.apache.jackrabbit.JcrConstants.JCR_FROZENMIXINTYPES;\n+import static org.apache.jackrabbit.JcrConstants.JCR_FROZENPRIMARYTYPE;\n+import static org.apache.jackrabbit.JcrConstants.JCR_FROZENUUID;\n import static org.apache.jackrabbit.JcrConstants.JCR_MIXINTYPES;\n import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYTYPE;\n import static org.apache.jackrabbit.JcrConstants.JCR_UUID;\n import static org.apache.jackrabbit.JcrConstants.MIX_REFERENCEABLE;\n+import static org.apache.jackrabbit.JcrConstants.NT_FROZENNODE;\n import static org.apache.jackrabbit.JcrConstants.NT_UNSTRUCTURED;\n+import static org.apache.jackrabbit.oak.api.Type.NAME;\n+import static org.apache.jackrabbit.oak.api.Type.NAMES;\n+import static org.apache.jackrabbit.oak.api.Type.STRING;\n import static org.apache.jackrabbit.oak.plugins.tree.TreeConstants.OAK_CHILD_ORDER;\n \n import java.io.ByteArrayInputStream;\n@@ -97,6 +106,8 @@ private static void logNewNode(JackrabbitNodeState state) {\n \n     private final TypePredicate isOrderable;\n \n+    private final TypePredicate isFrozenNode;\n+\n     /**\n      * Source namespace mappings (URI -&lt; prefix).\n      */\n@@ -116,6 +127,7 @@ private JackrabbitNodeState(\n         this.loader = parent.loader;\n         this.isReferenceable = parent.isReferenceable;\n         this.isOrderable = parent.isOrderable;\n+        this.isFrozenNode = parent.isFrozenNode;\n         this.uriToPrefix = parent.uriToPrefix;\n         this.nodes = createNodes(bundle);\n         this.properties = createProperties(bundle);\n@@ -133,6 +145,7 @@ private JackrabbitNodeState(\n         this.loader = new BundleLoader(source);\n         this.isReferenceable = new TypePredicate(root, MIX_REFERENCEABLE);\n         this.isOrderable = TypePredicate.isOrderable(root);\n+        this.isFrozenNode = new TypePredicate(root, NT_FROZENNODE);\n         this.uriToPrefix = uriToPrefix;\n         try {\n             NodePropBundle bundle = loader.loadBundle(id);\n@@ -239,7 +252,7 @@ public NodeBuilder builder() {\n         return children;\n     }\n \n-    public Map<String, PropertyState> createProperties(NodePropBundle bundle) {\n+    private Map<String, PropertyState> createProperties(NodePropBundle bundle) {\n         Map<String, PropertyState> properties = newHashMap();\n \n         String primary;\n@@ -290,6 +303,32 @@ public NodeBuilder builder() {\n             }\n         }\n \n+        // OAK-1789: Convert the jcr:frozenUuid of a non-referenceable\n+        // frozen node from UUID to a path identifier\n+        PropertyState frozenUuid = properties.get(JCR_FROZENUUID);\n+        if (frozenUuid != null\n+                && frozenUuid.getType() == STRING\n+                && isFrozenNode.apply(primary, mixins)) {\n+            String frozenPrimary = NT_UNSTRUCTURED;\n+            Set<String> frozenMixins = newHashSet();\n+\n+            PropertyState property = properties.get(JCR_FROZENPRIMARYTYPE);\n+            if (property != null && property.getType() == NAME) {\n+                primary = property.getValue(NAME);\n+            }\n+            property = properties.get(JCR_FROZENMIXINTYPES);\n+            if (property != null && property.getType() == NAMES) {\n+                addAll(frozenMixins, property.getValue(NAMES));\n+            }\n+\n+            if (!isReferenceable.apply(frozenPrimary, frozenMixins)) {\n+                frozenUuid = PropertyStates.createProperty(\n+                        JCR_FROZENUUID,\n+                        parent.getString(JCR_FROZENUUID) + \"/\" + name);\n+                properties.put(JCR_FROZENUUID, frozenUuid);\n+            }\n+        }\n+\n         return properties;\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 38,
        "jira_id": "1789",
        "nb_skipped": 0,
        "commit": "08ba79d4",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1562,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\nindex 5c3716232f..5f79f71703 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\n@@ -42,7 +42,7 @@ public static Expression and(Expression old, Expression add) {\n         } else if (add == null) {\n             return old;\n         }\n-        return new Expression.Condition(old, \"and\", add, Expression.PRECEDENCE_AND);\n+        return new Expression.AndCondition(old, add);\n     }\n     \n     /**\n@@ -54,6 +54,15 @@ boolean isCondition() {\n         return false;\n     }\n     \n+    /**\n+     * Pull an OR condition up to the right hand side of an AND condition.\n+     * \n+     * @return the (possibly rotated) expression\n+     */\n+    Expression pullOrRight() {\n+        return this;\n+    }\n+    \n     /**\n      * Get the operator / operation precedence. The JCR specification uses:\n      * 1=OR, 2=AND, 3=condition, 4=operand  \n@@ -255,6 +264,27 @@ public String getCommonLeftPart() {\n             super(left, \"and\", right, Expression.PRECEDENCE_AND);\n         }\n         \n+        @Override\n+        AndCondition pullOrRight() {\n+            if (right instanceof OrCondition) {\n+                return this;\n+            } else if (left instanceof OrCondition) {\n+                return new AndCondition(right, left);\n+            }\n+            if (right instanceof AndCondition) {\n+                // pull up x:\n+                // a and (b and (x)) -> (a and b) and (x)\n+                AndCondition r2 = (AndCondition) right;\n+                r2 = r2.pullOrRight();\n+                AndCondition l2 = new AndCondition(left, r2.left);\n+                l2 = l2.pullOrRight();\n+                return new AndCondition(l2, r2.right);\n+            } else if (left instanceof AndCondition) {\n+                return new AndCondition(right, left).pullOrRight();\n+            }\n+            return this;\n+        }\n+        \n     }\n     \n     /**\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\nindex 03a243855e..05044299a3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\n@@ -58,8 +58,34 @@ public Statement optimize() {\n         if (where == null) {\n             return this;\n         }\n-        if (where instanceof OrCondition) {\n-            OrCondition or = (OrCondition) where;\n+        ArrayList<Expression> unionList = new ArrayList<Expression>();\n+        addToUnionList(where, unionList);\n+        if (unionList.size() == 1) {\n+            return this;\n+        }\n+        Statement union = null;\n+        for (int i = 0; i < unionList.size(); i++) {\n+            Expression e = unionList.get(i);\n+            Statement s = new Statement();\n+            s.columnSelector = columnSelector;\n+            s.selectors = selectors;\n+            s.columnList = columnList;\n+            s.where = e;\n+            if (i == unionList.size() - 1) {\n+                s.xpathQuery = xpathQuery;\n+            }\n+            if (union == null) {\n+                union = s;\n+            } else {\n+                union = new UnionStatement(union.optimize(), s.optimize());\n+            }\n+        }\n+        return union;\n+    }\n+    \n+    private static void addToUnionList(Expression condition,  ArrayList<Expression> unionList) {\n+        if (condition instanceof OrCondition) {\n+            OrCondition or = (OrCondition) condition;\n             if (or.getCommonLeftPart() != null) {\n                 // @x = 1 or @x = 2 \n                 // is automatically converted to \n@@ -72,29 +98,17 @@ public Statement optimize() {\n                 // @x = 1 or @y = 2\n                 // or similar are converted to\n                 // (@x = 1) union (@y = 2)\n-                Statement s1 = new Statement();\n-                s1.columnSelector = columnSelector;\n-                s1.selectors = selectors;\n-                s1.columnList = columnList;\n-                s1.where = or.left;\n-                Statement s2 = new Statement();\n-                s2.columnSelector = columnSelector;\n-                s2.selectors = selectors;\n-                s2.columnList = columnList;\n-                s2.where = or.right;\n-                s2.xpathQuery = xpathQuery;\n-                return new UnionStatement(s1.optimize(), s2.optimize());\n-            }\n-        } else if (where instanceof AndCondition) {\n+                addToUnionList(or.left, unionList);\n+                addToUnionList(or.right, unionList);\n+                return;\n+            }\n+        } else if (condition instanceof AndCondition) {\n             // conditions of type\n             // @a = 1 and (@x = 1 or @y = 2)\n             // are automatically converted to\n             // (@a = 1 and @x = 1) union (@a = 1 and @y = 2)\n-            AndCondition and = (AndCondition) where;\n-            if (and.left instanceof OrCondition && !(and.right instanceof OrCondition)) {\n-                // swap left and right\n-                and = new AndCondition(and.right, and.left);\n-            }\n+            AndCondition and = (AndCondition) condition;\n+            and = and.pullOrRight();\n             if (and.right instanceof OrCondition) {\n                 OrCondition or = (OrCondition) and.right;\n                 if (or.getCommonLeftPart() != null) {\n@@ -106,23 +120,13 @@ public Statement optimize() {\n                     // do not optimize \"contains\"\n                 } else {\n                     // same as above, but with the added \"and\"\n-                    // TODO avoid code duplication if possible\n-                    Statement s1 = new Statement();\n-                    s1.columnSelector = columnSelector;\n-                    s1.selectors = selectors;\n-                    s1.columnList = columnList;\n-                    s1.where = new AndCondition(and.left, or.left);\n-                    Statement s2 = new Statement();\n-                    s2.columnSelector = columnSelector;\n-                    s2.selectors = selectors;\n-                    s2.columnList = columnList;\n-                    s2.where = new AndCondition(and.left, or.right);\n-                    s2.xpathQuery = xpathQuery;\n-                    return new UnionStatement(s1.optimize(), s2.optimize());\n+                    addToUnionList(new AndCondition(and.left, or.left), unionList);\n+                    addToUnionList(new AndCondition(and.left, or.right), unionList);\n+                    return;\n                 }\n             }\n         }\n-        return this;\n+        unionList.add(condition);\n     }\n     \n     @Override\n",
        "project": "jackrabbit-oak",
        "linesAdd": 63,
        "jira_id": "1432",
        "nb_skipped": 7,
        "commit": "808ac9c0",
        "nb_failure": 0,
        "linesRem": 34,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1841,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest",
            "org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AndImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AndImpl.java\nindex d0b9245535..090c265bb7 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AndImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AndImpl.java\n@@ -110,7 +110,13 @@ public FullTextExpression getFullTextConstraint(SelectorImpl s) {\n         for (Entry<DynamicOperandImpl, Set<StaticOperandImpl>> e2 : m2.entrySet()) {\n             Set<StaticOperandImpl> s = result.get(e2.getKey());\n             if (s != null) {\n-                s.retainAll(e2.getValue());\n+                // OAK-1933\n+                // a property can have multiple values at the same time,\n+                // so that \"where a=1 and a=2\" needs to be kept and can not\n+                // be reduced to \"where false\" - in fact, we could \n+                // extend it to \"where a in (1, 2)\" so that an index can be used,\n+                // but we might as well keep it at \"where a = 1\" as that would\n+                // also use an index\n             } else {\n                 result.put(e2.getKey(), e2.getValue());\n             }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/QueryIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/QueryIndex.java\nindex a5cfe1019b..f3cf5ef44b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/QueryIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/QueryIndex.java\n@@ -194,8 +194,8 @@\n         double getCostPerEntry();\n \n         /**\n-         * The estimated number of entries. This value does not have to be\n-         * accurate.\n+         * The estimated number of entries in the cursor that is returned by the query method,\n+         * when using this plan. This value does not have to be accurate.\n          * \n          * @return the estimated number of entries\n          */\n",
        "project": "jackrabbit-oak",
        "linesAdd": 0,
        "jira_id": "1933",
        "nb_skipped": 9,
        "commit": "2e16a983",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": true
    },
    {
        "files": 1,
        "nb_test": 403,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.kernel.KernelNodeBuilderTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex 0168d6e9e5..3efa027c6b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -187,22 +187,11 @@ private MutableNodeState getWriteState(String name) {\n         }\n     }\n \n-    /**\n-     * Determine whether the named child has been removed. This is the\n-     * case when the write state has a corresponding {@code null} entry.\n-     * Assumes {@code read()}, {@code write()} needs not be called.\n-     * @param name  name of the child\n-     * @return  {@code true} iff a child with the given name has been removed\n-     */\n-    private boolean removed(String name) {\n-        return writeState != null && writeState.isRemoved(name);\n-    }\n-\n     @Nonnull\n     private NodeState read() {\n         if (revision != root.revision) {\n             assert(!isRoot()); // root never gets here since revision == root.revision\n-            checkState(!parent.removed(name), \"This node has already been removed\");\n+            checkState(!isRemoved(), \"This node has already been removed\");\n             parent.read();\n \n             // The builder could have been reset, need to re-get base state\n@@ -232,7 +221,7 @@ private MutableNodeState write() {\n     private MutableNodeState write(long newRevision, boolean skipRemovedCheck) {\n         // make sure that all revision numbers up to the root gets updated\n         if (!isRoot()) {\n-            checkState(skipRemovedCheck || !parent.removed(name));\n+            checkState(skipRemovedCheck || !isRemoved());\n             parent.write(newRevision, skipRemovedCheck);\n         }\n \n@@ -244,7 +233,7 @@ private MutableNodeState write(long newRevision, boolean skipRemovedCheck) {\n \n             writeState = parent.getWriteState(name);\n             if (writeState == null) {\n-                if (parent.removed(name)) {\n+                if (isRemoved()) {\n                     writeState = new MutableNodeState(null);\n                 }\n                 else {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "531",
        "nb_skipped": 0,
        "commit": "90c45a02",
        "nb_failure": 2,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2016,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.RevisionTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\nindex a9cff7eaf8..3079d886c5 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n@@ -554,7 +554,14 @@ public long getMinimumTimestamp(@Nonnull Revision revision,\n                 return timestamp;\n             }\n             // go through all known cluster nodes\n-            for (List<RevisionRange> list : map.values()) {\n+            for (Map.Entry<Integer, List<RevisionRange>> e : map.entrySet()) {\n+                if (revision.getClusterId() == currentClusterNodeId\n+                        && e.getKey() == currentClusterNodeId) {\n+                    // range and revision is for current cluster node\n+                    // no need to adjust timestamp\n+                    continue;\n+                }\n+                List<RevisionRange> list = e.getValue();\n                 RevisionRange range;\n                 for (int i = list.size() - 1; i >= 0; i--) {\n                     range = list.get(i);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 6,
        "jira_id": "2318",
        "nb_skipped": 9,
        "commit": "1d08cbd3",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1562,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.cache.ConcurrentTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\nindex 33561315b1..431d1f3b02 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\n@@ -154,11 +154,6 @@ public void invalidateAll() {\n         }\n     }\n \n-    private Entry<K, V> find(Object key) {\n-        int hash = getHash(key);\n-        return getSegment(hash).find(key, hash);\n-    }\n-\n     /**\n      * Check whether there is a resident entry for the given key. This\n      * method does not adjust the internal state of the cache.\n@@ -179,7 +174,8 @@ public boolean containsKey(Object key) {\n      * @return the value, or null if there is no resident entry\n      */\n     public V peek(K key) {\n-        Entry<K, V> e = find(key);\n+        int hash = getHash(key);\n+        Entry<K, V> e = getSegment(hash).find(key, hash);\n         return e == null ? null : e.value;\n     }\n \n@@ -459,7 +455,10 @@ public long getMaxMemory() {\n     public synchronized Set<Map.Entry<K, V>> entrySet() {\n         HashMap<K, V> map = new HashMap<K, V>();\n         for (K k : keySet()) {\n-            map.put(k,  find(k).value);\n+            V v = peek(k);\n+            if (v != null) {\n+                map.put(k,  v);\n+            }\n         }\n         return map.entrySet();\n     }\n@@ -467,7 +466,7 @@ public long getMaxMemory() {\n     protected Collection<V> values() {\n         ArrayList<V> list = new ArrayList<V>();\n         for (K k : keySet()) {\n-            V v = find(k).value;\n+            V v = peek(k);\n             if (v != null) {\n                 list.add(v);\n             }\n@@ -478,7 +477,7 @@ public long getMaxMemory() {\n     boolean containsValue(Object value) {\n         for (Segment<K, V> s : segments) {\n             for (K k : s.keySet()) {\n-                V v = find(k).value;\n+                V v = peek(k);\n                 if (v != null && v.equals(value)) {\n                     return true;\n                 }\n@@ -860,6 +859,9 @@ synchronized V get(K key, int hash, Callable<? extends V> valueLoader) throws Ex\n         synchronized V get(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {\n             V value = get(key, hash);\n             if (value == null) {\n+                if (loader == null) {\n+                    return null;\n+                }\n                 long start = System.nanoTime();\n                 try {\n                     value = loader.load(key);\n@@ -1394,7 +1396,7 @@ public boolean containsValue(Object value) {\n             @SuppressWarnings(\"unchecked\")\n             @Override\n             public V get(Object key) {\n-                return CacheLIRS.this.getUnchecked((K) key);\n+                return CacheLIRS.this.peek((K) key);\n             }\n \n             @Override\n",
        "project": "jackrabbit-oak",
        "linesAdd": 12,
        "jira_id": "1364",
        "nb_skipped": 6,
        "commit": "05c89637",
        "nb_failure": 0,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 2013,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java\nindex 4b83da95d7..9cf769b262 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java\n@@ -168,18 +168,7 @@ public boolean hasChildNode(String name) {\n     @Nonnull\n     @Override\n     public NodeState getChildNode(@Nonnull String name) {\n-        if (!hasChildren) {\n-            checkValidName(name);\n-            return EmptyNodeState.MISSING_NODE;\n-        }\n-        String p = PathUtils.concat(getPath(), name);\n-        DocumentNodeState child = store.getNode(p, lastRevision);\n-        if (child == null) {\n-            checkValidName(name);\n-            return EmptyNodeState.MISSING_NODE;\n-        } else {\n-            return child;\n-        }\n+        return getChildNode(name, lastRevision);\n     }\n \n     @Override\n@@ -282,6 +271,23 @@ public boolean compareAgainstBaseState(NodeState base, NodeStateDiff diff) {\n         return super.compareAgainstBaseState(base, diff);\n     }\n \n+    @Nonnull\n+    NodeState getChildNode(@Nonnull String name,\n+                           @Nonnull Revision revision) {\n+        if (!hasChildren) {\n+            checkValidName(name);\n+            return EmptyNodeState.MISSING_NODE;\n+        }\n+        String p = PathUtils.concat(getPath(), name);\n+        DocumentNodeState child = store.getNode(p, checkNotNull(revision));\n+        if (child == null) {\n+            checkValidName(name);\n+            return EmptyNodeState.MISSING_NODE;\n+        } else {\n+            return child;\n+        }\n+    }\n+\n     void setProperty(String propertyName, String value) {\n         if (value == null) {\n             properties.remove(propertyName);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 1087f533c2..1ed7072c5b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -1905,14 +1905,14 @@ private boolean dispatch(@Nonnull String jsonDiff,\n                     while (t.read() != '}') {\n                         // skip properties\n                     }\n-                    NodeState child = getNode(concat(node.getPath(), name), nodeRev);\n-                    continueComparison = diff.childNodeAdded(name, child);\n+                    continueComparison = diff.childNodeAdded(name,\n+                            node.getChildNode(name, nodeRev));\n                     break;\n                 }\n                 case '-': {\n                     String name = unshareString(t.readString());\n-                    NodeState child = getNode(concat(base.getPath(), name), baseRev);\n-                    continueComparison = diff.childNodeDeleted(name, child);\n+                    continueComparison = diff.childNodeDeleted(name,\n+                            base.getChildNode(name, baseRev));\n                     break;\n                 }\n                 case '^': {\n@@ -1920,10 +1920,9 @@ private boolean dispatch(@Nonnull String jsonDiff,\n                     t.read(':');\n                     if (t.matches('{')) {\n                         t.read('}');\n-                        NodeState nodeChild = getNode(concat(node.getPath(), name), nodeRev);\n-                        NodeState baseChild = getNode(concat(base.getPath(), name), baseRev);\n-                        continueComparison = diff.childNodeChanged(\n-                                name, baseChild, nodeChild);\n+                        continueComparison = diff.childNodeChanged(name,\n+                                base.getChildNode(name, baseRev),\n+                                node.getChildNode(name, nodeRev));\n                     } else if (t.matches('[')) {\n                         // ignore multi valued property\n                         while (t.read() != ']') {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 25,
        "jira_id": "2695",
        "nb_skipped": 9,
        "commit": "0598498e",
        "nb_failure": 1,
        "linesRem": 20,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1519,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.cache.CacheTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\nindex 52747acb07..33561315b1 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\n@@ -922,8 +922,12 @@ synchronized void refresh(K key, int hash, CacheLoader<K, V> loader) throws Exec\n             V old = get(key, hash);\n             long start = System.nanoTime();\n             try {\n+                if (old == null) {\n+                    value = loader.load(key);\n+                } else {\n                     ListenableFuture<V> future = loader.reload(key, old);\n                     value = future.get();\n+                }\n                 loadSuccessCount++;\n             } catch (Exception e) {\n                 loadExceptionCount++;\n",
        "project": "jackrabbit-oak",
        "linesAdd": 4,
        "jira_id": "1094",
        "nb_skipped": 6,
        "commit": "2e20589f",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 511,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.CRUDTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\nindex 2c8566bb19..7cb7e2c477 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n@@ -250,11 +250,10 @@ public Node perform() throws RepositoryException {\n                 String ntName = primaryNodeTypeName;\n                 if (ntName == null) {\n                     DefinitionProvider dp = sessionDelegate.getDefinitionProvider();\n-                    try {\n                     String childName = sessionDelegate.getOakName(PathUtils.getName(relPath));\n                     NodeDefinition def = dp.getDefinition(new NodeImpl<NodeDelegate>(parent), childName);\n                     ntName = def.getDefaultPrimaryTypeName();\n-                    } catch (RepositoryException e) {\n+                    if (ntName == null) {\n                         throw new ConstraintViolationException(\n                                 \"no matching child node definition found for \" + relPath);\n                     }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "642",
        "nb_skipped": 1,
        "commit": "7a84b3a8",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 1580,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.SimpleTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\nindex 4e14f428d6..7c70035836 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\n@@ -214,7 +214,7 @@ public String getNodes(String path, String revisionId, int depth,\n             if (maxChildNodes-- <= 0) {\n                 break;\n             }\n-            String name = PathUtils.getName(c.children.get((int) i));\n+            String name = c.children.get((int) i);\n             json.key(name).object().endObject();\n         }\n         if (c.hasMore) {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java\nindex 64a1eb8fee..7396f4e271 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java\n@@ -381,28 +381,25 @@ private boolean dispatch(@Nonnull String jsonDiff,\n             }\n             switch (r) {\n                 case '+': {\n-                    String path = t.readString();\n+                    String name = t.readString();\n                     t.read(':');\n                     t.read('{');\n                     while (t.read() != '}') {\n                         // skip properties\n                     }\n-                    String name = PathUtils.getName(path);\n                     continueComparison = diff.childNodeAdded(name, getChildNode(name));\n                     break;\n                 }\n                 case '-': {\n-                    String path = t.readString();\n-                    String name = PathUtils.getName(path);\n+                    String name = t.readString();\n                     continueComparison = diff.childNodeDeleted(name, base.getChildNode(name));\n                     break;\n                 }\n                 case '^': {\n-                    String path = t.readString();\n+                    String name = t.readString();\n                     t.read(':');\n                     if (t.matches('{')) {\n                         t.read('}');\n-                        String name = PathUtils.getName(path);\n                         continueComparison = diff.childNodeChanged(name,\n                                 base.getChildNode(name), getChildNode(name));\n                     } else if (t.matches('[')) {\n@@ -416,21 +413,6 @@ private boolean dispatch(@Nonnull String jsonDiff,\n                     }\n                     break;\n                 }\n-                case '>': {\n-                    String from = t.readString();\n-                    t.read(':');\n-                    String to = t.readString();\n-                    String fromName = PathUtils.getName(from);\n-                    continueComparison = diff.childNodeDeleted(\n-                            fromName, base.getChildNode(fromName));\n-                    if (!continueComparison) {\n-                        break;\n-                    }\n-                    String toName = PathUtils.getName(to);\n-                    continueComparison = diff.childNodeAdded(\n-                            toName, getChildNode(toName));\n-                    break;\n-                }\n                 default:\n                     throw new IllegalArgumentException(\"jsonDiff: illegal token '\"\n                             + t.getToken() + \"' at pos: \" + t.getLastPos() + ' ' + jsonDiff);\n@@ -478,6 +460,9 @@ public NodeState getNodeState() {\n      */\n     public static class Children implements CacheValue {\n \n+        /**\n+         * Ascending sorted list of names of child nodes.\n+         */\n         final ArrayList<String> children = new ArrayList<String>();\n         boolean hasMore;\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 3a520e0e65..26bb4b4eb4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -56,6 +56,8 @@\n \n import org.apache.jackrabbit.mk.api.MicroKernelException;\n import org.apache.jackrabbit.oak.api.PropertyState;\n+import org.apache.jackrabbit.oak.commons.json.JsopReader;\n+import org.apache.jackrabbit.oak.commons.json.JsopTokenizer;\n import org.apache.jackrabbit.oak.spi.blob.BlobStore;\n import org.apache.jackrabbit.oak.commons.json.JsopStream;\n import org.apache.jackrabbit.oak.commons.json.JsopWriter;\n@@ -665,7 +667,7 @@ public DocumentNodeState call() throws Exception {\n                 }\n                 if (c.children.size() < limit) {\n                     // add to children until limit is reached\n-                    c.children.add(p);\n+                    c.children.add(Utils.unshareString(PathUtils.getName(p)));\n                 } else {\n                     // enough collected and we know there are more\n                     c.hasMore = true;\n@@ -785,7 +787,8 @@ public NodeDocument apply(String name) {\n                 new Function<String, DocumentNodeState>() {\n             @Override\n             public DocumentNodeState apply(String input) {\n-                return getNode(input, readRevision);\n+                String p = PathUtils.concat(parent.getPath(), input);\n+                return getNode(p, readRevision);\n             }\n         });\n     }\n@@ -832,10 +835,9 @@ public void applyChanges(Revision rev, Revision before, String path,\n         if (isNew) {\n             CacheValue key = childNodeCacheKey(path, rev, null);\n             DocumentNodeState.Children c = new DocumentNodeState.Children();\n-            Set<String> set = Sets.newTreeSet(added);\n-            set.removeAll(removed);\n+            Set<String> set = Sets.newTreeSet();\n             for (String p : added) {\n-                set.add(Utils.unshareString(p));\n+                set.add(Utils.unshareString(PathUtils.getName(p)));\n             }\n             c.children.addAll(set);\n             nodeChildrenCache.put(key, c);\n@@ -844,13 +846,13 @@ public void applyChanges(Revision rev, Revision before, String path,\n             PathRev key = diffCacheKey(path, before, rev);\n             JsopWriter w = new JsopStream();\n             for (String p : added) {\n-                w.tag('+').key(p).object().endObject().newline();\n+                w.tag('+').key(PathUtils.getName(p)).object().endObject().newline();\n             }\n             for (String p : removed) {\n-                w.tag('-').value(p).newline();\n+                w.tag('-').value(PathUtils.getName(p)).newline();\n             }\n             for (String p : changed) {\n-                w.tag('^').key(p).object().endObject().newline();\n+                w.tag('^').key(PathUtils.getName(p)).object().endObject().newline();\n             }\n             diffCache.put(key, new StringValue(w.toString()));\n         }\n@@ -1148,12 +1150,35 @@ String diff(@Nonnull final String fromRevisionId,\n         try {\n             JsopWriter writer = new JsopStream();\n             diffProperties(from, to, writer);\n-            return writer.toString() + diffCache.get(key, new Callable<StringValue>() {\n+            String compactDiff = diffCache.get(key, new Callable<StringValue>() {\n                 @Override\n                 public StringValue call() throws Exception {\n                     return new StringValue(diffImpl(from, to));\n                 }\n-            });\n+            }).toString();\n+            JsopTokenizer t = new JsopTokenizer(compactDiff);\n+            int r;\n+            do {\n+                r = t.read();\n+                switch (r) {\n+                    case '+':\n+                    case '^': {\n+                        String name = t.readString();\n+                        t.read(':');\n+                        t.read('{');\n+                        t.read('}');\n+                        writer.tag((char) r).key(PathUtils.concat(path, name));\n+                        writer.object().endObject().newline();\n+                        break;\n+                    }\n+                    case '-': {\n+                        String name = t.readString();\n+                        writer.tag('-').value(PathUtils.concat(path, name));\n+                        writer.newline();\n+                    }\n+                }\n+            } while (r != JsopReader.END);\n+            return writer.toString();\n         } catch (ExecutionException e) {\n             if (e.getCause() instanceof MicroKernelException) {\n                 throw (MicroKernelException) e.getCause();\n@@ -1414,7 +1439,6 @@ private static void diffProperties(DocumentNodeState from,\n     private String diffImpl(DocumentNodeState from, DocumentNodeState to)\n             throws MicroKernelException {\n         JsopWriter w = new JsopStream();\n-        diffProperties(from, to, w);\n         // TODO this does not work well for large child node lists\n         // use a document store index instead\n         int max = MANY_CHILDREN_THRESHOLD;\n@@ -1422,8 +1446,8 @@ private String diffImpl(DocumentNodeState from, DocumentNodeState to)\n         fromChildren = getChildren(from, null, max);\n         toChildren = getChildren(to, null, max);\n         if (!fromChildren.hasMore && !toChildren.hasMore) {\n-            diffFewChildren(w, fromChildren, from.getLastRevision(),\n-                    toChildren, to.getLastRevision());\n+            diffFewChildren(w, from.getPath(), fromChildren,\n+                    from.getLastRevision(), toChildren, to.getLastRevision());\n         } else {\n             if (FAST_DIFF) {\n                 diffManyChildren(w, from.getPath(),\n@@ -1432,8 +1456,8 @@ private String diffImpl(DocumentNodeState from, DocumentNodeState to)\n                 max = Integer.MAX_VALUE;\n                 fromChildren = getChildren(from, null, max);\n                 toChildren = getChildren(to, null, max);\n-                diffFewChildren(w, fromChildren, from.getLastRevision(),\n-                        toChildren, to.getLastRevision());\n+                diffFewChildren(w, from.getPath(), fromChildren,\n+                        from.getLastRevision(), toChildren, to.getLastRevision());\n             }\n         }\n         return w.toString();\n@@ -1463,23 +1487,24 @@ private void diffManyChildren(JsopWriter w, String path, Revision fromRev, Revis\n         for (String p : paths) {\n             DocumentNodeState fromNode = getNode(p, fromRev);\n             DocumentNodeState toNode = getNode(p, toRev);\n+            String name = PathUtils.getName(p);\n             if (fromNode != null) {\n                 // exists in fromRev\n                 if (toNode != null) {\n                     // exists in both revisions\n                     // check if different\n                     if (!fromNode.getLastRevision().equals(toNode.getLastRevision())) {\n-                        w.tag('^').key(p).object().endObject().newline();\n+                        w.tag('^').key(name).object().endObject().newline();\n                     }\n                 } else {\n                     // does not exist in toRev -> was removed\n-                    w.tag('-').value(p).newline();\n+                    w.tag('-').value(name).newline();\n                 }\n             } else {\n                 // does not exist in fromRev\n                 if (toNode != null) {\n                     // exists in toRev\n-                    w.tag('+').key(p).object().endObject().newline();\n+                    w.tag('+').key(name).object().endObject().newline();\n                 } else {\n                     // does not exist in either revisions\n                     // -> do nothing\n@@ -1503,21 +1528,22 @@ private static void addPathsForDiff(String path,\n         }\n     }\n \n-    private void diffFewChildren(JsopWriter w, DocumentNodeState.Children fromChildren, Revision fromRev, DocumentNodeState.Children toChildren, Revision toRev) {\n+    private void diffFewChildren(JsopWriter w, String parentPath, DocumentNodeState.Children fromChildren, Revision fromRev, DocumentNodeState.Children toChildren, Revision toRev) {\n         Set<String> childrenSet = Sets.newHashSet(toChildren.children);\n         for (String n : fromChildren.children) {\n             if (!childrenSet.contains(n)) {\n                 w.tag('-').value(n).newline();\n             } else {\n-                DocumentNodeState n1 = getNode(n, fromRev);\n-                DocumentNodeState n2 = getNode(n, toRev);\n+                String path = PathUtils.concat(parentPath, n);\n+                DocumentNodeState n1 = getNode(path, fromRev);\n+                DocumentNodeState n2 = getNode(path, toRev);\n                 // this is not fully correct:\n                 // a change is detected if the node changed recently,\n                 // even if the revisions are well in the past\n                 // if this is a problem it would need to be changed\n-                checkNotNull(n1, \"Node at [%s] not found for fromRev [%s]\", n, fromRev);\n-                checkNotNull(n2, \"Node at [%s] not found for toRev [%s]\", n, toRev);\n-                if (!n1.getId().equals(n2.getId())) {\n+                checkNotNull(n1, \"Node at [%s] not found for fromRev [%s]\", path, fromRev);\n+                checkNotNull(n2, \"Node at [%s] not found for toRev [%s]\", path, toRev);\n+                if (!n1.getLastRevision().equals(n2.getLastRevision())) {\n                     w.tag('^').key(n).object().endObject().newline();\n                 }\n             }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 54,
        "jira_id": "1429",
        "nb_skipped": 6,
        "commit": "c2f5ca6c",
        "nb_failure": 1,
        "linesRem": 46,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 212,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.query.QueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/XPathToSQL2Converter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/XPathToSQL2Converter.java\nindex 6a5f5a929b..8103898d7b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/XPathToSQL2Converter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/XPathToSQL2Converter.java\n@@ -381,10 +381,20 @@ private Expression parseFunction(String functionName) throws ParseException {\n             Cast c = new Cast(expr, \"date\");\n             read(\")\");\n             return c;\n+        } else if (\"fn:lower-case\".equals(functionName)) {\n+            Function f = new Function(\"lower\");\n+            f.params.add(parseExpression());\n+            read(\")\");\n+            return f;\n+        } else if (\"fn:upper-case\".equals(functionName)) {\n+            Function f = new Function(\"upper\");\n+            f.params.add(parseExpression());\n+            read(\")\");\n+            return f;\n         // } else if (\"jcr:deref\".equals(functionName)) {\n             // TODO support jcr:deref?\n         } else {\n-            throw getSyntaxError(\"jcr:like | jcr:contains | jcr:score | jcr:deref\");\n+            throw getSyntaxError(\"jcr:like | jcr:contains | jcr:score | jcr:deref | fn:lower-case | fn:upper-case\");\n         }\n     }\n \n@@ -537,7 +547,9 @@ private void read() throws ParseException {\n         case CHAR_NAME:\n             while (true) {\n                 type = types[i];\n-                if (type != CHAR_NAME && type != CHAR_VALUE) {\n+                // the '-' can be part of a name, \n+                // for example in \"fn:lower-case\"\n+                if (type != CHAR_NAME && type != CHAR_VALUE && chars[i] != '-') {\n                     c = chars[i];\n                     break;\n                 }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 12,
        "jira_id": "225",
        "nb_skipped": 0,
        "commit": "e33328e0",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 269,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexSuggestionTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\nindex 0a38732b44..a582292276 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n@@ -1038,14 +1038,17 @@ public NodeAggregator getNodeAggregator() {\n         final String path;\n         final double score;\n         final Iterable<String> suggestWords;\n+        final boolean isVirtual;\n \n         LuceneResultRow(String path, double score) {\n+            this.isVirtual = false;\n             this.path = path;\n             this.score = score;\n             this.suggestWords = Collections.emptySet();\n         }\n \n         LuceneResultRow(Iterable<String> suggestWords) {\n+            this.isVirtual = true;\n             this.path = \"/\";\n             this.score = 1.0d;\n             this.suggestWords = suggestWords;\n@@ -1110,7 +1113,7 @@ public IndexRow next() {\n \n                 @Override\n                 public boolean isVirtualRow() {\n-                    return getPath() == null;\n+                    return currentRow.isVirtual;\n                 }\n \n                 @Override\ndiff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\nindex 40952779be..2b7e4776eb 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n@@ -1280,14 +1280,17 @@ private static Query newDepthQuery(String path) {\n         final String path;\n         final double score;\n         final Iterable<String> suggestWords;\n+        final boolean isVirutal;\n \n         LuceneResultRow(String path, double score) {\n+            this.isVirutal = false;\n             this.path = path;\n             this.score = score;\n             this.suggestWords = Collections.emptySet();\n         }\n \n         LuceneResultRow(Iterable<String> suggestWords) {\n+            this.isVirutal = true;\n             this.path = \"/\";\n             this.score = 1.0d;\n             this.suggestWords = suggestWords;\n@@ -1354,7 +1357,7 @@ public IndexRow next() {\n \n                 @Override\n                 public boolean isVirtualRow() {\n-                    return getPath() == null;\n+                    return currentRow.isVirutal;\n                 }\n \n                 @Override\n",
        "project": "jackrabbit-oak",
        "linesAdd": 8,
        "jira_id": "3156",
        "nb_skipped": 4,
        "commit": "786b3d76",
        "nb_failure": 3,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 418,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopierTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\nindex 6f67427a5a..47e57d5d0b 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\n@@ -188,9 +188,12 @@ private void copy(final FileReference reference) {\n                 @Override\n                 public void run() {\n                     String name = reference.name;\n+                    boolean success = false;\n+                    boolean copyAttempted = false;\n                     try {\n                         if (!local.fileExists(name)) {\n                             long start = System.currentTimeMillis();\n+                            copyAttempted = true;\n                             remote.copy(local, name, name, IOContext.READ);\n                             reference.markValid();\n                             downloadTime.addAndGet(System.currentTimeMillis() - start);\n@@ -210,11 +213,22 @@ public void run() {\n                                 reference.markValid();\n                             }\n                         }\n+                        success = true;\n                     } catch (IOException e) {\n                         //TODO In case of exception there would not be any other attempt\n                         //to download the file. Look into support for retry\n                         log.warn(\"Error occurred while copying file [{}] \" +\n                                 \"from {} to {}\", name, remote, local, e);\n+                    } finally {\n+                        if (copyAttempted && !success){\n+                            try {\n+                                if (local.fileExists(name)) {\n+                                    local.deleteFile(name);\n+                                }\n+                            } catch (IOException e) {\n+                                log.warn(\"Error occurred while deleting corrupted file [{}] from [{}]\", name, local, e);\n+                            }\n+                        }\n                     }\n                 }\n             });\n",
        "project": "jackrabbit-oak",
        "linesAdd": 14,
        "jira_id": "2649",
        "nb_skipped": 2,
        "commit": "72d24f4b",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 17,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest"
        ],
        "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\nindex 6db5152eba..27e82ab09b 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n@@ -256,6 +256,9 @@ public void copy(RepositoryInitializer initializer) throws RepositoryException {\n             if (initializer != null) {\n                 initializer.initialize(builder);\n             }\n+            for (SecurityConfiguration sc : security.getConfigurations()) {\n+                sc.getRepositoryInitializer().initialize(builder);\n+            }\n             for (SecurityConfiguration sc : security.getConfigurations()) {\n                 sc.getWorkspaceInitializer().initialize(builder, workspaceName);\n             }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "2047",
        "nb_skipped": 0,
        "commit": "ca63fdf3",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 466,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopierTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\nindex e1e8a535a1..bea03c6bd9 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\n@@ -75,6 +75,7 @@\n import static com.google.common.collect.Iterables.toArray;\n import static com.google.common.collect.Iterables.transform;\n import static com.google.common.collect.Maps.newConcurrentMap;\n+import static com.google.common.collect.Maps.newHashMap;\n import static org.apache.jackrabbit.oak.commons.IOUtils.humanReadableByteCount;\n \n public class IndexCopier implements CopyOnReadStatsMBean, Closeable {\n@@ -111,6 +112,7 @@\n \n \n     private final Map<String, String> indexPathMapping = newConcurrentMap();\n+    private final Map<String, Set<String>> sharedWorkingSetMap = newHashMap();\n     private final Map<String, String> indexPathVersionMapping = newConcurrentMap();\n     private final ConcurrentMap<String, LocalIndexFile> failedToDeleteFiles = newConcurrentMap();\n     private final Set<LocalIndexFile> copyInProgressFiles = Collections.newSetFromMap(new ConcurrentHashMap<LocalIndexFile, Boolean>());\n@@ -131,12 +133,13 @@ public IndexCopier(Executor executor, File indexRootDir, boolean prefetchEnabled\n     public Directory wrapForRead(String indexPath, IndexDefinition definition,\n             Directory remote) throws IOException {\n         Directory local = createLocalDirForIndexReader(indexPath, definition);\n-        return new CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath);\n+        return new CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath, getSharedWorkingSet(definition));\n     }\n \n     public Directory wrapForWrite(IndexDefinition definition, Directory remote, boolean reindexMode) throws IOException {\n         Directory local = createLocalDirForIndexWriter(definition);\n-        return new CopyOnWriteDirectory(remote, local, reindexMode, getIndexPathForLogging(definition));\n+        return new CopyOnWriteDirectory(remote, local, reindexMode,\n+                getIndexPathForLogging(definition), getSharedWorkingSet(definition));\n     }\n \n     @Override\n@@ -237,6 +240,34 @@ private void successfullyDeleted(LocalIndexFile file, boolean fileExisted){\n         }\n     }\n \n+    /**\n+     * Provide the corresponding shared state to enable COW inform COR\n+     * about new files it is creating while indexing. This would allow COR to ignore\n+     * such files while determining the deletion candidates.\n+     *\n+     * @param defn index definition for which the directory is being created\n+     * @return a set to maintain the state of new files being created by the COW Directory\n+     */\n+    private Set<String> getSharedWorkingSet(IndexDefinition defn){\n+        String indexPath = defn.getIndexPathFromConfig();\n+\n+        if (indexPath == null){\n+            //With indexPath null the working directory would not\n+            //be shared between COR and COW. So just return a new set\n+            return new HashSet<String>();\n+        }\n+\n+        Set<String> sharedSet;\n+        synchronized (sharedWorkingSetMap){\n+            sharedSet = sharedWorkingSetMap.get(indexPath);\n+            if (sharedSet == null){\n+                sharedSet = Sets.newConcurrentHashSet();\n+                sharedWorkingSetMap.put(indexPath, sharedSet);\n+            }\n+        }\n+        return sharedSet;\n+    }\n+\n     /**\n      * Creates the workDir. If it exists then it is cleaned\n      *\n@@ -274,12 +305,17 @@ private static String getIndexPathForLogging(IndexDefinition defn){\n          */\n         private final Set<String> localFileNames = Sets.newConcurrentHashSet();\n \n-        public CopyOnReadDirectory(Directory remote, Directory local, boolean prefetch, String indexPath) throws IOException {\n+        public CopyOnReadDirectory(Directory remote, Directory local, boolean prefetch,\n+                                   String indexPath, Set<String> sharedWorkingSet) throws IOException {\n             super(remote);\n             this.remote = remote;\n             this.local = local;\n             this.indexPath = indexPath;\n+\n             this.localFileNames.addAll(Arrays.asList(local.listAll()));\n+            //Remove files which are being worked upon by COW\n+            this.localFileNames.removeAll(sharedWorkingSet);\n+\n             if (prefetch) {\n                 prefetchIndexFiles();\n             }\n@@ -549,6 +585,7 @@ public Void call() throws Exception {\n         private final CountDownLatch copyDone = new CountDownLatch(1);\n         private final boolean reindexMode;\n         private final String indexPathForLogging;\n+        private final Set<String> sharedWorkingSet;\n \n         /**\n          * Current background task\n@@ -602,12 +639,13 @@ public void run() {\n         };\n \n         public CopyOnWriteDirectory(Directory remote, Directory local, boolean reindexMode,\n-                                    String indexPathForLogging) throws IOException {\n+                                    String indexPathForLogging, Set<String> sharedWorkingSet) throws IOException {\n             super(local);\n             this.remote = remote;\n             this.local = local;\n             this.indexPathForLogging = indexPathForLogging;\n             this.reindexMode = reindexMode;\n+            this.sharedWorkingSet = sharedWorkingSet;\n             initialize();\n         }\n \n@@ -647,6 +685,7 @@ public IndexOutput createOutput(String name, IOContext context) throws IOExcepti\n             }\n             ref = new COWLocalFileReference(name);\n             fileMap.put(name, ref);\n+            sharedWorkingSet.add(name);\n             return ref.createOutput(context);\n         }\n \n@@ -723,6 +762,7 @@ public void close() throws IOException {\n \n             local.close();\n             remote.close();\n+            sharedWorkingSet.clear();\n         }\n \n         @Override\n@@ -994,7 +1034,7 @@ private boolean deleteFile(Directory dir, String fileName, boolean copiedFromRem\n         } catch (IOException e) {\n             failedToDelete(file);\n             log.debug(\"Error occurred while removing deleted file {} from Local {}. \" +\n-                    \"Attempt would be maid to delete it on next run \", fileName, dir, e);\n+                    \"Attempt would be made to delete it on next run \", fileName, dir, e);\n         }\n         return successFullyDeleted;\n     }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 34,
        "jira_id": "3110",
        "nb_skipped": 3,
        "commit": "d10362c0",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 408,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinitionTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\nindex fcd547cd82..69d3431c8c 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n@@ -23,6 +23,7 @@\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n import java.util.regex.Pattern;\n@@ -559,6 +560,9 @@ private boolean areAllTypesIndexed() {\n     public class IndexingRule {\n         private final String baseNodeType;\n         private final String nodeTypeName;\n+        /**\n+         * Case insensitive map of lower cased propertyName to propertyConfigs\n+         */\n         private final Map<String, PropertyDefinition> propConfigs;\n         private final List<NamePattern> namePatterns;\n         private final List<PropertyDefinition> nullCheckEnabledProperties;\n@@ -697,7 +701,7 @@ public boolean isFulltextEnabled() {\n          */\n         @CheckForNull\n         public PropertyDefinition getConfig(String propertyName) {\n-            PropertyDefinition config = propConfigs.get(propertyName);\n+            PropertyDefinition config = propConfigs.get(propertyName.toLowerCase(Locale.ENGLISH));\n             if (config != null) {\n                 return config;\n             } else if (namePatterns.size() > 0) {\n@@ -761,7 +765,7 @@ public boolean isBasedOnNtBase(){\n                     if(pd.isRegexp){\n                         patterns.add(new NamePattern(pd.name, pd));\n                     } else {\n-                        propDefns.put(pd.name, pd);\n+                        propDefns.put(pd.name.toLowerCase(Locale.ENGLISH), pd);\n                     }\n \n                     if (pd.relative){\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "2559",
        "nb_skipped": 2,
        "commit": "dfa87520",
        "nb_failure": 2,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 7,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.segment.standby.FailoverTest"
        ],
        "patch": "diff --git a/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/StandbyClient.java b/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/StandbyClient.java\nindex bdcf51341c..79b348fd6c 100644\n--- a/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/StandbyClient.java\n+++ b/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/StandbyClient.java\n@@ -81,7 +81,7 @@\n     private final AtomicBoolean running = new AtomicBoolean(true);\n \n     public StandbyClient(String host, int port, SegmentStore store) throws SSLException {\n-        this(host, port, store, false, 5000);\n+        this(host, port, store, false, 10000);\n     }\n \n     public StandbyClient(String host, int port, SegmentStore store, boolean secure, int readTimeoutMs) throws SSLException {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "2355",
        "nb_skipped": 0,
        "commit": "74f22886",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 2233,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest",
            "org.apache.jackrabbit.oak.plugins.index.property.OrderedIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\nindex af95c65c71..fb046c53dd 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n@@ -497,8 +497,14 @@ private Expression parseExpression() throws ParseException {\n         if (readIf(\"@\")) {\n             return readProperty();\n         } else if (readIf(\"true\")) {\n+            if (readIf(\"(\")) {\n+                read(\")\");\n+            }\n             return Expression.Literal.newBoolean(true);\n         } else if (readIf(\"false\")) {\n+            if (readIf(\"(\")) {\n+                read(\")\");\n+            }\n             return Expression.Literal.newBoolean(false);\n         } else if (currentTokenType == VALUE_NUMBER) {\n             Expression.Literal l = Expression.Literal.newNumber(currentToken);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 6,
        "jira_id": "2864",
        "nb_skipped": 1,
        "commit": "f51ea2a2",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 1756,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.namepath.NamePathMapperImplTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrNameParser.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrNameParser.java\nindex 205a754979..ebc7c08cce 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrNameParser.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrNameParser.java\n@@ -92,7 +92,6 @@ public static boolean parse(String jcrName, Listener listener, int index) {\n         String prefix;\n         int nameStart = 0;\n         int state = STATE_PREFIX_START;\n-        boolean trailingSpaces = false;\n \n         for (int i = 0; i < len; i++) {\n             char c = jcrName.charAt(i);\n@@ -101,10 +100,6 @@ public static boolean parse(String jcrName, Listener listener, int index) {\n                     listener.error(\"Prefix must not be empty\");\n                     return false;\n                 } else if (state == STATE_PREFIX) {\n-                    if (trailingSpaces) {\n-                        listener.error(\"Trailing spaces not allowed\");\n-                        return false;\n-                    }\n                     prefix = jcrName.substring(0, i);\n                     if (!XMLChar.isValidNCName(prefix)) {\n                         listener.error(\"Invalid name prefix: \"+ prefix);\n@@ -117,14 +112,7 @@ public static boolean parse(String jcrName, Listener listener, int index) {\n                     listener.error(\"'\" + c + \"' not allowed in name\");\n                     return false;\n                 }\n-                trailingSpaces = false;\n-            } else if (c == ' ') {\n-                if (state == STATE_PREFIX_START || state == STATE_NAME_START) {\n-                    listener.error(\"'\" + c + \"' not valid name start\");\n-                    return false;\n-                }\n-                trailingSpaces = true;\n-            } else if (Character.isWhitespace(c) || c == '[' || c == ']' || c == '*' || c == '|') {\n+            } else if (c == '[' || c == ']' || c == '*' || c == '|') {\n                 listener.error(\"'\" + c + \"' not allowed in name\");\n                 return false;\n             } else if (c == '/') {\n@@ -134,7 +122,6 @@ public static boolean parse(String jcrName, Listener listener, int index) {\n                     listener.error(\"'\" + c + \"' not allowed in name\");\n                     return false;\n                 }\n-                trailingSpaces = false;\n             } else if (c == '{') {\n                 if (state == STATE_PREFIX_START) {\n                     state = STATE_URI_START;\n@@ -147,7 +134,6 @@ public static boolean parse(String jcrName, Listener listener, int index) {\n                     state = STATE_NAME;\n                     nameStart = i;\n                 }\n-                trailingSpaces = false;\n             } else if (c == '}') {\n                 if (state == STATE_URI_START || state == STATE_URI) {\n                     String tmp = jcrName.substring(1, i);\n@@ -178,7 +164,6 @@ public static boolean parse(String jcrName, Listener listener, int index) {\n                     state = STATE_NAME;\n                     nameStart = i;\n                 }\n-                trailingSpaces = false;\n             } else {\n                 if (state == STATE_PREFIX_START) {\n                     state = STATE_PREFIX; // prefix start\n@@ -188,7 +173,6 @@ public static boolean parse(String jcrName, Listener listener, int index) {\n                 } else if (state == STATE_URI_START) {\n                     state = STATE_URI;\n                 }\n-                trailingSpaces = false;\n             }\n         }\n \n@@ -203,10 +187,6 @@ public static boolean parse(String jcrName, Listener listener, int index) {\n             listener.error(\"Local name must not be empty\");\n             return false;\n         }\n-        if (trailingSpaces) {\n-            listener.error(\"Trailing spaces not allowed\");\n-            return false;\n-        }\n \n         return listener.name(jcrName, index);\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrPathParser.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrPathParser.java\nindex b63958a23f..54c1c9ebb1 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrPathParser.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrPathParser.java\n@@ -80,10 +80,6 @@ public static boolean parse(String jcrPath, Listener listener) {\n         while (pos <= len) {\n             char c = pos == len ? EOF : jcrPath.charAt(pos);\n             pos++;\n-            // special check for whitespace\n-            if (c != ' ' && Character.isWhitespace(c)) {\n-                c = '\\t';\n-            }\n \n             switch (c) {\n                 case '/':\n@@ -205,24 +201,6 @@ public static boolean parse(String jcrPath, Listener listener) {\n                     }\n                     break;\n \n-                case ' ':\n-                    if (state == STATE_PREFIX_START || state == STATE_NAME_START) {\n-                        listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c +\n-                                \"' not valid name start\");\n-                        return false;\n-                    } else if (state == STATE_INDEX_END) {\n-                        listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c +\n-                                \"' not valid after index. '/' expected.\");\n-                        return false;\n-                    } else if (state == STATE_DOT || state == STATE_DOTDOT) {\n-                        state = STATE_PREFIX;\n-                    }\n-                    break;\n-\n-                case '\\t':\n-                    listener.error('\\'' + jcrPath + \"' is not a valid path. \" +\n-                            \"Whitespace not a allowed in name.\");\n-                    return false;\n                 case '*':\n                 case '|':\n                     listener.error('\\'' + jcrPath + \"' is not a valid path. '\" + c +\n@@ -257,7 +235,7 @@ public static boolean parse(String jcrPath, Listener listener) {\n                         return false;\n                     }\n             }\n-            wasSlash = c == ' ';\n+            wasSlash = c == '/';\n         }\n         return true;\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\nindex 3b4219c430..d0d1e26e8a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\n@@ -244,10 +244,14 @@ public static boolean isValidLocalName(String local) {\n \n         for (int i = 0; i < local.length(); i++) {\n             char ch = local.charAt(i);\n-            if (i == 0 && Character.isWhitespace(ch)) {\n+            if (Character.isSpaceChar(ch)) {\n+                if (i == 0) {\n                     return false; // leading whitespace\n-            } else if (i == local.length() - 1 && Character.isWhitespace(ch)) {\n+                } else if (i == local.length() - 1) {\n                     return false; // trailing whitespace\n+                } else if (ch != ' ') {\n+                    return false; // only spaces are allowed as whitespace\n+                }\n             } else if (\"/:[]|*\".indexOf(ch) != -1) { // TODO: XMLChar check\n                 return false; // invalid name character\n             }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 8,
        "jira_id": "1174",
        "nb_skipped": 8,
        "commit": "342809f7",
        "nb_failure": 1,
        "linesRem": 45,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2439,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.name.NameValidatorTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\nindex d0d1e26e8a..a0a2367450 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\n@@ -58,6 +58,13 @@\n      */\n     private static final Map<String, String> ENCODED_URIS = newConcurrentMap();\n \n+    /**\n+     * By default node names with non space whitespace chars are not allowed.\n+     * However initial Oak release did allowed that and this flag is provided\n+     * to revert back to old behaviour if required for some case temporarily\n+     */\n+    private static final boolean allowOtherWhitespaceChars = Boolean.getBoolean(\"oak.allowOtherWhitespaceChars\");\n+\n     private Namespaces() {\n     }\n \n@@ -244,7 +251,8 @@ public static boolean isValidLocalName(String local) {\n \n         for (int i = 0; i < local.length(); i++) {\n             char ch = local.charAt(i);\n-            if (Character.isSpaceChar(ch)) {\n+            boolean spaceChar = allowOtherWhitespaceChars ? Character.isSpaceChar(ch) : Character.isWhitespace(ch);\n+            if (spaceChar) {\n                 if (i == 0) {\n                     return false; // leading whitespace\n                 } else if (i == local.length() - 1) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 4,
        "jira_id": "3412",
        "nb_skipped": 1,
        "commit": "2f85bd78",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3065,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.user.PasswordExpiryHistoryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserAuthentication.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserAuthentication.java\nindex f7b3b693a9..95fd76ae33 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserAuthentication.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserAuthentication.java\n@@ -169,7 +169,7 @@ private boolean changePassword(User user, SimpleCredentials credentials) {\n                 }\n             }\n         } catch (PasswordHistoryException e) {\n-            credentials.setAttribute(e.getClass().getName(), e.getMessage());\n+            credentials.setAttribute(e.getClass().getSimpleName(), e.getMessage());\n             log.error(\"Failed to change password for user \" + userId, e.getMessage());\n         } catch (RepositoryException e) {\n             log.error(\"Failed to change password for user \" + userId, e.getMessage());\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "3792",
        "nb_skipped": 1,
        "commit": "94110f21",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 1497,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.mongomk.RangeTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Range.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Range.java\nindex 19ed201916..52045fc9e9 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Range.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Range.java\n@@ -51,8 +51,9 @@\n      * @return <code>true</code> if within this range; <code>false</code>\n      * otherwise.\n      */\n-    boolean includes(Revision r) {\n-        return high.compareRevisionTime(r) >= 0\n+    boolean includes(@Nonnull Revision r) {\n+        return high.getClusterId() == r.getClusterId()\n+                && high.compareRevisionTime(r) >= 0\n                 && low.compareRevisionTime(r) <= 0;\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "1289",
        "nb_skipped": 6,
        "commit": "0c3e3d70",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2801,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentSplitTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\nindex dc3eb5e872..75853cec30 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\n@@ -240,10 +240,10 @@ private void collectRevisionsAndCommitRoot() {\n             } else if (r.getClusterId() == context.getClusterId() \n                     && !changes.contains(r)) {\n                 // OAK-2528: _commitRoot entry without associated change\n-                // consider all but most recent as garbage (OAK-3333)\n-                if (mostRecent) {\n+                // consider all but most recent as garbage (OAK-3333, OAK-4050)\n+                if (mostRecent && doc.isCommitted(r)) {\n                     mostRecent = false;\n-                } else {\n+                } else if (isGarbage(r)) {\n                     addGarbage(r, COMMIT_ROOT);\n                 }\n             }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "4050",
        "nb_skipped": 1,
        "commit": "52ca008c",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 702,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.RepositoryTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemImpl.java\nindex d59feb587f..ba16709b8f 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemImpl.java\n@@ -430,8 +430,12 @@ PropertyState createMultiState(String name, int type, Value[] values, PropertyDe\n         Value[] nonNullValues = compact(values);\n         int targetType = getType(definition, type);\n         if (nonNullValues.length == 0) {\n+            if (targetType == PropertyType.UNDEFINED) {\n+                // default to string when no other type hints are available\n+                targetType = PropertyType.STRING;\n+            }\n             return MemoryPropertyBuilder\n-                    .array(Type.fromTag(type, false), name)\n+                    .array(Type.fromTag(targetType, false), name)\n                     .getPropertyState();\n         } else if (targetType == type) {\n             return PropertyStates.createProperty(name, Arrays.asList(nonNullValues));\n",
        "project": "jackrabbit-oak",
        "linesAdd": 4,
        "jira_id": "510",
        "nb_skipped": 7,
        "commit": "f63d745a",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 12,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberSplitUpgradeTest",
            "org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberUpgradeTest",
            "org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest"
        ],
        "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\nindex 2734f3bf9f..d29b8f5aeb 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n@@ -22,6 +22,7 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Properties;\n+import java.util.Set;\n \n import javax.jcr.NamespaceException;\n import javax.jcr.NamespaceRegistry;\n@@ -38,8 +39,10 @@\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.plugins.index.reference.ReferenceEditorProvider;\n+import org.apache.jackrabbit.oak.plugins.name.NamespaceConstants;\n import org.apache.jackrabbit.oak.plugins.name.Namespaces;\n import org.apache.jackrabbit.oak.plugins.nodetype.RegistrationEditorProvider;\n+import org.apache.jackrabbit.oak.plugins.nodetype.write.InitialContent;\n import org.apache.jackrabbit.oak.spi.commit.CommitHook;\n import org.apache.jackrabbit.oak.spi.commit.CompositeHook;\n import org.apache.jackrabbit.oak.spi.commit.EditorHook;\n@@ -58,6 +61,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.common.collect.ImmutableSet;\n+\n import static com.google.common.base.Preconditions.checkState;\n import static com.google.common.collect.Lists.newArrayListWithCapacity;\n import static com.google.common.collect.Maps.newHashMap;\n@@ -118,6 +123,85 @@\n      */\n     private final NodeStore target;\n \n+    /**\n+     * the set of oak built-in nodetypes\n+     * todo: load from file or from repo\n+     */\n+    private static final Set<String> BUILT_IN_NODE_TYPES = ImmutableSet.of(\n+            \"mix:created\",\n+            \"mix:etag\",\n+            \"mix:language\",\n+            \"mix:lastModified\",\n+            \"mix:lifecycle\",\n+            \"mix:lockable\",\n+            \"mix:mimeType\",\n+            \"mix:referenceable\",\n+            \"mix:shareable\",\n+            \"mix:simpleVersionable\",\n+            \"mix:title\",\n+            \"mix:versionable\",\n+            \"nt:activity\",\n+            \"nt:address\",\n+            \"nt:base\",\n+            \"nt:childNodeDefinition\",\n+            \"nt:configuration\",\n+            \"nt:file\",\n+            \"nt:folder\",\n+            \"nt:frozenNode\",\n+            \"nt:hierarchyNode\",\n+            \"nt:linkedFile\",\n+            \"nt:nodeType\",\n+            \"nt:propertyDefinition\",\n+            \"nt:query\",\n+            \"nt:resource\",\n+            \"nt:unstructured\",\n+            \"nt:version\",\n+            \"nt:versionHistory\",\n+            \"nt:versionLabels\",\n+            \"nt:versionedChild\",\n+            \"oak:childNodeDefinition\",\n+            \"oak:childNodeDefinitions\",\n+            \"oak:namedChildNodeDefinitions\",\n+            \"oak:namedPropertyDefinitions\",\n+            \"oak:nodeType\",\n+            \"oak:propertyDefinition\",\n+            \"oak:propertyDefinitions\",\n+            \"oak:queryIndexDefinition\",\n+            \"oak:unstructured\",\n+            \"rep:ACE\",\n+            \"rep:ACL\",\n+            \"rep:AccessControl\",\n+            \"rep:AccessControllable\",\n+            \"rep:Activities\",\n+            \"rep:Authorizable\",\n+            \"rep:AuthorizableFolder\",\n+            \"rep:Configurations\",\n+            \"rep:DenyACE\",\n+            \"rep:GrantACE\",\n+            \"rep:Group\",\n+            \"rep:Impersonatable\",\n+            \"rep:MemberReferences\",\n+            \"rep:MemberReferencesList\",\n+            \"rep:Members\",\n+            \"rep:MergeConflict\",\n+            \"rep:PermissionStore\",\n+            \"rep:Permissions\",\n+            \"rep:Policy\",\n+            \"rep:PrincipalAccessControl\",\n+            \"rep:Privilege\",\n+            \"rep:Privileges\",\n+            \"rep:RepoAccessControllable\",\n+            \"rep:Restrictions\",\n+            \"rep:RetentionManageable\",\n+            \"rep:Token\",\n+            \"rep:User\",\n+            \"rep:VersionReference\",\n+            \"rep:nodeTypes\",\n+            \"rep:root\",\n+            \"rep:system\",\n+            \"rep:versionStorage\"\n+    );\n+\n     /**\n      * Copies the contents of the repository in the given source directory\n      * to the given target node store.\n@@ -183,6 +267,9 @@ public void copy() throws RepositoryException {\n         try {\n             NodeBuilder builder = target.getRoot().builder();\n \n+            // init target repository first\n+            new InitialContent().initialize(builder);\n+\n             Map<Integer, String> idxToPrefix = copyNamespaces(builder);\n             copyNodeTypes(builder);\n             copyVersionStore(builder, idxToPrefix);\n@@ -223,7 +310,7 @@ private String getOakName(Name name) throws NamespaceException {\n         Map<Integer, String> idxToPrefix = newHashMap();\n \n         NodeBuilder system = root.child(JCR_SYSTEM);\n-        NodeBuilder namespaces = Namespaces.createStandardMappings(system);\n+        NodeBuilder namespaces = system.child(NamespaceConstants.REP_NAMESPACES);\n \n         Properties registry = loadProperties(\"/namespaces/ns_reg.properties\");\n         Properties indexes  = loadProperties(\"/namespaces/ns_idx.properties\");\n@@ -292,8 +379,14 @@ private void copyNodeTypes(NodeBuilder root) throws RepositoryException {\n \n         logger.info(\"Copying registered node types\");\n         for (Name name : sourceRegistry.getRegisteredNodeTypes()) {\n+            // skip built-in nodetypes (OAK-1235)\n+            String oakName = getOakName(name);\n+            if (BUILT_IN_NODE_TYPES.contains(oakName)) {\n+                logger.info(\"skipping built-on nodetype: {}\", name);\n+                continue;\n+            }\n             QNodeTypeDefinition def = sourceRegistry.getNodeTypeDef(name);\n-            NodeBuilder type = types.child(getOakName(name));\n+            NodeBuilder type = types.child(oakName);\n             copyNodeType(def, type);\n         }\n     }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 89,
        "jira_id": "1235",
        "nb_skipped": 1,
        "commit": "1beb2a50",
        "nb_failure": 4,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 404,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.p2.strategy.ContentMirrorStoreStrategyTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java\nindex 36c1dee6ef..9792b659ef 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java\n@@ -16,11 +16,12 @@\n  */\n package org.apache.jackrabbit.oak.plugins.index.p2.strategy;\n \n+import java.util.Collections;\n import java.util.HashSet;\n import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.Queue;\n+import java.util.Map;\n import java.util.Set;\n+import java.util.TreeMap;\n \n import org.apache.jackrabbit.oak.api.CommitFailedException;\n import org.apache.jackrabbit.oak.api.PropertyState;\n@@ -38,46 +39,66 @@ public void remove(NodeBuilder index, String key, Iterable<String> values) {\n             return;\n         }\n         NodeBuilder child = index.child(key);\n-        Queue<NodeBuilder> parentQueue = new LinkedList<NodeBuilder>();\n+        Map<String, NodeBuilder> parents = new TreeMap<String, NodeBuilder>(Collections.reverseOrder());\n+\n         for (String rm : values) {\n             if (PathUtils.denotesRoot(rm)) {\n                 child.removeProperty(\"match\");\n             } else {\n-                NodeBuilder indexEntry = child;\n-                Iterator<String> segments = PathUtils.elements(rm).iterator();\n+                String parentPath = PathUtils.getParentPath(rm);\n+                String name = PathUtils.getName(rm);\n+                NodeBuilder indexEntry = parents.get(parentPath);\n+                if (indexEntry == null) {\n+                    indexEntry = child;\n+                    String segmentPath = \"\";\n+                    Iterator<String> segments = PathUtils.elements(parentPath)\n+                            .iterator();\n                     while (segments.hasNext()) {\n                         String segment = segments.next();\n-                    if (segments.hasNext()) {\n-                        parentQueue.add(indexEntry);\n+                        segmentPath = PathUtils.concat(segmentPath, segment);\n                         indexEntry = indexEntry.child(segment);\n-                    } else {\n-                        // last segment\n-                        if (indexEntry.hasChildNode(segment)) {\n-                            indexEntry.removeNode(segment);\n+                        parents.put(segmentPath, indexEntry);\n+                    }\n                 }\n+                if (indexEntry.hasChildNode(name)) {\n+                    NodeBuilder childEntry = indexEntry.child(name);\n+                    childEntry.removeProperty(\"match\");\n+                    if (childEntry.getChildNodeCount() == 0) {\n+                        indexEntry.removeNode(name);\n                     }\n                 }\n             }\n         }\n         // prune the index: remove all children that have no children\n         // and no \"match\" property progressing bottom up\n-        // see OAK-520\n-        // while (!parentQueue.isEmpty()) {\n-        // NodeBuilder node = parentQueue.poll();\n-        // for (String name : node.getChildNodeNames()) {\n-        // NodeBuilder segment = node.child(name);\n-        // if (segment.getChildNodeCount() == 0\n-        // && segment.getProperty(\"match\") == null) {\n-        // segment.removeNode(name);\n-        // }\n-        // }\n-        // }\n-        // finally remove the index node if empty\n-        if (child.getChildNodeCount() == 0) {\n+        Iterator<String> it = parents.keySet().iterator();\n+        while (it.hasNext()) {\n+            String path = it.next();\n+            NodeBuilder parent = parents.get(path);\n+            pruneNode(parent);\n+        }\n+\n+        // finally prune the index node\n+        pruneNode(child);\n+        if (child.getChildNodeCount() == 0\n+                && child.getProperty(\"match\") == null) {\n             index.removeNode(key);\n         }\n     }\n \n+    private void pruneNode(NodeBuilder parent) {\n+        if (parent.isRemoved()) {\n+            return;\n+        }\n+        for (String name : parent.getChildNodeNames()) {\n+            NodeBuilder segment = parent.child(name);\n+            if (segment.getChildNodeCount() == 0\n+                    && segment.getProperty(\"match\") == null) {\n+                parent.removeNode(name);\n+            }\n+        }\n+    }\n+\n     @Override\n     public void insert(NodeBuilder index, String key, boolean unique,\n             Iterable<String> values) throws CommitFailedException {\n@@ -85,9 +106,7 @@ public void insert(NodeBuilder index, String key, boolean unique,\n \n         for (String add : values) {\n             NodeBuilder indexEntry = child;\n-            Iterator<String> segments = PathUtils.elements(add).iterator();\n-            while (segments.hasNext()) {\n-                String segment = segments.next();\n+            for(String segment: PathUtils.elements(add)){\n                 indexEntry = indexEntry.child(segment);\n             }\n             indexEntry.setProperty(\"match\", true);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 45,
        "jira_id": "520",
        "nb_skipped": 0,
        "commit": "ec961a38",
        "nb_failure": 1,
        "linesRem": 14,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1795,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.RepositoryTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java\nindex bc2eb6b10b..f6d2c44ec4 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java\n@@ -404,7 +404,12 @@ public void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos)\n                     conflicting = currentStateIdManager.getTree(id);\n                 }\n \n-                if (conflicting != null && conflicting.exists()) {\n+                // resolve conflict if there is one or force\n+                // conflict resolution when behavior is IMPORT_UUID_CREATE_NEW.\n+                // the latter will always create a new UUID even if no\n+                // conflicting node exists. see OAK-1244\n+                if ((conflicting != null && conflicting.exists())\n+                        || uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n                     // resolve uuid conflict\n                     tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n                     if (tree == null) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "1244",
        "nb_skipped": 5,
        "commit": "b4a93c81",
        "nb_failure": 4,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1809,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\nindex 914881cac5..443f0cb26b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\n@@ -30,6 +30,8 @@\n import org.apache.jackrabbit.oak.spi.query.Filter.PropertyRestriction;\n import org.apache.jackrabbit.oak.spi.query.QueryIndex;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import com.google.common.base.Charsets;\n import com.google.common.collect.Iterables;\n@@ -90,6 +92,8 @@\n      */\n     private static final String EMPTY_TOKEN = \":\";\n \n+    private static final Logger LOG = LoggerFactory.getLogger(PropertyIndex.class);\n+\n     static Set<String> encode(PropertyValue value) {\n         if (value == null) {\n             return null;\n@@ -113,6 +117,37 @@\n         return values;\n     }\n \n+    private Cheapest findCheapestProperty(Filter filter, PropertyIndexLookup lookup) {\n+        Cheapest cost = new Cheapest();\n+        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n+            String propertyName = PathUtils.getName(pr.propertyName);\n+            double propertyCost = Double.POSITIVE_INFINITY;\n+            // TODO support indexes on a path\n+            // currently, only indexes on the root node are supported\n+            if (lookup.isIndexed(propertyName, \"/\", filter)) {\n+                if (pr.firstIncluding && pr.lastIncluding\n+                    && pr.first != null && pr.first.equals(pr.last)) {\n+                    // \"[property] = $value\"\n+                    propertyCost = lookup.getCost(filter, propertyName, pr.first);\n+                } else if (pr.list != null) {\n+                    propertyCost = 0;\n+                    for (PropertyValue p : pr.list) {\n+                        propertyCost += lookup.getCost(filter, propertyName, p);\n+                    }\n+                } else {\n+                    // processed as \"[property] is not null\"\n+                    propertyCost = lookup.getCost(filter, propertyName, null);\n+                }\n+            }\n+            LOG.debug(\"property cost for {} is {}\", propertyName, propertyCost);\n+            if (propertyCost < cost.cost) {\n+                cost.cost = propertyCost;\n+                cost.propertyRestriction = pr;\n+            }\n+        }\n+        return cost;\n+    }\n+\n     //--------------------------------------------------------< QueryIndex >--\n \n     @Override\n@@ -142,29 +177,9 @@ public double getCost(Filter filter, NodeState root) {\n         }\n \n         PropertyIndexLookup lookup = getLookup(root);\n-        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n-            String propertyName = PathUtils.getName(pr.propertyName);\n-            // TODO support indexes on a path\n-            // currently, only indexes on the root node are supported\n-            if (lookup.isIndexed(propertyName, \"/\", filter)) {\n-                if (pr.firstIncluding && pr.lastIncluding\n-                    && pr.first != null && pr.first.equals(pr.last)) {\n-                    // \"[property] = $value\"\n-                    return lookup.getCost(filter, propertyName, pr.first);\n-                } else if (pr.list != null) {\n-                    double cost = 0;\n-                    for (PropertyValue p : pr.list) {\n-                        cost += lookup.getCost(filter, propertyName, p);\n-                    }\n-                    return cost;\n-                } else {\n-                    // processed as \"[property] is not null\"\n-                    return lookup.getCost(filter, propertyName, null);\n-                }\n-            }\n-        }\n-        // not an appropriate index\n-        return Double.POSITIVE_INFINITY;\n+        Cheapest cheapest = findCheapestProperty(filter, lookup);\n+        LOG.debug(\"Cheapest property cost is {} for property {}\", cheapest.cost, cheapest.propertyRestriction != null ? cheapest.propertyRestriction.propertyName : null);\n+        return cheapest.cost;\n     }\n \n     @Override\n@@ -173,7 +188,11 @@ public Cursor query(Filter filter, NodeState root) {\n \n         PropertyIndexLookup lookup = getLookup(root);\n         int depth = 1;\n-        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n+\n+        Cheapest cheapest = findCheapestProperty(filter, lookup);\n+        PropertyRestriction pr = cheapest.propertyRestriction;\n+\n+        if (pr != null) {\n             String propertyName = PathUtils.getName(pr.propertyName);\n             depth = PathUtils.getDepth(pr.propertyName);\n             // TODO support indexes on a path\n@@ -184,7 +203,6 @@ public Cursor query(Filter filter, NodeState root) {\n                     && pr.first != null && pr.first.equals(pr.last)) {\n                     // \"[property] = $value\"\n                     paths = lookup.query(filter, propertyName, pr.first);\n-                    break;\n                 } else if (pr.list != null) {\n                     for (PropertyValue pv : pr.list) {\n                         Iterable<String> p = lookup.query(filter, propertyName, pv);\n@@ -194,11 +212,9 @@ public Cursor query(Filter filter, NodeState root) {\n                             paths = Iterables.concat(paths, p);\n                         }\n                     }\n-                    break;\n                 } else {\n                     // processed as \"[property] is not null\"\n                     paths = lookup.query(filter, propertyName, null);\n-                    break;\n                 }\n             }\n         }\n@@ -217,7 +233,10 @@ public String getPlan(Filter filter, NodeState root) {\n         StringBuilder buff = new StringBuilder(\"property\");\n         StringBuilder notIndexed = new StringBuilder();\n         PropertyIndexLookup lookup = getLookup(root);\n-        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n+        Cheapest cheapest = findCheapestProperty(filter, lookup);\n+        PropertyRestriction pr = cheapest.propertyRestriction;\n+\n+        if (pr != null) {\n             String propertyName = PathUtils.getName(pr.propertyName);\n             // TODO support indexes on a path\n             // currently, only indexes on the root node are supported\n@@ -251,4 +270,9 @@ public String getPlan(Filter filter, NodeState root) {\n         return buff.toString();\n     }\n \n+    private static class Cheapest {\n+        private double cost = Double.POSITIVE_INFINITY;\n+        private PropertyRestriction propertyRestriction;\n+    }\n+\n }\n\\ No newline at end of file\n",
        "project": "jackrabbit-oak",
        "linesAdd": 48,
        "jira_id": "1894",
        "nb_skipped": 9,
        "commit": "35562cce",
        "nb_failure": 0,
        "linesRem": 23,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1355,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.CompatibilityIssuesTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/NodeDelegate.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/NodeDelegate.java\nindex 925a88bd2d..c42f7f9abd 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/NodeDelegate.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/delegate/NodeDelegate.java\n@@ -586,6 +586,7 @@ private Tree findMatchingPropertyDefinition(\n         }\n \n         // First look for a matching named property definition\n+        Tree fuzzyMatch = null;\n         for (Tree type : types) {\n             Tree definitions = type\n                     .getChild(OAK_NAMED_PROPERTY_DEFINITIONS)\n@@ -598,10 +599,12 @@ private Tree findMatchingPropertyDefinition(\n             if (definition.exists()) {\n                 return definition;\n             }\n-            if (!exactTypeMatch) {\n             for (Tree def : definitions.getChildren()) {\n                 if (propertyType.isArray() == TreeUtil.getBoolean(def, JCR_MULTIPLE)) {\n-                        return def;\n+                    if (getBoolean(def, JCR_PROTECTED)) {\n+                        return null; // no fuzzy matches for protected items\n+                    } else if (!exactTypeMatch && fuzzyMatch == null) {\n+                        fuzzyMatch = def;\n                     }\n                 }\n             }\n@@ -618,16 +621,17 @@ private Tree findMatchingPropertyDefinition(\n             if (definition.exists()) {\n                 return definition;\n             }\n-            if (!exactTypeMatch) {\n+            if (!exactTypeMatch && fuzzyMatch == null) {\n                 for (Tree def : definitions.getChildren()) {\n                     if (propertyType.isArray() == TreeUtil.getBoolean(def, JCR_MULTIPLE)) {\n-                        return def;\n+                        fuzzyMatch = def;\n+                        break;\n                     }\n                 }\n             }\n         }\n \n-        return null;\n+        return fuzzyMatch;\n     }\n \n     private Tree findMatchingChildNodeDefinition(\n",
        "project": "jackrabbit-oak",
        "linesAdd": 9,
        "jira_id": "1020",
        "nb_skipped": 3,
        "commit": "83427028",
        "nb_failure": 3,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 330,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.CRUDTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\nindex 2771c2805f..a3d9da9157 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n@@ -1450,13 +1450,17 @@ private Property internalSetProperty(final String jcrName, final Value value,\n         return sessionDelegate.perform(new SessionOperation<Property>() {\n             @Override\n             public Property perform() throws RepositoryException {\n+                String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n                 if (value == null) {\n+                    if (hasProperty(jcrName)) {\n                         Property property = getProperty(jcrName);\n                         property.remove();\n                         return property;\n                     } else {\n-                    String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n-\n+                        return new PropertyImpl(new PropertyDelegate(\n+                                sessionDelegate, dlg.getLocation().getChild(oakName)));\n+                    }\n+                } else {\n                     PropertyDefinition definition;\n                     if (hasProperty(jcrName)) {\n                         definition = getProperty(jcrName).getDefinition();\n@@ -1485,13 +1489,17 @@ private Property internalSetProperty(final String jcrName, final Value[] values,\n         return sessionDelegate.perform(new SessionOperation<Property>() {\n             @Override\n             public Property perform() throws RepositoryException {\n+                String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n                 if (values == null) {\n-                    Property p = getProperty(jcrName);\n-                    p.remove();\n-                    return p;\n+                    if (hasProperty(jcrName)) {\n+                        Property property = getProperty(jcrName);\n+                        property.remove();\n+                        return property;\n+                    } else {\n+                        return new PropertyImpl(new PropertyDelegate(\n+                                sessionDelegate, dlg.getLocation().getChild(oakName)));\n+                    }\n                 } else {\n-                    String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n-\n                     PropertyDefinition definition;\n                     if (hasProperty(jcrName)) {\n                         definition = getProperty(jcrName).getDefinition();\n",
        "project": "jackrabbit-oak",
        "linesAdd": 15,
        "jira_id": "395",
        "nb_skipped": 4,
        "commit": "e6c31270",
        "nb_failure": 0,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2425,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentSplitTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\nindex 33aafe5a08..a4265212db 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\n@@ -233,6 +233,7 @@ private void collectRevisionsAndCommitRoot() {\n         committedChanges.put(REVISIONS, revisions);\n         NavigableMap<Revision, String> commitRoot =\n                 new TreeMap<Revision, String>(context.getRevisionComparator());\n+        boolean mostRecent = true;\n         for (Map.Entry<Revision, String> entry : doc.getLocalCommitRoot().entrySet()) {\n             Revision r = entry.getKey();\n             if (splitRevs.contains(r)) {\n@@ -240,11 +241,15 @@ private void collectRevisionsAndCommitRoot() {\n                 numValues++;\n             } else if (r.getClusterId() == context.getClusterId() \n                     && !changes.contains(r)) {\n-                // OAK-2528: _commitRoot entry without associated\n-                // change -> consider as garbage\n+                // OAK-2528: _commitRoot entry without associated change\n+                // consider all but most recent as garbage (OAK-3333)\n+                if (mostRecent) {\n+                    mostRecent = false;\n+                } else {\n                     addGarbage(r, COMMIT_ROOT);\n                 }\n             }\n+        }\n         committedChanges.put(COMMIT_ROOT, commitRoot);\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 5,
        "jira_id": "3333",
        "nb_skipped": 1,
        "commit": "194999ed",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3096,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex fbcb6468c1..f4006d4c5f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -757,6 +757,15 @@ Revision getNewestRevision(final RevisionContext context,\n                     clusterIds.add(prevRev.getClusterId());\n                 }\n             }\n+            if (!clusterIds.isEmpty()) {\n+                // add clusterIds of local changes as well\n+                for (Revision r : getLocalCommitRoot().keySet()) {\n+                    clusterIds.add(r.getClusterId());\n+                }\n+                for (Revision r : getLocalRevisions().keySet()) {\n+                    clusterIds.add(r.getClusterId());\n+                }\n+            }\n         }\n         // if we don't have clusterIds, we can use the local changes only\n         boolean fullScan = true;\n@@ -786,7 +795,8 @@ Revision getNewestRevision(final RevisionContext context,\n             }\n             if (!fullScan) {\n                 // check if we can stop going through changes\n-                if (clusterIds.contains(r.getClusterId())) {\n+                if (isRevisionNewer(context, lower, r)\n+                        && newestRevs.containsKey(r.getClusterId())) {\n                     if (isRevisionNewer(context, lower, r)) {\n                         clusterIds.remove(r.getClusterId());\n                         if (clusterIds.isEmpty()) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 10,
        "jira_id": "3798",
        "nb_skipped": 1,
        "commit": "2ac1dccd",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1859,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java\nindex 070996035c..83a0e229dd 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java\n@@ -207,9 +207,11 @@ public TokenInfo createToken(Credentials credentials) {\n     @Override\n     public TokenInfo createToken(String userId, Map<String, ?> attributes) {\n         String error = \"Failed to create login token. \";\n-        NodeUtil tokenParent = getTokenParent(userId);\n+        User user = getUser(userId);\n+        NodeUtil tokenParent = getTokenParent(user);\n         if (tokenParent != null) {\n             try {\n+                String id = user.getID();\n                 long creationTime = new Date().getTime();\n                 NodeUtil tokenNode = createTokenNode(tokenParent, creationTime);\n                 tokenNode.setString(JcrConstants.JCR_UUID, IdentifierManager.generateUUID());\n@@ -218,7 +220,7 @@ public TokenInfo createToken(String userId, Map<String, ?> attributes) {\n                 String nodeId = getIdentifier(tokenNode.getTree());\n                 String token = new StringBuilder(nodeId).append(DELIM).append(key).toString();\n \n-                String keyHash = PasswordUtil.buildPasswordHash(getKeyValue(key, userId), options);\n+                String keyHash = PasswordUtil.buildPasswordHash(getKeyValue(key, id), options);\n                 tokenNode.setString(TOKEN_ATTRIBUTE_KEY, keyHash);\n \n                 long exp;\n@@ -237,7 +239,7 @@ public TokenInfo createToken(String userId, Map<String, ?> attributes) {\n                     }\n                 }\n                 root.commit();\n-                return new TokenInfoImpl(tokenNode, token, userId);\n+                return new TokenInfoImpl(tokenNode, token, id);\n             } catch (NoSuchAlgorithmException e) {\n                 // error while generating login token\n                 log.error(error, e.getMessage());\n@@ -247,7 +249,7 @@ public TokenInfo createToken(String userId, Map<String, ?> attributes) {\n             } catch (CommitFailedException e) {\n                 // conflict while committing changes\n                 log.warn(error, e.getMessage());\n-            } catch (AccessDeniedException e) {\n+            } catch (RepositoryException e) {\n                 log.warn(error, e.getMessage());\n             }\n         } else {\n@@ -320,7 +322,7 @@ private static String generateKey(int size) {\n     }\n \n     @Nonnull\n-    private static String getKeyValue(String key, String userId) {\n+    private static String getKeyValue(@Nonnull String key, @Nonnull String userId) {\n         return key + userId;\n     }\n \n@@ -359,12 +361,29 @@ private String getUserId(Tree tokenTree) {\n     }\n \n     @CheckForNull\n-    private NodeUtil getTokenParent(String userId) {\n-        NodeUtil tokenParent = null;\n-        String parentPath = null;\n+    private User getUser(String userId) {\n         try {\n             Authorizable user = userManager.getAuthorizable(userId);\n             if (user != null && !user.isGroup()) {\n+                return (User) user;\n+            } else {\n+                log.debug(\"Cannot create login token: No corresponding node for User \" + userId + '.');\n+            }\n+        } catch (RepositoryException e) {\n+            // error while accessing user.\n+            log.debug(\"Error while accessing user \" + userId + '.', e);\n+        }\n+        return null;\n+    }\n+\n+    @CheckForNull\n+    private NodeUtil getTokenParent(@CheckForNull User user) {\n+        if (user == null) {\n+            return null;\n+        }\n+        NodeUtil tokenParent = null;\n+        String parentPath = null;\n+        try {\n             String userPath = user.getPath();\n             NodeUtil userNode = new NodeUtil(root.getTree(userPath));\n             tokenParent = userNode.getChild(TOKENS_NODE_NAME);\n@@ -373,12 +392,9 @@ private NodeUtil getTokenParent(String userId) {\n                 parentPath = userPath + '/' + TOKENS_NODE_NAME;\n                 root.commit();\n             }\n-            } else {\n-                log.debug(\"Cannot create login token: No corresponding node for User \" + userId + '.');\n-            }\n         } catch (RepositoryException e) {\n-            // error while accessing user.\n-            log.debug(\"Error while accessing user \" + userId + '.', e);\n+            // error while creating token node.\n+            log.debug(\"Error while creating token node \", e.getMessage());\n         } catch (CommitFailedException e) {\n             // conflict while creating token store for this user -> refresh and\n             // try to get the tree from the updated root.\n",
        "project": "jackrabbit-oak",
        "linesAdd": 27,
        "jira_id": "1985",
        "nb_skipped": 9,
        "commit": "f620b79b",
        "nb_failure": 1,
        "linesRem": 12,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 1562,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.authentication.TokenDefaultLoginModuleTest",
            "org.apache.jackrabbit.oak.security.authentication.Jackrabbit2ConfigurationTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenLoginModule.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenLoginModule.java\nindex 79a05df510..74f5281d24 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenLoginModule.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenLoginModule.java\n@@ -170,7 +170,8 @@ public boolean commit() throws LoginException {\n                     for (String name : attributes.keySet()) {\n                         tc.setAttribute(name, attributes.get(name));\n                     }\n-                    updateSubject(tc, getAuthInfo(ti), null);\n+                    sharedState.put(SHARED_KEY_ATTRIBUTES, attributes);\n+                    updateSubject(tc, null, null);\n                 } else {\n                     // failed to create token -> fail commit()\n                     log.debug(\"TokenProvider failed to create a login token for user \" + userId);\n@@ -236,19 +237,21 @@ private TokenProvider getTokenProvider() {\n      * @param tokenInfo The tokenInfo to retrieve attributes from.\n      * @return The {@code AuthInfo} resulting from the successful login.\n      */\n-    @Nonnull\n-    private AuthInfo getAuthInfo(TokenInfo tokenInfo) {\n+    @CheckForNull\n+    private AuthInfo getAuthInfo(@Nullable TokenInfo tokenInfo) {\n+        if (tokenInfo != null) {\n             Map<String, Object> attributes = new HashMap<String, Object>();\n-        if (tokenProvider != null && tokenInfo != null) {\n             Map<String, String> publicAttributes = tokenInfo.getPublicAttributes();\n             for (String attrName : publicAttributes.keySet()) {\n                 attributes.put(attrName, publicAttributes.get(attrName));\n             }\n+            return new AuthInfoImpl(tokenInfo.getUserId(), attributes, principals);\n+        } else {\n+            return null;\n         }\n-        return new AuthInfoImpl(userId, attributes, principals);\n     }\n \n-    private void updateSubject(@Nonnull TokenCredentials tc, @Nonnull AuthInfo authInfo,\n+    private void updateSubject(@Nonnull TokenCredentials tc, @Nullable AuthInfo authInfo,\n                                @Nullable Set<? extends Principal> principals) {\n         if (!subject.isReadOnly()) {\n             subject.getPublicCredentials().add(tc);\n@@ -257,12 +260,9 @@ private void updateSubject(@Nonnull TokenCredentials tc, @Nonnull AuthInfo authI\n                 subject.getPrincipals().addAll(principals);\n             }\n \n-            // replace all existing auth-info\n-            Set<AuthInfo> ais = subject.getPublicCredentials(AuthInfo.class);\n-            if (!ais.isEmpty()) {\n-                subject.getPublicCredentials().removeAll(ais);\n+            if (authInfo != null) {\n+                setAuthInfo(authInfo, subject);\n             }\n-            subject.getPublicCredentials().add(authInfo);\n         }\n     }\n }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/user/LoginModuleImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/user/LoginModuleImpl.java\nindex 6434c4b9c3..489b5d254c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/user/LoginModuleImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/user/LoginModuleImpl.java\n@@ -33,9 +33,9 @@\n \n import org.apache.jackrabbit.oak.api.AuthInfo;\n import org.apache.jackrabbit.oak.spi.security.ConfigurationParameters;\n-import org.apache.jackrabbit.oak.spi.security.authentication.AuthInfoImpl;\n import org.apache.jackrabbit.oak.spi.security.SecurityProvider;\n import org.apache.jackrabbit.oak.spi.security.authentication.AbstractLoginModule;\n+import org.apache.jackrabbit.oak.spi.security.authentication.AuthInfoImpl;\n import org.apache.jackrabbit.oak.spi.security.authentication.Authentication;\n import org.apache.jackrabbit.oak.spi.security.authentication.ImpersonationCredentials;\n import org.apache.jackrabbit.oak.spi.security.user.UserConfiguration;\n@@ -143,10 +143,7 @@ public boolean commit() {\n             if (!subject.isReadOnly()) {\n                 subject.getPrincipals().addAll(principals);\n                 subject.getPublicCredentials().add(credentials);\n-                Set<AuthInfo> ais = subject.getPublicCredentials(AuthInfo.class);\n-                if (ais.isEmpty()) {\n-                    subject.getPublicCredentials().add(createAuthInfo());\n-                }\n+                setAuthInfo(createAuthInfo(), subject);\n             } else {\n                 log.debug(\"Could not add information to read only subject {}\", subject);\n             }\n@@ -213,14 +210,19 @@ private String getAnonymousId() {\n     }\n \n     private AuthInfo createAuthInfo() {\n-        Map<String, Object> attributes = new HashMap<String, Object>();\n         Credentials creds;\n         if (credentials instanceof ImpersonationCredentials) {\n             creds = ((ImpersonationCredentials) credentials).getBaseCredentials();\n         } else {\n             creds = credentials;\n         }\n-        if (creds instanceof SimpleCredentials) {\n+        Map<String, Object> attributes = new HashMap<String, Object>();\n+        Object shared = sharedState.get(SHARED_KEY_ATTRIBUTES);\n+        if (shared instanceof Map) {\n+            for (Object key : ((Map) shared).keySet()) {\n+                attributes.put(key.toString(), ((Map) shared).get(key));\n+            }\n+        } else if (creds instanceof SimpleCredentials) {\n             SimpleCredentials sc = (SimpleCredentials) creds;\n             for (String attrName : sc.getAttributeNames()) {\n                 attributes.put(attrName, sc.getAttribute(attrName));\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/AbstractLoginModule.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/AbstractLoginModule.java\nindex 5a73a5cefc..e9a2d8d064 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/AbstractLoginModule.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/AbstractLoginModule.java\n@@ -35,6 +35,7 @@\n import javax.security.auth.spi.LoginModule;\n \n import org.apache.jackrabbit.api.security.user.UserManager;\n+import org.apache.jackrabbit.oak.api.AuthInfo;\n import org.apache.jackrabbit.oak.api.ContentRepository;\n import org.apache.jackrabbit.oak.api.ContentSession;\n import org.apache.jackrabbit.oak.api.Root;\n@@ -154,6 +155,12 @@\n      */\n     public static final String SHARED_KEY_LOGIN_NAME = \"javax.security.auth.login.name\";\n \n+    /**\n+     * Key of the sharedState entry referring to public attributes that are shared\n+     * between multiple login modules.\n+     */\n+    public static final String SHARED_KEY_ATTRIBUTES = \"javax.security.auth.login.attributes\";\n+\n     protected Subject subject;\n     protected CallbackHandler callbackHandler;\n     protected Map sharedState;\n@@ -441,4 +448,12 @@ protected PrincipalProvider getPrincipalProvider() {\n             return principalProvider.getPrincipals(userId);\n         }\n     }\n+\n+    static protected void setAuthInfo(@Nonnull AuthInfo authInfo, @Nonnull Subject subject) {\n+        Set<AuthInfo> ais = subject.getPublicCredentials(AuthInfo.class);\n+        if (!ais.isEmpty()) {\n+            subject.getPublicCredentials().removeAll(ais);\n+        }\n+        subject.getPublicCredentials().add(authInfo);\n+    }\n }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 31,
        "jira_id": "1363",
        "nb_skipped": 6,
        "commit": "69b68890",
        "nb_failure": 2,
        "linesRem": 17,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1895,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\nindex 11427c3500..44e31c04ba 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n@@ -58,6 +58,8 @@\n import org.apache.jackrabbit.oak.spi.query.QueryIndex.AdvancedQueryIndex;\n import org.apache.jackrabbit.oak.spi.query.QueryIndex.IndexPlan;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Iterables;\n@@ -66,6 +68,7 @@\n  * A selector within a query.\n  */\n public class SelectorImpl extends SourceImpl {\n+    private static final Logger LOG = LoggerFactory.getLogger(SelectorImpl.class);\n     \n     // TODO possibly support using multiple indexes (using index intersection / index merge)\n     private SelectorExecutionPlan plan;\n@@ -547,6 +550,10 @@ private PropertyValue currentOakProperty(String oakPropertyName, Integer propert\n         boolean asterisk = oakPropertyName.indexOf('*') >= 0;\n         if (asterisk) {\n             Tree t = currentTree();\n+            if (t != null) {\n+                LOG.trace(\"currentOakProperty() - '*' case. looking for '{}' in '{}'\",\n+                    oakPropertyName, t.getPath());\n+            }\n             ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();\n             readOakProperties(list, t, oakPropertyName, propertyType);\n             if (list.size() == 0) {\n@@ -630,10 +637,13 @@ private PropertyValue currentOakProperty(Tree t, String oakPropertyName, Integer\n     \n     private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String oakPropertyName, Integer propertyType) {\n         boolean skipCurrentNode = false;\n-        while (true) {\n+\n+        while (!skipCurrentNode) {\n             if (t == null || !t.exists()) {\n                 return;\n             }\n+            LOG.trace(\"readOakProperties() - reading '{}' for '{}'\", t.getPath(),\n+                oakPropertyName);\n             int slash = oakPropertyName.indexOf('/');\n             if (slash < 0) {\n                 break;\n@@ -659,6 +669,7 @@ private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String o\n         if (!\"*\".equals(oakPropertyName)) {\n             PropertyValue value = currentOakProperty(t, oakPropertyName, propertyType);\n             if (value != null) {\n+                LOG.trace(\"readOakProperties() - adding: '{}' from '{}'\", value, t.getPath());\n                 target.add(value);\n             }\n             return;\n",
        "project": "jackrabbit-oak",
        "linesAdd": 12,
        "jira_id": "2062",
        "nb_skipped": 9,
        "commit": "5c4589bd",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1847,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollectorTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 8f5e1ab94a..920cb9c5a6 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -51,10 +51,12 @@\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.collect.Iterables.filter;\n import static com.google.common.collect.Iterables.transform;\n+import static java.util.Collections.disjoint;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation;\n \n@@ -1339,7 +1341,7 @@ private static void setSplitDocProps(NodeDocument mainDoc, NodeDocument oldDoc,\n         setSplitDocMaxRev(old, maxRev);\n \n         SplitDocType type = SplitDocType.DEFAULT;\n-        if(!mainDoc.hasChildren()){\n+        if(!mainDoc.hasChildren() && !referencesOldDocAfterSplit(mainDoc, oldDoc)){\n             type = SplitDocType.DEFAULT_NO_CHILD;\n         } else if (oldDoc.getLocalRevisions().isEmpty()){\n             type = SplitDocType.PROP_COMMIT_ONLY;\n@@ -1353,6 +1355,31 @@ private static void setSplitDocProps(NodeDocument mainDoc, NodeDocument oldDoc,\n         setSplitDocType(old,type);\n     }\n \n+    /**\n+     * Checks if the main document has changes referencing {@code oldDoc} after\n+     * the split.\n+     *\n+     * @param mainDoc the main document before the split.\n+     * @param oldDoc  the old document created by the split.\n+     * @return {@code true} if the main document contains references to the\n+     *         old document after the split; {@code false} otherwise.\n+     */\n+    private static boolean referencesOldDocAfterSplit(NodeDocument mainDoc,\n+                                                      NodeDocument oldDoc) {\n+        Set<Revision> revs = oldDoc.getLocalRevisions().keySet();\n+        for (String property : mainDoc.data.keySet()) {\n+            if (IGNORE_ON_SPLIT.contains(property)) {\n+                continue;\n+            }\n+            Set<Revision> changes = Sets.newHashSet(mainDoc.getLocalMap(property).keySet());\n+            changes.removeAll(oldDoc.getLocalMap(property).keySet());\n+            if (!disjoint(changes, revs)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Set various properties for intermediate split document\n      *\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\nindex 320afb7746..e671b66d0d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\n@@ -46,8 +46,7 @@\n      */\n     private static final Set<NodeDocument.SplitDocType> GC_TYPES = EnumSet.of(\n             NodeDocument.SplitDocType.DEFAULT_NO_CHILD,\n-            NodeDocument.SplitDocType.PROP_COMMIT_ONLY,\n-            NodeDocument.SplitDocType.INTERMEDIATE);\n+            NodeDocument.SplitDocType.PROP_COMMIT_ONLY);\n \n \n     VersionGarbageCollector(DocumentNodeStore nodeStore) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 20,
        "jira_id": "1729",
        "nb_skipped": 8,
        "commit": "7ba9dd66",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 328,
        "nb_error": 9,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.query.QueryFulltextTest",
            "org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexProviderServiceTest",
            "org.apache.jackrabbit.oak.jcr.query.TextExtractionQueryTest",
            "org.apache.jackrabbit.oak.jcr.query.MultiSessionQueryTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexProviderService.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexProviderService.java\nindex c8f0cfe09c..29a893a5e8 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexProviderService.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexProviderService.java\n@@ -190,7 +190,7 @@\n     private IndexAugmentorFactory augmentorFactory;\n \n     @Reference(policy = ReferencePolicy.DYNAMIC,\n-            cardinality = ReferenceCardinality.OPTIONAL_MULTIPLE,\n+            cardinality = ReferenceCardinality.OPTIONAL_UNARY,\n             policyOption = ReferencePolicyOption.GREEDY\n     )\n     private volatile PreExtractedTextProvider extractedTextProvider;\n@@ -441,7 +441,9 @@ private void initializeExtractedTextCache(BundleContext bundleContext, Map<Strin\n                 PROP_EXTRACTED_TEXT_CACHE_EXPIRY_DEFAULT);\n \n         extractedTextCache = new ExtractedTextCache(cacheSizeInMB * ONE_MB, cacheExpiryInSecs);\n-\n+        if (extractedTextProvider != null){\n+            registerExtractedTextProvider(extractedTextProvider);\n+        }\n         CacheStats stats = extractedTextCache.getCacheStats();\n         if (stats != null){\n             oakRegs.add(registerMBean(whiteboard,\n",
        "project": "jackrabbit-oak",
        "linesAdd": 4,
        "jira_id": "4036",
        "nb_skipped": 5,
        "commit": "f4324736",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1257,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextTerm.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextTerm.java\nindex 2d33a2964c..78a672f840 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextTerm.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextTerm.java\n@@ -67,7 +67,7 @@ public FullTextTerm(String propertyName, String text, boolean not, boolean escap\n                 } else if (c == '_') {\n                     buff.append(\"\\\\_\");\n                     pattern = true;\n-                } else if (Character.isLetterOrDigit(c) || \" +-:&\".indexOf(c) >= 0) {\n+                } else if (Character.isLetterOrDigit(c) || \" +-:&/\".indexOf(c) >= 0) {\n                     buff.append(c);\n                 }\n             }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "1024",
        "nb_skipped": 8,
        "commit": "2b5d3afb",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 246,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexTest",
            "org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexQueryTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\nindex 8889094627..0e24834423 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n@@ -73,10 +73,13 @@\n import org.apache.lucene.index.IndexReader;\n import org.apache.lucene.index.MultiFields;\n import org.apache.lucene.index.Term;\n+import org.apache.lucene.index.Terms;\n+import org.apache.lucene.index.TermsEnum;\n import org.apache.lucene.search.BooleanClause;\n import org.apache.lucene.search.BooleanQuery;\n import org.apache.lucene.search.IndexSearcher;\n import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.search.MultiPhraseQuery;\n import org.apache.lucene.search.PhraseQuery;\n import org.apache.lucene.search.PrefixQuery;\n import org.apache.lucene.search.Query;\n@@ -87,6 +90,9 @@\n import org.apache.lucene.search.WildcardQuery;\n import org.apache.lucene.store.Directory;\n import org.apache.lucene.store.FSDirectory;\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.lucene.util.automaton.Automaton;\n+import org.apache.lucene.util.automaton.CompiledAutomaton;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -416,7 +422,7 @@ private static Query getQuery(Filter filter, IndexReader reader,\n             // when using the LowCostLuceneIndexProvider\n             // which is used for testing\n         } else {\n-            qs.add(getFullTextQuery(ft, analyzer));\n+            qs.add(getFullTextQuery(ft, analyzer, reader));\n         }\n         if (nonFullTextConstraints) {\n             addNonFullTextConstraints(qs, filter, reader);\n@@ -582,7 +588,7 @@ private static void addNodeTypeConstraints(List<Query> qs, Filter filter) {\n         qs.add(bq);\n     }\n \n-    static Query getFullTextQuery(FullTextExpression ft, final Analyzer analyzer) {\n+    static Query getFullTextQuery(FullTextExpression ft, final Analyzer analyzer, final IndexReader reader) {\n         // a reference to the query, so it can be set in the visitor\n         // (a \"non-local return\")\n         final AtomicReference<Query> result = new AtomicReference<Query>();\n@@ -592,7 +598,7 @@ static Query getFullTextQuery(FullTextExpression ft, final Analyzer analyzer) {\n             public boolean visit(FullTextOr or) {\n                 BooleanQuery q = new BooleanQuery();\n                 for (FullTextExpression e : or.list) {\n-                    Query x = getFullTextQuery(e, analyzer);\n+                    Query x = getFullTextQuery(e, analyzer, reader);\n                     q.add(x, SHOULD);\n                 }\n                 result.set(q);\n@@ -603,7 +609,7 @@ public boolean visit(FullTextOr or) {\n             public boolean visit(FullTextAnd and) {\n                 BooleanQuery q = new BooleanQuery();\n                 for (FullTextExpression e : and.list) {\n-                    Query x = getFullTextQuery(e, analyzer);\n+                    Query x = getFullTextQuery(e, analyzer, reader);\n                     // Lucene can't deal with \"must(must_not(x))\"\n                     if (x instanceof BooleanQuery) {\n                         BooleanQuery bq = (BooleanQuery) x;\n@@ -625,7 +631,7 @@ public boolean visit(FullTextTerm term) {\n                     // do not add constraints on child nodes properties\n                     p = \"*\";\n                 }\n-                Query q = tokenToQuery(term.getText(), analyzer);\n+                Query q = tokenToQuery(term.getText(), analyzer, reader);\n                 if (q == null) {\n                     return false;\n                 }\n@@ -646,7 +652,7 @@ public boolean visit(FullTextTerm term) {\n         return result.get();\n     }\n \n-    static Query tokenToQuery(String text, Analyzer analyzer) {\n+    static Query tokenToQuery(String text, Analyzer analyzer, IndexReader reader) {\n         if (analyzer == null) {\n             return null;\n         }\n@@ -657,22 +663,27 @@ static Query tokenToQuery(String text, Analyzer analyzer) {\n             // TODO what should be returned in the case there are no tokens?\n             return new BooleanQuery();\n         }\n-\n         if (tokens.size() == 1) {\n-            text = tokens.iterator().next();\n-            boolean hasFulltextToken = false;\n-            for (char c : fulltextTokens) {\n-                if (text.indexOf(c) != -1) {\n-                    hasFulltextToken = true;\n-                    break;\n+            String token = tokens.iterator().next();\n+            if (hasFulltextToken(token)) {\n+                return new WildcardQuery(newFulltextTerm(token));\n+            } else {\n+                return new TermQuery(newFulltextTerm(token));\n             }\n+        } else {\n+            if (hasFulltextToken(tokens)) {\n+                MultiPhraseQuery mpq = new MultiPhraseQuery();\n+                for(String token: tokens){\n+                    if (hasFulltextToken(token)) {\n+                        Term[] terms = extractMatchingTokens(reader, token);\n+                        if (terms != null && terms.length > 0) {\n+                            mpq.add(terms);\n                         }\n-\n-            if (hasFulltextToken) {\n-                return new WildcardQuery(newFulltextTerm(text));\n                     } else {\n-                return new TermQuery(newFulltextTerm(text));\n+                        mpq.add(newFulltextTerm(token));\n                     }\n+                }\n+                return mpq;\n             } else {\n                 PhraseQuery pq = new PhraseQuery();\n                 for (String t : tokens) {\n@@ -681,6 +692,48 @@ static Query tokenToQuery(String text, Analyzer analyzer) {\n                 return pq;\n             }\n         }\n+    }\n+\n+    private static Term[] extractMatchingTokens(IndexReader reader, String token) {\n+        if (reader == null) {\n+            // getPlan call\n+            return null;\n+        }\n+\n+        try {\n+            List<Term> terms = new ArrayList<Term>();\n+            Terms t = MultiFields.getTerms(reader, FieldNames.FULLTEXT);\n+            Automaton a = WildcardQuery.toAutomaton(newFulltextTerm(token));\n+            CompiledAutomaton ca = new CompiledAutomaton(a);\n+            TermsEnum te = ca.getTermsEnum(t);\n+            BytesRef text;\n+            while ((text = te.next()) != null) {\n+                terms.add(newFulltextTerm(text.utf8ToString()));\n+            }\n+            return terms.toArray(new Term[terms.size()]);\n+        } catch (IOException e) {\n+            LOG.error(\"Building fulltext query failed\", e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    private static boolean hasFulltextToken(List<String> tokens) {\n+        for (String token : tokens) {\n+            if (hasFulltextToken(token)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean hasFulltextToken(String token) {\n+        for (char c : fulltextTokens) {\n+            if (token.indexOf(c) != -1) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n \n     private static char[] fulltextTokens = new char[] { '*', '?' };\n \n@@ -727,6 +780,7 @@ static Query tokenToQuery(String text, Analyzer analyzer) {\n                 poz = end;\n                 if (hasFulltextToken) {\n                     token.append(term);\n+                    hasFulltextToken = false;\n                 } else {\n                     if (token.length() > 0) {\n                         tokens.add(token.toString());\n",
        "project": "jackrabbit-oak",
        "linesAdd": 70,
        "jira_id": "1270",
        "nb_skipped": 1,
        "commit": "70564c7c",
        "nb_failure": 2,
        "linesRem": 17,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1868,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.UpdateOpTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\nindex b957c37b22..707149d723 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n@@ -368,7 +368,7 @@ public boolean equals(Object obj) {\n             if (obj instanceof Key) {\n                 Key other = (Key) obj;\n                 return name.equals(other.name) &&\n-                        revision != null ? revision.equals(other.revision) : other.revision == null;\n+                        (revision != null ? revision.equals(other.revision) : other.revision == null);\n             }\n             return false;\n         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "2435",
        "nb_skipped": 9,
        "commit": "7e250001",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 396,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.memory.MemoryPropertyBuilderTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryPropertyBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryPropertyBuilder.java\nindex 2e9ac56dd1..286b4536aa 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryPropertyBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryPropertyBuilder.java\n@@ -223,13 +223,23 @@ else if (isArray()) {\n             setName(property.getName());\n             if (property.isArray()) {\n                 isArray = true;\n+                if (type == Type.DATE) {\n+                    setValues((Iterable<T>) property.getValue(Type.STRINGS));\n+                }\n+                else {\n                     setValues((Iterable<T>) property.getValue(type.getArrayType()));\n                 }\n+            }\n             else {\n                 isArray = false;\n+                if (type == Type.DATE) {\n+                    setValue((T) property.getValue(Type.STRING));\n+                }\n+                else {\n                     setValue(property.getValue(type));\n                 }\n             }\n+        }\n         return this;\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 10,
        "jira_id": "429",
        "nb_skipped": 3,
        "commit": "c02ecef8",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 271,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.spi.security.authentication.external.basic.DefaultSyncContextTest"
        ],
        "patch": "diff --git a/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/basic/DefaultSyncContext.java b/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/basic/DefaultSyncContext.java\nindex 7d781591e5..1218fb7230 100644\n--- a/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/basic/DefaultSyncContext.java\n+++ b/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/basic/DefaultSyncContext.java\n@@ -531,10 +531,10 @@ protected void syncMembership(@Nonnull ExternalIdentity external, @Nonnull Autho\n             if (a == null) {\n                 grp = createGroup(extGroup);\n                 log.debug(\"- created new group\");\n-            } else if (a.isGroup()) {\n+            } else if (a.isGroup() && isSameIDP(a)) {\n                 grp = (Group) a;\n             } else {\n-                log.warn(\"Authorizable '{}' is not a group, but should be one.\", extGroup.getId());\n+                log.warn(\"Existing authorizable '{}' is not a group from this IDP '{}'.\", extGroup.getId(), idp.getName());\n                 continue;\n             }\n             log.debug(\"- user manager returned '{}'\", grp);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "4397",
        "nb_skipped": 2,
        "commit": "e33516d5",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1868,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.query.SQL2ParserTest",
            "org.apache.jackrabbit.oak.plugins.index.property.OrderedIndexQueryTest",
            "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\nindex 782a543c2f..b34fb56337 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\n@@ -17,6 +17,8 @@\n package org.apache.jackrabbit.oak.query.xpath;\n \n import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n \n import org.apache.jackrabbit.oak.query.SQL2Parser;\n import org.apache.jackrabbit.util.ISO9075;\n@@ -45,6 +47,15 @@ public static Expression and(Expression old, Expression add) {\n         return new Expression.AndCondition(old, add);\n     }\n     \n+    /**\n+     * Get the optimized expression.\n+     * \n+     * @return the optimized expression\n+     */\n+    Expression optimize() {\n+        return this;\n+    }\n+\n     /**\n      * Whether this is a condition.\n      * \n@@ -54,6 +65,43 @@ boolean isCondition() {\n         return false;\n     }\n     \n+    /**\n+     * Whether this is a or contains a full-text condition.\n+     * \n+     * @return true if it is\n+     */\n+    boolean containsFullTextCondition() {\n+        return false;\n+    }\n+    \n+    /**\n+     * Get the left-hand-side expression for equality conditions. \n+     * For example, for x=1, it is x. If it is not equality, return null.\n+     * \n+     * @return the left-hand-side expression, or null\n+     */        \n+    String getCommonLeftPart() {\n+        return null;\n+    }\n+    \n+    /**\n+     * Get the left hand side of an expression.\n+     * \n+     * @return the left hand side\n+     */\n+    Expression getLeft() {\n+        return null;\n+    }\n+    \n+    /**\n+     * Get the list of the right hand side of an expression.\n+     * \n+     * @return the list\n+     */\n+    List<Expression> getRight() {\n+        return null;\n+    }\n+\n     /**\n      * Pull an OR condition up to the right hand side of an AND condition.\n      * \n@@ -157,19 +205,24 @@ int getPrecedence() {\n             return precedence;\n         }\n              \n-        /**\n-         * Get the left-hand-side expression for equality conditions. \n-         * For example, for x=1, it is x. If it is not equality, return null.\n-         * \n-         * @return the left-hand-side expression, or null\n-         */        \n-        public String getCommonLeftPart() {\n+        @Override\n+        String getCommonLeftPart() {\n             if (!\"=\".equals(operator)) {\n                 return null;\n             }\n             return left.toString();\n         }\n         \n+        @Override\n+        Expression getLeft() {\n+            return left;\n+        }\n+        \n+        @Override\n+        List<Expression> getRight() {\n+            return Collections.singletonList(right);\n+        }\n+    \n         @Override\n         public String toString() {\n             String leftExpr;\n@@ -223,6 +276,11 @@ boolean isCondition() {\n             return true;\n         }\n         \n+        @Override\n+        Expression optimize() {\n+            return this;\n+        }\n+    \n     }\n     \n     /**\n@@ -243,16 +301,87 @@ boolean isCondition() {\n          */\n         @Override\n         public String getCommonLeftPart() {\n-            if (left instanceof Condition && right instanceof Condition) {\n-                String l = ((Condition) left).getCommonLeftPart();\n-                String r = ((Condition) right).getCommonLeftPart();\n+            String l = left.getCommonLeftPart();\n+            String r = right.getCommonLeftPart();\n             if (l != null && r != null && l.equals(r)) {\n                 return l;\n             }\n-            }\n             return null;\n         }\n         \n+        @Override\n+        Expression optimize() {\n+            Expression l = left.optimize();\n+            Expression r = right.optimize();\n+            if (l != left || r != right) {\n+                return new OrCondition(l, r).optimize();\n+            }\n+            String commonLeft = getCommonLeftPart();\n+            if (commonLeft == null) {\n+                return this;\n+            }\n+            // \"@x = 1 or @x = 2\" is converted to \"@x in (1, 2)\"\n+            ArrayList<Expression> list = new ArrayList<Expression>();\n+            list.addAll(left.getRight());\n+            list.addAll(right.getRight());\n+            Expression le = left.getLeft();\n+            InCondition in = new InCondition(le, list);\n+            return in.optimize();\n+        }\n+        \n+        @Override\n+        boolean containsFullTextCondition() {\n+            return left.containsFullTextCondition() || right.containsFullTextCondition();\n+        }\n+        \n+    }\n+    \n+    /**\n+     * An \"or\" condition.\n+     */\n+    static class InCondition extends Expression {\n+\n+        final Expression left;\n+        final List<Expression> list;\n+        \n+        InCondition(Expression left, List<Expression> list) {\n+            this.left = left;\n+            this.list = list;\n+        }\n+        \n+        @Override\n+        String getCommonLeftPart() {\n+            return left.toString();\n+        }\n+        \n+        @Override\n+        Expression getLeft() {\n+            return left;\n+        }\n+        \n+        @Override\n+        List<Expression> getRight() {\n+            return list;\n+        }\n+    \n+        @Override\n+        public String toString() {\n+            StringBuilder buff = new StringBuilder();\n+            buff.append(left).append(\" in(\");\n+            for (int i = 0; i < list.size(); i++) {\n+                if (i > 0) {\n+                    buff.append(\", \");\n+                }\n+                buff.append(list.get(i));\n+            }\n+            return buff.append(')').toString();\n+        }\n+    \n+        @Override\n+        boolean isCondition() {\n+            return true;\n+        }        \n+        \n     }\n     \n     /**\n@@ -264,6 +393,16 @@ public String getCommonLeftPart() {\n             super(left, \"and\", right, Expression.PRECEDENCE_AND);\n         }\n \n+        @Override\n+        Expression optimize() {\n+            Expression l = left.optimize();\n+            Expression r = right.optimize();\n+            if (l != left || r != right) {\n+                return new AndCondition(l, r);\n+            }\n+            return this;\n+        }\n+        \n         @Override\n         AndCondition pullOrRight() {\n             if (right instanceof OrCondition) {\n@@ -285,6 +424,11 @@ AndCondition pullOrRight() {\n             return this;\n         }\n         \n+        @Override\n+        boolean containsFullTextCondition() {\n+            return left.containsFullTextCondition() || right.containsFullTextCondition();\n+        }\n+        \n     }\n     \n     /**\n@@ -319,6 +463,11 @@ boolean isCondition() {\n             return true;\n         }\n         \n+        @Override\n+        boolean containsFullTextCondition() {\n+            return true;\n+        }\n+        \n         @Override\n         boolean isName() {\n             return left.isName();\n@@ -353,6 +502,11 @@ boolean isCondition() {\n             return true;\n         }\n \n+        @Override\n+        boolean containsFullTextCondition() {\n+            return true;\n+        }\n+        \n         @Override\n         boolean isName() {\n             return false;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\nindex 05044299a3..6113c0cc09 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\n@@ -20,7 +20,6 @@\n \n import org.apache.jackrabbit.oak.query.QueryImpl;\n import org.apache.jackrabbit.oak.query.xpath.Expression.AndCondition;\n-import org.apache.jackrabbit.oak.query.xpath.Expression.Contains;\n import org.apache.jackrabbit.oak.query.xpath.Expression.OrCondition;\n import org.apache.jackrabbit.oak.query.xpath.Expression.Property;\n \n@@ -29,8 +28,6 @@\n  */\n public class Statement {\n \n-    private String xpathQuery;\n-    \n     private boolean explain;\n     private boolean measure;\n     \n@@ -49,15 +46,18 @@\n     \n     private Expression where;\n \n-    private ArrayList<Order> orderList = new ArrayList<Order>();\n+    ArrayList<Order> orderList = new ArrayList<Order>();\n+    \n+    String xpathQuery;\n     \n     public Statement optimize() {\n-        if (explain || measure || orderList.size() > 0) {\n+        if (explain || measure) {\n             return this;\n         }\n         if (where == null) {\n             return this;\n         }\n+        where = where.optimize();\n         ArrayList<Expression> unionList = new ArrayList<Expression>();\n         addToUnionList(where, unionList);\n         if (unionList.size() == 1) {\n@@ -71,29 +71,22 @@ public Statement optimize() {\n             s.selectors = selectors;\n             s.columnList = columnList;\n             s.where = e;\n-            if (i == unionList.size() - 1) {\n-                s.xpathQuery = xpathQuery;\n-            }\n             if (union == null) {\n                 union = s;\n             } else {\n                 union = new UnionStatement(union.optimize(), s.optimize());\n             }\n         }\n+        union.orderList = orderList;\n+        union.xpathQuery = xpathQuery;\n         return union;\n     }\n     \n     private static void addToUnionList(Expression condition,  ArrayList<Expression> unionList) {\n-        if (condition instanceof OrCondition) {\n+        if (condition.containsFullTextCondition()) {\n+            // do not use union\n+        } else if (condition instanceof OrCondition) {\n             OrCondition or = (OrCondition) condition;\n-            if (or.getCommonLeftPart() != null) {\n-                // @x = 1 or @x = 2 \n-                // is automatically converted to \n-                // @x in (1, 2)\n-                // within the query engine\n-            } else if (or.left instanceof Contains && or.right instanceof Contains) {\n-                // do not optimize \"contains\"\n-            } else {\n             // conditions of type                \n             // @x = 1 or @y = 2\n             // or similar are converted to\n@@ -101,7 +94,6 @@ private static void addToUnionList(Expression condition,  ArrayList<Expression>\n             addToUnionList(or.left, unionList);\n             addToUnionList(or.right, unionList);\n             return;\n-            }\n         } else if (condition instanceof AndCondition) {\n             // conditions of type\n             // @a = 1 and (@x = 1 or @y = 2)\n@@ -111,21 +103,12 @@ private static void addToUnionList(Expression condition,  ArrayList<Expression>\n             and = and.pullOrRight();\n             if (and.right instanceof OrCondition) {\n                 OrCondition or = (OrCondition) and.right;\n-                if (or.getCommonLeftPart() != null) {\n-                    // @x = 1 or @x = 2 \n-                    // is automatically converted to \n-                    // @x in (1, 2)\n-                    // within the query engine                \n-                } else if (or.left instanceof Contains && or.right instanceof Contains) {\n-                    // do not optimize \"contains\"\n-                } else {\n                 // same as above, but with the added \"and\"\n                 addToUnionList(new AndCondition(and.left, or.left), unionList);\n                 addToUnionList(new AndCondition(and.left, or.right), unionList);\n                 return;\n             }\n         }\n-        }\n         unionList.add(condition);\n     }\n     \n@@ -255,7 +238,25 @@ public void setOriginalQuery(String xpathQuery) {\n         \n         @Override\n         public String toString() {\n-            return s1 + \" union \" + s2;\n+            StringBuilder buff = new StringBuilder();\n+            buff.append(s1).append(\" union \").append(s2);\n+            // order by ...\n+            if (orderList != null && !orderList.isEmpty()) {\n+                buff.append(\" order by \");\n+                for (int i = 0; i < orderList.size(); i++) {\n+                    if (i > 0) {\n+                        buff.append(\", \");\n+                    }\n+                    buff.append(orderList.get(i));\n+                }\n+            }\n+            // leave original xpath string as a comment\n+            if (xpathQuery != null) {\n+                buff.append(\" /* xpath: \");\n+                buff.append(xpathQuery);\n+                buff.append(\" */\");\n+            }\n+            return buff.toString();\n         }\n         \n     }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 161,
        "jira_id": "2021",
        "nb_skipped": 9,
        "commit": "004db804",
        "nb_failure": 1,
        "linesRem": 23,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1845,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.RevisionTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\nindex db6a698cbc..79043e9fd9 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n@@ -521,9 +521,14 @@ public int compare(Revision o1, Revision o2) {\n             if (range1 == FUTURE && range2 == FUTURE) {\n                 return o1.compareRevisionTimeThenClusterId(o2);\n             }\n-            if (range1 == null || range2 == null) {\n+            if (range1 == null && range2 == null) {\n                 return o1.compareRevisionTimeThenClusterId(o2);\n             }\n+            if (range1 == null) {\n+                return -1;\n+            } else if (range2 == null) {\n+                return 1;\n+            }\n             int comp = range1.compareRevisionTimeThenClusterId(range2);\n             if (comp != 0) {\n                 return comp;\n",
        "project": "jackrabbit-oak",
        "linesAdd": 6,
        "jira_id": "1727",
        "nb_skipped": 9,
        "commit": "26041fe7",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 511,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.memory.PropertyStatesTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/PropertyStates.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/PropertyStates.java\nindex 3837e967a2..372ca2353b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/PropertyStates.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/PropertyStates.java\n@@ -32,6 +32,7 @@\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.plugins.value.Conversions;\n+import org.apache.jackrabbit.oak.plugins.value.ValueImpl;\n \n import static org.apache.jackrabbit.oak.api.Type.STRINGS;\n \n@@ -55,7 +57,7 @@ public static PropertyState createProperty(String name, Value value) throws Repo\n         int type = value.getType();\n         switch (type) {\n             case PropertyType.STRING:\n-                return StringPropertyState.stringProperty(name, value.getString());\n+                return StringPropertyState.stringProperty(name, getString(value, type));\n             case PropertyType.BINARY:\n                 return BinaryPropertyState.binaryProperty(name, value);\n             case PropertyType.LONG:\n@@ -69,7 +71,7 @@ public static PropertyState createProperty(String name, Value value) throws Repo\n             case PropertyType.DECIMAL:\n                 return DecimalPropertyState.decimalProperty(name, value.getDecimal());\n             default:\n-                return new GenericPropertyState(name, value.getString(), Type.fromTag(type, false));\n+                return new GenericPropertyState(name, getString(value, type), Type.fromTag(type, false));\n         }\n     }\n \n@@ -96,7 +98,7 @@ public static PropertyState createProperty(String name, Iterable<Value> values)\n             case PropertyType.STRING:\n                 List<String> strings = Lists.newArrayList();\n                 for (Value value : values) {\n-                    strings.add(value.getString());\n+                    strings.add(getString(value, type));\n                 }\n                 return MultiStringPropertyState.stringProperty(name, strings);\n             case PropertyType.BINARY:\n@@ -138,12 +140,24 @@ public static PropertyState createProperty(String name, Iterable<Value> values)\n             default:\n                 List<String> vals = Lists.newArrayList();\n                 for (Value value : values) {\n-                    vals.add(value.getString());\n+                    vals.add(getString(value, type));\n                 }\n                 return new MultiGenericPropertyState(name, vals, Type.fromTag(type, true));\n         }\n     }\n \n+    private static String getString(Value value, int type) throws RepositoryException {\n+        if (value instanceof ValueImpl) {\n+            return ((ValueImpl) value).getOakString();\n+        }\n+        else if (type == PropertyType.NAME || type == PropertyType.PATH) {\n+            throw new IllegalArgumentException(\"Cannot create name of path property state from Value \" +\n+                    \"of class '\" + value.getClass() + '\\'');\n+        } else {\n+            return value.getString();\n+        }\n+    }\n+\n     /**\n      * Create a {@code PropertyState} from a string.\n      * @param name  The name of the property state\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueImpl.java\nindex 59ea8460bb..4f733eb05c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueImpl.java\n@@ -73,6 +73,15 @@\n         this(checkSingleValued(property), 0, namePathMapper);\n     }\n \n+    /**\n+     * Same as {@link #getString()} unless that names and paths are returned in their\n+     * Oak representation instead of being mapped to their JCR representation.\n+     * @return  A String representation of the value of this property.\n+     */\n+    public String getOakString() {\n+        return propertyState.getValue(Type.STRING, index);\n+    }\n+\n     private static PropertyState checkSingleValued(PropertyState property) {\n         checkArgument(!property.isArray());\n         return property;\n@@ -208,9 +217,9 @@ public String getString() throws RepositoryException {\n \n         switch (getType()) {\n             case PropertyType.NAME:\n-                return namePathMapper.getJcrName(propertyState.getValue(Type.STRING, index));\n+                return namePathMapper.getJcrName(getOakString());\n             case PropertyType.PATH:\n-                String s = propertyState.getValue(Type.STRING, index);\n+                String s = getOakString();\n                 if (s.startsWith(\"[\") && s.endsWith(\"]\")) {\n                     // identifier paths are returned as-is (JCR 2.0, 3.4.3.1)\n                     return s;\n@@ -218,7 +227,7 @@ public String getString() throws RepositoryException {\n                     return namePathMapper.getJcrPath(s);\n                 }\n             default:\n-                return propertyState.getValue(Type.STRING, index);\n+                return getOakString();\n         }\n     }\n \n@@ -273,13 +282,13 @@ public int hashCode() {\n             return propertyState.getValue(Type.BINARY, index).hashCode();\n         }\n         else {\n-            return propertyState.getValue(Type.STRING, index).hashCode();\n+            return getOakString().hashCode();\n         }\n     }\n \n     @Override\n     public String toString() {\n-        return propertyState.getValue(Type.STRING, index);\n+        return getOakString();\n     }\n \n     private static int compare(PropertyState p1, int i1, PropertyState p2, int i2) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 26,
        "jira_id": "554",
        "nb_skipped": 5,
        "commit": "3f51fb09",
        "nb_failure": 2,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2421,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.query.ast.FullTextTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextParser.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextParser.java\nindex 82179601d7..1827d72fe2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextParser.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextParser.java\n@@ -163,7 +163,14 @@ FullTextExpression parseTerm() throws ParseException {\n                 } else if (c == '^') {\n                     boost = \"\";\n                     break;\n-                } else if (c == ' ') {\n+                } else if (c <= ' ') {\n+                    while (parseIndex < text.length()) {\n+                        c = text.charAt(parseIndex);\n+                        if (c > ' ') {\n+                            break;\n+                        }\n+                        parseIndex++;\n+                    }\n                     break;\n                 } else {\n                     buff.append(c);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 8,
        "jira_id": "3377",
        "nb_skipped": 1,
        "commit": "00b9bc52",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 186,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.mongomk.MongoDocumentStoreTest"
        ],
        "patch": "diff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MemoryDocumentStore.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MemoryDocumentStore.java\nindex e984585eef..ad581b78a0 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MemoryDocumentStore.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MemoryDocumentStore.java\n@@ -178,14 +178,14 @@ private static boolean checkConditions(Map<String, Object> target,\n                         return false;\n                     }\n                 } else {\n-                    if (value instanceof java.util.Collection) {\n-                        java.util.Collection<?> col = (java.util.Collection<?>) value;\n+                    if (value instanceof Map) {\n+                        Map map = (Map) value;\n                         if (Boolean.TRUE.equals(op.value)) {\n-                            if (!col.contains(kv[1])) {\n+                            if (!map.containsKey(kv[1])) {\n                                 return false;\n                             }\n                         } else {\n-                            if (col.contains(kv[1])) {\n+                            if (map.containsKey(kv[1])) {\n                                 return false;\n                             }\n                         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 4,
        "jira_id": "847",
        "nb_skipped": 4,
        "commit": "65aa40dd",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 2413,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.authorization.restriction.PermissionTest",
            "org.apache.jackrabbit.oak.security.authorization.restriction.CustomRestrictionProviderTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/CompiledPermissionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/CompiledPermissionImpl.java\nindex 84f16ae242..153884f2c1 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/CompiledPermissionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/CompiledPermissionImpl.java\n@@ -145,7 +145,8 @@ public RepositoryPermission getRepositoryPermission() {\n         return new RepositoryPermission() {\n             @Override\n             public boolean isGranted(long repositoryPermissions) {\n-                return hasPermissions(getEntryIterator(new EntryPredicate()), repositoryPermissions, null);\n+                EntryPredicate predicate = new EntryPredicate();\n+                return hasPermissions(getEntryIterator(predicate), predicate, repositoryPermissions, null);\n             }\n         };\n     }\n@@ -242,8 +243,8 @@ public boolean isGranted(@Nonnull Tree tree, @Nullable PropertyState property, l\n \n     @Override\n     public boolean isGranted(@Nonnull String path, long permissions) {\n-        Iterator<PermissionEntry> it = getEntryIterator(new EntryPredicate(path, Permissions.respectParentPermissions(permissions)));\n-        return hasPermissions(it, permissions, path);\n+        EntryPredicate predicate = new EntryPredicate(path, Permissions.respectParentPermissions(permissions));\n+        return hasPermissions(getEntryIterator(predicate), predicate, permissions, path);\n     }\n \n     @Nonnull\n@@ -260,11 +261,12 @@ public boolean hasPrivileges(@Nullable Tree tree, @Nonnull String... privilegeNa\n     //------------------------------------------------------------< private >---\n \n     private boolean internalIsGranted(@Nonnull Tree tree, @Nullable PropertyState property, long permissions) {\n-        Iterator<PermissionEntry> it = getEntryIterator(tree, property, permissions);\n-        return hasPermissions(it, permissions, tree.getPath());\n+        EntryPredicate predicate = new EntryPredicate(tree, property, Permissions.respectParentPermissions(permissions));\n+        return hasPermissions(getEntryIterator(predicate), predicate, permissions, tree.getPath());\n     }\n \n     private boolean hasPermissions(@Nonnull Iterator<PermissionEntry> entries,\n+                                   @Nonnull EntryPredicate predicate,\n                                    long permissions, @Nullable String path) {\n         // calculate readable paths if the given permissions includes any read permission.\n         boolean isReadable = Permissions.diff(Permissions.READ, permissions) != Permissions.READ && readPolicy.isReadablePath(path, false);\n@@ -310,14 +312,18 @@ private boolean hasPermissions(@Nonnull Iterator<PermissionEntry> entries,\n             }\n \n             if (entry.isAllow) {\n+                if (!respectParent || predicate.apply(entry, false)) {\n                     allowBits.addDifference(entry.privilegeBits, denyBits);\n+                }\n                 long ap = PrivilegeBits.calculatePermissions(allowBits, parentAllowBits, true);\n                 allows |= Permissions.diff(ap, denies);\n                 if ((allows | ~permissions) == -1) {\n                     return true;\n                 }\n             } else {\n+                if (!respectParent || predicate.apply(entry, false)) {\n                     denyBits.addDifference(entry.privilegeBits, allowBits);\n+                }\n                 long dp = PrivilegeBits.calculatePermissions(denyBits, parentDenyBits, false);\n                 denies |= Permissions.diff(dp, allows);\n                 if (Permissions.includes(denies, permissions)) {\n@@ -376,11 +382,6 @@ private PrivilegeBits getPrivilegeBits(@Nullable Tree tree) {\n         return allowBits;\n     }\n \n-    @Nonnull\n-    private Iterator<PermissionEntry> getEntryIterator(@Nonnull Tree tree, @Nullable PropertyState property, long permissions) {\n-        return getEntryIterator(new EntryPredicate(tree, property, Permissions.respectParentPermissions(permissions)));\n-    }\n-\n     @Nonnull\n     private Iterator<PermissionEntry> getEntryIterator(@Nonnull EntryPredicate predicate) {\n         Iterator<PermissionEntry> userEntries = userStore.getEntryIterator(predicate);\n@@ -526,12 +527,16 @@ public boolean canReadProperties() {\n \n         @Override\n         public boolean isGranted(long permissions) {\n-            return hasPermissions(getIterator(null, permissions), permissions, tree.getPath());\n+            EntryPredicate predicate = new EntryPredicate(tree, null, Permissions.respectParentPermissions(permissions));\n+            Iterator<PermissionEntry> it = concat(new LazyIterator(this, true, predicate), new LazyIterator(this, false, predicate));\n+            return hasPermissions(it, predicate, permissions, tree.getPath());\n         }\n \n         @Override\n         public boolean isGranted(long permissions, @Nonnull PropertyState property) {\n-            return hasPermissions(getIterator(property, permissions), permissions, tree.getPath());\n+            EntryPredicate predicate = new EntryPredicate(tree, property, Permissions.respectParentPermissions(permissions));\n+            Iterator<PermissionEntry> it = concat(new LazyIterator(this, true, predicate), new LazyIterator(this, false, predicate));\n+            return hasPermissions(it, predicate, permissions, tree.getPath());\n         }\n \n         //--------------------------------------------------------< private >---\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/EntryPredicate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/EntryPredicate.java\nindex 20fe76508f..023e18e534 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/EntryPredicate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/EntryPredicate.java\n@@ -37,6 +37,7 @@\n \n     private final String parentPath;\n     private final Tree parent;\n+    private final boolean respectParent;\n \n     public EntryPredicate(@Nonnull Tree tree, @Nullable PropertyState property,\n                           boolean respectParent) {\n@@ -64,6 +65,7 @@ private EntryPredicate(@Nullable Tree tree, @Nullable PropertyState property,\n             parentPath = null;\n             parent = null;\n         }\n+        this.respectParent = parent != null || parentPath != null;\n     }\n \n     @CheckForNull\n@@ -73,25 +75,22 @@ public String getPath() {\n \n     @Override\n     public boolean apply(@Nullable PermissionEntry entry) {\n+        return apply(entry, true);\n+    }\n+\n+    public boolean apply(@Nullable PermissionEntry entry, boolean respectParent) {\n         if (entry == null) {\n             return false;\n         }\n+        respectParent &= this.respectParent;\n+\n         if (tree != null) {\n-            return entry.matches(tree, property) || applyToParent(entry);\n+            return entry.matches(tree, property) || (respectParent && parent != null && entry.matches(parent, null));\n         } else if (path != null) {\n-            return entry.matches(path) || applyToParent(entry);\n+            return entry.matches(path) || (respectParent && parentPath != null && entry.matches(parentPath));\n         } else {\n             return entry.matches();\n         }\n     }\n \n-    private boolean applyToParent(@Nonnull PermissionEntry entry) {\n-        if (parent != null) {\n-            return entry.matches(parent, null);\n-        } else if (parentPath != null) {\n-            return entry.matches(parentPath);\n-        } else {\n-            return false;\n-        }\n-    }\n }\n\\ No newline at end of file\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntry.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntry.java\nindex 36dbe01e95..136ccb9afc 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntry.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntry.java\n@@ -122,4 +122,16 @@ public boolean equals(Object o) {\n     public int hashCode() {\n         return Objects.hashCode(privilegeBits, index, path, isAllow, restriction);\n     }\n+\n+    @Override\n+    public String toString() {\n+        final StringBuilder sb = new StringBuilder(\"PermissionEntry{\");\n+        sb.append(\"isAllow=\").append(isAllow);\n+        sb.append(\", privilegeBits=\").append(privilegeBits);\n+        sb.append(\", index=\").append(index);\n+        sb.append(\", path='\").append(path).append('\\'');\n+        sb.append(\", restriction=\").append(restriction);\n+        sb.append('}');\n+        return sb.toString();\n+    }\n }\n\\ No newline at end of file\n",
        "project": "jackrabbit-oak",
        "linesAdd": 39,
        "jira_id": "3324",
        "nb_skipped": 1,
        "commit": "5f863af6",
        "nb_failure": 4,
        "linesRem": 23,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2023,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex e617e173f1..1134673e93 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -775,7 +775,7 @@ public DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore,\n             // check if there may be more recent values in a previous document\n             if (value != null && !getPreviousRanges().isEmpty()) {\n                 Revision newest = getLocalMap(key).firstKey();\n-                if (!value.revision.equals(newest)) {\n+                if (isRevisionNewer(nodeStore, newest, value.revision)) {\n                     // not reading the most recent value, we may need to\n                     // consider previous documents as well\n                     Revision newestPrev = getPreviousRanges().firstKey();\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "2336",
        "nb_skipped": 9,
        "commit": "d0f6715d",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1874,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/LowerCaseImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/LowerCaseImpl.java\nindex 3f36512f05..1b13e1d43f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/LowerCaseImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/LowerCaseImpl.java\n@@ -27,7 +27,11 @@\n import org.apache.jackrabbit.oak.query.index.FilterImpl;\n import org.apache.jackrabbit.oak.spi.query.PropertyValues;\n \n+import com.google.common.base.Function;\n+\n+import static com.google.common.collect.Iterables.transform;\n import static org.apache.jackrabbit.oak.api.Type.STRING;\n+import static org.apache.jackrabbit.oak.api.Type.STRINGS;\n \n /**\n  * The function \"lower(..)\".\n@@ -70,12 +74,21 @@ public PropertyValue currentProperty() {\n         if (p == null) {\n             return null;\n         }\n-        // TODO what is the expected result of LOWER(x) for an array property?\n-        // currently throws an exception\n-        String value = p.getValue(STRING);\n         // TODO toLowerCase(): document the Turkish locale problem\n+        if (p.getType().isArray()) {\n+            Iterable<String> lowerCase = transform(p.getValue(STRINGS),\n+                    new Function<String, String>() {\n+                        @Override\n+                        public String apply(String input) {\n+                            return input.toLowerCase();\n+                        }\n+                    });\n+            return PropertyValues.newString(lowerCase);\n+        } else {\n+            String value = p.getValue(STRING);\n             return PropertyValues.newString(value.toLowerCase());\n         }\n+    }\n \n     @Override\n     public void restrict(FilterImpl f, Operator operator, PropertyValue v) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 16,
        "jira_id": "1829",
        "nb_skipped": 9,
        "commit": "ca36450e",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 195,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.CRUDTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeDelegate.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeDelegate.java\nindex 351ae8bb5c..bda7280a1e 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeDelegate.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeDelegate.java\n@@ -291,6 +291,10 @@ public PropertyDelegate setProperty(String name, CoreValue value) throws Invalid\n         return new PropertyDelegate(sessionDelegate, getTree(), propertyState);\n     }\n \n+    public void removeProperty(String name) throws InvalidItemStateException {\n+        getTree().removeProperty(name);\n+    }\n+\n     /**\n      * Set a multi valued property\n      * @param name  oak name\ndiff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\nindex 70d0494bfb..fbb8b1050e 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n@@ -264,15 +264,16 @@ public Property setProperty(String jcrName, Value value, int type)\n             throws RepositoryException {\n         checkStatus();\n \n-        int targetType = getTargetType(value, type);\n-        Value targetValue = ValueHelper.convert(value, targetType, getValueFactory());\n+        String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n         if (value == null) {\n-            Property p = getProperty(jcrName);\n-            p.remove();\n-            return p;\n+            dlg.removeProperty(oakName);\n+            return null;\n         } else {\n-            String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n-            CoreValue oakValue = ValueConverter.toCoreValue(targetValue, sessionDelegate);\n+            int targetType = getTargetType(value, type);\n+            Value targetValue =\n+                    ValueHelper.convert(value, targetType, getValueFactory());\n+            CoreValue oakValue =\n+                    ValueConverter.toCoreValue(targetValue, sessionDelegate);\n             return new PropertyImpl(dlg.setProperty(oakName, oakValue));\n         }\n     }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 12,
        "jira_id": "185",
        "nb_skipped": 9,
        "commit": "7fe28a0e",
        "nb_failure": 0,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1482,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.segment.CheckpointTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java\nindex a2be1233a6..d75758570c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java\n@@ -178,17 +178,45 @@ public Blob createBlob(InputStream stream) throws IOException {\n     @Override @Nonnull\n     public synchronized String checkpoint(long lifetime) {\n         checkArgument(lifetime > 0);\n-        // TODO: Guard the checkpoint from garbage collection\n-        return head.getRecordId().toString();\n+        String name = UUID.randomUUID().toString();\n+\n+        // try 5 times\n+        for (int i = 0; i < 5; i++) {\n+            if (commitSemaphore.tryAcquire()) {\n+                try {\n+                    refreshHead();\n+\n+                    SegmentNodeState ns = head;\n+                    RecordId ri = head.getRecordId();\n+\n+                    SegmentRootBuilder builder = ns.builder();\n+                    NodeBuilder cp = builder.child(name);\n+                    cp.setProperty(\"timestamp\", System.currentTimeMillis()\n+                            + lifetime);\n+                    cp.setChildNode(ROOT, ns.getChildNode(ROOT));\n+\n+                    if (journal.setHead(ri, builder.getNodeState()\n+                            .getRecordId())) {\n+                        refreshHead();\n+                        return name;\n+                    }\n+\n+                } finally {\n+                    commitSemaphore.release();\n+                }\n+            }\n+        }\n+\n+        return name;\n     }\n \n     @Override @CheckForNull\n     public synchronized NodeState retrieve(@Nonnull String checkpoint) {\n-        // TODO: Verify validity of the checkpoint\n-        RecordId id = RecordId.fromString(checkNotNull(checkpoint));\n-        SegmentNodeState root =\n-                new SegmentNodeState(store.getWriter().getDummySegment(), id);\n-        return root.getChildNode(ROOT);\n+        NodeState cp = head.getChildNode(checkpoint).getChildNode(ROOT);\n+        if (cp.exists()) {\n+            return cp;\n+        }\n+        return null;\n     }\n \n     private class Commit {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 34,
        "jira_id": "1250",
        "nb_skipped": 6,
        "commit": "0c3b3306",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 468,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlannerTest",
            "org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexPlanner.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexPlanner.java\nindex 522aa66d4b..19ad3cf7b5 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexPlanner.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexPlanner.java\n@@ -315,7 +315,12 @@ private void visitTerm(String propertyName) {\n     }\n \n     private boolean canEvalPathRestrictions(IndexingRule rule) {\n-        if (filter.getPathRestriction() == Filter.PathRestriction.NO_RESTRICTION){\n+        //Opt out if one is looking for all children for '/' as its equivalent to\n+        //NO_RESTRICTION\n+        if (filter.getPathRestriction() == Filter.PathRestriction.NO_RESTRICTION\n+                || (filter.getPathRestriction() == Filter.PathRestriction.ALL_CHILDREN\n+                        && PathUtils.denotesRoot(filter.getPath()))\n+                ){\n             return false;\n         }\n         //If no other restrictions is provided and query is pure\n",
        "project": "jackrabbit-oak",
        "linesAdd": 4,
        "jira_id": "3137",
        "nb_skipped": 4,
        "commit": "c65b07c3",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 705,
        "nb_error": 23,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest",
            "org.apache.jackrabbit.oak.namepath.NamePathMapperImplTest",
            "org.apache.jackrabbit.oak.spi.security.authorization.restriction.RestrictionDefinitionImplTest",
            "org.apache.jackrabbit.oak.spi.security.authorization.restriction.RestrictionImplTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/LocalNameMapper.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/LocalNameMapper.java\nindex f17a69b790..eb558c555a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/LocalNameMapper.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/LocalNameMapper.java\n@@ -40,8 +40,8 @@ private static boolean isExpandedName(String name) {\n     @Override @CheckForNull\n     public String getJcrName(String oakName) {\n         checkNotNull(oakName);\n-        checkArgument(!oakName.startsWith(\":\")); // hidden name\n-        checkArgument(isExpandedName(oakName));  // expanded name\n+        checkArgument(!oakName.startsWith(\":\"), oakName); // hidden name\n+        checkArgument(!isExpandedName(oakName), oakName); // expanded name\n \n         if (hasSessionLocalMappings()) {\n             int colon = oakName.indexOf(':');\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "509",
        "nb_skipped": 1,
        "commit": "b896c926",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 2,
        "nb_test": 1818,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 2f238381c3..8000126183 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -798,7 +798,7 @@ public DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore,\n                     min, readRevision, validRevisions, lastRevs);\n \n             // check if there may be more recent values in a previous document\n-            if (value != null && !getPreviousRanges().isEmpty()) {\n+            if (!getPreviousRanges().isEmpty()) {\n                 Revision newest = getLocalMap(key).firstKey();\n                 if (isRevisionNewer(nodeStore, newest, value.revision)) {\n                     // not reading the most recent value, we may need to\n@@ -894,13 +894,13 @@ public Revision getLiveRevision(RevisionContext context, Revision maxRev,\n         // check local deleted map first\n         Value value = getLatestValue(context, getLocalDeleted(),\n                 null, maxRev, validRevisions, lastRevs);\n-        if (value == null && !getPreviousRanges().isEmpty()) {\n+        if (value.value == null && !getPreviousRanges().isEmpty()) {\n             // need to check complete map\n             value = getLatestValue(context, getDeleted(),\n                     null, maxRev, validRevisions, lastRevs);\n         }\n \n-        return value != null && \"false\".equals(value.value) ? value.revision : null;\n+        return \"false\".equals(value.value) ? value.revision : null;\n     }\n \n     /**\n@@ -1435,10 +1435,12 @@ private static boolean includeRevision(RevisionContext context,\n \n     /**\n      * Get the latest property value that is larger or equal the min revision,\n-     * and smaller or equal the readRevision revision. A {@code null} return\n-     * value indicates that the property was not set or removed within the given\n-     * range. A non-null value means the the property was either set or removed\n-     * depending on {@link Value#value}.\n+     * and smaller or equal the readRevision revision. The returned value will\n+     * provide the revision when the value was set between the {@code min} and\n+     * {@code readRevision}. The returned value will have a {@code null} value\n+     * contained if there is no valid change within the given range. In this\n+     * case the associated revision is {@code min} or {@code readRevision} if\n+     * no {@code min} is provided.\n      *\n      * @param valueMap the sorted revision-value map\n      * @param min the minimum revision (null meaning unlimited)\n@@ -1446,9 +1448,9 @@ private static boolean includeRevision(RevisionContext context,\n      * @param validRevisions map of revision to commit value considered valid\n      *                       against the given readRevision.\n      * @param lastRevs to keep track of the most recent modification.\n-     * @return the value, or null if not found\n+     * @return the latest value from the {@code readRevision} point of view.\n      */\n-    @CheckForNull\n+    @Nonnull\n     private Value getLatestValue(@Nonnull RevisionContext context,\n                                  @Nonnull Map<Revision, String> valueMap,\n                                  @Nullable Revision min,\n@@ -1486,7 +1488,9 @@ private Value getLatestValue(@Nonnull RevisionContext context,\n                 return new Value(commitRev, entry.getValue());\n             }\n         }\n-        return null;\n+\n+        Revision r = min != null ? min : readRevision;\n+        return new Value(r, null);\n     }\n \n     @Override\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java\nindex 94d21d321b..7b1bec62ac 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java\n@@ -120,27 +120,34 @@ public int size() {\n \n             @Override\n             public String get(Object key) {\n+                Revision r = (Revision) key;\n                 // first check values map of this document\n-                String value = map.get(key);\n-                if (value != null) {\n-                    return value;\n+                if (map.containsKey(r)) {\n+                    return map.get(r);\n                 }\n-                Revision r = (Revision) key;\n                 for (NodeDocument prev : doc.getPreviousDocs(property, r)) {\n-                    value = prev.getValueMap(property).get(key);\n+                    String value = prev.getValueMap(property).get(r);\n                     if (value != null) {\n                         return value;\n                     }\n                 }\n-                // not found\n+                // not found or null\n                 return null;\n             }\n \n             @Override\n             public boolean containsKey(Object key) {\n-                // can use get()\n-                // the values map does not have null values\n-                return get(key) != null;\n+                // check local map first\n+                if (map.containsKey(key)) {\n+                    return true;\n+                }\n+                Revision r = (Revision) key;\n+                for (NodeDocument prev : doc.getPreviousDocs(property, r)) {\n+                    if (prev.getValueMap(property).containsKey(key)) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n             }\n         };\n     }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 21,
        "jira_id": "2359",
        "nb_skipped": 9,
        "commit": "b3071839",
        "nb_failure": 1,
        "linesRem": 11,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 619,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.core.RootImplTest",
            "org.apache.jackrabbit.oak.core.TreeImplTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\nindex 3cbd5b8d9c..ac0353adbf 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n@@ -57,6 +57,11 @@\n      */\n     private final RootImpl root;\n \n+    /**\n+     * The {@code NodeBuilder} for the underlying node state\n+     */\n+    private final NodeBuilder nodeBuilder;\n+\n     /**\n      * Parent of this tree. Null for the root.\n      */\n@@ -67,32 +72,26 @@\n      */\n     private String name;\n \n-    /**\n-     * Lazily initialised {@code NodeBuilder} for the underlying node state\n-     */\n-    NodeBuilder nodeBuilder;\n+    private TreeImpl(RootImpl root) {\n+        this.root = checkNotNull(root);\n+        this.name = \"\";\n+        this.nodeBuilder = root.createRootBuilder();\n+    }\n \n     private TreeImpl(RootImpl root, TreeImpl parent, String name) {\n         this.root = checkNotNull(root);\n-        this.parent = parent;\n+        this.parent = checkNotNull(parent);\n         this.name = checkNotNull(name);\n+        this.nodeBuilder = parent.getNodeBuilder().child(name);\n     }\n \n     @Nonnull\n     static TreeImpl createRoot(final RootImpl root) {\n-        return new TreeImpl(root, null, \"\") {\n+        return new TreeImpl(root) {\n             @Override\n             protected NodeState getBaseState() {\n                 return root.getBaseState();\n             }\n-\n-            @Override\n-            protected synchronized NodeBuilder getNodeBuilder() {\n-                if (nodeBuilder == null) {\n-                    nodeBuilder = root.createRootBuilder();\n-                }\n-                return nodeBuilder;\n-            }\n         };\n     }\n \n@@ -189,7 +188,7 @@ public long getPropertyCount() {\n     @Override\n     public Iterable<? extends PropertyState> getProperties() {\n         root.checkLive();\n-        return Iterables.filter(getNodeBuilder().getProperties(),\n+        return Iterables.filter(nodeBuilder.getProperties(),\n                 new Predicate<PropertyState>() {\n                     @Override\n                     public boolean apply(PropertyState propertyState) {\n@@ -219,7 +218,7 @@ private boolean isDisconnected() {\n         if (!parent.nodeBuilder.isConnected()) {\n             return true;\n         }\n-        return !getNodeBuilder().isConnected();\n+        return !nodeBuilder.isConnected();\n     }\n \n     @Override\n@@ -230,7 +229,7 @@ public Status getStatus() {\n             return Status.DISCONNECTED;\n         }\n \n-        NodeBuilder builder = getNodeBuilder();\n+        NodeBuilder builder = nodeBuilder;\n         if (builder.isNew()) {\n             return Status.NEW;\n         } else if (builder.isModified()) {\n@@ -250,7 +249,7 @@ public boolean hasChild(String name) {\n     public long getChildrenCount() {\n         // TODO: make sure cnt respects access control\n         root.checkLive();\n-        return getNodeBuilder().getChildNodeCount();\n+        return nodeBuilder.getChildNodeCount();\n     }\n \n     @Override\n@@ -260,7 +259,7 @@ public long getChildrenCount() {\n         if (hasOrderableChildren()) {\n             childNames = getOrderedChildNames();\n         } else {\n-            childNames = getNodeBuilder().getChildNodeNames();\n+            childNames = nodeBuilder.getChildNodeNames();\n         }\n         return Iterables.filter(Iterables.transform(\n                 childNames,\n@@ -282,9 +281,9 @@ public boolean apply(Tree tree) {\n     public Tree addChild(String name) {\n         root.checkLive();\n         if (!hasChild(name)) {\n-            getNodeBuilder().child(name);\n+            nodeBuilder.child(name);\n             if (hasOrderableChildren()) {\n-                getNodeBuilder().setProperty(\n+                nodeBuilder.setProperty(\n                         MemoryPropertyBuilder.copy(Type.STRING, internalGetProperty(OAK_CHILD_ORDER))\n                                 .addValue(name)\n                                 .getPropertyState());\n@@ -292,8 +291,10 @@ public Tree addChild(String name) {\n             root.updated();\n         }\n \n-        TreeImpl child = getChild(name);\n-        assert child != null;\n+        TreeImpl child = new TreeImpl(root, this, name);\n+\n+        // Make sure to allocate the node builder for new nodes in order to correctly\n+        // track removes and moves. See OAK-621\n         return child;\n     }\n \n@@ -305,7 +306,7 @@ public boolean remove() {\n         }\n \n         if (!isRoot() && parent.hasChild(name)) {\n-            NodeBuilder builder = parent.getNodeBuilder();\n+            NodeBuilder builder = parent.nodeBuilder;\n             builder.removeNode(name);\n             if (parent.hasOrderableChildren()) {\n                 builder.setProperty(\n@@ -360,7 +361,7 @@ public boolean apply(@Nullable String input) {\n             tail = Iterables.skip(filtered, idx);\n         }\n         // concatenate head, this name and tail\n-        parent.getNodeBuilder().setProperty(MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, Iterables.concat(head, Collections.singleton(getName()), tail))\n+        parent.nodeBuilder.setProperty(MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, Iterables.concat(head, Collections.singleton(getName()), tail))\n         );\n         root.updated();\n         return true;\n@@ -369,7 +370,7 @@ public boolean apply(@Nullable String input) {\n     @Override\n     public void setProperty(PropertyState property) {\n         root.checkLive();\n-        NodeBuilder builder = getNodeBuilder();\n+        NodeBuilder builder = nodeBuilder;\n         builder.setProperty(property);\n         root.updated();\n     }\n@@ -377,7 +378,7 @@ public void setProperty(PropertyState property) {\n     @Override\n     public <T> void setProperty(String name, T value) {\n         root.checkLive();\n-        NodeBuilder builder = getNodeBuilder();\n+        NodeBuilder builder = nodeBuilder;\n         builder.setProperty(name, value);\n         root.updated();\n     }\n@@ -385,7 +386,7 @@ public void setProperty(PropertyState property) {\n     @Override\n     public <T> void setProperty(String name, T value, Type<T> type) {\n         root.checkLive();\n-        NodeBuilder builder = getNodeBuilder();\n+        NodeBuilder builder = nodeBuilder;\n         builder.setProperty(name, value, type);\n         root.updated();\n     }\n@@ -393,7 +394,7 @@ public void setProperty(PropertyState property) {\n     @Override\n     public void removeProperty(String name) {\n         root.checkLive();\n-        NodeBuilder builder = getNodeBuilder();\n+        NodeBuilder builder = nodeBuilder;\n         builder.removeProperty(name);\n         root.updated();\n     }\n@@ -418,16 +419,13 @@ protected NodeState getBaseState() {\n                 : parentBaseState.getChildNode(name);\n     }\n \n+    //-----------------------------------------------------------< internal >---\n+\n     @Nonnull\n-    protected synchronized NodeBuilder getNodeBuilder() {\n-        if (nodeBuilder == null) {\n-            nodeBuilder = parent.getNodeBuilder().child(name);\n-        }\n+    NodeBuilder getNodeBuilder() {\n         return nodeBuilder;\n     }\n \n-    //-----------------------------------------------------------< internal >---\n-\n     /**\n      * Move this tree to the parent at {@code destParent} with the new name\n      * {@code destName}.\n@@ -446,7 +444,7 @@ void moveTo(TreeImpl destParent, String destName) {\n \n     @Nonnull\n     NodeState getNodeState() {\n-        return getNodeBuilder().getNodeState();\n+        return nodeBuilder.getNodeState();\n     }\n \n     /**\n@@ -480,29 +478,29 @@ void updateChildOrder() {\n         }\n         Set<String> names = Sets.newLinkedHashSet();\n         for (String name : getOrderedChildNames()) {\n-            if (getNodeBuilder().hasChildNode(name)) {\n+            if (nodeBuilder.hasChildNode(name)) {\n                 names.add(name);\n             }\n         }\n-        for (String name : getNodeBuilder().getChildNodeNames()) {\n+        for (String name : nodeBuilder.getChildNodeNames()) {\n             names.add(name);\n         }\n         PropertyBuilder<String> builder = MemoryPropertyBuilder.array(\n                 Type.STRING, OAK_CHILD_ORDER);\n         builder.setValues(names);\n-        getNodeBuilder().setProperty(builder.getPropertyState());\n+        nodeBuilder.setProperty(builder.getPropertyState());\n     }\n \n     //------------------------------------------------------------< private >---\n \n     private TreeImpl internalGetChild(String childName) {\n-        return getNodeBuilder().hasChildNode(childName)\n+        return nodeBuilder.hasChildNode(childName)\n                 ? new TreeImpl(root, this, childName)\n                 : null;\n     }\n \n     private PropertyState internalGetProperty(String propertyName) {\n-        return getNodeBuilder().getProperty(propertyName);\n+        return nodeBuilder.getProperty(propertyName);\n     }\n \n     private void buildPath(StringBuilder sb) {\n@@ -574,10 +572,10 @@ public void remove() {\n      * of the children as returned by {@link NodeBuilder#getChildNodeNames()}.\n      */\n     public void ensureChildOrderProperty() {\n-        PropertyState childOrder = getNodeBuilder().getProperty(OAK_CHILD_ORDER);\n+        PropertyState childOrder = nodeBuilder.getProperty(OAK_CHILD_ORDER);\n         if (childOrder == null) {\n-            getNodeBuilder().setProperty(\n-                    MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, getNodeBuilder().getChildNodeNames()));\n+            nodeBuilder.setProperty(\n+                    MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, nodeBuilder.getChildNodeNames()));\n         }\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 36,
        "jira_id": "621",
        "nb_skipped": 8,
        "commit": "00b4b8a0",
        "nb_failure": 2,
        "linesRem": 40,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2101,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.authorization.evaluation.MoveWithoutEntryCacheTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/MoveAwarePermissionValidator.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/MoveAwarePermissionValidator.java\nindex 3f2382a2a5..cee534a18d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/MoveAwarePermissionValidator.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/MoveAwarePermissionValidator.java\n@@ -75,10 +75,11 @@ PermissionValidator createValidator(@Nullable Tree parentBefore,\n     private Validator visibleValidator(@Nonnull Tree source,\n                                        @Nonnull Tree dest) {\n         // TODO improve: avoid calculating the 'before' permissions in case the current parent permissions already point to the correct tree.\n-        ImmutableTree parent = (ImmutableTree) moveCtx.rootBefore.getTree(\"/\");\n-        TreePermission tp = getPermissionProvider().getTreePermission(parent, TreePermission.EMPTY);\n+        ImmutableTree immutableTree = (ImmutableTree) moveCtx.rootBefore.getTree(\"/\");\n+        TreePermission tp = getPermissionProvider().getTreePermission(immutableTree, TreePermission.EMPTY);\n         for (String n : PathUtils.elements(source.getPath())) {\n-            tp = tp.getChildPermission(n, parent.getChild(n).getNodeState());\n+            immutableTree = immutableTree.getChild(n);\n+            tp = tp.getChildPermission(n, immutableTree.getNodeState());\n         }\n         Validator validator = createValidator(source, dest, tp, this);\n         return new VisibleValidator(validator, true, false);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 4,
        "jira_id": "2933",
        "nb_skipped": 9,
        "commit": "44585b0c",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 699,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.p2.strategy.ContentMirrorStoreStrategyTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java\nindex 0d3b25980e..f3d48048aa 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java\n@@ -42,7 +42,26 @@\n import com.google.common.collect.Sets;\n \n /**\n- * TODO document\n+ * An IndexStoreStrategy implementation that saves the nodes under a hierarchy\n+ * that mirrors the repository tree. <br>\n+ * This should minimize the chance that concurrent updates overlap on the same\n+ * content node.<br>\n+ * <br>\n+ * For example for a node that is under <code>/test/node</code>, the index\n+ * structure will be <code>/oak:index/index/test/node</code>:\n+ * \n+ * <pre>\n+ * <code>\n+ * /\n+ *   test\n+ *     node\n+ *   oak:index\n+ *     index\n+ *       test\n+ *         node\n+ * </code>\n+ * </pre>\n+ * \n  */\n public class ContentMirrorStoreStrategy implements IndexStoreStrategy {\n \n@@ -118,6 +137,12 @@ private static void pruneNode(NodeBuilder parent) {\n     public void insert(NodeBuilder index, String key, boolean unique,\n             Iterable<String> values) throws CommitFailedException {\n         NodeBuilder child = index.child(key);\n+        if (unique\n+                && (child.getProperty(\"match\") != null || child\n+                        .getChildNodeCount() > 0)) {\n+            throw new CommitFailedException(\n+                    \"Uniqueness constraint violated for key \" + key);\n+        }\n \n         for (String add : values) {\n             NodeBuilder indexEntry = child;\n@@ -126,14 +151,6 @@ public void insert(NodeBuilder index, String key, boolean unique,\n             }\n             indexEntry.setProperty(\"match\", true);\n         }\n-        CountingNodeVisitor v = new CountingNodeVisitor(2);\n-        v.visit(child.getNodeState());\n-        int matchCount = v.getCount();\n-        if (matchCount == 0) {\n-            index.removeNode(key);\n-        } else if (unique && matchCount > 1) {\n-            throw new CommitFailedException(\"Uniqueness constraint violated for key \" + key);\n-        }\n     }\n \n     @Override\n",
        "project": "jackrabbit-oak",
        "linesAdd": 6,
        "jira_id": "748",
        "nb_skipped": 1,
        "commit": "503451c1",
        "nb_failure": 1,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1752,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.blob.datastore.DataStoreBlobStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/DataStoreBlobStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/DataStoreBlobStore.java\nindex b0552783dc..3ad49ad2fa 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/DataStoreBlobStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/DataStoreBlobStore.java\n@@ -32,6 +32,7 @@\n import javax.jcr.RepositoryException;\n \n import com.google.common.base.Function;\n+import com.google.common.base.Predicate;\n import com.google.common.collect.Iterators;\n import com.google.common.io.ByteStreams;\n import com.google.common.io.Closeables;\n@@ -47,6 +48,8 @@\n import org.slf4j.LoggerFactory;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.collect.Iterators.filter;\n+import static com.google.common.collect.Iterators.transform;\n \n /**\n  * BlobStore wrapper for DataStore. Wraps Jackrabbit 2 DataStore and expose them as BlobStores\n@@ -258,12 +261,23 @@ public long getBlockSizeMin() {\n     }\n \n     @Override\n-    public Iterator<String> getAllChunkIds(long maxLastModifiedTime) throws Exception {\n-        //TODO Ignores the maxLastModifiedTime currently.\n-        return Iterators.transform(delegate.getAllIdentifiers(), new Function<DataIdentifier, String>() {\n-            @Nullable\n+    public Iterator<String> getAllChunkIds(final long maxLastModifiedTime) throws Exception {\n+        return transform(filter(delegate.getAllIdentifiers(), new Predicate<DataIdentifier>() {\n             @Override\n-            public String apply(@Nullable DataIdentifier input) {\n+            public boolean apply(DataIdentifier input) {\n+                try {\n+                    DataRecord dr = delegate.getRecord(input);\n+                    if(dr != null && dr.getLastModified() < maxLastModifiedTime){\n+                        return true;\n+                    }\n+                } catch (DataStoreException e) {\n+                    log.warn(\"Error occurred while fetching DataRecord for identifier {}\",input, e);\n+                }\n+                return false;\n+            }\n+        }),new Function<DataIdentifier, String>() {\n+            @Override\n+            public String apply(DataIdentifier input) {\n                 return input.toString();\n             }\n         });\n",
        "project": "jackrabbit-oak",
        "linesAdd": 19,
        "jira_id": "1655",
        "nb_skipped": 8,
        "commit": "01a8b283",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 278,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.AggregateTest",
            "org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/Aggregate.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/Aggregate.java\nindex e9f7dd2c4c..fa5728beda 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/Aggregate.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/Aggregate.java\n@@ -30,7 +30,6 @@\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n-import org.apache.jackrabbit.oak.api.CommitFailedException;\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.plugins.index.lucene.util.ConfigUtil;\n@@ -79,7 +78,7 @@\n     }\n \n     public void collectAggregates(NodeState root, ResultCollector collector) {\n-        if (nodeTypeName.equals(ConfigUtil.getPrimaryTypeName(root))) {\n+        if (matchingType(nodeTypeName, root)) {\n             List<Matcher> matchers = createMatchers();\n             collectAggregates(root, matchers, collector);\n         }\n@@ -111,6 +110,19 @@ public String toString() {\n         return nodeTypeName;\n     }\n \n+    private static boolean matchingType(String nodeTypeName, NodeState nodeState) {\n+        if (nodeTypeName.equals(ConfigUtil.getPrimaryTypeName(nodeState))) {\n+            return true;\n+        }\n+\n+        for (String mixin : ConfigUtil.getMixinNames(nodeState)) {\n+            if (nodeTypeName.equals(mixin)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     private static void collectAggregates(NodeState nodeState, List<Matcher> matchers,\n                                           ResultCollector collector) {\n         for (ChildNodeEntry cne : nodeState.getChildNodeEntries()) {\n@@ -231,7 +243,7 @@ public boolean match(String name, NodeState nodeState, int depth) {\n             //last segment -> add to collector if node type matches\n             if (depth == maxDepth() - 1\n                     && primaryType != null\n-                    && !primaryType.equals(ConfigUtil.getPrimaryTypeName(nodeState))) {\n+                    && !matchingType(primaryType, nodeState)) {\n                 return false;\n             }\n             return super.match(name, nodeState, depth);\n@@ -256,7 +268,19 @@ public boolean aggregatesProperty(String name) {\n \n         @Override\n         public Aggregate getAggregate(NodeState matchedNodeState) {\n-            return aggMapper.getAggregate(ConfigUtil.getPrimaryTypeName(matchedNodeState));\n+            //Check agg defn for primaryType first\n+            Aggregate agg = aggMapper.getAggregate(ConfigUtil.getPrimaryTypeName(matchedNodeState));\n+\n+            //If not found then look for defn for mixins\n+            if (agg == null) {\n+                for (String mixin : ConfigUtil.getMixinNames(matchedNodeState)) {\n+                    agg = aggMapper.getAggregate(mixin);\n+                    if (agg != null) {\n+                        break;\n+                    }\n+                }\n+            }\n+            return agg;\n         }\n \n         @Override\ndiff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/ConfigUtil.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/ConfigUtil.java\nindex 476f7e1cc3..73287a06c1 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/ConfigUtil.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/ConfigUtil.java\n@@ -19,6 +19,8 @@\n \n package org.apache.jackrabbit.oak.plugins.index.lucene.util;\n \n+import java.util.Collections;\n+\n import com.google.common.primitives.Ints;\n import org.apache.jackrabbit.JcrConstants;\n import org.apache.jackrabbit.oak.api.Blob;\n@@ -60,6 +62,11 @@ public static String getPrimaryTypeName(NodeState nodeState) {\n         return (ps == null) ? JcrConstants.NT_BASE : ps.getValue(Type.NAME);\n     }\n \n+    public static Iterable<String> getMixinNames(NodeState nodeState) {\n+        PropertyState ps = nodeState.getProperty(JcrConstants.JCR_MIXINTYPES);\n+        return (ps == null) ? Collections.<String>emptyList() : ps.getValue(Type.NAMES);\n+    }\n+\n     /**\n      * Assumes that given state is of type nt:file and then reads\n      * the jcr:content/@jcr:data property to get the binary content\ndiff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/package-info.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/package-info.java\nindex 0761902d01..b1049b9096 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/package-info.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/package-info.java\n@@ -14,7 +14,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-@Version(\"1.1.0\")\n+@Version(\"1.2.0\")\n @Export(optional = \"provide:=true\")\n package org.apache.jackrabbit.oak.plugins.index.lucene.util;\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 34,
        "jira_id": "3630",
        "nb_skipped": 3,
        "commit": "fcd64766",
        "nb_failure": 3,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1851,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollectorTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\nindex 885f7218c5..74b4a84954 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\n@@ -20,7 +20,7 @@\n package org.apache.jackrabbit.oak.plugins.document;\n \n import java.util.ArrayList;\n-import java.util.EnumSet;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n@@ -43,11 +43,10 @@\n \n     /**\n      * Split document types which can be safely Garbage Collected\n+     * OAK-1793: SplitDocType.DEFAULT_NO_CHILD and SplitDocType.PROP_COMMIT_ONLY\n+     * have been removed, but should be added again when OAK-1794 is fixed.\n      */\n-    private static final Set<NodeDocument.SplitDocType> GC_TYPES = EnumSet.of(\n-            NodeDocument.SplitDocType.DEFAULT_NO_CHILD,\n-            NodeDocument.SplitDocType.PROP_COMMIT_ONLY);\n-\n+    private static final Set<NodeDocument.SplitDocType> GC_TYPES = Collections.emptySet();\n \n     VersionGarbageCollector(DocumentNodeStore nodeStore) {\n         this.nodeStore = nodeStore;\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "1793",
        "nb_skipped": 9,
        "commit": "16225d51",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 197,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.ValueFactoryTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/value/ValueFactoryImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/value/ValueFactoryImpl.java\nindex eb452329e4..a72250903f 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/value/ValueFactoryImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/value/ValueFactoryImpl.java\n@@ -37,6 +37,7 @@\n import java.io.UnsupportedEncodingException;\n import java.math.BigDecimal;\n import java.util.Calendar;\n+import java.util.UUID;\n \n /**\n  * Implementation of {@link ValueFactory} interface based on the\n@@ -185,6 +186,17 @@ public Value createValue(String value, int type) throws ValueFormatException {\n                     cv = factory.createValue(value, type);\n                     break;\n \n+                case PropertyType.REFERENCE:\n+                case PropertyType.WEAKREFERENCE:\n+                    // TODO: move to identifier/uuid management utility instead of relying on impl specific uuid-format here.\n+                    try {\n+                        UUID.fromString(value);\n+                    } catch (IllegalArgumentException e) {\n+                        throw new ValueFormatException(e);\n+                    }\n+                    cv = factory.createValue(value, type);\n+                    break;\n+\n                 case PropertyType.BINARY:\n                     cv = factory.createValue(new ByteArrayInputStream(value.getBytes(\"UTF-8\")));\n                     break;\n",
        "project": "jackrabbit-oak",
        "linesAdd": 11,
        "jira_id": "238",
        "nb_skipped": 2,
        "commit": "24ce6788",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 14,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest"
        ],
        "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\nindex 3752b91f31..fded86c6ad 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\n@@ -332,13 +332,15 @@ private void fixFrozenUuid() {\n             }\n \n             if (!isReferenceable.apply(frozenPrimary, frozenMixins)) {\n+                String parentFrozenUuid = parent.getString(JCR_FROZENUUID);\n+                if (parentFrozenUuid != null) {\n                     frozenUuid = PropertyStates.createProperty(\n-                        JCR_FROZENUUID,\n-                        parent.getString(JCR_FROZENUUID) + \"/\" + name);\n+                            JCR_FROZENUUID, parentFrozenUuid + \"/\" + name);\n                     properties.put(JCR_FROZENUUID, frozenUuid);\n                 }\n             }\n         }\n+    }\n \n     private org.apache.jackrabbit.oak.api.PropertyState createProperty(\n             String name, int type, InternalValue value)\ndiff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\nindex 5dff050ff4..ce8b0194d0 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n@@ -238,7 +238,8 @@ public void copy(RepositoryInitializer initializer) throws RepositoryException {\n         logger.info(\n                 \"Copying repository content from {} to Oak\", config.getHomeDir());\n         try {\n-            NodeBuilder builder = target.getRoot().builder();\n+            NodeState base = target.getRoot();\n+            NodeBuilder builder = base.builder();\n \n             String workspace =\n                     source.getRepositoryConfig().getDefaultWorkspaceName();\n@@ -260,6 +261,11 @@ public void copy(RepositoryInitializer initializer) throws RepositoryException {\n             copyNodeTypes(builder, uriToPrefix.inverse());\n             copyPrivileges(builder);\n \n+            // Triggers compilation of type information, which we need for\n+            // the type predicates used by the bulk  copy operations below.\n+            new TypeEditorProvider(false).getRootEditor(\n+                    base, builder.getNodeState(), builder, null);\n+\n             NodeState root = builder.getNodeState();\n             copyVersionStore(builder, root, uriToPrefix, idxToPrefix);\n             copyWorkspace(builder, root, workspace, uriToPrefix, idxToPrefix);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 9,
        "jira_id": "1789",
        "nb_skipped": 0,
        "commit": "07646fba",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 14,
        "nb_error": 14,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberSplitUpgradeTest",
            "org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberUpgradeTest",
            "org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest"
        ],
        "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\nindex c063a26214..3752b91f31 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/JackrabbitNodeState.java\n@@ -32,6 +32,7 @@\n import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYTYPE;\n import static org.apache.jackrabbit.JcrConstants.JCR_UUID;\n import static org.apache.jackrabbit.JcrConstants.MIX_REFERENCEABLE;\n+import static org.apache.jackrabbit.JcrConstants.NT_BASE;\n import static org.apache.jackrabbit.JcrConstants.NT_FROZENNODE;\n import static org.apache.jackrabbit.JcrConstants.NT_UNSTRUCTURED;\n import static org.apache.jackrabbit.oak.api.Type.NAME;\n@@ -131,6 +132,8 @@ private JackrabbitNodeState(\n         this.uriToPrefix = parent.uriToPrefix;\n         this.properties = createProperties(bundle);\n         this.nodes = createNodes(bundle);\n+        setChildOrder();\n+        fixFrozenUuid();\n         this.useBinaryReferences = parent.useBinaryReferences;\n         logNewNode(this);\n     }\n@@ -151,6 +154,7 @@ private JackrabbitNodeState(\n             NodePropBundle bundle = loader.loadBundle(id);\n             this.properties = createProperties(bundle);\n             this.nodes = createNodes(bundle);\n+            setChildOrder();\n         } catch (ItemStateException e) {\n             throw new IllegalStateException(\"Unable to access node \" + id, e);\n         }\n@@ -239,6 +243,13 @@ public NodeBuilder builder() {\n \n     //-----------------------------------------------------------< private >--\n \n+    private void setChildOrder() {\n+        if (isOrderable.apply(this)) {\n+            properties.put(OAK_CHILD_ORDER, PropertyStates.createProperty(\n+                    OAK_CHILD_ORDER, nodes.keySet(), Type.NAMES));\n+        }\n+    }\n+\n     private Map<String, NodeId> createNodes(NodePropBundle bundle) {\n         Map<String, NodeId> children = newLinkedHashMap();\n         for (ChildNodeEntry entry : bundle.getChildNodeEntries()) {\n@@ -282,11 +293,6 @@ public NodeBuilder builder() {\n                     JCR_UUID, bundle.getId().toString()));\n         }\n \n-        if (isOrderable.apply(primary, mixins)) {\n-            properties.put(OAK_CHILD_ORDER, PropertyStates.createProperty(\n-                    OAK_CHILD_ORDER, nodes.keySet(), Type.NAMES));\n-        }\n-\n         for (PropertyEntry property : bundle.getPropertyEntries()) {\n             String name = createName(property.getName());\n             try {\n@@ -303,18 +309,22 @@ public NodeBuilder builder() {\n             }\n         }\n \n+        return properties;\n+    }\n+\n+    private void fixFrozenUuid() {\n         // OAK-1789: Convert the jcr:frozenUuid of a non-referenceable\n         // frozen node from UUID to a path identifier\n         PropertyState frozenUuid = properties.get(JCR_FROZENUUID);\n         if (frozenUuid != null\n                 && frozenUuid.getType() == STRING\n-                && isFrozenNode.apply(primary, mixins)) {\n-            String frozenPrimary = NT_UNSTRUCTURED;\n+                && isFrozenNode.apply(this)) {\n+            String frozenPrimary = NT_BASE;\n             Set<String> frozenMixins = newHashSet();\n \n             PropertyState property = properties.get(JCR_FROZENPRIMARYTYPE);\n             if (property != null && property.getType() == NAME) {\n-                primary = property.getValue(NAME);\n+                frozenPrimary = property.getValue(NAME);\n             }\n             property = properties.get(JCR_FROZENMIXINTYPES);\n             if (property != null && property.getType() == NAMES) {\n@@ -328,8 +338,6 @@ public NodeBuilder builder() {\n                 properties.put(JCR_FROZENUUID, frozenUuid);\n             }\n         }\n-\n-        return properties;\n     }\n \n     private org.apache.jackrabbit.oak.api.PropertyState createProperty(\n",
        "project": "jackrabbit-oak",
        "linesAdd": 18,
        "jira_id": "1789",
        "nb_skipped": 0,
        "commit": "9f7c1df0",
        "nb_failure": 0,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1999,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.VersionGCDeletionTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\nindex 2f816d1474..9b12714038 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\n@@ -20,6 +20,7 @@\n package org.apache.jackrabbit.oak.plugins.document;\n \n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.EnumSet;\n import java.util.List;\n import java.util.Set;\n@@ -109,6 +110,8 @@ private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision\n             Utils.closeIfCloseable(itr);\n         }\n \n+        Collections.sort(docIdsToDelete, PathComparator.INSTANCE);\n+\n         if(log.isDebugEnabled()) {\n             StringBuilder sb = new StringBuilder(\"Deleted document with following ids were deleted as part of GC \\n\");\n             Joiner.on(StandardSystemProperty.LINE_SEPARATOR.value()).appendTo(sb, docIdsToDelete);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "2603",
        "nb_skipped": 9,
        "commit": "77d2d3b0",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1276,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.user.UserValidatorTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserValidator.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserValidator.java\nindex c731481b5a..f4c736cb0a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserValidator.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserValidator.java\n@@ -56,7 +56,7 @@\n         this.parentAfter = parentAfter;\n         this.provider = provider;\n \n-        authorizableType = UserUtil.getType(parentAfter);\n+        authorizableType = (parentAfter == null) ? null : UserUtil.getType(parentAfter);\n     }\n \n     //----------------------------------------------------------< Validator >---\n@@ -149,12 +149,17 @@ public Validator childNodeChanged(String name, NodeState before, NodeState after\n \n     @Override\n     public Validator childNodeDeleted(String name, NodeState before) throws CommitFailedException {\n-        Tree node = parentBefore.getChild(name);\n-        if (isAdminUser(node)) {\n+        Tree tree = parentBefore.getChild(name);\n+        AuthorizableType type = UserUtil.getType(tree);\n+        if (type == AuthorizableType.USER || type == AuthorizableType.GROUP) {\n+            if (isAdminUser(tree)) {\n                 String msg = \"The admin user cannot be removed.\";\n                 throw constraintViolation(27, msg);\n             }\n             return null;\n+        } else {\n+            return new VisibleValidator(new UserValidator(tree, null, provider), true, true);\n+        }\n     }\n \n     //------------------------------------------------------------< private >---\n",
        "project": "jackrabbit-oak",
        "linesAdd": 8,
        "jira_id": "1054",
        "nb_skipped": 8,
        "commit": "0adf3a6e",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1578,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.api.TreeTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/commit/ChildOrderConflictHandler.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/commit/ChildOrderConflictHandler.java\nindex bf31922021..c4ea380410 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/commit/ChildOrderConflictHandler.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/commit/ChildOrderConflictHandler.java\n@@ -45,7 +45,8 @@ public Resolution addExistingProperty(NodeBuilder parent,\n         if (isChildOrderProperty(ours)) {\n             // two sessions concurrently called orderBefore() on a Tree\n             // that was previously unordered.\n-            return Resolution.THEIRS;\n+            merge(parent, ours, theirs);\n+            return Resolution.MERGED;\n         } else {\n             return handler.addExistingProperty(parent, ours, theirs);\n         }\n@@ -75,11 +76,11 @@ public Resolution changeChangedProperty(NodeBuilder parent,\n     }\n \n     private static void merge(NodeBuilder parent, PropertyState ours, PropertyState theirs) {\n-        Set<String> theirOrder = Sets.newHashSet(theirs.getValue(Type.STRINGS));\n-        PropertyBuilder<String> merged = PropertyBuilder.array(Type.STRING).assignFrom(theirs);\n+        Set<String> theirOrder = Sets.newHashSet(theirs.getValue(Type.NAMES));\n+        PropertyBuilder<String> merged = PropertyBuilder.array(Type.NAME).assignFrom(theirs);\n \n         // Append child node names from ours that are not in theirs\n-        for (String ourChild : ours.getValue(Type.STRINGS)) {\n+        for (String ourChild : ours.getValue(Type.NAMES)) {\n             if (!theirOrder.contains(ourChild)) {\n                 merged.addValue(ourChild);\n             }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 5,
        "jira_id": "1460",
        "nb_skipped": 7,
        "commit": "f1ba7a42",
        "nb_failure": 4,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1836,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java\nindex a77a85ce1f..585b44e0ac 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java\n@@ -24,8 +24,10 @@\n \n import javax.jcr.PropertyType;\n \n+import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.api.Type;\n+import org.apache.jackrabbit.oak.plugins.memory.PropertyStates;\n import org.apache.jackrabbit.oak.query.fulltext.LikePattern;\n import org.apache.jackrabbit.oak.query.index.FilterImpl;\n import org.apache.jackrabbit.oak.spi.query.PropertyValues;\n@@ -101,8 +103,23 @@ public boolean evaluate() {\n             // unable to convert, just skip this node\n             return false;\n         }\n+        if (p1.isArray()) {\n+            // JCR 2.0 spec, 6.7.16 Comparison:\n+            // \"... constraint is satisfied as a whole if the comparison\n+            // against any element of the array is satisfied.\"\n+            Type<?> base = p1.getType().getBaseType();\n+            for (int i = 0; i < p1.count(); i++) {\n+                PropertyState value = PropertyStates.createProperty(\n+                        \"value\", p1.getValue(base, i), base);\n+                if (evaluate(PropertyValues.create(value), p2)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        } else {\n             return evaluate(p1, p2);\n         }\n+    }\n \n     /**\n      * \"operand2 always evaluates to a scalar value\"\n",
        "project": "jackrabbit-oak",
        "linesAdd": 14,
        "jira_id": "1739",
        "nb_skipped": 8,
        "commit": "8188ef54",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 0,
        "nb_test": 1443,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.mongomk.MongoMKResetTest"
        ],
        "patch": "",
        "project": "jackrabbit-oak",
        "linesAdd": 0,
        "jira_id": "1186",
        "nb_skipped": 6,
        "commit": "52372042",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1963,
        "nb_error": 4,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.RepositoryTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\nindex 2dbd284919..21a32d0671 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\n@@ -797,6 +797,7 @@ public PropertyIterator getWeakReferences(String name) throws RepositoryExceptio\n \n     @Override\n     public boolean hasNode(String relPath) throws RepositoryException {\n+        try {\n             final String oakPath = getOakPathOrThrow(relPath);\n             return perform(new NodeOperation<Boolean>(dlg) {\n                 @Override\n@@ -804,10 +805,14 @@ public Boolean perform() throws RepositoryException {\n                     return node.getChild(oakPath) != null;\n                 }\n             });\n+        } catch (PathNotFoundException e) {\n+            return false;\n+        }\n     }\n \n     @Override\n     public boolean hasProperty(String relPath) throws RepositoryException {\n+        try {\n             final String oakPath = getOakPathOrThrow(relPath);\n             return perform(new NodeOperation<Boolean>(dlg) {\n                 @Override\n@@ -815,6 +820,9 @@ public Boolean perform() throws RepositoryException {\n                     return node.getPropertyOrNull(oakPath) != null;\n                 }\n             });\n+        } catch (PathNotFoundException e) {\n+            return false;\n+        }\n     }\n \n     @Override\n",
        "project": "jackrabbit-oak",
        "linesAdd": 8,
        "jira_id": "1227",
        "nb_skipped": 5,
        "commit": "117b0a3d",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 8,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.segment.standby.StandbyTest"
        ],
        "patch": "diff --git a/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/StandbyApplyDiff.java b/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/StandbyApplyDiff.java\nindex fc055e25b1..7b32f51662 100644\n--- a/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/StandbyApplyDiff.java\n+++ b/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/StandbyApplyDiff.java\n@@ -26,9 +26,9 @@\n import org.apache.jackrabbit.oak.api.Blob;\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Type;\n-import org.apache.jackrabbit.oak.commons.PathUtils;\n-import org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState;\n+import org.apache.jackrabbit.oak.plugins.segment.RecordId;\n import org.apache.jackrabbit.oak.plugins.segment.SegmentBlob;\n+import org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState;\n import org.apache.jackrabbit.oak.plugins.segment.SegmentStore;\n import org.apache.jackrabbit.oak.plugins.segment.standby.store.RemoteSegmentLoader;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n@@ -50,22 +50,20 @@\n \n     private final String path;\n \n+    private final boolean logOnly;\n+\n     public StandbyApplyDiff(NodeBuilder builder, SegmentStore store,\n             RemoteSegmentLoader loader) {\n-        this(builder, store, loader, \"/\");\n+        this(builder, store, loader, \"/\", false);\n     }\n \n     private StandbyApplyDiff(NodeBuilder builder, SegmentStore store,\n-            RemoteSegmentLoader loader, String path) {\n+            RemoteSegmentLoader loader, String path, boolean logOnly) {\n         this.builder = builder;\n         this.store = store;\n         this.loader = loader;\n         this.path = path;\n-        if (log.isTraceEnabled()) {\n-            if (PathUtils.getDepth(path) < 5) {\n-                log.trace(\"running diff on {}\", path);\n-            }\n-        }\n+        this.logOnly = logOnly;\n     }\n \n     @Override\n@@ -73,7 +71,9 @@ public boolean propertyAdded(PropertyState after) {\n         if (!loader.isRunning()) {\n             return false;\n         }\n+        if (!logOnly) {\n             builder.setProperty(binaryCheck(after));\n+        }\n         return true;\n     }\n \n@@ -82,7 +82,9 @@ public boolean propertyChanged(PropertyState before, PropertyState after) {\n         if (!loader.isRunning()) {\n             return false;\n         }\n+        if (!logOnly) {\n             builder.setProperty(binaryCheck(after));\n+        }\n         return true;\n     }\n \n@@ -91,7 +93,9 @@ public boolean propertyDeleted(PropertyState before) {\n         if (!loader.isRunning()) {\n             return false;\n         }\n+        if (!logOnly) {\n             builder.removeProperty(before.getName());\n+        }\n         return true;\n     }\n \n@@ -143,13 +147,18 @@ public boolean childNodeAdded(String name, NodeState after) {\n         if (!loader.isRunning()) {\n             return false;\n         }\n-        NodeBuilder child = EmptyNodeState.EMPTY_NODE.builder();\n-        boolean success = EmptyNodeState.compareAgainstEmptyState(after,\n-                new StandbyApplyDiff(child, store, loader, path + name + \"/\"));\n-        if (success) {\n-            builder.setChildNode(name, child.getNodeState());\n+\n+        if (after instanceof SegmentNodeState) {\n+            if (log.isTraceEnabled()) {\n+                log.trace(\"childNodeAdded {}, RO:{}\", path + name, logOnly);\n             }\n-        return success;\n+            if (!logOnly) {\n+                RecordId id = ((SegmentNodeState) after).getRecordId();\n+                builder.setChildNode(name, new SegmentNodeState(id));\n+            }\n+            return true;\n+        }\n+        return false;\n     }\n \n     @Override\n@@ -159,8 +168,26 @@ public boolean childNodeChanged(String name, NodeState before,\n             return false;\n         }\n \n+        if (after instanceof SegmentNodeState) {\n+            RecordId id = ((SegmentNodeState) after).getRecordId();\n+\n+            if (log.isTraceEnabled()) {\n+                // if (PathUtils.getDepth(path) < 5) {\n+                RecordId oldId = ((SegmentNodeState) before).getRecordId();\n+                log.trace(\"childNodeChanged {}, {} -> {}, RO:{}\", path + name,\n+                        oldId, id, logOnly);\n+                // }\n+            }\n+            if (!logOnly) {\n+                builder.setChildNode(name, new SegmentNodeState(id));\n+            }\n+\n+            // return true;\n             return after.compareAgainstBaseState(before, new StandbyApplyDiff(\n-                builder.getChildNode(name), store, loader, path + name + \"/\"));\n+                    builder.getChildNode(name), store, loader, path + name\n+                            + \"/\", true));\n+        }\n+        return false;\n     }\n \n     @Override\n@@ -168,7 +195,10 @@ public boolean childNodeDeleted(String name, NodeState before) {\n         if (!loader.isRunning()) {\n             return false;\n         }\n+        log.trace(\"childNodeDeleted {}, RO:{}\", path + name, logOnly);\n+        if (!logOnly) {\n             builder.getChildNode(name).remove();\n+        }\n         return true;\n     }\n }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 43,
        "jira_id": "2430",
        "nb_skipped": 0,
        "commit": "be3a9114",
        "nb_failure": 1,
        "linesRem": 16,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 53,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.commons.json.JsopTest"
        ],
        "patch": "diff --git a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\nindex 8489197562..bffa237eea 100644\n--- a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\n+++ b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\n@@ -254,7 +254,7 @@ public static String encode(String s) {\n         }\n         for (int i = 0; i < length; i++) {\n             char c = s.charAt(i);\n-            if (c == '\\\"' || c == '\\\\' || c < ' ') {\n+            if (c == '\\\"' || c == '\\\\' || c < ' ' || (c >= 0xd800 && c <= 0xdbff)) {\n                 StringBuilder buff = new StringBuilder(length + 2 + length / 8);\n                 buff.append('\\\"');\n                 escape(s, length, buff);\n@@ -285,7 +285,6 @@ public static void escape(String s, StringBuilder buff) {\n     private static void escape(String s, int length, StringBuilder buff) {\n         for (int i = 0; i < length; i++) {\n             char c = s.charAt(i);\n-            int ic = (int)c;\n             switch (c) {\n             case '\"':\n                 // quotation mark\n@@ -317,8 +316,8 @@ private static void escape(String s, int length, StringBuilder buff) {\n                 break;\n             default:\n                 if (c < ' ') {\n-                    buff.append(String.format(\"\\\\u%04x\", ic));\n-                } else if (ic >= 0xD800 && ic <= 0xDBFF) {\n+                    buff.append(String.format(\"\\\\u%04x\", (int) c));\n+                } else if (c >= 0xd800 && c <= 0xdbff) {\n                     // isSurrogate(), only available in Java 7\n                     if (i < length - 1 && Character.isSurrogatePair(c, s.charAt(i + 1))) {\n                         // ok surrogate\n@@ -327,7 +326,7 @@ private static void escape(String s, int length, StringBuilder buff) {\n                         i += 1;\n                     } else {\n                         // broken surrogate -> escape\n-                        buff.append(String.format(\"\\\\u%04x\", ic));\n+                        buff.append(String.format(\"\\\\u%04x\", (int) c));\n                     }\n                 } else {\n                     buff.append(c);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 4,
        "jira_id": "2389",
        "nb_skipped": 0,
        "commit": "0fa892b3",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 11,
        "nb_test": 542,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.p2.Property2IndexQueryTest",
            "org.apache.jackrabbit.oak.plugins.index.old.QueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java\nindex 57bf0d1672..002bad8e36 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java\n@@ -308,7 +308,7 @@ public ResultImpl executeQuery() {\n         prepare();\n         Iterator<ResultRowImpl> it;\n         if (explain) {\n-            String plan = source.getPlan(rootState);\n+            String plan = getPlan();\n             columns = new ColumnImpl[] { new ColumnImpl(\"explain\", \"plan\", \"plan\")};\n             ResultRowImpl r = new ResultRowImpl(this,\n                     new String[0], \n@@ -317,7 +317,7 @@ public ResultImpl executeQuery() {\n             it = Arrays.asList(r).iterator();\n         } else {\n             if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"plan: \" + source.getPlan(rootState));\n+                LOG.debug(\"plan: \" + getPlan());\n             }\n             if (orderings == null) {\n                 // can apply limit and offset directly\n@@ -438,6 +438,15 @@ public int compareRows(PropertyValue[] orderValues,\n         return comp;\n     }\n     \n+    /**\n+     * Get the query plan. The query must already be prepared.\n+     * \n+     * @return the query plan\n+     */\n+    private String getPlan() {\n+        return source.getPlan(rootState);\n+    }\n+\n     void prepare() {\n         if (prepared) {\n             return;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java\nindex a7569bce82..2a79d6779e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java\n@@ -176,11 +176,14 @@ public QueryIndex getBestIndex(Query query, NodeState rootState, Filter filter)\n                 best = index;\n             }\n         }\n-        if (best == null) {\n+        QueryIndex index = new TraversingIndex();\n+        double cost = index.getCost(filter, rootState);\n         if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"no indexes found - using TraversingIndex; indexProvider: \" + indexProvider);\n+            LOG.debug(\"cost for \" + index.getIndexName() + \" is \" + cost);\n         }\n-            best = new TraversingIndex();\n+        if (cost < bestCost) {\n+            bestCost = cost;\n+            best = index;\n         }\n         return best;\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ChildNodeJoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ChildNodeJoinConditionImpl.java\nindex 829196abc5..6213557f38 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ChildNodeJoinConditionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ChildNodeJoinConditionImpl.java\n@@ -66,12 +66,22 @@ public boolean evaluate() {\n     public void restrict(FilterImpl f) {\n         if (f.getSelector() == parentSelector) {\n             String c = childSelector.currentPath();\n+            if (c == null && f.isPreparing() && childSelector.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                c = KNOWN_PATH;\n+            }\n             if (c != null) {\n                 f.restrictPath(PathUtils.getParentPath(c), Filter.PathRestriction.EXACT);\n             }\n         }\n         if (f.getSelector() == childSelector) {\n             String p = parentSelector.currentPath();\n+            if (p == null && f.isPreparing() && parentSelector.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                p = KNOWN_PATH;\n+            }\n             if (p != null) {\n                 f.restrictPath(p, Filter.PathRestriction.DIRECT_CHILDREN);\n             }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/DescendantNodeJoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/DescendantNodeJoinConditionImpl.java\nindex 1552155cf1..8e5f945dcb 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/DescendantNodeJoinConditionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/DescendantNodeJoinConditionImpl.java\n@@ -66,12 +66,22 @@ public boolean evaluate() {\n     public void restrict(FilterImpl f) {\n         if (f.getSelector() == ancestorSelector) {\n             String d = descendantSelector.currentPath();\n+            if (d == null && f.isPreparing() && descendantSelector.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                d = KNOWN_PATH;\n+            }\n             if (d != null) {\n                 f.restrictPath(PathUtils.getParentPath(d), Filter.PathRestriction.PARENT);\n             }\n         }\n         if (f.getSelector() == descendantSelector) {\n             String a = ancestorSelector.currentPath();\n+            if (a == null && f.isPreparing() && ancestorSelector.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                a = KNOWN_PATH;\n+            }\n             if (a != null) {\n                 f.restrictPath(a, Filter.PathRestriction.DIRECT_CHILDREN);\n             }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/EquiJoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/EquiJoinConditionImpl.java\nindex dae131d44a..01d1ce29d4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/EquiJoinConditionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/EquiJoinConditionImpl.java\n@@ -97,21 +97,35 @@ public boolean evaluate() {\n     public void restrict(FilterImpl f) {\n         if (f.getSelector() == selector1) {\n             PropertyValue p2 = selector2.currentProperty(property2Name);\n+            if (p2 == null && f.isPreparing() && selector2.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                p2 = PropertyValues.newString(KNOWN_VALUE);\n+            }\n             if (p2 != null) {\n-                if (!p2.isArray()) {\n+                if (p2.isArray()) {\n                     // TODO support join on multi-valued properties\n-                    f.restrictProperty(property1Name, Operator.EQUAL, p2);\n+                    p2 = null;\n                 }\n             }\n+            // always set the condition, even if unkown ( -> is not null)\n+            f.restrictProperty(property1Name, Operator.EQUAL, p2);\n         }\n         if (f.getSelector() == selector2) {\n             PropertyValue p1 = selector1.currentProperty(property1Name);\n+            if (p1 == null && f.isPreparing() && selector1.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                p1 = PropertyValues.newString(KNOWN_VALUE);\n+            }\n             if (p1 != null) {\n-                if (!p1.isArray()) {\n+                if (p1.isArray()) {\n                     // TODO support join on multi-valued properties\n-                    f.restrictProperty(property2Name, Operator.EQUAL, p1);\n+                    p1 = null;\n                 }\n             }\n+            // always set the condition, even if unkown ( -> is not null)\n+            f.restrictProperty(property2Name, Operator.EQUAL, p1);\n         }\n     }\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinConditionImpl.java\nindex b3e2fd54d4..f5c82986d4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinConditionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinConditionImpl.java\n@@ -20,10 +20,35 @@\n  */\n public abstract class JoinConditionImpl extends AstElement {\n     \n+    /**\n+     * A path with 6 elements, which is the expected average for a join.\n+     */\n+    protected static final String KNOWN_PATH = \"/path/from/the/join/selector\";\n+\n+    protected static final String KNOWN_VALUE = \"valueFromTheJoinSelector\";\n+\n+    /**\n+     * Evaluate the result using the currently set values.\n+     * \n+     * @return true if the constraint matches\n+     */\n     public abstract boolean evaluate();\n     \n+    /**\n+     * Apply the condition to the filter, further restricting the filter if\n+     * possible. This may also verify the data types are compatible, and that\n+     * paths are valid.\n+     * \n+     * @param f the filter\n+     */\n     public abstract void restrict(FilterImpl f);\n \n-    public abstract void restrictPushDown(SelectorImpl selectorImpl);\n+    /**\n+     * Push as much of the condition down to this selector, further restricting\n+     * the selector condition if possible.\n+     * \n+     * @param s the selector\n+     */\n+    public abstract void restrictPushDown(SelectorImpl s);\n \n }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinImpl.java\nindex 6e4e408ea6..a5ab71f54d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinImpl.java\n@@ -60,8 +60,15 @@ boolean accept(AstVisitor v) {\n \n     @Override\n     public String getPlan(NodeState rootState) {\n-        return left.getPlan(rootState) + ' ' + joinType +\n-                \" \" + right.getPlan(rootState) + \" on \" + joinCondition;\n+        StringBuilder buff = new StringBuilder();\n+        buff.append(left.getPlan(rootState)).\n+            append(' ').\n+            append(joinType).\n+            append(' ').\n+            append(right.getPlan(rootState)).\n+            append(\" on \").\n+            append(joinCondition);\n+        return buff.toString();\n     }\n \n     @Override\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SameNodeJoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SameNodeJoinConditionImpl.java\nindex 187a795efb..7ab0cbee9b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SameNodeJoinConditionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SameNodeJoinConditionImpl.java\n@@ -81,6 +81,11 @@ public boolean evaluate() {\n     public void restrict(FilterImpl f) {\n         if (f.getSelector() == selector1) {\n             String p2 = selector2.currentPath();\n+            if (p2 == null && f.isPreparing() && selector2.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                p2 = KNOWN_PATH;\n+            }\n             if (p2 != null) {\n                 if (selector2Path.equals(\".\")) {\n                     f.restrictPath(p2, Filter.PathRestriction.EXACT);\n@@ -93,6 +98,11 @@ public void restrict(FilterImpl f) {\n         }\n         if (f.getSelector() == selector2) {\n             String p1 = selector1.currentPath();\n+            if (p1 == null && f.isPreparing() && selector1.isPrepared()) {\n+                // during the prepare phase, if the selector is already\n+                // prepared, then we would know the value\n+                p1 = KNOWN_PATH;\n+            }\n             if (p1 != null) {\n                 if (selector2Path.equals(\".\")) {\n                     f.restrictPath(p1, Filter.PathRestriction.EXACT);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\nindex ecf1e5b705..3e779ff094 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n@@ -95,6 +95,9 @@ public String toString() {\n         return quote(nodeTypeName) + \" as \" + quote(selectorName);\n     }\n \n+    public boolean isPrepared() {\n+        return index != null;\n+    }\n \n     @Override\n     public void prepare() {\n@@ -106,19 +109,19 @@ public void prepare() {\n                 c.restrictPushDown(this);\n             }\n         }\n-        index = query.getBestIndex(createFilter());\n+        index = query.getBestIndex(createFilter(true));\n     }\n \n     @Override\n     public void execute(NodeState rootState) {\n-        cursor = index.query(createFilter(), rootState);\n+        cursor = index.query(createFilter(false), rootState);\n     }\n \n     @Override\n     public String getPlan(NodeState rootState) {\n         StringBuilder buff = new StringBuilder();\n         buff.append(toString());\n-        buff.append(\" /* \").append(index.getPlan(createFilter(), rootState));\n+        buff.append(\" /* \").append(index.getPlan(createFilter(true), rootState));\n         if (selectorCondition != null) {\n             buff.append(\" where \").append(selectorCondition);\n         }\n@@ -126,8 +129,15 @@ public String getPlan(NodeState rootState) {\n         return buff.toString();\n     }\n \n-    private Filter createFilter() {\n+    /**\n+     * Create the filter condition for planning or execution.\n+     * \n+     * @param preparing whether a filter for the prepare phase should be made \n+     * @return the filter\n+     */\n+    private Filter createFilter(boolean preparing) {\n         FilterImpl f = new FilterImpl(this, query.getStatement());\n+        f.setPreparing(preparing);\n         validateNodeType(nodeTypeName);\n         f.setNodeType(nodeTypeName);\n         if (joinCondition != null) {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\nindex 9bf1ef2d6a..dc1d8e9f3f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\n@@ -141,8 +141,8 @@ public SelectorImpl getExistingSelector(String selectorName) {\n     public abstract String getPlan(NodeState rootState);\n \n     /**\n-     * Prepare executing the query. This method will decide which index to use.\n-     *\n+     * Prepare executing the query (recursively). This method will decide which\n+     * index to use.\n      */\n     public abstract void prepare();\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\nindex f540e187f0..767ea3e5ac 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n@@ -76,6 +76,11 @@\n      */\n     private boolean distinct;\n     \n+    /**\n+     * Set during the prepare phase of a query.\n+     */\n+    private boolean preparing;\n+\n     // TODO support \"order by\"\n \n     public FilterImpl(SelectorImpl selector, String queryStatement) {\n@@ -83,6 +88,14 @@ public FilterImpl(SelectorImpl selector, String queryStatement) {\n         this.queryStatement = queryStatement;\n     }\n     \n+    public void setPreparing(boolean preparing) {\n+        this.preparing = preparing;\n+    }\n+    \n+    public boolean isPreparing() {\n+        return preparing;\n+    }\n+\n     /**\n      * Get the path.\n      *\n",
        "project": "jackrabbit-oak",
        "linesAdd": 74,
        "jira_id": "579",
        "nb_skipped": 6,
        "commit": "7d72e6ed",
        "nb_failure": 0,
        "linesRem": 16,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 1776,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\nindex 2e32b74237..5d7b137e2a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n@@ -20,6 +20,7 @@\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n import java.util.concurrent.TimeUnit;\n@@ -53,7 +54,7 @@\n     private final Revision revision;\n     private HashMap<String, UpdateOp> operations = new LinkedHashMap<String, UpdateOp>();\n     private JsopWriter diff = new JsopStream();\n-    private List<Revision> collisions = new ArrayList<Revision>();\n+    private Set<Revision> collisions = new LinkedHashSet<Revision>();\n \n     /**\n      * List of all node paths which have been modified in this commit. In addition to the nodes\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 770cc9cc1d..8b4eb792fa 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -1210,7 +1210,7 @@ public DocumentNodeState getRoot() {\n     @Override\n     public NodeState merge(@Nonnull NodeBuilder builder,\n                            @Nonnull CommitHook commitHook,\n-                           @Nullable CommitInfo info)\n+                           @Nonnull CommitInfo info)\n             throws CommitFailedException {\n         return asDocumentRootBuilder(builder).merge(commitHook, info);\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 35a230685d..e685b36482 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -581,29 +581,45 @@ public String getCommitRootPath(Revision revision) {\n      * @return the revision, or null if deleted\n      */\n     @CheckForNull\n-    public Revision getNewestRevision(RevisionContext context,\n-                                      Revision changeRev,\n-                                      CollisionHandler handler) {\n-        // no need to look at all commits. the primary document\n-        // always contains at least one commit, including all\n-        // branch commits which are not yet merged\n+    public Revision getNewestRevision(final RevisionContext context,\n+                                      final Revision changeRev,\n+                                      final CollisionHandler handler) {\n+        final Map<Revision, String> validRevisions = Maps.newHashMap();\n+        Predicate<Revision> predicate = new Predicate<Revision>() {\n+            @Override\n+            public boolean apply(Revision input) {\n+                if (input.equals(changeRev)) {\n+                    return false;\n+                }\n+                if (isValidRevision(context, input, null, changeRev, validRevisions)) {\n+                    return true;\n+                }\n+                handler.concurrentModification(input);\n+                return false;\n+            }\n+        };\n+\n+        Revision newestRev = null;\n+        // check local commits first\n         SortedMap<Revision, String> revisions = getLocalRevisions();\n         SortedMap<Revision, String> commitRoots = getLocalCommitRoot();\n-        Revision newestRev = null;\n-        for (Revision r : Iterables.mergeSorted(\n+        Iterator<Revision> it = filter(Iterables.mergeSorted(\n                 Arrays.asList(revisions.keySet(), commitRoots.keySet()),\n-                revisions.comparator())) {\n-            if (!r.equals(changeRev)) {\n-                if (isValidRevision(context, r, null, changeRev, new HashMap<Revision, String>())) {\n-                    newestRev = r;\n-                    // found newest revision, no need to check more revisions\n-                    // revisions are sorted newest first\n-                    break;\n+                revisions.comparator()), predicate).iterator();\n+        if (it.hasNext()) {\n+            newestRev = it.next();\n         } else {\n-                    handler.concurrentModification(r);\n-                }\n+            // check full history (only needed in rare cases)\n+            it = filter(Iterables.mergeSorted(\n+                    Arrays.asList(\n+                            getValueMap(REVISIONS).keySet(),\n+                            getValueMap(COMMIT_ROOT).keySet()),\n+                    revisions.comparator()), predicate).iterator();\n+            if (it.hasNext()) {\n+                newestRev = it.next();\n             }\n         }\n+\n         if (newestRev == null) {\n             return null;\n         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 34,
        "jira_id": "1662",
        "nb_skipped": 8,
        "commit": "3efb5cbf",
        "nb_failure": 0,
        "linesRem": 14,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 395,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.OrderableNodesTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\nindex 79e0eb30a1..c84f6251e0 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n@@ -274,6 +274,10 @@ public Node perform() throws RepositoryException {\n                     throw new ItemExistsException();\n                 }\n \n+                if (getPrimaryNodeType().hasOrderableChildNodes()) {\n+                    dlg.orderBefore(oakName, null);\n+                }\n+\n                 NodeImpl<?> childNode = new NodeImpl<NodeDelegate>(added);\n                 childNode.internalSetPrimaryType(ntName);\n                 childNode.autoCreateItems();\n@@ -1431,6 +1435,18 @@ public Void perform() throws RepositoryException {\n                 String jcrPrimaryType = sessionDelegate.getOakPath(Property.JCR_PRIMARY_TYPE);\n                 Value value = sessionDelegate.getValueFactory().createValue(nodeTypeName, PropertyType.NAME);\n                 dlg.setProperty(jcrPrimaryType, value);\n+\n+                if (nt.hasOrderableChildNodes()) {\n+                    // freeze child order with a call to orderBefore()\n+                    // only makes sense with a least two child nodes\n+                    Iterator<NodeDelegate> children = dlg.getChildren();\n+                    NodeDelegate child1 = children.hasNext() ? children.next() : null;\n+                    NodeDelegate child2 = children.hasNext() ? children.next() : null;\n+                    if (child1 != null && child2 != null) {\n+                        dlg.orderBefore(child1.getName(), child2.getName());\n+                    }\n+                }\n+\n                 return null;\n             }\n         });\n",
        "project": "jackrabbit-oak",
        "linesAdd": 14,
        "jira_id": "612",
        "nb_skipped": 1,
        "commit": "df9e6913",
        "nb_failure": 4,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1901,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.IndexUpdateTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\nindex f68c213a4d..47cdfd18fc 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\n@@ -45,6 +45,7 @@\n import org.apache.jackrabbit.oak.spi.commit.Editor;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n+import org.apache.jackrabbit.oak.spi.state.NodeStateUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -170,8 +171,10 @@ private void collectIndexEditors(NodeBuilder definitions,\n                         // as we don't know the index content node name\n                         // beforehand, we'll remove all child nodes\n                         for (String rm : definition.getChildNodeNames()) {\n+                            if (NodeStateUtils.isHidden(rm)) {\n                                 definition.getChildNode(rm).remove();\n                             }\n+                        }\n                         reindex.put(concat(getPath(), INDEX_DEFINITIONS_NAME, name), editor);\n                     }\n                 } else {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "2117",
        "nb_skipped": 9,
        "commit": "c7669f31",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2029,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.authorization.AuthorizationContextTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/AuthorizationContext.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/AuthorizationContext.java\nindex 953d00b7ee..49bfe472c1 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/AuthorizationContext.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/AuthorizationContext.java\n@@ -47,7 +47,11 @@ public boolean definesProperty(@Nonnull Tree parent, @Nonnull PropertyState prop\n     @Override\n     public boolean definesContextRoot(@Nonnull Tree tree) {\n         String name = tree.getName();\n-        return POLICY_NODE_NAMES.contains(name) || REP_PERMISSION_STORE.equals(name);\n+        if (POLICY_NODE_NAMES.contains(name)) {\n+            return NT_REP_ACL.equals(TreeUtil.getPrimaryTypeName(tree));\n+        } else {\n+            return REP_PERMISSION_STORE.equals(name);\n+        }\n     }\n \n     @Override\n",
        "project": "jackrabbit-oak",
        "linesAdd": 5,
        "jira_id": "2740",
        "nb_skipped": 9,
        "commit": "429baf4d",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 203,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.core.RootImplTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/RootImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/RootImpl.java\nindex abda5d2690..a86895939a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/RootImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/RootImpl.java\n@@ -225,9 +225,7 @@ void purge() {\n      * All registered {@link PurgeListener}s are notified.\n      */\n     private void purgePendingChanges() {\n-        if (hasPendingChanges()) {\n         branch.setRoot(rootTree.getNodeState());\n-        }\n         notifyListeners();\n     }\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeStoreBranch.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeStoreBranch.java\nindex 79ffaffb1a..63b1ec553d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeStoreBranch.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeStoreBranch.java\n@@ -80,9 +80,11 @@ public NodeState getBase() {\n \n     @Override\n     public void setRoot(NodeState newRoot) {\n+        if (!currentRoot.equals(newRoot)) {\n             currentRoot = newRoot;\n             commit(buildJsop());\n         }\n+    }\n \n     @Override\n     public boolean move(String source, String target) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "208",
        "nb_skipped": 0,
        "commit": "daf9a4ef",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 141,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.segment.CheckpointTest"
        ],
        "patch": "diff --git a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentNodeStore.java b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentNodeStore.java\nindex 61d16aa9f7..af2ade62f6 100644\n--- a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentNodeStore.java\n+++ b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/SegmentNodeStore.java\n@@ -404,7 +404,11 @@ public Boolean call() {\n             }\n \n             NodeBuilder cp = checkpoints.child(name);\n+            if (Long.MAX_VALUE - now > lifetime) {\n                 cp.setProperty(\"timestamp\", now + lifetime);\n+            } else {\n+                cp.setProperty(\"timestamp\", Long.MAX_VALUE);\n+            }\n             cp.setProperty(\"created\", now);\n \n             NodeBuilder props = cp.setChildNode(\"properties\");\n",
        "project": "jackrabbit-oak",
        "linesAdd": 4,
        "jira_id": "4423",
        "nb_skipped": 1,
        "commit": "08f0b280",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2215,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollectorTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitDocumentCleanUp.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitDocumentCleanUp.java\nindex 081a422bea..7cdaebc660 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitDocumentCleanUp.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitDocumentCleanUp.java\n@@ -79,14 +79,16 @@ private void disconnect(NodeDocument splitDoc) {\n                     mainId, splitId);\n             return;\n         }\n-        int slashIdx = splitId.lastIndexOf('/');\n-        int height = Integer.parseInt(splitId.substring(slashIdx + 1));\n+        \n+        String splitDocPath = splitDoc.getPath();\n+        int slashIdx = splitDocPath.lastIndexOf('/');\n+        int height = Integer.parseInt(splitDocPath.substring(slashIdx + 1));\n         Revision rev = Revision.fromString(\n-                splitId.substring(splitId.lastIndexOf('/', slashIdx - 1) + 1, slashIdx));\n+                splitDocPath.substring(splitDocPath.lastIndexOf('/', slashIdx - 1) + 1, slashIdx));\n         doc = doc.findPrevReferencingDoc(rev, height);\n         if (doc == null) {\n-            LOG.warn(\"Split document {} not referenced anymore. Main document is {}\",\n-                    splitId, mainId);\n+            LOG.warn(\"Split document {} for path {} not referenced anymore. Main document is {}\",\n+                    splitId, splitDocPath, mainId);\n             return;\n         }\n         // remove reference\n",
        "project": "jackrabbit-oak",
        "linesAdd": 7,
        "jira_id": "3099",
        "nb_skipped": 1,
        "commit": "25850476",
        "nb_failure": 0,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2009,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.VersionGCDeletionTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 03dd859ef6..fe60e13b92 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -18,6 +18,7 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.collect.Iterables.filter;\n import static com.google.common.collect.Iterables.toArray;\n import static com.google.common.collect.Iterables.transform;\n import static org.apache.jackrabbit.oak.api.CommitFailedException.MERGE;\n@@ -27,6 +28,7 @@\n import static org.apache.jackrabbit.oak.plugins.document.DocumentMK.MANY_CHILDREN_THRESHOLD;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation;\n+import static org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath;\n import static org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString;\n \n import java.io.Closeable;\n@@ -60,6 +62,7 @@\n import javax.management.NotCompliantMBeanException;\n \n import com.google.common.base.Function;\n+import com.google.common.base.Predicates;\n import com.google.common.cache.Cache;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n@@ -866,11 +869,11 @@ public DocumentNodeState call() throws Exception {\n      * @return the child documents.\n      */\n     @Nonnull\n-    Iterable<NodeDocument> readChildDocs(@Nonnull final String path,\n+    private Iterable<NodeDocument> readChildDocs(@Nonnull final String path,\n                                                  @Nullable String name,\n-                                         int limit) {\n-        String to = Utils.getKeyUpperLimit(checkNotNull(path));\n-        String from;\n+                                                 final int limit) {\n+        final String to = Utils.getKeyUpperLimit(checkNotNull(path));\n+        final String from;\n         if (name != null) {\n             from = Utils.getIdFromPath(concat(path, name));\n         } else {\n@@ -881,7 +884,7 @@ public DocumentNodeState call() throws Exception {\n             // or more than 16k child docs are requested\n             return store.query(Collection.NODES, from, to, limit);\n         }\n-        StringValue key = new StringValue(path);\n+        final StringValue key = new StringValue(path);\n         // check cache\n         NodeDocument.Children c = docChildrenCache.getIfPresent(key);\n         if (c == null) {\n@@ -898,10 +901,10 @@ public DocumentNodeState call() throws Exception {\n             // fetch more and update cache\n             String lastName = c.childNames.get(c.childNames.size() - 1);\n             String lastPath = concat(path, lastName);\n-            from = Utils.getIdFromPath(lastPath);\n+            String low = Utils.getIdFromPath(lastPath);\n             int remainingLimit = limit - c.childNames.size();\n             List<NodeDocument> docs = store.query(Collection.NODES,\n-                    from, to, remainingLimit);\n+                    low, to, remainingLimit);\n             NodeDocument.Children clone = c.clone();\n             for (NodeDocument doc : docs) {\n                 String p = doc.getPath();\n@@ -911,22 +914,36 @@ public DocumentNodeState call() throws Exception {\n             docChildrenCache.put(key, clone);\n             c = clone;\n         }\n-        Iterable<NodeDocument> it = transform(c.childNames, new Function<String, NodeDocument>() {\n+        Iterable<NodeDocument> head = filter(transform(c.childNames,\n+                new Function<String, NodeDocument>() {\n             @Override\n             public NodeDocument apply(String name) {\n                 String p = concat(path, name);\n                 NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath(p));\n                 if (doc == null) {\n-                    docChildrenCache.invalidateAll();\n-                    throw new NullPointerException(\"Document \" + p + \" not found\");\n+                    docChildrenCache.invalidate(key);\n                 }\n                 return doc;\n             }\n-        });\n-        if (c.childNames.size() > limit * 2) {\n-            it = Iterables.limit(it, limit * 2);\n+        }), Predicates.notNull());\n+        Iterable<NodeDocument> it;\n+        if (c.isComplete) {\n+            it = head;\n+        } else {\n+            // OAK-2420: 'head' may have null documents when documents are\n+            // concurrently removed from the store. concat 'tail' to fetch\n+            // more documents if necessary\n+            final String last = getIdFromPath(concat(\n+                    path, c.childNames.get(c.childNames.size() - 1)));\n+            Iterable<NodeDocument> tail = new Iterable<NodeDocument>() {\n+                @Override\n+                public Iterator<NodeDocument> iterator() {\n+                    return store.query(NODES, last, to, limit).iterator();\n+                }\n+            };\n+            it = Iterables.concat(head, tail);\n         }\n-        return it;\n+        return Iterables.limit(it, limit);\n     }\n \n     /**\n",
        "project": "jackrabbit-oak",
        "linesAdd": 28,
        "jira_id": "2420",
        "nb_skipped": 9,
        "commit": "24cb1908",
        "nb_failure": 0,
        "linesRem": 14,
        "singleLine": false
    },
    {
        "files": 4,
        "nb_test": 1866,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 043339237e..b49f72ef81 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -1205,7 +1205,7 @@ public static void setChildrenFlag(@Nonnull UpdateOp op,\n \n     public static void setModified(@Nonnull UpdateOp op,\n                                    @Nonnull Revision revision) {\n-        checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\n+        checkNotNull(op).max(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\n     }\n \n     public static void setRevision(@Nonnull UpdateOp op,\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\nindex 56b0698468..0517fe1cc7 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n@@ -131,9 +131,7 @@ public boolean hasChanges() {\n      * @param value the value\n      */\n     void setMapEntry(@Nonnull String property, @Nonnull Revision revision, Object value) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.SET_MAP_ENTRY;\n-        op.value = value;\n+        Operation op = new Operation(Operation.Type.SET_MAP_ENTRY, value);\n         changes.put(new Key(property, checkNotNull(revision)), op);\n     }\n \n@@ -145,8 +143,7 @@ void setMapEntry(@Nonnull String property, @Nonnull Revision revision, Object va\n      * @param revision the revision\n      */\n     public void removeMapEntry(@Nonnull String property, @Nonnull Revision revision) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.REMOVE_MAP_ENTRY;\n+        Operation op = new Operation(Operation.Type.REMOVE_MAP_ENTRY, null);\n         changes.put(new Key(property, checkNotNull(revision)), op);\n     }\n \n@@ -157,9 +154,23 @@ public void removeMapEntry(@Nonnull String property, @Nonnull Revision revision)\n      * @param value the value\n      */\n     void set(String property, Object value) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.SET;\n-        op.value = value;\n+        Operation op = new Operation(Operation.Type.SET, value);\n+        changes.put(new Key(property, null), op);\n+    }\n+\n+    /**\n+     * Set the property to the given value if the new value is higher than the\n+     * existing value. The property is also set to the given value if the\n+     * property does not yet exist.\n+     * <p>\n+     * The result of a max operation with different types of values is\n+     * undefined.\n+     *\n+     * @param property the name of the property to set.\n+     * @param value the new value for the property.\n+     */\n+    <T> void max(String property, Comparable<T> value) {\n+        Operation op = new Operation(Operation.Type.MAX, value);\n         changes.put(new Key(property, null), op);\n     }\n \n@@ -187,9 +198,7 @@ void containsMapEntry(@Nonnull String property,\n         if (isNew) {\n             throw new IllegalStateException(\"Cannot use containsMapEntry() on new document\");\n         }\n-        Operation op = new Operation();\n-        op.type = Operation.Type.CONTAINS_MAP_ENTRY;\n-        op.value = exists;\n+        Operation op = new Operation(Operation.Type.CONTAINS_MAP_ENTRY, exists);\n         changes.put(new Key(property, checkNotNull(revision)), op);\n     }\n \n@@ -200,9 +209,7 @@ void containsMapEntry(@Nonnull String property,\n      * @param value the increment\n      */\n     public void increment(@Nonnull String property, long value) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.INCREMENT;\n-        op.value = value;\n+        Operation op = new Operation(Operation.Type.INCREMENT, value);\n         changes.put(new Key(property, null), op);\n     }\n \n@@ -238,6 +245,14 @@ public String toString() {\n              */\n             SET,\n \n+            /**\n+             * Set the value if the new value is higher than the existing value.\n+             * The new value is also considered higher, when there is no\n+             * existing value.\n+             * The sub-key is not used.\n+             */\n+            MAX,\n+\n             /**\n              * Increment the Long value with the provided Long value.\n              * The sub-key is not used.\n@@ -267,12 +282,17 @@ public String toString() {\n         /**\n          * The operation type.\n          */\n-        public Type type;\n+        public final Type type;\n \n         /**\n          * The value, if any.\n          */\n-        public Object value;\n+        public final Object value;\n+\n+        Operation(Type type, Object value) {\n+            this.type = checkNotNull(type);\n+            this.value = value;\n+        }\n \n         @Override\n         public String toString() {\n@@ -283,18 +303,16 @@ public Operation getReverse() {\n             Operation reverse = null;\n             switch (type) {\n             case INCREMENT:\n-                reverse = new Operation();\n-                reverse.type = Type.INCREMENT;\n-                reverse.value = -(Long) value;\n+                reverse = new Operation(Type.INCREMENT, -(Long) value);\n                 break;\n             case SET:\n+            case MAX:\n             case REMOVE_MAP_ENTRY:\n             case CONTAINS_MAP_ENTRY:\n                 // nothing to do\n                 break;\n             case SET_MAP_ENTRY:\n-                reverse = new Operation();\n-                reverse.type = Type.REMOVE_MAP_ENTRY;\n+                reverse = new Operation(Type.REMOVE_MAP_ENTRY, null);\n                 break;\n             }\n             return reverse;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java\nindex b8015ff100..240665d422 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java\n@@ -44,7 +44,9 @@\n      * @param comparator\n      *            the revision comparator.\n      */\n-    public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {\n+    public static void applyChanges(@Nonnull Document doc,\n+                                    @Nonnull UpdateOp update,\n+                                    @Nonnull Comparator<Revision> comparator) {\n         for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {\n             Key k = e.getKey();\n             Operation op = e.getValue();\n@@ -53,6 +55,15 @@ public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update,\n                     doc.put(k.toString(), op.value);\n                     break;\n                 }\n+                case MAX: {\n+                    Comparable newValue = (Comparable) op.value;\n+                    Object old = doc.get(k.toString());\n+                    //noinspection unchecked\n+                    if (old == null || newValue.compareTo(old) > 0) {\n+                        doc.put(k.toString(), op.value);\n+                    }\n+                    break;\n+                }\n                 case INCREMENT: {\n                     Object old = doc.get(k.toString());\n                     Long x = (Long) op.value;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\nindex 0266e388a1..99db8d134c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\n@@ -570,6 +570,7 @@ public NodeDocument call() throws Exception {\n                 Operation op = entry.getValue();\n                 switch (op.type) {\n                     case SET:\n+                    case MAX:\n                     case INCREMENT: {\n                         inserts[i].put(k.toString(), op.value);\n                         break;\n@@ -965,6 +966,7 @@ private static QueryBuilder createQueryForUpdate(UpdateOp updateOp,\n     @Nonnull\n     private static DBObject createUpdate(UpdateOp updateOp) {\n         BasicDBObject setUpdates = new BasicDBObject();\n+        BasicDBObject maxUpdates = new BasicDBObject();\n         BasicDBObject incUpdates = new BasicDBObject();\n         BasicDBObject unsetUpdates = new BasicDBObject();\n \n@@ -980,16 +982,17 @@ private static DBObject createUpdate(UpdateOp updateOp) {\n             }\n             Operation op = entry.getValue();\n             switch (op.type) {\n-                case SET: {\n+                case SET:\n+                case SET_MAP_ENTRY: {\n                     setUpdates.append(k.toString(), op.value);\n                     break;\n                 }\n-                case INCREMENT: {\n-                    incUpdates.append(k.toString(), op.value);\n+                case MAX: {\n+                    maxUpdates.append(k.toString(), op.value);\n                     break;\n                 }\n-                case SET_MAP_ENTRY: {\n-                    setUpdates.append(k.toString(), op.value);\n+                case INCREMENT: {\n+                    incUpdates.append(k.toString(), op.value);\n                     break;\n                 }\n                 case REMOVE_MAP_ENTRY: {\n@@ -1003,6 +1006,9 @@ private static DBObject createUpdate(UpdateOp updateOp) {\n         if (!setUpdates.isEmpty()) {\n             update.append(\"$set\", setUpdates);\n         }\n+        if (!maxUpdates.isEmpty()) {\n+            update.append(\"$max\", maxUpdates);\n+        }\n         if (!incUpdates.isEmpty()) {\n             update.append(\"$inc\", incUpdates);\n         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 45,
        "jira_id": "1822",
        "nb_skipped": 9,
        "commit": "016df669",
        "nb_failure": 1,
        "linesRem": 28,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 13,
        "nb_error": 1,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.solr.query.SolrIndexQueryTest"
        ],
        "patch": "diff --git a/oak-solr-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/solr/index/SolrIndexUpdate.java b/oak-solr-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/solr/index/SolrIndexUpdate.java\nindex 3cdc05cf5b..45cc00d3ad 100644\n--- a/oak-solr-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/solr/index/SolrIndexUpdate.java\n+++ b/oak-solr-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/solr/index/SolrIndexUpdate.java\n@@ -152,6 +152,7 @@ private void deleteSubtreeWriter(SolrServer solrServer, String path)\n         if (!path.startsWith(\"/\")) {\n             path = \"/\" + path;\n         }\n+        path = path.replace(\"/\", \"\\\\/\");\n         solrServer.deleteByQuery(new StringBuilder(configuration.getPathField())\n                 .append(':').append(path).append(\"*\").toString());\n     }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "740",
        "nb_skipped": 1,
        "commit": "35a7f014",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": true,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 399,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.NodeStateAnalyzerFactoryTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/NodeStateAnalyzerFactory.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/NodeStateAnalyzerFactory.java\nindex dce4d4f8f5..589fc63163 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/NodeStateAnalyzerFactory.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/NodeStateAnalyzerFactory.java\n@@ -32,6 +32,7 @@\n \n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Maps;\n+import org.apache.jackrabbit.JcrConstants;\n import org.apache.jackrabbit.oak.api.Blob;\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Tree;\n@@ -67,7 +68,11 @@\n final class NodeStateAnalyzerFactory{\n     private static final AtomicBoolean versionWarningAlreadyLogged = new AtomicBoolean(false);\n \n-    private static final Set<String> IGNORE_PROP_NAMES = ImmutableSet.of(LuceneIndexConstants.ANL_CLASS, LuceneIndexConstants.ANL_NAME);\n+    private static final Set<String> IGNORE_PROP_NAMES = ImmutableSet.of(\n+            LuceneIndexConstants.ANL_CLASS,\n+            LuceneIndexConstants.ANL_NAME,\n+            JcrConstants.JCR_PRIMARYTYPE\n+    );\n \n     private static final Logger log = LoggerFactory.getLogger(NodeStateAnalyzerFactory.class);\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 6,
        "jira_id": "2524",
        "nb_skipped": 2,
        "commit": "977a31d8",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 260,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\nindex 6c2bfcc252..3107e21daf 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\n@@ -26,6 +26,7 @@\n \n import java.io.File;\n import java.io.IOException;\n+import java.util.Calendar;\n import java.util.Set;\n \n import javax.jcr.PropertyType;\n@@ -35,6 +36,7 @@\n import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.plugins.index.IndexUpdateCallback;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n+import org.apache.jackrabbit.util.ISO8601;\n import org.apache.lucene.analysis.Analyzer;\n import org.apache.lucene.index.IndexWriter;\n import org.apache.lucene.index.IndexWriterConfig;\n@@ -165,6 +167,13 @@ IndexWriter getWriter() throws IOException {\n     void closeWriter() throws IOException {\n         if (writer != null) {\n             writer.close();\n+\n+            //OAK-2029 Record the last updated status so\n+            //as to make IndexTracker detect changes when index\n+            //is stored in file system\n+            NodeBuilder status = definition.child(\":status\");\n+            status.setProperty(\"lastUpdated\", ISO8601.format(Calendar.getInstance()), Type.DATE);\n+            status.setProperty(\"indexedNodes\",indexedNodes);\n         }\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 6,
        "jira_id": "2029",
        "nb_skipped": 0,
        "commit": "e30023ba",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 380,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\nindex d35915cdc2..7b0934e66c 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n@@ -724,16 +724,8 @@ public boolean visit(FullTextAnd and) {\n                 BooleanQuery q = new BooleanQuery();\n                 for (FullTextExpression e : and.list) {\n                     Query x = getFullTextQuery(e, analyzer, reader);\n-                    // Lucene can't deal with \"must(must_not(x))\"\n-                    if (x instanceof BooleanQuery) {\n-                        BooleanQuery bq = (BooleanQuery) x;\n-                        for (BooleanClause c : bq.clauses()) {\n-                            q.add(c);\n-                        }\n-                    } else {\n                     q.add(x, MUST);\n                 }\n-                }\n                 result.set(q);\n                 return true;\n             }\ndiff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\nindex 136f973f6b..e0bbf7905c 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n@@ -836,16 +836,8 @@ public boolean visit(FullTextAnd and) {\n                 BooleanQuery q = new BooleanQuery();\n                 for (FullTextExpression e : and.list) {\n                     Query x = getFullTextQuery(plan, e, analyzer);\n-                    // Lucene can't deal with \"must(must_not(x))\"\n-                    if (x instanceof BooleanQuery) {\n-                        BooleanQuery bq = (BooleanQuery) x;\n-                        for (BooleanClause c : bq.clauses()) {\n-                            q.add(c);\n-                        }\n-                    } else {\n                     q.add(x, MUST);\n                 }\n-                }\n                 result.set(q);\n                 return true;\n             }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 0,
        "jira_id": "2434",
        "nb_skipped": 2,
        "commit": "8159fc21",
        "nb_failure": 2,
        "linesRem": 14,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2651,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex f78ffed58d..b1b7de79bd 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -966,8 +966,7 @@ public DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore,\n \n             // check if there may be more recent values in a previous document\n             if (!getPreviousRanges().isEmpty()) {\n-                Revision newest = local.firstKey();\n-                if (isRevisionNewer(nodeStore, newest, value.revision)) {\n+                if (!isMostRecentCommitted(nodeStore, local, value.revision)) {\n                     // not reading the most recent value, we may need to\n                     // consider previous documents as well\n                     Revision newestPrev = getPreviousRanges().firstKey();\n@@ -1708,6 +1707,39 @@ public static void setHasBinary(@Nonnull UpdateOp op) {\n \n     //----------------------------< internal >----------------------------------\n \n+    /**\n+     * Returns {@code true} if the given {@code revision} is more recent or\n+     * equal to the committed revision in {@code valueMap}. This method assumes\n+     * the given {@code revision} is committed.\n+     *\n+     * @param context the revision context.\n+     * @param valueMap the value map sorted most recent first.\n+     * @param revision a committed revision.\n+     * @return if {@code revision} is the most recent committed revision in the\n+     *          {@code valueMap}.\n+     */\n+    private boolean isMostRecentCommitted(RevisionContext context,\n+                                          SortedMap<Revision, String> valueMap,\n+                                          Revision revision) {\n+        if (valueMap.isEmpty()) {\n+            return true;\n+        }\n+        // shortcut when revision is the first key\n+        Revision first = valueMap.firstKey();\n+        if (!isRevisionNewer(context, first, revision)) {\n+            return true;\n+        }\n+        // need to check commit status\n+        for (Revision r : valueMap.keySet()) {\n+            Revision c = getCommitRevision(r);\n+            if (c != null) {\n+                return !isRevisionNewer(context, c, revision);\n+            }\n+        }\n+        // no committed revision found in valueMap\n+        return true;\n+    }\n+\n     /**\n      * Returns {@code true} if the two revisions are ambiguous. That is, they\n      * are from different cluster nodes and the comparison of the two revision\n",
        "project": "jackrabbit-oak",
        "linesAdd": 20,
        "jira_id": "3474",
        "nb_skipped": 1,
        "commit": "ff81ef72",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2029,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 95a82d5a8d..29a363e47c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -1532,6 +1532,13 @@ void backgroundRead(boolean dispatchChange) {\n             Revision last = lastKnownRevision.get(machineId);\n             if (last == null || r.compareRevisionTime(last) > 0) {\n                 lastKnownRevision.put(machineId, r);\n+                // OAK-2345\n+                // only consider as external change if\n+                // - the revision changed for the machineId\n+                // or\n+                // - the revision is within the time frame we remember revisions\n+                if (last != null\n+                        || r.getTimestamp() > revisionPurgeMillis())\n                 externalChanges.put(r, otherSeen);\n             }\n         }\n@@ -1562,7 +1569,17 @@ void backgroundRead(boolean dispatchChange) {\n                 backgroundOperationLock.writeLock().unlock();\n             }\n         }\n-        revisionComparator.purge(Revision.getCurrentTimestamp() - REMEMBER_REVISION_ORDER_MILLIS);\n+        revisionComparator.purge(revisionPurgeMillis());\n+    }\n+\n+    /**\n+     * Returns the time in milliseconds when revisions can be purged from the\n+     * revision comparator.\n+     *\n+     * @return time in milliseconds.\n+     */\n+    private static long revisionPurgeMillis() {\n+        return Revision.getCurrentTimestamp() - REMEMBER_REVISION_ORDER_MILLIS;\n     }\n \n     private void backgroundSplit() {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 7,
        "jira_id": "2345",
        "nb_skipped": 9,
        "commit": "a0dc4c89",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1805,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.RevisionTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\nindex 9265368c42..be45ba33b3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n@@ -549,6 +549,9 @@ public int compare(Revision o1, Revision o2) {\n          * <ul>\n          *     <li>\n          *         {@code null} if the revision is older than the earliest range\n+         *         and the revision timestamp is less than or equal the time\n+         *         of the last {@link #purge(long)} (see also\n+         *         {@link #oldestTimestamp}).\n          *     </li>\n          *     <li>\n          *         if the revision is newer than the lower bound of the newest\n@@ -565,9 +568,49 @@ public int compare(Revision o1, Revision o2) {\n          *     </li>\n          * </ul>\n          *\n+         * Below is a graph for a revision comparison example as seen from one\n+         * cluster node with some known revision ranges. Revision ranges less\n+         * than or equal r2-0-0 have been purged and there are known ranges for\n+         * cluster node 1 (this cluster node) and cluster node 2 (some other\n+         * cluster node).\n+         * <pre>\n+         *     View from cluster node 1:\n+         *\n+         *                purge    r3-0-1    r5-0-2    r7-0-1\n+         *                  \u02c5         \u02c5         \u02c5         \u02c5\n+         *     ---+---------+---------+---------+---------+---------\n+         *     r1-0-0    r2-0-0    r3-0-0    r4-0-0    r5-0-0\n+         *\n+         *            ^\n+         *         r1-0-1 -> null (1)\n+         *\n+         *                      ^\n+         *                   r4-0-2 -> r4-0-0 (2)\n+         *\n+         *                            ^\n+         *                         r3-0-1 -> r3-0-0 (3)\n+         *\n+         *                                           ^\n+         *                                        r6-0-2 -> FUTURE (4)\n+         *\n+         *                                                       ^\n+         *                                                    r9-0-1 -> NEWEST (5)\n+         * </pre>\n+         * <ol>\n+         *     <li>older than earliest range and purge time</li>\n+         *     <li>seen-at of next higher range</li>\n+         *     <li>seen-at of matching lower bound of range</li>\n+         *     <li>foreign revision is newer than most recent range</li>\n+         *     <li>local revision is newer than most recent range</li>\n+         * </ol>\n+         * This gives the following revision ordering:\n+         * <pre>\n+         * r1-0-1 < r3-0-1 < r-4-0-2 < r9-0-1 < r6-0-2\n+         * </pre>\n+         *\n          * @param r the revision\n          * @return the seen-at revision or {@code null} if the revision is older\n-         *          than the earliest range.\n+         *          than the earliest range and purge time.\n          */\n         Revision getRevisionSeen(Revision r) {\n             List<RevisionRange> list = map.get(r.getClusterId());\n@@ -586,8 +629,9 @@ Revision getRevisionSeen(Revision r) {\n             // search from latest backward\n             // (binary search could be used, but we expect most queries\n             // at the end of the list)\n+            RevisionRange range = null;\n             for (int i = list.size() - 1; i >= 0; i--) {\n-                RevisionRange range = list.get(i);\n+                range = list.get(i);\n                 int compare = r.compareRevisionTime(range.revision);\n                 if (compare == 0) {\n                     return range.seenAt;\n@@ -597,15 +641,21 @@ Revision getRevisionSeen(Revision r) {\n                         if (r.getClusterId() == currentClusterNodeId) {\n                             // newer than all others, except for FUTURE\n                             return NEWEST;\n-                        }\n+                        } else {\n                             // happens in the future (not visible yet)\n                             return FUTURE;\n+                        }\n                     } else {\n                         // there is a newer range\n                         return list.get(i + 1).seenAt;\n                     }\n                 }\n             }\n+            if (range != null && r.getTimestamp() > oldestTimestamp) {\n+                // revision is older than earliest range and after purge\n+                // timestamp. return seen-at revision of earliest range.\n+                return range.seenAt;\n+            }\n             return null;\n         }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 7,
        "jira_id": "1788",
        "nb_skipped": 9,
        "commit": "dd3437d4",
        "nb_failure": 3,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2427,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 2317b57aea..1004e0661c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -37,6 +37,7 @@\n import com.google.common.base.Function;\n import com.google.common.base.Predicate;\n import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterators;\n import com.google.common.collect.Queues;\n import org.apache.jackrabbit.oak.cache.CacheValue;\n@@ -57,7 +58,6 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.collect.Iterables.filter;\n import static com.google.common.collect.Iterables.transform;\n-import static java.util.Collections.reverseOrder;\n import static org.apache.jackrabbit.oak.plugins.document.Collection.NODES;\n import static org.apache.jackrabbit.oak.plugins.document.StableRevisionComparator.REVERSE;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key;\n@@ -737,11 +737,11 @@ public boolean apply(Revision input) {\n \n         Revision newestRev = null;\n         // check local commits first\n-        Comparator<Revision> comp = reverseOrder(context.getRevisionComparator());\n-        SortedSet<Revision> revisions = Sets.newTreeSet(comp);\n-        revisions.addAll(getLocalRevisions().keySet());\n-        revisions.addAll(getLocalCommitRoot().keySet());\n-        Iterator<Revision> it = filter(revisions, predicate).iterator();\n+        SortedMap<Revision, String> revisions = getLocalRevisions();\n+        SortedMap<Revision, String> commitRoots = getLocalCommitRoot();\n+        Iterator<Revision> it = filter(Iterables.mergeSorted(\n+                ImmutableList.of(revisions.keySet(), commitRoots.keySet()),\n+                revisions.comparator()), predicate).iterator();\n         if (it.hasNext()) {\n             newestRev = it.next();\n         } else {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 6,
        "jira_id": "3411",
        "nb_skipped": 1,
        "commit": "978c77ff",
        "nb_failure": 0,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 194,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.RepositoryTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\nindex 90b9c74ee5..fbdc48d9c9 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n@@ -16,8 +16,6 @@\n  */\n package org.apache.jackrabbit.oak.jcr;\n \n-import static org.apache.jackrabbit.oak.util.Iterators.filter;\n-\n import java.io.InputStream;\n import java.math.BigDecimal;\n import java.util.ArrayList;\n@@ -70,6 +68,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.jackrabbit.oak.util.Iterators.filter;\n+\n /**\n  * {@code NodeImpl}...\n  */\n@@ -441,7 +441,8 @@ public NodeIterator getNodes() throws RepositoryException {\n         checkStatus();\n \n         Iterator<NodeDelegate> children = dlg.getChildren();\n-        return new NodeIteratorAdapter(nodeIterator(children));\n+        long size = dlg.getChildCount();\n+        return new NodeIteratorAdapter(nodeIterator(children), size);\n     }\n \n     @Override\n@@ -505,7 +506,8 @@ public PropertyIterator getProperties() throws RepositoryException {\n         checkStatus();\n \n         Iterator<PropertyDelegate> properties = dlg.getProperties();\n-        return new PropertyIteratorAdapter(propertyIterator(properties));\n+        long size = dlg.getPropertyCount();\n+        return new PropertyIteratorAdapter(propertyIterator(properties), size);\n     }\n \n     @Override\n",
        "project": "jackrabbit-oak",
        "linesAdd": 6,
        "jira_id": "135",
        "nb_skipped": 1,
        "commit": "438e31a7",
        "nb_failure": 2,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1413,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.version.VersionableTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\nindex 71f12f9700..07e0ae3f8e 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\n@@ -1424,6 +1424,14 @@ private Property internalRemoveProperty(final String jcrName)\n             throws RepositoryException {\n         final String oakName = getOakName(checkNotNull(jcrName));\n         return perform(new ItemWriteOperation<Property>(\"internalRemoveProperty\") {\n+            @Override\n+            public void checkPreconditions() throws RepositoryException {\n+                super.checkPreconditions();\n+                if (!isCheckedOut()) {\n+                    throw new VersionException(\n+                            \"Cannot remove property. Node is checked in.\");\n+                }\n+            }\n             @Nonnull\n             @Override\n             public Property perform() throws RepositoryException {\ndiff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/PropertyImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/PropertyImpl.java\nindex 52ca344abd..7a54197682 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/PropertyImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/PropertyImpl.java\n@@ -37,6 +37,7 @@\n import javax.jcr.ValueFactory;\n import javax.jcr.ValueFormatException;\n import javax.jcr.nodetype.PropertyDefinition;\n+import javax.jcr.version.VersionException;\n \n import org.apache.jackrabbit.oak.api.Tree.Status;\n import org.apache.jackrabbit.oak.api.Type;\n@@ -109,6 +110,15 @@ public Boolean perform() {\n     @Override\n     public void remove() throws RepositoryException {\n         sessionDelegate.performVoid(new ItemWriteOperation(\"remove\") {\n+            @Override\n+            public void checkPreconditions() throws RepositoryException {\n+                super.checkPreconditions();\n+                if (!getParent().isCheckedOut()) {\n+                    throw new VersionException(\n+                            \"Cannot set property. Node is checked in.\");\n+                }\n+            }\n+\n             @Override\n             public void performVoid() {\n                 dlg.remove();\n@@ -450,6 +460,15 @@ private static long getLength(Value value) throws RepositoryException {\n     private void internalSetValue(@Nonnull final Value value)\n             throws RepositoryException {\n         sessionDelegate.performVoid(new ItemWriteOperation(\"internalSetValue\") {\n+            @Override\n+            public void checkPreconditions() throws RepositoryException {\n+                super.checkPreconditions();\n+                if (!getParent().isCheckedOut()) {\n+                    throw new VersionException(\n+                            \"Cannot set property. Node is checked in.\");\n+                }\n+            }\n+\n             @Override\n             public void performVoid() throws RepositoryException {\n                 Type<?> type = dlg.getPropertyState().getType();\n@@ -477,6 +496,15 @@ private void internalSetValue(@Nonnull final Value[] values)\n         }\n \n         sessionDelegate.performVoid(new ItemWriteOperation(\"internalSetValue\") {\n+            @Override\n+            public void checkPreconditions() throws RepositoryException {\n+                super.checkPreconditions();\n+                if (!getParent().isCheckedOut()) {\n+                    throw new VersionException(\n+                            \"Cannot set property. Node is checked in.\");\n+                }\n+            }\n+\n             @Override\n             public void performVoid() throws RepositoryException {\n                 Type<?> type = dlg.getPropertyState().getType();\n",
        "project": "jackrabbit-oak",
        "linesAdd": 36,
        "jira_id": "3310",
        "nb_skipped": 1,
        "commit": "4416a9f8",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1963,
        "nb_error": 4,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.RepositoryTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/SessionContext.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/SessionContext.java\nindex dff9421eea..86ca4bd63d 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/SessionContext.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/SessionContext.java\n@@ -327,9 +327,15 @@ public String getOakPathOrThrow(String jcrPath) throws RepositoryException {\n         String oakPath = getOakPath(jcrPath);\n         if (oakPath != null) {\n             return oakPath;\n+        } else {\n+            // check if the path is an SNS path with an index > 1 and throw a PathNotFoundException instead (see OAK-1216)\n+            if (getOakPathKeepIndex(jcrPath) != null) {\n+                throw new PathNotFoundException(jcrPath);\n             } else {\n                 throw new RepositoryException(\"Invalid name or path: \" + jcrPath);\n             }\n+\n+        }\n     }\n \n     /**\n",
        "project": "jackrabbit-oak",
        "linesAdd": 5,
        "jira_id": "1216",
        "nb_skipped": 5,
        "commit": "e403e003",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1563,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\nindex f6ad95a88d..5c3716232f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Expression.java\n@@ -180,10 +180,6 @@ public String toString() {\n             if (right == null) {\n                 rightExpr = \"\";\n             } else {\n-                if (left != null && left instanceof Property && ((Property) left).implicitAsterisk) {\n-                    throw new IllegalArgumentException(\n-                            \"Missing @ in front of the property name: \" + left);\n-                }\n                 if (leftExprIsName && !\"like\".equals(operator)) {\n                     // need to de-escape _x0020_ and so on\n                     if (!(right instanceof Literal)) {\n@@ -275,8 +271,16 @@ public String getCommonLeftPart() {\n     \n         @Override\n         public String toString() {\n-            StringBuilder buff = new StringBuilder(\"contains\").\n-                    append('(').append(left).append(\", \").append(right).append(')');\n+            StringBuilder buff = new StringBuilder(\"contains(\");\n+            Expression l = left;\n+            if (l instanceof Property) {\n+                Property p = (Property) l;\n+                if (p.thereWasNoAt) {\n+                    l = new Property(p.selector, p.name + \"/*\", true);\n+                }\n+            }\n+            buff.append(l);\n+            buff.append(\", \").append(right).append(')');\n             return buff.toString();\n         }\n     \n@@ -386,12 +390,18 @@ public String toString() {\n     \n         final Selector selector;\n         final String name;\n-        final boolean implicitAsterisk;\n         \n-        Property(Selector selector, String name, boolean implicitAsterisk) {\n+        /**\n+         * If there was no \"@\" character in front of the property name. If that\n+         * was the case, then it is still considered a property, except for\n+         * \"contains(x, 'y')\", where \"x\" is considered to be a node.\n+         */\n+        final boolean thereWasNoAt;\n+    \n+        Property(Selector selector, String name, boolean thereWasNoAt) {\n             this.selector = selector;\n             this.name = name;\n-            this.implicitAsterisk = implicitAsterisk;\n+            this.thereWasNoAt = thereWasNoAt;\n         }\n     \n         @Override\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\nindex 5ac0529a74..76955a0c8a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n@@ -552,9 +552,7 @@ private Expression parsePropertyOrFunction() throws ParseException {\n             // path without all attributes, as in:\n             // jcr:contains(jcr:content, 'x')\n             if (buff.toString().equals(\".\")) {\n-                buff = new StringBuilder(\"*\");\n-            } else {\n-                buff.append(\"/*\");\n+                return new Expression.Property(currentSelector, \"*\", false);\n             }\n             return new Expression.Property(currentSelector, buff.toString(), true);\n         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 15,
        "jira_id": "1369",
        "nb_skipped": 6,
        "commit": "ce0b0955",
        "nb_failure": 0,
        "linesRem": 12,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 6,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.commons.PathTest"
        ],
        "patch": "diff --git a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/PathUtils.java b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/PathUtils.java\nindex 62018046c9..883f197b4b 100644\n--- a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/PathUtils.java\n+++ b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/PathUtils.java\n@@ -16,10 +16,11 @@\n  */\n package org.apache.jackrabbit.oak.commons;\n \n-import javax.annotation.Nonnull;\n import java.util.Iterator;\n import java.util.NoSuchElementException;\n \n+import javax.annotation.Nonnull;\n+\n /**\n  * Utility methods to parse a path.\n  * <p/>\n@@ -288,7 +289,12 @@ public static boolean isAncestor(String ancestor, String path) {\n         if (ancestor.isEmpty() || path.isEmpty()) {\n             return false;\n         }\n-        if (!denotesRoot(ancestor)) {\n+        if (denotesRoot(ancestor)) {\n+            if (denotesRoot(path)) {\n+                return false;\n+            }\n+        }\n+        else {\n             ancestor += \"/\";\n         }\n         return path.startsWith(ancestor);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 8,
        "jira_id": "296",
        "nb_skipped": 0,
        "commit": "5449bf39",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1809,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.strategy.OrderedContentMirrorStorageStrategyTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\nindex 0fd121cf43..3f78b784b5 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n@@ -1021,8 +1021,11 @@ static String getPropertyNext(@Nonnull final NodeState state, final int lane) {\n         String next = \"\";\n         PropertyState ps = state.getProperty(NEXT);\n         if (ps != null) {\n-            next = (lane < OrderedIndex.LANES) ? ps.getValue(Type.STRING, lane)\n-                                               : \"\";\n+            if (ps.isArray()) {\n+                next = ps.getValue(Type.STRING, Math.min(ps.count() - 1, lane));\n+            } else {\n+                next = ps.getValue(Type.STRING);\n+            }\n         }\n         return next;\n     }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 5,
        "jira_id": "1899",
        "nb_skipped": 9,
        "commit": "b6f89048",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 375,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.AggregateTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/Aggregate.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/Aggregate.java\nindex 1143b81f31..8c94e08625 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/Aggregate.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/Aggregate.java\n@@ -242,7 +242,7 @@ public boolean match(String name, NodeState nodeState, int depth) {\n         public void collectResults(NodeInclude rootInclude, String rootIncludePath, String nodePath,\n                                    NodeState nodeState, ResultCollector results) throws CommitFailedException {\n             //For supporting jcr:contains(jcr:content, 'foo')\n-            if (rootInclude != this && rootInclude.relativeNode){\n+            if (rootInclude.relativeNode){\n                 results.onResult(new NodeIncludeResult(nodePath, rootIncludePath, nodeState));\n             }\n \n@@ -511,7 +511,10 @@ public Matcher match(String name, NodeState nodeState) {\n         public void collectResults(ResultCollector results)\n                 throws CommitFailedException {\n             checkArgument(status == Status.MATCH_FOUND);\n-            String rootIncludePath = aggregateStack.isEmpty() ?  null : aggregateStack.get(0);\n+\n+            //If result being collected as part of reaggregation then take path\n+            //from the stack otherwise its the current path\n+            String rootIncludePath = aggregateStack.isEmpty() ?  currentPath : aggregateStack.get(0);\n             currentInclude.collectResults(rootState.rootInclude, rootIncludePath,\n                     currentPath, matchedNodeState, results);\n         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "2426",
        "nb_skipped": 2,
        "commit": "920f32d0",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1867,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.query.SQL2ParserTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\nindex 6e614b5a08..66ccb04949 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\n@@ -179,16 +179,8 @@ public String toString() {\n                 buff.append(orderList.get(i));\n             }\n         }\n-\n         // leave original xpath string as a comment\n-        if (xpathQuery != null) {\n-            buff.append(\" /* xpath: \");\n-            // the xpath query may not contain the \"end comment\" marker\n-            String xpathEscaped = xpathQuery.replaceAll(\"\\\\*\\\\/\", \"* /\");\n-            buff.append(xpathEscaped);\n-            buff.append(\" */\");\n-        }\n-        \n+        appendXPathAsComment(buff, xpathQuery);\n         return buff.toString();        \n     }\n \n@@ -251,14 +243,21 @@ public String toString() {\n                 }\n             }\n             // leave original xpath string as a comment\n-            if (xpathQuery != null) {\n-                buff.append(\" /* xpath: \");\n-                buff.append(xpathQuery);\n-                buff.append(\" */\");\n-            }\n+            appendXPathAsComment(buff, xpathQuery);\n             return buff.toString();\n         }\n         \n     }\n     \n+    private static void appendXPathAsComment(StringBuilder buff, String xpath) {\n+        if (xpath == null) {\n+            return;\n+        }\n+        buff.append(\" /* xpath: \");\n+        // the xpath query may contain the \"end comment\" marker\n+        String xpathEscaped = xpath.replaceAll(\"\\\\*\\\\/\", \"* /\");\n+        buff.append(xpathEscaped);\n+        buff.append(\" */\");        \n+    }\n+\n }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 12,
        "jira_id": "2427",
        "nb_skipped": 9,
        "commit": "e6d4f9a6",
        "nb_failure": 0,
        "linesRem": 13,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 379,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlannerTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexPlanner.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexPlanner.java\nindex a2189a0400..9a413dce32 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexPlanner.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexPlanner.java\n@@ -36,6 +36,7 @@\n import org.apache.jackrabbit.oak.query.fulltext.FullTextTerm;\n import org.apache.jackrabbit.oak.query.fulltext.FullTextVisitor;\n import org.apache.jackrabbit.oak.spi.query.Filter;\n+import org.apache.jackrabbit.oak.spi.query.QueryIndex;\n import org.apache.lucene.index.IndexReader;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -43,6 +44,7 @@\n import static com.google.common.collect.Lists.newArrayList;\n import static com.google.common.collect.Lists.newArrayListWithCapacity;\n import static com.google.common.collect.Maps.newHashMap;\n+import static org.apache.jackrabbit.JcrConstants.JCR_SCORE;\n import static org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath;\n import static org.apache.jackrabbit.oak.commons.PathUtils.getDepth;\n import static org.apache.jackrabbit.oak.commons.PathUtils.getParentPath;\n@@ -156,7 +158,8 @@ public String toString() {\n         //Fulltext expression can also be like jcr:contains(jcr:content/metadata/@format, 'image')\n \n         List<OrderEntry> sortOrder = createSortOrder(indexingRule);\n-        if (!indexedProps.isEmpty() || !sortOrder.isEmpty() || ft != null || evalPathRestrictions) {\n+        boolean canSort = canHandleSorting(sortOrder);\n+        if (!indexedProps.isEmpty() || canSort || ft != null || evalPathRestrictions) {\n             //TODO Need a way to have better cost estimate to indicate that\n             //this index can evaluate more propertyRestrictions natively (if more props are indexed)\n             //For now we reduce cost per entry\n@@ -191,6 +194,20 @@ public String toString() {\n         return null;\n     }\n \n+    private boolean canHandleSorting(List<OrderEntry> sortOrder) {\n+        if (sortOrder.isEmpty()){\n+            return false;\n+        }\n+\n+        //If jcr:score is the only sort order then opt out\n+        if (sortOrder.size() == 1\n+                && JCR_SCORE.equals(sortOrder.get(0).getPropertyName())){\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n     private boolean canEvalAllFullText(final IndexingRule indexingRule, FullTextExpression ft) {\n         if (ft == null){\n             return false;\n",
        "project": "jackrabbit-oak",
        "linesAdd": 17,
        "jira_id": "2439",
        "nb_skipped": 3,
        "commit": "beaca1a4",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 684,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.authorization.evaluation.RootTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/AbstractNodeLocation.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/AbstractNodeLocation.java\nindex e70a1b11af..89df0acd50 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/AbstractNodeLocation.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/AbstractNodeLocation.java\n@@ -57,15 +57,15 @@ public TreeLocation getParent() {\n \n     @Override\n     public TreeLocation getChild(String name) {\n-        T child = getChildTree(name);\n-        if (child != null) {\n-            return createNodeLocation(child);\n-        }\n-\n         PropertyState prop = getPropertyState(name);\n         if (prop != null) {\n             return createPropertyLocation(this, name);\n         }\n+\n+        T child = getChildTree(name);\n+        if (child != null) {\n+            return createNodeLocation(child);\n+        }\n         return new NullLocation(this, name);\n     }\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\nindex 8bda9f2f28..efb5ec9e27 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n@@ -91,7 +91,7 @@ private TreeImpl(RootImpl root, TreeImpl parent, String name, Move pendingMoves)\n         this.root = checkNotNull(root);\n         this.parent = checkNotNull(parent);\n         this.name = checkNotNull(name);\n-        this.nodeBuilder = parent.nodeBuilder.child(name);\n+        this.nodeBuilder = parent.nodeBuilder.getChildNode(name);\n         this.pendingMoves = checkNotNull(pendingMoves);\n     }\n \n@@ -187,11 +187,7 @@ public TreeImpl getChild(@Nonnull String name) {\n         checkNotNull(name);\n         enter();\n         TreeImpl child = internalGetChild(name);\n-        if (child != null && canRead(child)) {\n-            return child;\n-        } else {\n-            return null;\n-        }\n+        return canRead(child) ? child : null;\n     }\n \n     @Override\n@@ -438,11 +434,8 @@ TreeImpl getTree(String path) {\n         TreeImpl child = this;\n         for (String name : elements(path)) {\n             child = child.internalGetChild(name);\n-            if (child == null) {\n-                return null;\n-            }\n         }\n-        return (canRead(child)) ? child : null;\n+        return canRead(child) ? child : null;\n     }\n \n     /**\n@@ -526,9 +519,7 @@ private void applyPendingMoves() {\n     }\n \n     private TreeImpl internalGetChild(String childName) {\n-        return nodeBuilder.hasChildNode(childName)\n-            ? new TreeImpl(root, this, childName, pendingMoves)\n-            : null;\n+        return new TreeImpl(root, this, childName, pendingMoves);\n     }\n \n     private PropertyState internalGetProperty(String propertyName) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 9,
        "jira_id": "766",
        "nb_skipped": 1,
        "commit": "6fc5ea9d",
        "nb_failure": 4,
        "linesRem": 18,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3040,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.blob.RDBBlobStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBBlobStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBBlobStore.java\nindex 530c87758f..2ae668b0f3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBBlobStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBBlobStore.java\n@@ -506,8 +506,10 @@ public long countDeleteChunks(List<String> chunkIds, long maxLastModifiedTime) t\n                         .append(inClause.getStatementComponent());\n \n                 if (maxLastModifiedTime > 0) {\n+                    // delete only if the last modified is OLDER than x\n                     metaStatement.append(\" and LASTMOD <= ?\");\n-                    dataStatement.append(\" and not exists(select * from \" + this.tnMeta + \" m where ID = m.ID and m.LASTMOD <= ?)\");\n+                    // delete if there is NO entry where the last modified of the meta is YOUNGER than x\n+                    dataStatement.append(\" and not exists(select * from \" + this.tnMeta + \" m where ID = m.ID and m.LASTMOD > ?)\");\n                 }\n \n                 prepMeta = con.prepareStatement(metaStatement.toString());\n@@ -522,8 +524,17 @@ public long countDeleteChunks(List<String> chunkIds, long maxLastModifiedTime) t\n                     prepData.setLong(dindex, maxLastModifiedTime);\n                 }\n \n-                count += prepMeta.executeUpdate();\n-                prepData.execute();\n+                int deletedMeta = prepMeta.executeUpdate();\n+                int deletedData = prepData.executeUpdate();\n+\n+                if (deletedMeta != deletedData) {\n+                    String message = String.format(\n+                            \"chunk deletion affected different numbers of DATA records (%s) and META records (%s)\", deletedMeta,\n+                            deletedData);\n+                    LOG.info(message);\n+                }\n+\n+                count += deletedMeta;\n             } finally {\n                 closeStatement(prepMeta);\n                 closeStatement(prepData);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 12,
        "jira_id": "3872",
        "nb_skipped": 1,
        "commit": "c13708e3",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 351,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexSuggestionTest",
            "org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/SuggestHelper.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/SuggestHelper.java\nindex 4d0aa5cf5c..e6de6fb59e 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/SuggestHelper.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/util/SuggestHelper.java\n@@ -66,8 +66,10 @@ public static void updateSuggester(Directory directory, Analyzer analyzer, Index\n             tempDir = Files.createTempDir();\n             File tempSubChild = new File(tempDir, \"non-existing-sub-child\");\n \n+            if (reader.getDocCount(FieldNames.SUGGEST) > 0) {\n                 Dictionary dictionary = new LuceneDictionary(reader, FieldNames.SUGGEST);\n                 getLookup(directory, analyzer, tempSubChild).build(dictionary);\n+            }\n         } catch (RuntimeException e) {\n             log.debug(\"could not update the suggester\", e);\n         } finally {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "4067",
        "nb_skipped": 6,
        "commit": "56accddf",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1579,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\nindex 75510da8d3..93b4bd055e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n@@ -408,7 +408,9 @@ private void rollback(List<UpdateOp> newDocuments,\n             store.createOrUpdate(NODES, reverse);\n         }\n         for (UpdateOp op : newDocuments) {\n-            store.remove(NODES, op.id);\n+            UpdateOp reverse = op.getReverseOperation();\n+            NodeDocument.unsetLastRev(reverse, revision.getClusterId());\n+            store.createOrUpdate(NODES, reverse);\n         }\n         UpdateOp removeCollision = new UpdateOp(commitRoot.getId(), false);\n         NodeDocument.removeCollision(removeCollision, revision);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "1467",
        "nb_skipped": 7,
        "commit": "dde7de85",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 257,
        "nb_error": 0,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinitionTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\nindex cd4a119290..843fc82b40 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n@@ -865,7 +865,6 @@ public boolean isBasedOnNtBase(){\n \n                     //Include props with name, boosted and nodeScopeIndex\n                     if (pd.nodeScopeIndex\n-                            && pd.boost != PropertyDefinition.DEFAULT_BOOST\n                             && pd.analyzed\n                             && !pd.isRegexp){\n                         boostedProps.add(pd);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 0,
        "jira_id": "3367",
        "nb_skipped": 4,
        "commit": "06812d25",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": true
    },
    {
        "files": 1,
        "nb_test": 1269,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\nindex 433bac391a..97a34086d5 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\n@@ -164,7 +164,9 @@ public long count(NodeState indexMeta, Set<String> values, int max) {\n             int i = 0;\n             for (String p : values) {\n                 if (count > max && i > 3) {\n-                    count = count / size / i;\n+                    // the total count is extrapolated from the the number \n+                    // of values counted so far to the total number of values\n+                    count = count * size / i;\n                     break;\n                 }\n                 NodeState s = index.getChildNode(p);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "1035",
        "nb_skipped": 8,
        "commit": "b2ca8baa",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 1,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest"
        ],
        "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/PersistenceCopier.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/PersistenceCopier.java\nindex 23c905e0a7..88030fe2c5 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/PersistenceCopier.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/PersistenceCopier.java\n@@ -292,7 +292,7 @@ private void copy(NodeState sourceNode, NodeBuilder builder)\n                     name, value.getBoolean(), Type.BOOLEAN);\n         case PropertyType.DATE:\n             return PropertyStates.createProperty(\n-                    name, value.getCalendar().getTimeInMillis(), Type.DATE);\n+                    name, value.getString(), Type.DATE);\n         case PropertyType.DECIMAL:\n             return PropertyStates.createProperty(\n                     name, value.getDecimal(), Type.DECIMAL);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "1111",
        "nb_skipped": 0,
        "commit": "459bd065",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 359,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\nindex 749756aac3..42a78041ec 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LucenePropertyIndex.java\n@@ -1371,7 +1371,7 @@ static Query tokenToQuery(String text, String fieldName, Analyzer analyzer) {\n     /**\n      * Following chars are used as operators in Lucene Query and should be escaped\n      */\n-    private static final char[] LUCENE_QUERY_OPERATORS = {':' , '/', '!', '&', '|'};\n+    private static final char[] LUCENE_QUERY_OPERATORS = {':' , '/', '!', '&', '|', '='};\n \n     /**\n      * Following logic is taken from org.apache.jackrabbit.core.query.lucene.JackrabbitQueryParser#parse(java.lang.String)\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "4359",
        "nb_skipped": 6,
        "commit": "002c5845",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1351,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.xml.ImportTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java\nindex 176dffe333..8e7e72f0a8 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/ImporterImpl.java\n@@ -47,6 +47,7 @@\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import org.apache.jackrabbit.JcrConstants;\n+import org.apache.jackrabbit.oak.api.ContentSession;\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Root;\n import org.apache.jackrabbit.oak.api.Tree;\n@@ -82,26 +83,10 @@\n     private final String userID;\n     private final AccessManager accessManager;\n \n-    /**\n-     * There are two IdentifierManagers used.\n-     *\n-     * 1) currentStateIdManager - Associated with current root on which all import\n-     *    operations are being performed\n-     *\n-     * 2) baseStateIdManager - Associated with the initial root on which\n-     *    no modifications are performed\n-     */\n-    private final IdentifierManager currentStateIdManager;\n-    private final IdentifierManager baseStateIdManager;\n-\n     private final EffectiveNodeTypeProvider effectiveNodeTypeProvider;\n     private final DefinitionProvider definitionProvider;\n \n-    /**\n-     * Set of newly created uuid from nodes which are\n-     * created in this import\n-     */\n-    private final Set<String> uuids = new HashSet<String>();\n+    private final IdResolver idLookup;\n \n     private final Stack<Tree> parents;\n \n@@ -171,8 +156,7 @@ public ImporterImpl(String absPath,\n \n         accessManager = sessionContext.getAccessManager();\n \n-        currentStateIdManager = new IdentifierManager(root);\n-        baseStateIdManager = new IdentifierManager(sd.getContentSession().getLatestRoot());\n+        idLookup = new IdResolver(root, sd.getContentSession());\n \n         refTracker = new ReferenceChangeTracker();\n \n@@ -465,24 +449,7 @@ public void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos)\n                 }\n             } else {\n \n-                //1. First check from base state that tree corresponding to\n-                //this id exist\n-                Tree conflicting = baseStateIdManager.getTree(id);\n-\n-                if (conflicting == null) {\n-                    //1.a. Check if id is found in newly created nodes\n-                    if (uuids.contains(id)) {\n-                        conflicting = currentStateIdManager.getTree(id);\n-                    }\n-                } else {\n-                    //1.b Re obtain the conflicting tree from Id Manager\n-                    //associated with current root. Such that any operation\n-                    //on it gets reflected in later operations\n-                    //In case a tree with same id was removed earlier then it\n-                    //would return null\n-                    conflicting = currentStateIdManager.getTree(id);\n-                }\n-\n+                Tree conflicting = idLookup.getConflictingTree(id);\n                 if (conflicting != null && conflicting.exists()) {\n                     // resolve uuid conflict\n                     tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n@@ -522,22 +489,7 @@ public void endNode(NodeInfo nodeInfo) throws RepositoryException {\n             }\n         }\n \n-        collectUUIDs(parent);\n-    }\n-\n-    private void collectUUIDs(Tree tree) {\n-        if (tree == null) {\n-            return;\n-        }\n-\n-        String uuid = TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n-        if (uuid != null) {\n-            uuids.add(uuid);\n-        }\n-\n-        for (Tree child : tree.getChildren()) {\n-            collectUUIDs(child);\n-        }\n+        idLookup.rememberImportedUUIDs(parent);\n     }\n \n     @Override\n@@ -621,4 +573,78 @@ private void setProperty(Iterable<String> newValues) {\n             tree.setProperty(prop);\n         }\n     }\n+\n+    /**\n+     * Resolves 'uuid' property values to {@code Tree} objects and optionally\n+     * keeps track of newly imported UUIDs.\n+     */\n+    private static final class IdResolver {\n+        /**\n+         * There are two IdentifierManagers used.\n+         *\n+         * 1) currentStateIdManager - Associated with current root on which all import\n+         *    operations are being performed\n+         *\n+         * 2) baseStateIdManager - Associated with the initial root on which\n+         *    no modifications are performed\n+         */\n+        private final IdentifierManager currentStateIdManager;\n+        private final IdentifierManager baseStateIdManager;\n+\n+        /**\n+         * Set of newly created uuid from nodes which are\n+         * created in this import, which are only remembered if the editing\n+         * session doesn't have any pending transient changes preventing this\n+         * performance optimisation from working properly (see OAK-2246).\n+         */\n+        private final Set<String> importedUUIDs;\n+\n+        private IdResolver(@Nonnull Root root, @Nonnull ContentSession contentSession) {\n+            currentStateIdManager = new IdentifierManager(root);\n+            baseStateIdManager = new IdentifierManager(contentSession.getLatestRoot());\n+\n+            if (!root.hasPendingChanges()) {\n+                importedUUIDs = new HashSet<String>();\n+            } else {\n+                importedUUIDs = null;\n+            }\n+        }\n+\n+\n+        @CheckForNull\n+        private Tree getConflictingTree(@Nonnull String id) {\n+            //1. First check from base state that tree corresponding to\n+            //this id exist\n+            Tree conflicting = baseStateIdManager.getTree(id);\n+            if (conflicting == null && importedUUIDs != null) {\n+                //1.a. Check if id is found in newly created nodes\n+                if (importedUUIDs.contains(id)) {\n+                    conflicting = currentStateIdManager.getTree(id);\n+                }\n+            } else {\n+                //1.b Re obtain the conflicting tree from Id Manager\n+                //associated with current root. Such that any operation\n+                //on it gets reflected in later operations\n+                //In case a tree with same id was removed earlier then it\n+                //would return null\n+                conflicting = currentStateIdManager.getTree(id);\n+            }\n+            return conflicting;\n+        }\n+\n+        private void rememberImportedUUIDs(@CheckForNull Tree tree) {\n+            if (tree == null || importedUUIDs == null) {\n+                return;\n+            }\n+\n+            String uuid = TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n+            if (uuid != null) {\n+                importedUUIDs.add(uuid);\n+            }\n+\n+            for (Tree child : tree.getChildren()) {\n+                rememberImportedUUIDs(child);\n+            }\n+        }\n+    }\n }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 52,
        "jira_id": "2246",
        "nb_skipped": 1,
        "commit": "dcadb0e1",
        "nb_failure": 2,
        "linesRem": 32,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 151,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.core.RootImplTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\nindex 9631cbec8f..d20d8203f7 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java\n@@ -21,6 +21,7 @@\n import org.apache.jackrabbit.oak.api.CoreValue;\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Tree;\n+import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.spi.state.ChildNodeEntry;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n import org.apache.jackrabbit.oak.spi.state.NodeStateBuilder;\n@@ -29,8 +30,10 @@\n import org.apache.jackrabbit.oak.util.Function1;\n import org.apache.jackrabbit.oak.util.Iterators;\n \n+import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n \n /**\n  * Implementation of tree based on {@link NodeStateBuilder}s. Each subtree\n@@ -42,43 +45,46 @@\n     /** Underlying store */\n     private final NodeStore store;\n \n+    private final NodeStateBuilder rootBuilder;\n+\n     /**\n      * Underlying persistent state or {@code null} if this instance represents an\n      * added tree\n      */\n     private final NodeState baseState;\n \n-    private final NodeStateBuilder builder;\n-\n     /** Listener for changes on this tree */\n     private final Listener listener;\n \n+    /** Parent of this tree */\n+    private TreeImpl parent;\n+\n     /** Name of this tree */\n     private String name;\n \n-    /** Parent of this tree */\n-    private TreeImpl parent;\n+    // FIXME: should be synchronized, and weak refs\n+    private final Map<String, TreeImpl> children = new HashMap<String, TreeImpl>();\n \n-    private TreeImpl(NodeStore store, NodeState baseState, NodeStateBuilder builder,\n+    private TreeImpl(NodeStore store, NodeState baseState, NodeStateBuilder rootBuilder,\n             TreeImpl parent, String name, Listener listener) {\n \n         this.store = store;\n-        this.builder = builder;\n+        this.rootBuilder = rootBuilder;\n         this.baseState = baseState;\n         this.listener = listener;\n-        this.name = name;\n         this.parent = parent;\n+        this.name = name;\n     }\n \n     /**\n      * Create a new instance which represents the root of a tree.\n      * @param store  underlying store to the tree\n-     * @param nodeStateBuilder  builder for the root\n+     * @param rootBuilder  builder for the root\n      * @param listener  change listener for the tree. May be {@code null} if\n      *                  listening to changes is not needed.\n      */\n-    TreeImpl(NodeStore store, NodeStateBuilder nodeStateBuilder, Listener listener) {\n-        this(store, nodeStateBuilder.getNodeState(), nodeStateBuilder, null, \"\", listener);\n+    TreeImpl(NodeStore store, NodeStateBuilder rootBuilder, Listener listener) {\n+        this(store, rootBuilder.getNodeState(), rootBuilder, null, \"\", listener);\n     }\n \n     /**\n@@ -147,15 +153,14 @@ public String getName() {\n \n     @Override\n     public String getPath() {\n+        // Shortcut for root\n         if (parent == null) {\n-            return name;\n-        }\n-        else {\n-            String path = parent.getPath();\n-            return path.isEmpty()\n-                    ? name\n-                    : path + '/' + name;\n+            return \"\";\n         }\n+\n+        StringBuilder sb = new StringBuilder();\n+        buildPath(sb);\n+        return sb.toString();\n     }\n \n     @Override\n@@ -233,17 +238,22 @@ public long getPropertyCount() {\n \n     @Override\n     public TreeImpl getChild(String name) {\n-        NodeStateBuilder childBuilder = builder.getChildBuilder(name);\n-        if (childBuilder == null) {\n+        TreeImpl child = children.get(name);\n+        if (child != null) {\n+            return child;\n+        }\n+\n+        if (!hasChild(name)) {\n             return null;\n         }\n-        else {\n+\n         NodeState childBaseState = baseState == null\n                 ? null\n                 : baseState.getChildNode(name);\n \n-            return new TreeImpl(store, childBaseState, childBuilder, this, name, listener);\n-        }\n+        child = new TreeImpl(store, childBaseState, rootBuilder, this, name, listener);\n+        children.put(name, child);\n+        return child;\n     }\n \n     @Override\n@@ -307,14 +317,24 @@ public long getChildrenCount() {\n         return new Iterable<Tree>() {\n             @Override\n             public Iterator<Tree> iterator() {\n+                final NodeState nodeState = getNodeState();\n+\n                 Iterator<? extends ChildNodeEntry> childEntries =\n-                        getNodeState().getChildNodeEntries().iterator();\n+                        nodeState.getChildNodeEntries().iterator();\n \n                 return Iterators.map(childEntries, new Function1<ChildNodeEntry, Tree>() {\n                     @Override\n                     public Tree apply(ChildNodeEntry entry) {\n-                        NodeStateBuilder childBuilder = builder.getChildBuilder(entry.getName());\n-                        return new TreeImpl(store, childBuilder.getNodeState(), childBuilder, TreeImpl.this, entry.getName(), listener);\n+                        String childName = entry.getName();\n+                        TreeImpl child = children.get(entry.getName());\n+                        if (child != null) {\n+                            return child;\n+                        }\n+\n+                        NodeState childNodeState = nodeState.getChildNode(childName);\n+                        child = new TreeImpl(store, childNodeState, rootBuilder, TreeImpl.this, childName, listener);\n+                        children.put(childName, child);\n+                        return child;\n                     }\n                 });\n             }\n@@ -323,24 +343,27 @@ public Tree apply(ChildNodeEntry entry) {\n \n     @Override\n     public Tree addChild(String name) {\n-        if (builder.addNode(name) != null) {\n+        if (getBuilder().addNode(name) != null) {\n             listener.addChild(this, name);\n         }\n-        return getChild(name);\n+        TreeImpl child = getChild(name);\n+        children.put(name, child);\n+        return child;\n     }\n \n     @Override\n     public boolean removeChild(String name) {\n-        boolean result = builder.removeNode(name);\n+        boolean result = getBuilder().removeNode(name);\n         if (result) {\n             listener.removeChild(this, name);\n+            children.remove(name);\n         }\n         return result;\n     }\n \n     @Override\n     public PropertyState setProperty(String name, CoreValue value) {\n-        PropertyState property = builder.setProperty(name, value);\n+        PropertyState property = getBuilder().setProperty(name, value);\n         if (listener != null) {\n             listener.setProperty(this, name, value);\n         }\n@@ -349,7 +372,7 @@ public PropertyState setProperty(String name, CoreValue value) {\n \n     @Override\n     public PropertyState setProperty(String name, List<CoreValue> values) {\n-        PropertyState property = builder.setProperty(name, values);\n+        PropertyState property = getBuilder().setProperty(name, values);\n         if (listener != null) {\n             listener.setProperty(this, name, values);\n         }\n@@ -358,7 +381,7 @@ public PropertyState setProperty(String name, List<CoreValue> values) {\n \n     @Override\n     public void removeProperty(String name) {\n-        builder.removeProperty(name);\n+        getBuilder().removeProperty(name);\n         if (listener != null) {\n             listener.removeProperty(this, name);\n         }\n@@ -374,8 +397,13 @@ public void removeProperty(String name) {\n      * when {@code destName} already exists at {@code destParent}\n      */\n     public boolean move(TreeImpl destParent, String destName) {\n-        boolean result = builder.moveTo(destParent.builder, destName);\n+        NodeStateBuilder builder = getBuilder();\n+        NodeStateBuilder destParentBuilder = destParent.getBuilder();\n+        boolean result = builder.moveTo(destParentBuilder, destName);\n         if (result) {\n+            parent.children.remove(name);\n+            destParent.children.put(destName, this);\n+\n             TreeImpl oldParent = parent;\n             String oldName = name;\n \n@@ -398,7 +426,7 @@ public boolean move(TreeImpl destParent, String destName) {\n      * when {@code destName} already exists at {@code destParent}\n      */\n     public boolean copy(TreeImpl destParent, String destName) {\n-        boolean result = builder.copyTo(destParent.builder, destName);\n+        boolean result = getBuilder().copyTo(destParent.getBuilder(), destName);\n         if (result) {\n             if (listener != null) {\n                 listener.copy(parent, name, destParent.getChild(destName));\n@@ -410,8 +438,30 @@ public boolean copy(TreeImpl destParent, String destName) {\n \n     //------------------------------------------------------------< private >---\n \n+    private void buildPath(StringBuilder sb) {\n+        if (parent != null) {\n+            parent.buildPath(sb);\n+            if (sb.length() > 0) {\n+                sb.append('/');\n+            }\n+            sb.append(name);\n+        }\n+    }\n+\n+    private NodeStateBuilder getBuilder() {\n+        NodeStateBuilder builder = rootBuilder;\n+        for (String name : PathUtils.elements(getPath())) {\n+            builder = builder.getChildBuilder(name);\n+            if (builder == null) {\n+                throw new IllegalStateException(\"Stale NodeStateBuilder for \" + getPath());\n+            }\n+        }\n+\n+        return builder;\n+    }\n+\n     private NodeState getNodeState() {\n-        return builder.getNodeState();\n+        return getBuilder().getNodeState();\n     }\n \n     private boolean isSame(NodeState state1, NodeState state2) {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeStateBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeStateBuilder.java\nindex d35d82e679..5c477f8274 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeStateBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeStateBuilder.java\n@@ -28,27 +28,28 @@\n public class KernelNodeStateBuilder implements NodeStateBuilder {\n     private final NodeStateBuilderContext context;\n \n-    private String path;\n+    private KernelNodeStateBuilder parent;\n+    private String name;\n \n-    private KernelNodeStateBuilder(NodeStateBuilderContext context, String path) {\n+    private KernelNodeStateBuilder(NodeStateBuilderContext context, KernelNodeStateBuilder parent, String name) {\n         this.context = context;\n-        this.path = path;\n+        this.parent = parent;\n+        this.name = name;\n     }\n \n     public static NodeStateBuilder create(NodeStateBuilderContext context) {\n-        return new KernelNodeStateBuilder(context, \"\");\n+        return new KernelNodeStateBuilder(context, null, \"\");\n     }\n \n-\n     @Override\n     public NodeState getNodeState() {\n-        return context.getNodeState(path);\n+        return context.getNodeState(getPath());\n     }\n \n     @Override\n     public NodeStateBuilder getChildBuilder(String name) {\n         return hasChild(name)\n-            ? new KernelNodeStateBuilder(context, PathUtils.concat(path, name))\n+            ? new KernelNodeStateBuilder(context, this, name)\n             : null;\n     }\n \n@@ -58,9 +59,9 @@ public NodeStateBuilder addNode(String name, NodeState nodeState) {\n             return null;\n         }\n         else {\n-            String targetPath = PathUtils.concat(path, name);\n+            String targetPath = PathUtils.concat(getPath(), name);\n             context.addNode(nodeState, targetPath);\n-            return new KernelNodeStateBuilder(context, targetPath);\n+            return new KernelNodeStateBuilder(context, this, name);\n         }\n     }\n \n@@ -70,16 +71,16 @@ public NodeStateBuilder addNode(String name) {\n             return null;\n         }\n         else {\n-            String targetPath = PathUtils.concat(path, name);\n+            String targetPath = PathUtils.concat(getPath(), name);\n             context.addNode(targetPath);\n-            return new KernelNodeStateBuilder(context, targetPath);\n+            return new KernelNodeStateBuilder(context, this, name);\n         }\n     }\n \n     @Override\n     public boolean removeNode(String name) {\n         if (hasChild(name)) {\n-            context.removeNode(PathUtils.concat(path, name));\n+            context.removeNode(PathUtils.concat(getPath(), name));\n             return true;\n         }\n         else {\n@@ -91,10 +92,10 @@ public boolean removeNode(String name) {\n     public PropertyState setProperty(String name, CoreValue value) {\n         PropertyState property = new PropertyStateImpl(name, value);\n         if (hasProperty(name)) {\n-            context.setProperty(property, path);\n+            context.setProperty(property, getPath());\n         }\n         else {\n-            context.addProperty(property, path);\n+            context.addProperty(property, getPath());\n         }\n         return property;\n     }\n@@ -103,10 +104,10 @@ public PropertyState setProperty(String name, CoreValue value) {\n     public PropertyState setProperty(String name, List<CoreValue> values) {\n         PropertyState property = new PropertyStateImpl(name, values);\n         if (hasProperty(name)) {\n-            context.setProperty(property, path);\n+            context.setProperty(property, getPath());\n         }\n         else {\n-            context.addProperty(property, path);\n+            context.addProperty(property, getPath());\n         }\n         return property;\n     }\n@@ -114,7 +115,7 @@ public PropertyState setProperty(String name, List<CoreValue> values) {\n     @Override\n     public void removeProperty(String name) {\n         if (hasProperty(name)) {\n-            context.removeProperty(PathUtils.concat(path, name));\n+            context.removeProperty(PathUtils.concat(getPath(), name));\n         }\n     }\n \n@@ -129,10 +130,13 @@ public boolean moveTo(NodeStateBuilder destParent, String destName) {\n         }\n \n         KernelNodeStateBuilder destParentBuilder = (KernelNodeStateBuilder) destParent;\n-        String destPath = PathUtils.concat(destParentBuilder.path, destName);\n+        String destPath = PathUtils.concat(destParentBuilder.getPath(), destName);\n+\n+        context.moveNode(getPath(), destPath);\n+\n+        name = destName;\n+        parent = destParentBuilder;\n \n-        context.moveNode(path, destPath);\n-        path = destPath;\n         return true;\n     }\n \n@@ -147,9 +151,9 @@ public boolean copyTo(NodeStateBuilder destParent, String destName) {\n         }\n \n         KernelNodeStateBuilder destParentBuilder = (KernelNodeStateBuilder) destParent;\n-        String destPath = PathUtils.concat(destParentBuilder.path, destName);\n+        String destPath = PathUtils.concat(destParentBuilder.getPath(), destName);\n \n-        context.copyNode(path, destPath);\n+        context.copyNode(getPath(), destPath);\n         return true;\n     }\n \n@@ -161,6 +165,27 @@ NodeStateBuilderContext getContext() {\n \n     //------------------------------------------------------------< private >---\n \n+    private String getPath() {\n+        // Shortcut for root\n+        if (parent == null) {\n+            return \"\";\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        buildPath(sb);\n+        return sb.toString();\n+    }\n+\n+    private void buildPath(StringBuilder sb) {\n+        if (parent != null) {\n+            parent.buildPath(sb);\n+            if (sb.length() > 0) {\n+                sb.append('/');\n+            }\n+            sb.append(name);\n+        }\n+    }\n+\n     private boolean hasChild(String name) {\n         return getNodeState().getChildNode(name) != null;\n     }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 126,
        "jira_id": "93",
        "nb_skipped": 1,
        "commit": "0be7e8f0",
        "nb_failure": 1,
        "linesRem": 54,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1198,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.security.authorization.WriteTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\nindex 07e0ae3f8e..2e1733de4f 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/NodeImpl.java\n@@ -290,7 +290,7 @@ public Node perform() throws RepositoryException {\n                 // modification of that property in the PermissionValidator\n                 if (oakTypeName != null) {\n                     PropertyState prop = PropertyStates.createProperty(JCR_PRIMARYTYPE, oakTypeName, NAME);\n-                    sessionContext.getAccessManager().checkPermissions(dlg.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);\n+                    sessionContext.getAccessManager().checkPermissions(parent.getTree(), prop, Permissions.NODE_TYPE_MANAGEMENT);\n                 }\n \n                 NodeDelegate added = parent.addChild(oakName, oakTypeName);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "3517",
        "nb_skipped": 1,
        "commit": "24f7f60a",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2412,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\nindex fee60dcf37..dc3074f888 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\n@@ -19,12 +19,10 @@\n \n package org.apache.jackrabbit.oak.plugins.document;\n \n-import static com.google.common.collect.ImmutableList.of;\n-import static com.google.common.collect.Iterables.filter;\n-import static com.google.common.collect.Iterables.mergeSorted;\n+import static com.google.common.collect.Maps.filterKeys;\n import static java.util.Collections.singletonList;\n import static org.apache.jackrabbit.oak.plugins.document.Collection.JOURNAL;\n-import static org.apache.jackrabbit.oak.plugins.document.UnsavedModifications.Snapshot.IGNORE;\n+import static org.apache.jackrabbit.oak.plugins.document.util.Utils.PROPERTY_OR_DELETED;\n \n import java.util.Iterator;\n import java.util.List;\n@@ -35,6 +33,7 @@\n \n import com.google.common.base.Predicate;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n \n import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.plugins.document.mongo.MongoDocumentStore;\n@@ -152,13 +151,17 @@ public int recover(Iterator<NodeDocument> suspects,\n             }\n \n             Revision currentLastRev = doc.getLastRev().get(clusterId);\n-            if (currentLastRev != null) {\n-                knownLastRevs.put(doc.getPath(), currentLastRev);\n-            }\n+\n             // 1. determine last committed modification on document\n             Revision lastModifiedRev = determineLastModification(doc, clusterId);\n \n             Revision lastRevForParents = Utils.max(lastModifiedRev, currentLastRev);\n+            // remember the higher of the two revisions. this is the\n+            // most recent revision currently obtained from either a\n+            // _lastRev entry or an explicit modification on the document\n+            if (lastRevForParents != null) {\n+                knownLastRevs.put(doc.getPath(), lastRevForParents);\n+            }\n \n             //If both currentLastRev and lostLastRev are null it means\n             //that no change is done by suspect cluster on this document\n@@ -306,21 +309,17 @@ private int recoverCandidates(final int clusterId, final long startTime) {\n     private Revision determineLastModification(NodeDocument doc, int clusterId) {\n         ClusterPredicate cp = new ClusterPredicate(clusterId);\n \n-        // Merge sort the revs for which changes have been made\n-        // to this doc\n-\n-        // localMap always keeps the most recent valid commit entry\n-        // per cluster node so looking into that should be sufficient\n-        Iterable<Revision> revs = mergeSorted(of(\n-                filter(doc.getLocalCommitRoot().keySet(), cp),\n-                filter(doc.getLocalRevisions().keySet(), cp)),\n-                StableRevisionComparator.REVERSE\n-                );\n-\n         Revision lastModified = null;\n-        // Look for latest valid revision\n-        for (Revision rev : revs) {\n+        for (String property : Sets.filter(doc.keySet(), PROPERTY_OR_DELETED)) {\n+            Map<Revision, String> valueMap = doc.getLocalMap(property);\n+            // collect committed changes of this cluster node\n+            for (Map.Entry<Revision, String> entry : filterKeys(valueMap, cp).entrySet()) {\n+                Revision rev = entry.getKey();\n+                if (doc.isCommitted(rev)) {\n                     lastModified = Utils.max(lastModified, doc.getCommitRevision(rev));\n+                    break;\n+                }\n+            }\n         }\n         return lastModified;\n     }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 15,
        "jira_id": "3079",
        "nb_skipped": 1,
        "commit": "33c18762",
        "nb_failure": 1,
        "linesRem": 15,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1964,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 077d4b3950..388cca2ec3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -1330,9 +1330,6 @@ private boolean isCommitted(@Nonnull RevisionContext context,\n                                 @Nonnull Revision revision,\n                                 @Nullable String commitValue,\n                                 @Nonnull Revision readRevision) {\n-        if (revision.equalsIgnoreBranch(readRevision)) {\n-            return true;\n-        }\n         if (commitValue == null) {\n             commitValue = getCommitValue(revision);\n         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 0,
        "jira_id": "2288",
        "nb_skipped": 9,
        "commit": "57bd2dc5",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1859,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.query.IteratorsTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/FilterIterators.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/FilterIterators.java\nindex 11ae007bb6..6fba745bec 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/FilterIterators.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/FilterIterators.java\n@@ -205,9 +205,9 @@ private void init() {\n                 list.add(x);\n                 checkMemoryLimit(list.size(), settings);\n                 // from time to time, sort and truncate\n-                // this should results in O(n*log(2*keep)) operations,\n+                // this should need less than O(n*log(3*keep)) operations,\n                 // which is close to the optimum O(n*log(keep))\n-                if (list.size() > max * 2) {\n+                if (list.size() > (long) max * 2) {\n                     // remove tail entries right now, to save memory\n                     Collections.sort(list, orderBy);\n                     keepFirst(list, max);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "2418",
        "nb_skipped": 9,
        "commit": "039f892d",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 404,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.namepath.NamePathMapperImplTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrPathParser.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrPathParser.java\nindex 2dc5bee987..2854048aab 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrPathParser.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/JcrPathParser.java\n@@ -261,6 +261,7 @@ public static boolean parse(String jcrPath, Listener listener) {\n \n     public static boolean validate(String jcrPath) {\n         Listener listener = new Listener() {\n+            int depth;\n             boolean hasRoot;\n             @Override\n             public boolean root() {\n@@ -280,7 +281,8 @@ public boolean current() {\n \n             @Override\n             public boolean parent() {\n-                return true;\n+                depth--;\n+                return !hasRoot || depth >= 0;\n             }\n \n             @Override\n@@ -289,6 +291,7 @@ public void error(String message) {\n \n             @Override\n             public boolean name(String name, int index) {\n+                depth++;\n                 return true;\n             }\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\nindex 65639f1dcb..c19578ffe4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\n@@ -21,6 +21,7 @@\n \n import javax.annotation.Nonnull;\n \n+import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -77,7 +78,7 @@ public String getOakPathKeepIndex(String jcrPath) {\n \n     @Override\n     @Nonnull\n-    public String getJcrPath(String oakPath) {\n+    public String getJcrPath(final String oakPath) {\n         final List<String> elements = new ArrayList<String>();\n \n         if (\"/\".equals(oakPath)) {\n@@ -103,11 +104,18 @@ public boolean current() {\n \n             @Override\n             public boolean parent() {\n-                if (elements.isEmpty() || \"..\".equals(elements.get(elements.size() - 1))) {\n+                int prevIdx = elements.size() - 1;\n+                String prevElem = prevIdx >= 0 ? elements.get(prevIdx) : null;\n+\n+                if (prevElem == null || PathUtils.denotesParent(prevElem)) {\n                     elements.add(\"..\");\n                     return true;\n                 }\n-                elements.remove(elements.size() - 1);\n+                if (prevElem.isEmpty()) {\n+                    throw new IllegalArgumentException(\"Absolute path escapes root: \" + oakPath);\n+                }\n+\n+                elements.remove(prevElem);\n                 return true;\n             }\n \n@@ -150,7 +158,7 @@ public boolean name(String name, int index) {\n         return jcrPath.toString();\n     }\n \n-    private String getOakPath(String jcrPath, final boolean keepIndex) {\n+    private String getOakPath(final String jcrPath, final boolean keepIndex) {\n         if (\"/\".equals(jcrPath)) {\n             // avoid the need to special case the root path later on\n             return \"/\";\n@@ -237,11 +245,19 @@ public boolean current() {\n \n             @Override\n             public boolean parent() {\n-                if (elements.isEmpty() || \"..\".equals(elements.get(elements.size() - 1))) {\n+                int prevIdx = elements.size() - 1;\n+                String prevElem = prevIdx >= 0 ? elements.get(prevIdx) : null;\n+\n+                if (prevElem == null || PathUtils.denotesParent(prevElem)) {\n                     elements.add(\"..\");\n                     return true;\n                 }\n-                elements.remove(elements.size() - 1);\n+                if (prevElem.isEmpty()) {\n+                    parseErrors.append(\"Absolute path escapes root: \").append(jcrPath);\n+                    return false;\n+                }\n+\n+                elements.remove(prevElem);\n                 return true;\n             }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 26,
        "jira_id": "498",
        "nb_skipped": 0,
        "commit": "f2a2edec",
        "nb_failure": 3,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1253,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.mongomk.DocumentSplitTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java\nindex 9b6835f23b..dfe473d6f0 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java\n@@ -118,6 +118,11 @@\n \n     final DocumentStore store;\n \n+    /**\n+     * Parsed and sorted set of previous revisions.\n+     */\n+    private SortedMap<Revision, Range> previous;\n+\n     private final long time = System.currentTimeMillis();\n \n     NodeDocument(@Nonnull DocumentStore store) {\n@@ -151,19 +156,23 @@ public final long getCreated() {\n \n     /**\n      * Returns <code>true</code> if the given <code>revision</code> is marked\n-     * committed in <strong>this</strong> document including previous documents.\n+     * committed.\n      *\n      * @param revision the revision.\n      * @return <code>true</code> if committed; <code>false</code> otherwise.\n      */\n     public boolean isCommitted(@Nonnull Revision revision) {\n+        NodeDocument commitRootDoc = getCommitRoot(checkNotNull(revision));\n+        if (commitRootDoc == null) {\n+            return false;\n+        }\n         String rev = checkNotNull(revision).toString();\n-        String value = getLocalRevisions().get(rev);\n+        String value = commitRootDoc.getLocalRevisions().get(rev);\n         if (value != null) {\n             return Utils.isCommitted(value);\n         }\n         // check previous docs\n-        for (NodeDocument prev : getPreviousDocs(revision, REVISIONS)) {\n+        for (NodeDocument prev : commitRootDoc.getPreviousDocs(revision, REVISIONS)) {\n             if (prev.containsRevision(revision)) {\n                 return prev.isCommitted(revision);\n             }\n@@ -659,20 +668,26 @@ public boolean isConflicting(@Nonnull UpdateOp op,\n                     main.removeMapEntry(property, r);\n                     old.setMapEntry(property, r, entry.getValue());\n                 }\n+            }\n             splitOps.add(old);\n             splitOps.add(main);\n         }\n-        }\n         return splitOps;\n     }\n \n-    @Override\n+    /**\n+     * Returns previous revision ranges for this document. The revision keys are\n+     * sorted descending, newest first!\n+     *\n+     * @return the previous ranges for this document.\n+     */\n     @Nonnull\n-    protected Map<?, ?> transformAndSeal(@Nonnull Map<Object, Object> map,\n-                                         @Nullable String key,\n-                                         int level) {\n-        if (level == 1) {\n-            if (PREVIOUS.equals(key)) {\n+    SortedMap<Revision, Range> getPreviousRanges() {\n+        if (previous == null) {\n+            Map<String, String> map = getLocalMap(PREVIOUS);\n+            if (map.isEmpty()) {\n+                previous = EMPTY_RANGE_MAP;\n+            } else {\n                 SortedMap<Revision, Range> transformed = new TreeMap<Revision, Range>(\n                         new Comparator<Revision>() {\n                             @Override\n@@ -687,29 +702,13 @@ public int compare(Revision o1, Revision o2) {\n                                 return c;\n                             }\n                         });\n-                for (Map.Entry<Object, Object> entry : map.entrySet()) {\n-                    Revision high = Revision.fromString(entry.getKey().toString());\n-                    Revision low = Revision.fromString(entry.getValue().toString());\n+                for (Map.Entry<String, String> entry : map.entrySet()) {\n+                    Revision high = Revision.fromString(entry.getKey());\n+                    Revision low = Revision.fromString(entry.getValue());\n                     transformed.put(high, new Range(high, low));\n                 }\n-                return Collections.unmodifiableSortedMap(transformed);\n-            }\n-        }\n-        return super.transformAndSeal(map, key, level);\n+                previous = Collections.unmodifiableSortedMap(transformed);\n             }\n-\n-    /**\n-     * Returns previous revision ranges for this document. The revision keys are\n-     * sorted descending, newest first!\n-     *\n-     * @return the previous ranges for this document.\n-     */\n-    @Nonnull\n-    SortedMap<Revision, Range> getPreviousRanges() {\n-        @SuppressWarnings(\"unchecked\")\n-        SortedMap<Revision, Range> previous = (SortedMap<Revision, Range>) get(PREVIOUS);\n-        if (previous == null) {\n-            previous = EMPTY_RANGE_MAP;\n         }\n         return previous;\n     }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 19,
        "jira_id": "926",
        "nb_skipped": 8,
        "commit": "e1ae968c",
        "nb_failure": 1,
        "linesRem": 23,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1275,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\nindex d22c83bc6c..2cf9cef7db 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\n@@ -184,6 +184,10 @@ public boolean evaluate() {\n             appendString(buff, p);\n         } else {\n             String path = selector.currentPath();\n+            if (!PathUtils.denotesRoot(path)) {\n+                appendString(buff,\n+                        PropertyValues.newString(PathUtils.getName(path)));\n+            }\n             if (relativePath != null) {\n                 path = PathUtils.concat(path, relativePath);\n             }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 4,
        "jira_id": "1024",
        "nb_skipped": 8,
        "commit": "ecc5bdfd",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2166,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.VisibleChangesTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/VersionablePathHook.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/VersionablePathHook.java\nindex 9369ddeb54..132296a8c2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/VersionablePathHook.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/VersionablePathHook.java\n@@ -37,6 +37,7 @@\n import org.apache.jackrabbit.oak.spi.state.DefaultNodeStateDiff;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n+import org.apache.jackrabbit.oak.spi.state.NodeStateUtils;\n \n import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.EMPTY_NODE;\n \n@@ -108,6 +109,10 @@ public boolean childNodeAdded(String name, NodeState after) {\n         @Override\n         public boolean childNodeChanged(\n                 String name, NodeState before, NodeState after) {\n+            if (NodeStateUtils.isHidden(name)) {\n+                // stop comparison\n+                return false;\n+            }\n             Node node = new Node(nodeAfter, name);\n             return after.compareAgainstBaseState(\n                     before, new Diff(versionManager, node, exceptions));\n@@ -117,7 +122,8 @@ private boolean setVersionablePath(PropertyState after) {\n             if (JcrConstants.JCR_VERSIONHISTORY.equals(after.getName()) && nodeAfter.isVersionable(versionManager)) {\n                 NodeBuilder vhBuilder;\n                 try {\n-                    vhBuilder = versionManager.getOrCreateVersionHistory(nodeAfter.builder, Collections.EMPTY_MAP);\n+                    vhBuilder = versionManager.getOrCreateVersionHistory(\n+                            nodeAfter.builder, Collections.<String, Object>emptyMap());\n                 } catch (CommitFailedException e) {\n                     exceptions.add(e);\n                     // stop further comparison\n",
        "project": "jackrabbit-oak",
        "linesAdd": 6,
        "jira_id": "3019",
        "nb_skipped": 9,
        "commit": "5135cf4b",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 84,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.authentication.ldap.LdapProviderTest"
        ],
        "patch": "diff --git a/oak-auth-ldap/src/main/java/org/apache/jackrabbit/oak/security/authentication/ldap/impl/LdapIdentityProvider.java b/oak-auth-ldap/src/main/java/org/apache/jackrabbit/oak/security/authentication/ldap/impl/LdapIdentityProvider.java\nindex e6b2ba4710..512a1bf1c9 100644\n--- a/oak-auth-ldap/src/main/java/org/apache/jackrabbit/oak/security/authentication/ldap/impl/LdapIdentityProvider.java\n+++ b/oak-auth-ldap/src/main/java/org/apache/jackrabbit/oak/security/authentication/ldap/impl/LdapIdentityProvider.java\n@@ -702,7 +702,13 @@ private ExternalUser createUser(@Nonnull Entry entry, @CheckForNull String id)\n             throws LdapInvalidAttributeValueException {\n         ExternalIdentityRef ref = new ExternalIdentityRef(entry.getDn().getName(), this.getName());\n         if (id == null) {\n-            id = entry.get(config.getUserConfig().getIdAttribute()).getString();\n+            String idAttribute = config.getUserConfig().getIdAttribute();\n+            Attribute attr = entry.get(idAttribute);\n+            if (attr == null) {\n+                throw new LdapInvalidAttributeValueException(ResultCodeEnum.CONSTRAINT_VIOLATION,\n+                        \"no value found for attribute '\" + idAttribute + \"' for entry \" + entry);\n+            }\n+            id = attr.getString();\n         }\n         String path = config.getUserConfig().makeDnPath()\n                 ? createDNPath(entry.getDn())\n@@ -718,7 +724,13 @@ private ExternalGroup createGroup(@Nonnull Entry entry, @CheckForNull String nam\n             throws LdapInvalidAttributeValueException {\n         ExternalIdentityRef ref = new ExternalIdentityRef(entry.getDn().getName(), this.getName());\n         if (name == null) {\n-            name = entry.get(config.getGroupConfig().getIdAttribute()).getString();\n+            String idAttribute = config.getGroupConfig().getIdAttribute();\n+            Attribute attr = entry.get(idAttribute);\n+            if (attr == null) {\n+                throw new LdapInvalidAttributeValueException(ResultCodeEnum.CONSTRAINT_VIOLATION,\n+                        \"no value found for attribute '\" + idAttribute + \"' for entry \" + entry);\n+            }\n+            name = attr.getString();\n         }\n         String path = config.getGroupConfig().makeDnPath()\n                 ? createDNPath(entry.getDn())\n",
        "project": "jackrabbit-oak",
        "linesAdd": 14,
        "jira_id": "3396",
        "nb_skipped": 1,
        "commit": "c83755c3",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 99,
        "nb_error": 4,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.upgrade.CopyVersionHistoryTest"
        ],
        "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\nindex f4684cc4a3..93b5133a54 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n@@ -462,7 +462,7 @@ protected Root getWriteRoot() {\n                 createIndexEditorProvider()\n             )));\n \n-            target.merge(builder, new LoggingCompositeHook(hooks, source, earlyShutdown), CommitInfo.EMPTY);\n+            target.merge(builder, new LoggingCompositeHook(hooks, source, overrideEarlyShutdown()), CommitInfo.EMPTY);\n             logger.info(\"Processing commit hooks completed in {}s ({})\", watch.elapsed(TimeUnit.SECONDS), watch);\n             logger.debug(\"Repository upgrade completed.\");\n         } catch (Exception e) {\n@@ -470,6 +470,24 @@ protected Root getWriteRoot() {\n         }\n     }\n \n+    private boolean overrideEarlyShutdown() {\n+        if (earlyShutdown == false) {\n+            return false;\n+        }\n+\n+        final VersionCopyConfiguration c = this.versionCopyConfiguration;\n+        if (c.isCopyVersions() && c.skipOrphanedVersionsCopy()) {\n+            logger.info(\"Overriding early shutdown to false because of the copy versions settings\");\n+            return false;\n+        }\n+        if (c.isCopyVersions() && !c.skipOrphanedVersionsCopy()\n+                && c.getOrphanedMinDate().after(c.getVersionsMinDate())) {\n+            logger.info(\"Overriding early shutdown to false because of the copy versions settings\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n     private static EditorProvider createTypeEditorProvider() {\n         return new EditorProvider() {\n             @Override\n",
        "project": "jackrabbit-oak",
        "linesAdd": 19,
        "jira_id": "3249",
        "nb_skipped": 0,
        "commit": "64712735",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1607,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.query.QueryTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/QueryImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/QueryImpl.java\nindex 0ee38df..acff663 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/QueryImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/QueryImpl.java\n@@ -34,9 +34,10 @@ import javax.jcr.version.VersionException;\n \n import org.apache.jackrabbit.JcrConstants;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n+import org.apache.jackrabbit.oak.jcr.delegate.NodeDelegate;\n import org.apache.jackrabbit.oak.jcr.session.NodeImpl;\n import org.apache.jackrabbit.oak.jcr.session.SessionContext;\n-import org.apache.jackrabbit.oak.jcr.delegate.NodeDelegate;\n+import org.apache.jackrabbit.oak.jcr.session.operation.SessionOperation;\n \n /**\n  * The implementation of the corresponding JCR interface.\n@@ -86,7 +87,14 @@ public class QueryImpl implements Query {\n \n     @Override\n     public QueryResult execute() throws RepositoryException {\n-        return manager.executeQuery(statement, language, limit, offset, bindVariableMap);\n+        return sessionContext.getSessionDelegate().perform(\n+                new SessionOperation<QueryResult>() {\n+                    @Override\n+                    public QueryResult perform() throws RepositoryException {\n+                        return manager.executeQuery(statement, language, limit,\n+                                offset, bindVariableMap);\n+                    }\n+                });\n     }\n \n     @Override\n",
        "project": "jackrabbit-oak",
        "linesAdd": 10,
        "jira_id": "1096",
        "nb_skipped": 3,
        "commit": "be44b816",
        "nb_failure": 3,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1517,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\nindex 91a257bffa..3cf0717291 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n@@ -516,7 +516,7 @@ private Expression parsePropertyOrFunction() throws ParseException {\n         boolean isPath = false;\n         while (true) {\n             if (currentTokenType == IDENTIFIER) {\n-                String name = readIdentifier();\n+                String name = readPathSegment();\n                 buff.append(name);\n             } else if (readIf(\"*\")) {\n                 // any node\n@@ -533,7 +533,7 @@ private Expression parsePropertyOrFunction() throws ParseException {\n                     // xpath supports @*, even thought jackrabbit may not\n                     buff.append('*');\n                 } else {\n-                    buff.append(readIdentifier());\n+                    buff.append(readPathSegment());\n                 }\n                 return new Expression.Property(currentSelector, buff.toString());\n             } else {\n@@ -649,7 +649,7 @@ private void read(String expected) throws ParseException {\n         if (readIf(\"*\")) {\n             return new Expression.Property(currentSelector, \"*\");\n         }\n-        return new Expression.Property(currentSelector, readIdentifier());\n+        return new Expression.Property(currentSelector, readPathSegment());\n     }\n     \n     private void readExcerpt() throws ParseException {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "1308",
        "nb_skipped": 6,
        "commit": "69ba2a54",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1946,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.OrderedPropertyIndexQueryTest",
            "org.apache.jackrabbit.oak.plugins.index.property.OrderedPropertyIndexDescendingQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java\nindex 0574916b5a..b6753249db 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java\n@@ -191,7 +191,7 @@ public Cursor query(IndexPlan plan, NodeState root) {\n         PropertyRestriction pr = plan.getPropertyRestriction();\n         if (pr != null) {\n             String propertyName = PathUtils.getName(pr.propertyName);\n-            depth = PathUtils.getDepth(propertyName);\n+            depth = PathUtils.getDepth(pr.propertyName);\n             paths = strategy.query(plan.getFilter(), propertyName,\n                     plan.getDefinition(), pr, pathPrefix);\n         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "2219",
        "nb_skipped": 9,
        "commit": "f2740ce1",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 78,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.mk.store.DefaultRevisionStoreTest"
        ],
        "patch": "diff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/store/DefaultRevisionStore.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/store/DefaultRevisionStore.java\nindex 4e299c3f81..533ccc80f8 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/store/DefaultRevisionStore.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/store/DefaultRevisionStore.java\n@@ -223,12 +223,12 @@ protected static int determineInitialCacheSize() {\n      */\n     static class PutTokenImpl extends PutToken {\n \n-        private static int idCounter;\n+        private static final AtomicInteger ID_COUNTER = new AtomicInteger();\n         private int id;\n         private StoredNode lastModifiedNode;\n \n         public PutTokenImpl() {\n-            this.id = ++idCounter;\n+            this.id = ID_COUNTER.incrementAndGet();\n         }\n \n         @Override\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "543",
        "nb_skipped": 2,
        "commit": "3ce758b7",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1497,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.segment.RecordTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/ListRecord.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/ListRecord.java\nindex df2735efe4..27b5cba543 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/ListRecord.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/ListRecord.java\n@@ -57,8 +57,10 @@ public RecordId getEntry(int index) {\n             int bucketIndex = index / bucketSize;\r\n             int bucketOffset = index % bucketSize;\r\n             Segment segment = getSegment();\r\n-            RecordId bucketId = segment.readRecordId(getOffset(0, bucketIndex));\r\n-            ListRecord bucket = new ListRecord(segment, bucketId, bucketSize);\r\n+            RecordId id = segment.readRecordId(getOffset(0, bucketIndex));\r\n+            ListRecord bucket = new ListRecord(\r\n+                    segment, id,\r\n+                    Math.min(bucketSize, size - bucketIndex * bucketSize));\r\n             return bucket.getEntry(bucketOffset);\r\n         }\r\n     }\r\n@@ -78,7 +80,7 @@ public RecordId getEntry(int index) {\n                     list.add(id);\r\n                 } else {\r\n                     ListRecord bucket = new ListRecord(\r\n-                            segment, id, Math.min(bucketSize, size - offset));\r\n+                            segment, id, Math.min(bucketSize, size - i));\r\n                     list.addAll(bucket.getEntries());\r\n                 }\r\n                 offset += Segment.RECORD_ID_BYTES;\r\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\nindex a961cbf432..aeb7e98717 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n@@ -340,6 +340,7 @@ private MapRecord writeMapBranch(int level, int size, MapRecord[] buckets) {\n \n \n     private synchronized RecordId writeListBucket(List<RecordId> bucket) {\n+        checkArgument(bucket.size() > 1);\n         RecordId bucketId = prepare(RecordType.BUCKET, 0, bucket);\n         for (RecordId id : bucket) {\n             writeRecordId(id);\n@@ -516,7 +517,11 @@ public RecordId writeList(List<RecordId> list) {\n             List<RecordId> nextLevel = Lists.newArrayList();\n             for (List<RecordId> bucket :\n                     Lists.partition(thisLevel, ListRecord.LEVEL_SIZE)) {\n+                if (bucket.size() > 1) {\n                     nextLevel.add(writeListBucket(bucket));\n+                } else {\n+                    nextLevel.add(bucket.get(0));\n+                }\n             }\n             thisLevel = nextLevel;\n         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 10,
        "jira_id": "1287",
        "nb_skipped": 6,
        "commit": "14849e22",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 261,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest",
            "org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinitionTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\nindex 465ff12d1a..8642545ec7 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n@@ -748,6 +748,12 @@ public boolean isAggregated(String nodePath) {\n          *         <code>false</code> otherwise.\n          */\n         public boolean appliesTo(Tree state) {\n+            for (String mixinName : getMixinTypeNames(state)){\n+                if (nodeTypeName.equals(mixinName)){\n+                    return true;\n+                }\n+            }\n+\n             if (!nodeTypeName.equals(getPrimaryTypeName(state))) {\n                 return false;\n             }\n@@ -1242,7 +1248,7 @@ private static String getPrimaryTypeName(Tree state) {\n     }\n \n     private static Iterable<String> getMixinTypeNames(Tree tree) {\n-        PropertyState property = tree.getProperty(JcrConstants.JCR_MIMETYPE);\n+        PropertyState property = tree.getProperty(JcrConstants.JCR_MIXINTYPES);\n         return property != null ? property.getValue(Type.NAMES) : Collections.<String>emptyList();\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 7,
        "jira_id": "3318",
        "nb_skipped": 4,
        "commit": "e12e2052",
        "nb_failure": 3,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.spi.security.authentication.external.ExternalLoginModuleTest"
        ],
        "patch": "diff --git a/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/impl/DefaultSyncHandler.java b/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/impl/DefaultSyncHandler.java\nindex 43afa31067..be7be374dc 100644\n--- a/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/impl/DefaultSyncHandler.java\n+++ b/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/impl/DefaultSyncHandler.java\n@@ -644,7 +644,12 @@ private void syncProperties(ExternalIdentity ext, Authorizable auth, Map<String,\n                 String name = entry.getValue();\n                 Object obj = properties.get(name);\n                 if (obj == null) {\n+                    int nameLen = name.length();\n+                    if (nameLen > 1 && name.charAt(0) == '\"' && name.charAt(nameLen-1) == '\"') {\n+                        auth.setProperty(relPath, valueFactory.createValue(name.substring(1, nameLen - 1)));\n+                    } else {\n                         auth.removeProperty(relPath);\n+                    }\n                 } else {\n                     if (obj instanceof Collection) {\n                         auth.setProperty(relPath, createValues((Collection) obj));\n",
        "project": "jackrabbit-oak",
        "linesAdd": 5,
        "jira_id": "1848",
        "nb_skipped": 0,
        "commit": "093b9128",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 6,
        "nb_test": 93,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.mk.ConcurrentWriteTest"
        ],
        "patch": "diff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/core/MicroKernelImpl.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/core/MicroKernelImpl.java\nindex 24459590f8..2cbb066d7e 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/core/MicroKernelImpl.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/core/MicroKernelImpl.java\n@@ -18,9 +18,7 @@\n \n import java.io.InputStream;\n import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.HashMap;\n-import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n \n@@ -31,6 +29,7 @@\n import org.apache.jackrabbit.mk.model.ChildNodeEntry;\n import org.apache.jackrabbit.mk.model.Commit;\n import org.apache.jackrabbit.mk.model.CommitBuilder;\n+import org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree;\n import org.apache.jackrabbit.mk.model.Id;\n import org.apache.jackrabbit.mk.model.NodeState;\n import org.apache.jackrabbit.mk.model.PropertyState;\n@@ -40,7 +39,6 @@\n import org.apache.jackrabbit.mk.store.RevisionProvider;\n import org.apache.jackrabbit.mk.util.CommitGate;\n import org.apache.jackrabbit.mk.util.PathUtils;\n-import org.apache.jackrabbit.mk.util.SimpleLRUCache;\n \n /**\n  *\n@@ -50,11 +48,6 @@\n     protected Repository rep;\n     private final CommitGate gate = new CommitGate();\n \n-    /**\n-     * Key: revision id, Value: diff string\n-     */\n-    private final Map<Id, String> diffCache = Collections.synchronizedMap(SimpleLRUCache.<Id, String>newInstance(100));\n-\n     public MicroKernelImpl(String homeDir) throws MicroKernelException {\n         init(homeDir);\n     }\n@@ -97,7 +90,6 @@ public void dispose() {\n             }\n             rep = null;\n         }\n-        diffCache.clear();\n     }\n \n     public String getHeadRevision() throws MicroKernelException {\n@@ -211,13 +203,8 @@ public String getJournal(String fromRevision, String toRevision, String filter)\n             commitBuff.object().\n                     key(\"id\").value(commit.getId().toString()).\n                     key(\"ts\").value(commit.getCommitTS()).\n-                    key(\"msg\").value(commit.getMsg());\n-            String diff = diffCache.get(commit.getId());\n-            if (diff == null) {\n-                diff = diff(commit.getParentId(), commit.getId(), filter);\n-                diffCache.put(commit.getId(), diff);\n-            }\n-            commitBuff.key(\"changes\").value(diff).endObject();\n+                    key(\"msg\").value(commit.getMsg()).\n+                    key(\"changes\").value(commit.getChanges()).endObject();\n         }\n         return commitBuff.endArray().toString();\n     }\n@@ -478,12 +465,7 @@ public String commit(String path, String jsonDiff, String revision, String messa\n                             }\n                             String parentPath = PathUtils.getParentPath(nodePath);\n                             String nodeName = PathUtils.getName(nodePath);\n-                            // build the list of added nodes recursively\n-                            LinkedList<AddNodeOperation> list = new LinkedList<AddNodeOperation>();\n-                            addNode(list, parentPath, nodeName, t);\n-                            for (AddNodeOperation op : list) {\n-                                cb.addNode(op.path, op.name, op.props);\n-                            }\n+                            cb.addNode(parentPath, nodeName, parseNode(t));\n                         } else {\n                             String value;\n                             if (t.matches(JsopTokenizer.NULL)) {\n@@ -637,30 +619,20 @@ void toJson(JsopBuilder builder, NodeState node, int depth, int offset, int coun\n         }\n     }\n     \n-    static void addNode(LinkedList<AddNodeOperation> list, String path, String name, JsopTokenizer t) throws Exception {\n-        AddNodeOperation op = new AddNodeOperation();\n-        op.path = path;\n-        op.name = name;\n-        list.add(op);\n+    NodeTree parseNode(JsopTokenizer t) throws Exception {\n+        NodeTree node = new NodeTree();\n         if (!t.matches('}')) {\n             do {\n                 String key = t.readString();\n                 t.read(':');\n                 if (t.matches('{')) {\n-                    addNode(list, PathUtils.concat(path, name), key, t);\n+                    node.nodes.put(key, parseNode(t));\n                 } else {\n-                    op.props.put(key, t.readRawValue().trim());\n+                    node.props.put(key, t.readRawValue().trim());\n                 }\n             } while (t.matches(','));\n             t.read('}');\n         }\n+        return node;\n     }\n-\n-    //--------------------------------------------------------< inner classes >\n-    static class AddNodeOperation {\n-        String path;\n-        String name;\n-        Map<String, String> props = new HashMap<String, String>();\n-    }\n-\n }\ndiff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/AbstractCommit.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/AbstractCommit.java\nindex 97f2dea4b9..4f766ee36e 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/AbstractCommit.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/AbstractCommit.java\n@@ -32,6 +32,9 @@\n     // commit message\n     protected String msg;\n \n+    // changes\n+    protected String changes;\n+\n     // id of parent commit\n     protected Id parentId;\n \n@@ -42,6 +45,7 @@ protected AbstractCommit(Commit other) {\n         this.parentId = other.getParentId();\n         this.rootNodeId = other.getRootNodeId();\n         this.msg = other.getMsg();\n+        this.changes = other.getChanges();\n         this.commitTS = other.getCommitTS();\n     }\n \n@@ -61,10 +65,15 @@ public String getMsg() {\n         return msg;\n     }\n \n+    public String getChanges() {\n+        return changes;\n+    }\n+\n     public void serialize(Binding binding) throws Exception {\n         binding.write(\"rootNodeId\", rootNodeId.getBytes());\n         binding.write(\"commitTS\", commitTS);\n         binding.write(\"msg\", msg == null ? \"\" : msg);\n+        binding.write(\"changes\", changes == null ? \"\" : changes);\n         binding.write(\"parentId\", parentId == null ? \"\" : parentId.toString());\n     }\n }\ndiff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/Commit.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/Commit.java\nindex 82501a0450..697693cb03 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/Commit.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/Commit.java\n@@ -31,5 +31,7 @@\n \n     public String getMsg();\n \n+    public String getChanges();\n+\n     void serialize(Binding binding) throws Exception;\n }\ndiff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/CommitBuilder.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/CommitBuilder.java\nindex 645851b8ad..b7cfc9c37e 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/CommitBuilder.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/CommitBuilder.java\n@@ -50,130 +50,39 @@ public CommitBuilder(Id baseRevId, String msg, RevisionStore store) throws Excep\n         this.store = store;\n     }\n \n-    public void addNode(String parentNodePath, String nodeName) throws Exception {\n-        addNode(parentNodePath, nodeName, Collections.<String, String>emptyMap());\n-    }\n-\n-    public void addNode(String parentNodePath, String nodeName, Map<String, String> properties) throws Exception {\n-        MutableNode modParent = getOrCreateStagedNode(parentNodePath);\n-        if (modParent.getChildNodeEntry(nodeName) != null) {\n-            throw new Exception(\"there's already a child node with name '\" + nodeName + \"'\");\n-        }\n-        String newPath = PathUtils.concat(parentNodePath, nodeName);\n-        MutableNode newChild = new MutableNode(store, newPath);\n-        newChild.getProperties().putAll(properties);\n-\n-        // id will be computed on commit\n-        modParent.add(new ChildNode(nodeName, null));\n-        staged.put(newPath, newChild);\n+    public void addNode(String parentNodePath, String nodeName, NodeTree node) throws Exception {\n+        Change change = new AddNode(parentNodePath, nodeName, node);\n+        change.apply();\n         // update change log\n-        changeLog.add(new AddNode(parentNodePath, nodeName, properties));\n+        changeLog.add(change);\n     }\n \n     public void removeNode(String nodePath) throws NotFoundException, Exception {\n-        String parentPath = PathUtils.getParentPath(nodePath);\n-        String nodeName = PathUtils.getName(nodePath);\n-\n-        MutableNode parent = getOrCreateStagedNode(parentPath);\n-        if (parent.remove(nodeName) == null) {\n-            throw new NotFoundException(nodePath);\n-        }\n-\n-        // update staging area\n-        removeStagedNodes(nodePath);\n-\n+        Change change = new RemoveNode(nodePath);\n+        change.apply();\n         // update change log\n-        changeLog.add(new RemoveNode(nodePath));\n+        changeLog.add(change);\n     }\n \n     public void moveNode(String srcPath, String destPath) throws NotFoundException, Exception {\n-        if (PathUtils.isAncestor(srcPath, destPath)) {\n-            throw new Exception(\"target path cannot be descendant of source path: \" + destPath);\n-        }\n-\n-        String srcParentPath = PathUtils.getParentPath(srcPath);\n-        String srcNodeName = PathUtils.getName(srcPath);\n-\n-        String destParentPath = PathUtils.getParentPath(destPath);\n-        String destNodeName = PathUtils.getName(destPath);\n-\n-        MutableNode srcParent = getOrCreateStagedNode(srcParentPath);\n-        if (srcParentPath.equals(destParentPath)) {\n-            if (srcParent.getChildNodeEntry(destNodeName) != null) {\n-                throw new Exception(\"node already exists at move destination path: \" + destPath);\n-            }\n-            if (srcParent.rename(srcNodeName, destNodeName) == null) {\n-                throw new NotFoundException(srcPath);\n-            }\n-        } else {\n-            ChildNode srcCNE = srcParent.remove(srcNodeName);\n-            if (srcCNE == null) {\n-                throw new NotFoundException(srcPath);\n-            }\n-\n-            MutableNode destParent = getOrCreateStagedNode(destParentPath);\n-            if (destParent.getChildNodeEntry(destNodeName) != null) {\n-                throw new Exception(\"node already exists at move destination path: \" + destPath);\n-            }\n-            destParent.add(new ChildNode(destNodeName, srcCNE.getId()));\n-        }\n-\n-        // update staging area\n-        moveStagedNodes(srcPath, destPath);\n-\n+        Change change = new MoveNode(srcPath, destPath);\n+        change.apply();\n         // update change log\n-        changeLog.add(new MoveNode(srcPath, destPath));\n+        changeLog.add(change);\n     }\n \n     public void copyNode(String srcPath, String destPath) throws NotFoundException, Exception {\n-        String srcParentPath = PathUtils.getParentPath(srcPath);\n-        String srcNodeName = PathUtils.getName(srcPath);\n-\n-        String destParentPath = PathUtils.getParentPath(destPath);\n-        String destNodeName = PathUtils.getName(destPath);\n-\n-        MutableNode srcParent = getOrCreateStagedNode(srcParentPath);\n-        ChildNode srcCNE = srcParent.getChildNodeEntry(srcNodeName);\n-        if (srcCNE == null) {\n-            throw new NotFoundException(srcPath);\n-        }\n-\n-        MutableNode destParent = getOrCreateStagedNode(destParentPath);\n-        destParent.add(new ChildNode(destNodeName, srcCNE.getId()));\n-\n-        if (srcCNE.getId() == null) {\n-            // a 'new' node is being copied\n-\n-            // update staging area\n-            copyStagedNodes(srcPath, destPath);\n-        }\n-\n+        Change change = new CopyNode(srcPath, destPath);\n+        change.apply();\n         // update change log\n-        changeLog.add(new CopyNode(srcPath, destPath));\n+        changeLog.add(change);\n     }\n \n     public void setProperty(String nodePath, String propName, String propValue) throws Exception {\n-        MutableNode node = getOrCreateStagedNode(nodePath);\n-\n-        Map<String, String> properties = node.getProperties();\n-        if (propValue == null) {\n-            properties.remove(propName);\n-        } else {\n-            properties.put(propName, propValue);\n-        }\n-\n-        // update change log\n-        changeLog.add(new SetProperty(nodePath, propName, propValue));\n-    }\n-\n-    public void setProperties(String nodePath, Map<String, String> properties) throws Exception {\n-        MutableNode node = getOrCreateStagedNode(nodePath);\n-\n-        node.getProperties().clear();\n-        node.getProperties().putAll(properties);\n-\n+        Change change = new SetProperty(nodePath, propName, propValue);\n+        change.apply();\n         // update change log\n-        changeLog.add(new SetProperties(nodePath, properties));\n+        changeLog.add(change);\n     }\n \n     public Id /* new revId */ doCommit() throws Exception {\n@@ -190,9 +99,7 @@ public void setProperties(String nodePath, Map<String, String> properties) throw\n             // clear staging area\n             staged.clear();\n             // replay change log on new base revision\n-            // copy log in order to avoid concurrent modifications\n-            List<Change> log = new ArrayList<Change>(changeLog);\n-            for (Change change : log) {\n+            for (Change change : changeLog) {\n                 change.apply();\n             }\n         }\n@@ -222,19 +129,29 @@ public void setProperties(String nodePath, Map<String, String> properties) throw\n             newCommit.setParentId(baseRevId);\n             newCommit.setCommitTS(System.currentTimeMillis());\n             newCommit.setMsg(msg);\n+            StringBuilder diff = new StringBuilder();\n+            for (Change change : changeLog) {\n+                if (diff.length() > 0) {\n+                    diff.append('\\n');\n+                }\n+                diff.append(change.asDiff());\n+            }\n+            newCommit.setChanges(diff.toString());\n             newCommit.setRootNodeId(rootNodeId);\n             newRevId = store.putHeadCommit(newCommit);\n         } finally {\n             store.unlockHead();\n         }\n \n-        // reset instance in order to be reusable\n+        // reset instance\n         staged.clear();\n         changeLog.clear();\n \n         return newRevId;\n     }\n \n+    //--------------------------------------------------------< inner classes >\n+\n     MutableNode getOrCreateStagedNode(String nodePath) throws Exception {\n         MutableNode node = staged.get(nodePath);\n         if (node == null) {\n@@ -418,23 +335,79 @@ void mergeNode(StoredNode baseNode, StoredNode ourNode, StoredNode theirNode, St\n     }\n \n     //--------------------------------------------------------< inner classes >\n+\n+    public static class NodeTree {\n+        public Map<String, String> props = new HashMap<String, String>();\n+        public Map<String, NodeTree> nodes = new HashMap<String, NodeTree>();\n+\n+        void toJson(StringBuffer buf) {\n+            toJson(buf, this);\n+        }\n+\n+        private static void toJson(StringBuffer buf, NodeTree node) {\n+            buf.append('{');\n+            for (String name : node.props.keySet()) {\n+                if (buf.charAt(buf.length() - 1) != '{')  {\n+                    buf.append(',');\n+                }\n+                buf.append('\"').append(name).append(\"\\\":\").append(node.props.get(name));\n+            }\n+            for (String name : node.nodes.keySet()) {\n+                if (buf.charAt(buf.length() - 1) != '{')  {\n+                    buf.append(',');\n+                }\n+                buf.append('\"').append(name).append(\"\\\":\");\n+                toJson(buf, node.nodes.get(name));\n+            }\n+            buf.append('}');\n+        }\n+    }\n+\n     abstract class Change {\n         abstract void apply() throws Exception;\n+        abstract String asDiff();\n     }\n \n     class AddNode extends Change {\n         String parentNodePath;\n         String nodeName;\n-        Map<String, String> properties;\n+        NodeTree node;\n \n-        AddNode(String parentNodePath, String nodeName, Map<String, String> properties) {\n+        AddNode(String parentNodePath, String nodeName, NodeTree node) {\n             this.parentNodePath = parentNodePath;\n             this.nodeName = nodeName;\n-            this.properties = properties;\n+            this.node = node;\n         }\n \n+        @Override\n         void apply() throws Exception {\n-            addNode(parentNodePath, nodeName, properties);\n+            recursiveAddNode(parentNodePath, nodeName, node);\n+        }\n+\n+        @Override\n+        String asDiff() {\n+            StringBuffer diff = new StringBuffer(\"+\");\n+            diff.append('\"').append(PathUtils.concat(parentNodePath, nodeName)).append(\"\\\":\");\n+            node.toJson(diff);\n+            return diff.toString();\n+        }\n+\n+        private void recursiveAddNode(String parentPath, String name, NodeTree node) throws Exception {\n+            MutableNode modParent = getOrCreateStagedNode(parentPath);\n+            if (modParent.getChildNodeEntry(name) != null) {\n+                throw new Exception(\"there's already a child node with name '\" + name + \"'\");\n+            }\n+            String newPath = PathUtils.concat(parentPath, name);\n+            MutableNode newChild = new MutableNode(store, newPath);\n+            newChild.getProperties().putAll(node.props);\n+\n+            // id will be computed on commit\n+            modParent.add(new ChildNode(name, null));\n+            staged.put(newPath, newChild);\n+\n+            for (String childName : node.nodes.keySet()) {\n+                recursiveAddNode(PathUtils.concat(parentPath, name), childName, node.nodes.get(childName));\n+            }\n         }\n     }\n \n@@ -445,8 +418,25 @@ void apply() throws Exception {\n             this.nodePath = nodePath;\n         }\n \n+        @Override\n         void apply() throws Exception {\n-            removeNode(nodePath);\n+            String parentPath = PathUtils.getParentPath(nodePath);\n+            String nodeName = PathUtils.getName(nodePath);\n+\n+            MutableNode parent = getOrCreateStagedNode(parentPath);\n+            if (parent.remove(nodeName) == null) {\n+                throw new NotFoundException(nodePath);\n+            }\n+\n+            // update staging area\n+            removeStagedNodes(nodePath);\n+        }\n+\n+        @Override\n+        String asDiff() {\n+            StringBuffer diff = new StringBuffer(\"-\");\n+            diff.append('\"').append(nodePath).append('\"');\n+            return diff.toString();\n         }\n     }\n \n@@ -459,8 +449,48 @@ void apply() throws Exception {\n             this.destPath = destPath;\n         }\n \n+        @Override\n         void apply() throws Exception {\n-            moveNode(srcPath, destPath);\n+            if (PathUtils.isAncestor(srcPath, destPath)) {\n+                throw new Exception(\"target path cannot be descendant of source path: \" + destPath);\n+            }\n+\n+            String srcParentPath = PathUtils.getParentPath(srcPath);\n+            String srcNodeName = PathUtils.getName(srcPath);\n+\n+            String destParentPath = PathUtils.getParentPath(destPath);\n+            String destNodeName = PathUtils.getName(destPath);\n+\n+            MutableNode srcParent = getOrCreateStagedNode(srcParentPath);\n+            if (srcParentPath.equals(destParentPath)) {\n+                if (srcParent.getChildNodeEntry(destNodeName) != null) {\n+                    throw new Exception(\"node already exists at move destination path: \" + destPath);\n+                }\n+                if (srcParent.rename(srcNodeName, destNodeName) == null) {\n+                    throw new NotFoundException(srcPath);\n+                }\n+            } else {\n+                ChildNode srcCNE = srcParent.remove(srcNodeName);\n+                if (srcCNE == null) {\n+                    throw new NotFoundException(srcPath);\n+                }\n+\n+                MutableNode destParent = getOrCreateStagedNode(destParentPath);\n+                if (destParent.getChildNodeEntry(destNodeName) != null) {\n+                    throw new Exception(\"node already exists at move destination path: \" + destPath);\n+                }\n+                destParent.add(new ChildNode(destNodeName, srcCNE.getId()));\n+            }\n+\n+            // update staging area\n+            moveStagedNodes(srcPath, destPath);\n+        }\n+\n+        @Override\n+        String asDiff() {\n+            StringBuffer diff = new StringBuffer(\">\");\n+            diff.append('\"').append(srcPath).append(\"\\\":\\\"\").append(destPath).append('\"');\n+            return diff.toString();\n         }\n     }\n \n@@ -473,8 +503,36 @@ void apply() throws Exception {\n             this.destPath = destPath;\n         }\n \n+        @Override\n         void apply() throws Exception {\n-            copyNode(srcPath, destPath);\n+            String srcParentPath = PathUtils.getParentPath(srcPath);\n+            String srcNodeName = PathUtils.getName(srcPath);\n+\n+            String destParentPath = PathUtils.getParentPath(destPath);\n+            String destNodeName = PathUtils.getName(destPath);\n+\n+            MutableNode srcParent = getOrCreateStagedNode(srcParentPath);\n+            ChildNode srcCNE = srcParent.getChildNodeEntry(srcNodeName);\n+            if (srcCNE == null) {\n+                throw new NotFoundException(srcPath);\n+            }\n+\n+            MutableNode destParent = getOrCreateStagedNode(destParentPath);\n+            destParent.add(new ChildNode(destNodeName, srcCNE.getId()));\n+\n+            if (srcCNE.getId() == null) {\n+                // a 'new' node is being copied\n+\n+                // update staging area\n+                copyStagedNodes(srcPath, destPath);\n+            }\n+        }\n+\n+        @Override\n+        String asDiff() {\n+            StringBuffer diff = new StringBuffer(\"*\");\n+            diff.append('\"').append(srcPath).append(\"\\\":\\\"\").append(destPath).append('\"');\n+            return diff.toString();\n         }\n     }\n \n@@ -489,22 +547,23 @@ void apply() throws Exception {\n             this.propValue = propValue;\n         }\n \n+        @Override\n         void apply() throws Exception {\n-            setProperty(nodePath, propName, propValue);\n-        }\n-    }\n-\n-    class SetProperties extends Change {\n-        String nodePath;\n-        Map<String, String> properties;\n+            MutableNode node = getOrCreateStagedNode(nodePath);\n \n-        SetProperties(String nodePath, Map<String, String> properties) {\n-            this.nodePath = nodePath;\n-            this.properties = properties;\n+            Map<String, String> properties = node.getProperties();\n+            if (propValue == null) {\n+                properties.remove(propName);\n+            } else {\n+                properties.put(propName, propValue);\n+            }\n         }\n \n-        void apply() throws Exception {\n-            setProperties(nodePath, properties);\n+        @Override\n+        String asDiff() {\n+            StringBuffer diff = new StringBuffer(\"^\");\n+            diff.append('\"').append(PathUtils.concat(nodePath, propName)).append(\"\\\":\").append(propValue);\n+            return diff.toString();\n         }\n     }\n }\ndiff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/MutableCommit.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/MutableCommit.java\nindex 0992938a26..4a3312ca31 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/MutableCommit.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/MutableCommit.java\n@@ -39,6 +39,7 @@ public MutableCommit(StoredCommit other) {\n         setRootNodeId(other.getRootNodeId());\n         setCommitTS(other.getCommitTS());\n         setMsg(other.getMsg());\n+        setChanges(other.getChanges());\n         this.id = other.getId();\n     }\n \n@@ -58,6 +59,10 @@ public void setMsg(String msg) {\n         this.msg = msg;\n     }\n \n+    public void setChanges(String changes) {\n+        this.changes = changes;\n+    }\n+\n     /**\n      * Return the commit id.\n      * \ndiff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/StoredCommit.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/StoredCommit.java\nindex 0cb15b75f6..95206c4571 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/StoredCommit.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/StoredCommit.java\n@@ -29,17 +29,19 @@ public static StoredCommit deserialize(Id id, Binding binding) throws Exception\n         Id rootNodeId = new Id(binding.readBytesValue(\"rootNodeId\"));\n         long commitTS = binding.readLongValue(\"commitTS\");\n         String msg = binding.readStringValue(\"msg\");\n+        String changes = binding.readStringValue(\"changes\");\n         String parentId = binding.readStringValue(\"parentId\");\n         return new StoredCommit(id, \"\".equals(parentId) ? null : Id.fromString(parentId),\n-                commitTS, rootNodeId, \"\".equals(msg) ? null : msg);\n+                commitTS, rootNodeId, \"\".equals(msg) ? null : msg, changes);\n     }\n \n-    public StoredCommit(Id id, Id parentId, long commitTS, Id rootNodeId, String msg) {\n+    public StoredCommit(Id id, Id parentId, long commitTS, Id rootNodeId, String msg, String changes) {\n         this.id = id;\n         this.parentId = parentId;\n         this.commitTS = commitTS;\n         this.rootNodeId = rootNodeId;\n         this.msg = msg;\n+        this.changes = changes;\n     }\n \n     public StoredCommit(Id id, Commit commit) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 210,
        "jira_id": "43",
        "nb_skipped": 1,
        "commit": "668f08f2",
        "nb_failure": 0,
        "linesRem": 156,
        "singleLine": false
    },
    {
        "files": 4,
        "nb_test": 72,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.mk.MicroKernelImplTest"
        ],
        "patch": "diff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/H2Persistence.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/H2Persistence.java\nindex d6cb3b5fcc..76030dbd23 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/H2Persistence.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/H2Persistence.java\n@@ -70,6 +70,7 @@ public void initialize(File homeDir) throws Exception {\n         try {\n             Statement stmt = con.createStatement();\n             stmt.execute(\"create table if not exists REVS(ID binary primary key, DATA binary, TIME timestamp)\");\n+            stmt.execute(\"create table if not exists NODES(ID binary primary key, DATA binary, TIME timestamp)\");\n             stmt.execute(\"create table if not exists HEAD(ID binary) as select null\");\n             stmt.execute(\"create sequence if not exists DATASTORE_ID\");\n /*\n@@ -86,7 +87,16 @@ public void close() {\n         cp.dispose();\n     }\n \n-    public Id readHead() throws Exception {\n+    public Id[] readIds() throws Exception {\n+        Id lastCommitId = null;\n+        Id headId = readHead();\n+        if (headId != null) {\n+            lastCommitId = readLastCommitId();\n+        }\n+        return new Id[] { headId, lastCommitId };\n+    }\n+    \n+    private Id readHead() throws Exception {\n         Connection con = cp.getConnection();\n         try {\n             PreparedStatement stmt = con.prepareStatement(\"select * from HEAD\");\n@@ -102,6 +112,22 @@ public Id readHead() throws Exception {\n         }\n     }\n \n+    private Id readLastCommitId() throws Exception {\n+        Connection con = cp.getConnection();\n+        try {\n+            PreparedStatement stmt = con.prepareStatement(\"select MAX(ID) from REVS\");\n+            ResultSet rs = stmt.executeQuery();\n+            byte[] rawId = null;\n+            if (rs.next()) {\n+                rawId = rs.getBytes(1);\n+            }\n+            stmt.close();\n+            return rawId == null ? null : new Id(rawId); \n+        } finally {\n+            con.close();\n+        }\n+    }\n+\n     public void writeHead(Id id) throws Exception {\n         Connection con = cp.getConnection();\n         try {\n@@ -118,7 +144,7 @@ public void readNode(StoredNode node) throws NotFoundException, Exception {\n         Id id = node.getId();\n         Connection con = cp.getConnection();\n         try {\n-            PreparedStatement stmt = con.prepareStatement(\"select DATA from REVS where ID = ?\");\n+            PreparedStatement stmt = con.prepareStatement(\"select DATA from NODES where ID = ?\");\n             try {\n                 stmt.setBytes(1, id.getBytes());\n                 ResultSet rs = stmt.executeQuery();\n@@ -148,7 +174,7 @@ public Id writeNode(Node node) throws Exception {\n         try {\n             PreparedStatement stmt = con\n                     .prepareStatement(\n-                            \"insert into REVS (ID, DATA, TIME) select ?, ?, ? where not exists (select 1 from REVS where ID = ?)\");\n+                            \"insert into NODES (ID, DATA, TIME) select ?, ?, ? where not exists (select 1 from NODES where ID = ?)\");\n             try {\n                 stmt.setBytes(1, rawId);\n                 stmt.setBytes(2, bytes);\n@@ -212,7 +238,7 @@ public void writeCommit(Id id, Commit commit) throws Exception {\n     public ChildNodeEntriesMap readCNEMap(Id id) throws NotFoundException, Exception {\n         Connection con = cp.getConnection();\n         try {\n-            PreparedStatement stmt = con.prepareStatement(\"select DATA from REVS where ID = ?\");\n+            PreparedStatement stmt = con.prepareStatement(\"select DATA from NODES where ID = ?\");\n             try {\n                 stmt.setBytes(1, id.getBytes());\n                 ResultSet rs = stmt.executeQuery();\n@@ -241,7 +267,7 @@ public Id writeCNEMap(ChildNodeEntries map) throws Exception {\n         try {\n             PreparedStatement stmt = con\n                     .prepareStatement(\n-                            \"insert into REVS (ID, DATA, TIME) select ?, ?, ? where not exists (select 1 from REVS where ID = ?)\");\n+                            \"insert into NODES (ID, DATA, TIME) select ?, ?, ? where not exists (select 1 from NODES where ID = ?)\");\n             try {\n                 stmt.setBytes(1, rawId);\n                 stmt.setBytes(2, bytes);\n@@ -264,7 +290,7 @@ public void start() {\n     \n     @Override\n     public boolean markCommit(Id id) throws Exception {\n-        return touch(id, gcStart);\n+        return touch(\"REVS\", id, gcStart);\n     }\n \n     @Override\n@@ -292,22 +318,23 @@ public void replaceCommit(Id id, Commit commit) throws Exception {\n     \n     @Override\n     public boolean markNode(Id id) throws Exception {\n-        return touch(id, gcStart);\n+        return touch(\"NODES\", id, gcStart);\n     }\n \n     @Override\n     public boolean markCNEMap(Id id) throws Exception {\n-        return touch(id, gcStart);\n+        return touch(\"NODES\", id, gcStart);\n     }\n     \n-    private boolean touch(Id id, long timeMillis) throws Exception {\n+    private boolean touch(String table, Id id, long timeMillis) throws Exception {\n         Timestamp ts = new Timestamp(timeMillis);\n \n         Connection con = cp.getConnection();\n         try {\n-            PreparedStatement stmt = con\n-                    .prepareStatement(\n-                            \"update REVS set TIME = ? where ID = ? and TIME < ?\");\n+            PreparedStatement stmt = con.prepareStatement(\n+                    String.format(\"update %s set TIME = ? where ID = ? and TIME < ?\",\n+                            table));\n+                                    \n             try {\n                 stmt.setTimestamp(1, ts);\n                 stmt.setBytes(2, id.getBytes());\n@@ -324,20 +351,29 @@ private boolean touch(Id id, long timeMillis) throws Exception {\n     @Override\n     public int sweep() throws Exception {\n         Timestamp ts = new Timestamp(gcStart);\n+        int swept = 0;\n \n         Connection con = cp.getConnection();\n         try {\n-            PreparedStatement stmt = con\n-                    .prepareStatement(\n-                            \"delete REVS where TIME < ?\");\n+            PreparedStatement stmt = con.prepareStatement(\"delete REVS where TIME < ?\");\n+            try {\n+                stmt.setTimestamp(1, ts);\n+                swept += stmt.executeUpdate();\n+            } finally {\n+                stmt.close();\n+            }\n+\n+            stmt = con.prepareStatement(\"delete NODES where TIME < ?\");\n+            \n             try {\n                 stmt.setTimestamp(1, ts);\n-                return stmt.executeUpdate();\n+                swept += stmt.executeUpdate();\n             } finally {\n                 stmt.close();\n             }\n         } finally {\n             con.close();\n         }\n+        return swept;\n      }\n }\n\\ No newline at end of file\ndiff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/InMemPersistence.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/InMemPersistence.java\nindex bba95fc1e0..f8ddafe006 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/InMemPersistence.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/InMemPersistence.java\n@@ -42,7 +42,6 @@\n     private final Map<Id, byte[]> objects = Collections.synchronizedMap(new HashMap<Id, byte[]>());\n     private final Map<Id, byte[]> marked = Collections.synchronizedMap(new HashMap<Id, byte[]>());\n \n-    private Id head;\n     private long gcStart;\n \n     // TODO: make this configurable\n@@ -53,12 +52,13 @@ public void initialize(File homeDir) {\n         // nothing to initialize\n     }\n     \n-    public Id readHead() {\n-        return head;\n+    @Override\n+    public Id[] readIds() throws Exception {\n+        return new Id[2];\n     }\n \n     public void writeHead(Id id) {\n-        head = id;\n+        \n     }\n \n     public void readNode(StoredNode node) throws NotFoundException, Exception {\ndiff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/Persistence.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/Persistence.java\nindex dbb425344d..45ca883800 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/Persistence.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/persistence/Persistence.java\n@@ -36,7 +36,19 @@\n \n     public void initialize(File homeDir) throws Exception;\n     \n-    Id readHead() throws Exception;\n+    /**\n+     * Return an array of ids, where the first is the head id (as stored\n+     * with {@link #writeHead(Id)}) and the second is the highest commit\n+     * id found or {@code null}.\n+     * <p/>\n+     * This method is not guaranteed to deliver \"live\" results, after\n+     * something is written to the storage, so it should better be used\n+     * once after initialization. \n+     * \n+     * @return array of ids\n+     * @throws Exception if an error occurs\n+     */\n+    Id[] readIds() throws Exception;\n \n     void writeHead(Id id) throws Exception;\n \ndiff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/store/DefaultRevisionStore.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/store/DefaultRevisionStore.java\nindex 1d71ff8236..42b50a52c8 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/store/DefaultRevisionStore.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/store/DefaultRevisionStore.java\n@@ -134,7 +134,8 @@ public void initialize() throws Exception {\n         cache = Collections.synchronizedMap(SimpleLRUCache.<Id, Object> newInstance(initialCacheSize));\n \n         // make sure we've got a HEAD commit\n-        head = pm.readHead();\n+        Id[] ids = pm.readIds();\n+        head = ids[0];\n         if (head == null || head.getBytes().length == 0) {\n             // assume virgin repository\n             byte[] rawHead = Id.fromLong(commitCounter.incrementAndGet())\n@@ -148,7 +149,11 @@ public void initialize() throws Exception {\n             pm.writeCommit(head, initialCommit);\n             pm.writeHead(head);\n         } else {\n-            commitCounter.set(Long.parseLong(head.toString(), 16));\n+            Id lastCommitId = head;\n+            if (ids[1] != null && ids[1].compareTo(lastCommitId) > 0) {\n+                lastCommitId = ids[1];\n+            }\n+            commitCounter.set(Long.parseLong(lastCommitId.toString(), 16));\n         }\n \n         if (gcpm != null) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 64,
        "jira_id": "276",
        "nb_skipped": 1,
        "commit": "1bf5c550",
        "nb_failure": 0,
        "linesRem": 23,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1564,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.cache.ConcurrentTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\nindex 8392b7f1f7..34ca662491 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\n@@ -619,7 +619,9 @@ public CacheStats stats() {\n         int queue2Size;\n \n         /**\n-         * The map array. The size is always a power of 2.\n+         * The map array. The size is always a power of 2. The bit mask that is\n+         * applied to the key hash code to get the index in the map array. The\n+         * mask is the length of the array minus one.\n          */\n         Entry<K, V>[] entries;\n \n@@ -656,12 +658,6 @@ public CacheStats stats() {\n          */\n         private int averageMemory;\n \n-        /**\n-         * The bit mask that is applied to the key hash code to get the index in the\n-         * map array. The mask is the length of the array minus one.\n-         */\n-        private int mask;\n-\n         /**\n          * The LIRS stack size.\n          */\n@@ -722,8 +718,6 @@ synchronized void clear() {\n             }\n             // the array size is at most 2^31 elements\n             int len = (int) Math.min(1L << 31, l);\n-            // the bit mask has all bits set\n-            mask = len - 1;\n \n             // initialize the stack and queue heads\n             stack = new Entry<K, V>();\n@@ -733,8 +727,10 @@ synchronized void clear() {\n             queue2 = new Entry<K, V>();\n             queue2.queuePrev = queue2.queueNext = queue2;\n \n-            // first set to null - avoiding out of memory\n-            entries = null;\n+            // first set to a small array, to avoiding out of memory\n+            @SuppressWarnings(\"unchecked\")\n+            Entry<K, V>[] small = new Entry[1];\n+            entries = small;\n             @SuppressWarnings(\"unchecked\")\n             Entry<K, V>[] e = new Entry[len];\n             entries = e;\n@@ -920,6 +916,10 @@ synchronized V putIfAbsent(K key, int hash, V value, int memory) {\n         }\n \n         synchronized void refresh(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {\n+            if (loader == null) {\n+                // no loader - no refresh\n+                return;\n+            }            \n             V value;\n             V old = get(key, hash);\n             long start = System.nanoTime();\n@@ -968,9 +968,11 @@ synchronized V put(K key, int hash, V value, int memory) {\n             e.key = key;\n             e.value = value;\n             e.memory = memory;\n+            Entry<K, V>[] array = entries;\n+            int mask = array.length - 1;\n             int index = hash & mask;\n-            e.mapNext = entries[index];\n-            entries[index] = e;\n+            e.mapNext = array[index];\n+            array[index] = e;\n             usedMemory += memory;\n             if (usedMemory > maxMemory && mapSize > 0) {\n                 // an old entry needs to be removed\n@@ -990,13 +992,15 @@ synchronized V put(K key, int hash, V value, int memory) {\n          * @param hash the hash\n          */\n         synchronized void invalidate(Object key, int hash) {\n+            Entry<K, V>[] array = entries;\n+            int mask = array.length - 1;            \n             int index = hash & mask;\n-            Entry<K, V> e = entries[index];\n+            Entry<K, V> e = array[index];\n             if (e == null) {\n                 return;\n             }\n             if (e.key.equals(key)) {\n-                entries[index] = e.mapNext;\n+                array[index] = e.mapNext;\n             } else {\n                 Entry<K, V> last;\n                 do {\n@@ -1107,8 +1111,10 @@ private void pruneStack() {\n          * @return the entry (might be a non-resident)\n          */\n         Entry<K, V> find(Object key, int hash) {\n+            Entry<K, V>[] array = entries;\n+            int mask = array.length - 1;                \n             int index = hash & mask;\n-            Entry<K, V> e = entries[index];\n+            Entry<K, V> e = array[index];\n             while (e != null && !e.key.equals(key)) {\n                 e = e.mapNext;\n             }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 17,
        "jira_id": "1364",
        "nb_skipped": 6,
        "commit": "b481a14c",
        "nb_failure": 0,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2884,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\nindex d64d7cf459..98bcc5e723 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n@@ -192,20 +192,23 @@ private Statement convertToStatement(String query) throws ParseException {\n                         currentSelector.path = \"/\";\n                     }\n                 }\n-            } else if (readIf(\"text\")) {\n+            } else if (currentTokenType == IDENTIFIER) {\n+                // probably a path restriction\n+                // String name = readPathSegment();\n+                String identifier = readIdentifier();\n+                if (readIf(\"(\")) {\n+                    if (\"text\".equals(identifier)) {\n                         // \"...text()\"\n                         currentSelector.isChild = false;\n                         pathPattern += \"jcr:xmltext\";\n-                read(\"(\");\n                         read(\")\");\n                         if (currentSelector.isDescendant) {\n                             currentSelector.nodeName = \"jcr:xmltext\";\n                         } else {\n                             currentSelector.path = PathUtils.concat(currentSelector.path, \"jcr:xmltext\");\n                         }                        \n-            } else if (readIf(\"element\")) {\n+                    } else if (\"element\".equals(identifier)) {\n                         // \"...element(...\"\n-                read(\"(\");\n                         if (readIf(\")\")) {\n                             // any\n                             pathPattern += \"%\";\n@@ -223,14 +226,22 @@ private Statement convertToStatement(String query) throws ParseException {\n                             }\n                             read(\")\");\n                         }\n-            } else if (readIf(\"@\")) {\n+                    } else if (\"rep:excerpt\".equals(identifier)) {\n+                        readOpenDotClose(false);\n                         rewindSelector();\n-                Expression.Property p = readProperty();\n+                        Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\n                         statement.addSelectColumn(p);\n-            } else if (readIf(\"rep:excerpt\")) {\n+                    } else {\n+                        throw getSyntaxError();\n+                    }\n+                } else {\n+                    String name = ISO9075.decode(identifier);\n+                    pathPattern += name;\n+                    appendNodeName(name);\n+                }\n+            } else if (readIf(\"@\")) {\n                 rewindSelector();\n-                readExcerpt();\n-                Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\n+                Expression.Property p = readProperty();\n                 statement.addSelectColumn(p);\n             } else if (readIf(\"(\")) {\n                 rewindSelector();\n@@ -239,7 +250,7 @@ private Statement convertToStatement(String query) throws ParseException {\n                         Expression.Property p = readProperty();\n                         statement.addSelectColumn(p);\n                     } else if (readIf(\"rep:excerpt\")) {\n-                        readExcerpt();\n+                        readOpenDotClose(true);\n                         Expression.Property p = new Expression.Property(currentSelector, \"rep:excerpt\", false);\n                         statement.addSelectColumn(p);\n                     } else if (readIf(\"rep:spellcheck\")) {\n@@ -249,7 +260,7 @@ private Statement convertToStatement(String query) throws ParseException {\n                         Expression.Property p = new Expression.Property(currentSelector, \"rep:spellcheck()\", false);\n                         statement.addSelectColumn(p);\n                     } else if (readIf(\"rep:suggest\")) {\n-                        readExcerpt();\n+                        readOpenDotClose(true);\n                         Expression.Property p = new Expression.Property(currentSelector, \"rep:suggest()\", false);\n                         statement.addSelectColumn(p);\n                     }\n@@ -257,11 +268,6 @@ private Statement convertToStatement(String query) throws ParseException {\n                 if (!readIf(\")\")) {\n                     return convertToUnion(query, statement, startParseIndex - 1);\n                 }\n-            } else if (currentTokenType == IDENTIFIER) {\n-                // path restriction\n-                String name = readPathSegment();\n-                pathPattern += name;\n-                appendNodeName(name);\n             } else if (readIf(\".\")) {\n                 // just \".\" this is simply ignored, so that\n                 // \"a/./b\" is the same as \"a/b\"\n@@ -717,13 +723,19 @@ private void read(String expected) throws ParseException {\n         return new Expression.Property(currentSelector, readPathSegment(), false);\n     }\n     \n-    private void readExcerpt() throws ParseException {\n+    /**\n+     * Read open bracket (optional), and optional dot, and close bracket.\n+     * \n+     * @param readOpenBracket whether to read the open bracket (false if this\n+     *            was already read)\n+     * @throws ParseException if close bracket or the dot were not read\n+     */\n+    private void readOpenDotClose(boolean readOpenBracket) throws ParseException {\n+        if (readOpenBracket) {\n             read(\"(\");\n-        if (!readIf(\")\")) {\n-            // only rep:excerpt(.) and rep:excerpt() are currently supported\n-            read(\".\");\n-            read(\")\");\n         }\n+        readIf(\".\");\n+        read(\")\");\n     }\n \n     private String readPathSegment() throws ParseException {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 24,
        "jira_id": "4387",
        "nb_skipped": 1,
        "commit": "ca05fd06",
        "nb_failure": 0,
        "linesRem": 19,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1853,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.RevisionTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\nindex 79043e9fd9..a7806cdc07 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n@@ -156,6 +156,12 @@ static Revision newRevision(int clusterId) {\n         long timestamp = getCurrentTimestamp();\n         int c;\n         synchronized (Revision.class) {\n+            // need to check again, because threads\n+            // could arrive inside the synchronized block\n+            // out of order\n+            if (timestamp < lastRevisionTimestamp) {\n+                timestamp = lastRevisionTimestamp;\n+            }\n             if (timestamp == lastRevisionTimestamp) {\n                 c = ++lastRevisionCount;\n             } else {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "1807",
        "nb_skipped": 9,
        "commit": "077efee5",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 17,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest"
        ],
        "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\nindex 27e82ab09b..40b709f671 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n@@ -65,6 +65,7 @@\n import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_QUERYABLE;\n import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_QUERY_ORDERABLE;\n import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_NODE_TYPES;\n+import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.JCR_ALL;\n import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.NT_REP_PRIVILEGE;\n import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.NT_REP_PRIVILEGES;\n import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_AGGREGATES;\n@@ -267,7 +268,7 @@ public void copy(RepositoryInitializer initializer) throws RepositoryException {\n             Map<Integer, String> idxToPrefix = newHashMap();\n             copyNamespaces(builder, uriToPrefix, idxToPrefix);\n             copyNodeTypes(builder, uriToPrefix.inverse());\n-            copyPrivileges(builder);\n+            copyCustomPrivileges(builder);\n \n             // Triggers compilation of type information, which we need for\n             // the type predicates used by the bulk  copy operations below.\n@@ -466,7 +467,7 @@ private Properties loadProperties(String path) throws RepositoryException {\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private void copyPrivileges(NodeBuilder root) throws RepositoryException {\n+    private void copyCustomPrivileges(NodeBuilder root) {\n         PrivilegeRegistry registry = source.getPrivilegeRegistry();\n         NodeBuilder privileges = root.child(JCR_SYSTEM).child(REP_PRIVILEGES);\n         privileges.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGES, NAME);\n@@ -476,6 +477,12 @@ private void copyPrivileges(NodeBuilder root) throws RepositoryException {\n         logger.info(\"Copying registered privileges\");\n         for (Privilege privilege : registry.getRegisteredPrivileges()) {\n             String name = privilege.getName();\n+            if (PrivilegeBits.BUILT_IN.containsKey(name) || JCR_ALL.equals(name)) {\n+                // Ignore built in privileges as those have been installed by\n+                // the PrivilegesInitializer already\n+                continue;\n+            }\n+\n             NodeBuilder def = privileges.child(name);\n             def.setProperty(JCR_PRIMARYTYPE, NT_REP_PRIVILEGE, NAME);\n \n@@ -510,7 +517,7 @@ private void copyPrivileges(NodeBuilder root) throws RepositoryException {\n         }\n     }\n \n-    private PrivilegeBits resolvePrivilegeBits(\n+    private static PrivilegeBits resolvePrivilegeBits(\n             NodeBuilder privileges, String name) {\n         NodeBuilder def = privileges.getChildNode(name);\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 8,
        "jira_id": "2047",
        "nb_skipped": 0,
        "commit": "a0a495f0",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 361,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\nindex 09914c6bd0..8eac46e012 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\n@@ -137,13 +137,13 @@ public IndexCopier(Executor executor, File indexRootDir, boolean prefetchEnabled\n     public Directory wrapForRead(String indexPath, IndexDefinition definition,\n             Directory remote) throws IOException {\n         Directory local = createLocalDirForIndexReader(indexPath, definition);\n-        return new CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath, getSharedWorkingSet(definition));\n+        return new CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath, getSharedWorkingSet(indexPath));\n     }\n \n     public Directory wrapForWrite(IndexDefinition definition, Directory remote, boolean reindexMode) throws IOException {\n         Directory local = createLocalDirForIndexWriter(definition);\n         return new CopyOnWriteDirectory(remote, local, reindexMode,\n-                getIndexPathForLogging(definition), getSharedWorkingSet(definition));\n+                getIndexPathForLogging(definition), getSharedWorkingSet(definition.getIndexPathFromConfig()));\n     }\n \n     @Override\n@@ -238,9 +238,7 @@ private void successfullyDeleted(LocalIndexFile file, boolean fileExisted){\n      * @param defn index definition for which the directory is being created\n      * @return a set to maintain the state of new files being created by the COW Directory\n      */\n-    private Set<String> getSharedWorkingSet(IndexDefinition defn){\n-        String indexPath = defn.getIndexPathFromConfig();\n-\n+    private Set<String> getSharedWorkingSet(String indexPath){\n         Set<String> sharedSet;\n         synchronized (sharedWorkingSetMap){\n             sharedSet = sharedWorkingSetMap.get(indexPath);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "4431",
        "nb_skipped": 6,
        "commit": "7441a3d5",
        "nb_failure": 0,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1530,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.kernel.NodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRootBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRootBuilder.java\nindex c7da53602c..440e47b99e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRootBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRootBuilder.java\n@@ -145,7 +145,19 @@ NodeState reset() {\n      */\n     NodeState merge(CommitHook hook, CommitInfo info) throws CommitFailedException {\n         purge();\n+        boolean success = false;\n+        try {\n             branch.merge(hook, info);\n+            success = true;\n+        } finally {\n+            if (!success) {\n+                // need to adjust base and head of this builder\n+                // in case branch.merge() did a rebase and then\n+                // a commit hook failed the merge\n+                super.reset(branch.getHead());\n+                this.base = branch.getBase();\n+            }\n+        }\n         return reset();\n     }\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoRootBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoRootBuilder.java\nindex f4ac698761..268f3df42e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoRootBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoRootBuilder.java\n@@ -142,7 +142,19 @@ NodeState reset() {\n      */\n     NodeState merge(CommitHook hook, CommitInfo info) throws CommitFailedException {\n         purge();\n+        boolean success = false;\n+        try {\n             branch.merge(hook, info);\n+            success = true;\n+        } finally {\n+            if (!success) {\n+                // need to adjust base and head of this builder\n+                // in case branch.merge() did a rebase and then\n+                // a commit hook failed the merge\n+                super.reset(branch.getHead());\n+                this.base = branch.getBase();\n+            }\n+        }\n         return reset();\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 18,
        "jira_id": "1320",
        "nb_skipped": 6,
        "commit": "64045631",
        "nb_failure": 3,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 7,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.segment.standby.FailoverTest"
        ],
        "patch": "diff --git a/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/SegmentLoaderHandler.java b/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/SegmentLoaderHandler.java\nindex ba7e775a28..633652c5b2 100644\n--- a/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/SegmentLoaderHandler.java\n+++ b/oak-tarmk-standby/src/main/java/org/apache/jackrabbit/oak/plugins/segment/standby/client/SegmentLoaderHandler.java\n@@ -133,7 +133,7 @@ private void initSync() {\n     @Override\n     public Segment readSegment(final String id) {\n         ctx.writeAndFlush(newGetSegmentReq(this.clientID, id));\n-        return getSegment();\n+        return getSegment(id);\n     }\n \n     @Override\n@@ -145,15 +145,18 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)\n \n     // implementation of RemoteSegmentLoader\n \n-    public Segment getSegment() {\n+    public Segment getSegment(final String id) {\n         boolean interrupted = false;\n         try {\n             for (;;) {\n                 try {\n-                    // log.debug(\"polling segment\");\n                     Segment s = segment.poll(timeoutMs, TimeUnit.MILLISECONDS);\n-                    // log.debug(\"returning segment \" + s.getSegmentId());\n+                    if (s == null) {\n+                        return null;\n+                    }\n+                    if (s.getSegmentId().toString().equals(id)) {\n                         return s;\n+                    }\n                 } catch (InterruptedException ignore) {\n                     interrupted = true;\n                 }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 7,
        "jira_id": "2260",
        "nb_skipped": 0,
        "commit": "0ac7ff20",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1963,
        "nb_error": 4,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.RepositoryTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/SessionImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/SessionImpl.java\nindex 13ade55166..7d6e5d289a 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/SessionImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/session/SessionImpl.java\n@@ -161,7 +161,11 @@ public Node getNodeOrNull(final String absPath) throws RepositoryException {\n         return perform(new ReadOperation<Node>() {\n             @Override\n             public Node perform() throws RepositoryException {\n+                try {\n                     return NodeImpl.createNodeOrNull(sd.getNode(getOakPathOrThrow(absPath)), sessionContext);\n+                } catch (PathNotFoundException e) {\n+                    return null;\n+                }\n             }\n         });\n     }\n@@ -179,7 +183,12 @@ public Property getPropertyOrNull(final String absPath) throws RepositoryExcepti\n         if (absPath.equals(\"/\")) {\n             return null;\n         } else {\n-            final String oakPath = getOakPathOrThrow(absPath);\n+            final String oakPath;\n+            try {\n+                oakPath = getOakPathOrThrow(absPath);\n+            } catch (PathNotFoundException e) {\n+                return null;\n+            }\n             return perform(new ReadOperation<Property>() {\n                 @Override\n                 public Property perform() throws RepositoryException {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 10,
        "jira_id": "1225",
        "nb_skipped": 5,
        "commit": "3535afe2",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2882,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\nindex 9bfbd2d5e6..d64d7cf459 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/XPathToSQL2Converter.java\n@@ -162,6 +162,10 @@ private Statement convertToStatement(String query) throws ParseException {\n             } else if (readIf(\"/\")) {\n                 // \"//\" was read\n                 pathPattern += \"%\";\n+                if (currentSelector.isDescendant) {\n+                    // the query started with \"//\", and now \"//\" was read\n+                    nextSelector(true);\n+                }\n                 currentSelector.isDescendant = true;\n             } else {\n                 // the token \"/\" was read\n@@ -169,6 +173,10 @@ private Statement convertToStatement(String query) throws ParseException {\n                 if (startOfQuery) {\n                     currentSelector.path = \"/\";\n                 } else {\n+                    if (currentSelector.isDescendant) {\n+                        // the query started with \"//\", and now \"/\" was read\n+                        nextSelector(true);\n+                    }\n                     currentSelector.isChild = true;\n                 }\n             }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 6,
        "jira_id": "4376",
        "nb_skipped": 1,
        "commit": "037dea72",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 2232,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\nindex eec060989c..5bd72a3256 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n@@ -448,10 +448,14 @@ private void rollback(List<UpdateOp> newDocuments,\n         DocumentStore store = nodeStore.getDocumentStore();\n         for (UpdateOp op : changed) {\n             UpdateOp reverse = op.getReverseOperation();\n+            if (op.isNew()) {\n+                NodeDocument.setDeletedOnce(reverse);\n+            }\n             store.findAndUpdate(NODES, reverse);\n         }\n         for (UpdateOp op : newDocuments) {\n             UpdateOp reverse = op.getReverseOperation();\n+            NodeDocument.setDeletedOnce(reverse);\n             store.findAndUpdate(NODES, reverse);\n         }\n         UpdateOp removeCollision = new UpdateOp(commitRoot.getId(), false);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 84246631cd..c5dd0d39da 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -1372,10 +1372,13 @@ public static void setDeleted(@Nonnull UpdateOp op,\n         if(deleted) {\n             //DELETED_ONCE would be set upon every delete.\n             //possibly we can avoid that\n-            checkNotNull(op).set(DELETED_ONCE, Boolean.TRUE);\n+            setDeletedOnce(op);\n+        }\n+        checkNotNull(op).setMapEntry(DELETED, checkNotNull(revision), String.valueOf(deleted));\n     }\n-        checkNotNull(op).setMapEntry(DELETED, checkNotNull(revision),\n-                String.valueOf(deleted));\n+\n+    public static void setDeletedOnce(@Nonnull UpdateOp op) {\n+        checkNotNull(op).set(DELETED_ONCE, Boolean.TRUE);\n     }\n \n     public static void removeDeleted(@Nonnull UpdateOp op,\n",
        "project": "jackrabbit-oak",
        "linesAdd": 10,
        "jira_id": "3104",
        "nb_skipped": 1,
        "commit": "38f5ef13",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2008,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.kernel.CheckpointTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex a46af36d9f..c93221c1cb 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -1383,7 +1383,12 @@ public String checkpoint(long lifetime) {\n     @CheckForNull\n     @Override\n     public NodeState retrieve(@Nonnull String checkpoint) {\n-        return getRoot(Revision.fromString(checkpoint));\n+        Revision r = Revision.fromString(checkpoint);\n+        if (checkpoints.getCheckpoints().containsKey(r)) {\n+            return getRoot(r);\n+        } else {\n+            return null;\n+        }\n     }\n \n     @Override\n",
        "project": "jackrabbit-oak",
        "linesAdd": 6,
        "jira_id": "2311",
        "nb_skipped": 1,
        "commit": "ca85ecce",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 13,
        "nb_error": 13,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberSplitUpgradeTest",
            "org.apache.jackrabbit.oak.upgrade.RepositoryGroupMemberUpgradeTest",
            "org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest"
        ],
        "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\nindex e47aba3595..9c2446822a 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n@@ -47,7 +46,6 @@\n import org.apache.jackrabbit.oak.plugins.name.Namespaces;\n import org.apache.jackrabbit.oak.plugins.nodetype.TypeEditorProvider;\n import org.apache.jackrabbit.oak.plugins.nodetype.write.InitialContent;\n-import org.apache.jackrabbit.oak.security.authorization.AuthorizationConfigurationImpl;\n import org.apache.jackrabbit.oak.spi.commit.CommitHook;\n import org.apache.jackrabbit.oak.spi.commit.CommitInfo;\n import org.apache.jackrabbit.oak.spi.commit.CompositeEditorProvider;\n@@ -71,7 +69,6 @@\n import org.slf4j.LoggerFactory;\n \n import static com.google.common.base.Preconditions.checkState;\n-import static com.google.common.collect.Lists.newArrayList;\n import static com.google.common.collect.Lists.newArrayListWithCapacity;\n import static com.google.common.collect.Maps.newHashMap;\n import static java.util.Arrays.asList;\n@@ -225,7 +222,6 @@ public void copy() throws RepositoryException {\n \n             NodeState root = builder.getNodeState();\n             copyVersionStore(builder, root, uriToPrefix, idxToPrefix);\n-            String workspaceName =\n             copyWorkspaces(builder, root, uriToPrefix, idxToPrefix);\n \n             logger.info(\"Applying default commit hooks\");\n@@ -237,15 +233,14 @@ public void copy() throws RepositoryException {\n                 groupsPath = UserConstants.DEFAULT_GROUP_PATH;\n             }\n             // TODO: default hooks?\n-            List<CommitHook> hooks = newArrayList();\n-            hooks.add(new EditorHook(new CompositeEditorProvider(\n-                            new GroupEditorProvider(groupsPath),\n+            CommitHook hook = new CompositeHook(\n+                    new EditorHook(new GroupEditorProvider(groupsPath)),\n+                    new EditorHook(new CompositeEditorProvider(\n                             new TypeEditorProvider(false),\n                             new IndexUpdateProvider(new CompositeIndexEditorProvider(\n                                     new ReferenceEditorProvider(),\n                                     new PropertyIndexEditorProvider())))));\n-            hooks.addAll(new AuthorizationConfigurationImpl().getCommitHooks(workspaceName));\n-            target.merge(builder, CompositeHook.compose(hooks), CommitInfo.EMPTY);\n+            target.merge(builder, hook, CommitInfo.EMPTY);\n         } catch (Exception e) {\n             throw new RepositoryException(\"Failed to copy content\", e);\n         }\n@@ -562,7 +557,7 @@ private void copyVersionStore(\n                 \"/jcr:system/jcr:activities\", copyBinariesByReference));\n     }   \n \n-    private String copyWorkspaces(\n+    private void copyWorkspaces(\n             NodeBuilder builder, NodeState root,\n             Map<String, String> uriToPrefix, Map<Integer, String> idxToPrefix)\n             throws RepositoryException, IOException {\n@@ -587,7 +582,7 @@ private String copyWorkspaces(\n             }\n         }\n \n-        return name;\n+        // TODO: Copy all the active open-scoped locks\n     }\n \n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 5,
        "jira_id": "1719",
        "nb_skipped": 0,
        "commit": "c3773d53",
        "nb_failure": 0,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 687,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilderTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex d5712bae39..411c5fc88c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -193,10 +193,15 @@ private MutableNodeState getWriteState(String name) {\n      * @return {@code true} iff this child exists at its direct parent.\n      */\n     private boolean exists() {\n-        // No need to check the base state if write state is null. The fact that we have this\n-        // builder instance proofs that this child existed at some point as it must have been\n-        // retrieved from the base state.\n-        return isRoot() || parent.writeState == null || parent.writeState.hasChildNode(name);\n+        if (isRoot()) {\n+            return true;\n+        }\n+        else if (parent.writeState == null) {\n+            return parent.baseState != null && parent.baseState.hasChildNode(name);\n+        }\n+        else {\n+            return parent.writeState.hasChildNode(name);\n+        }\n     }\n \n     /**\n@@ -206,11 +211,8 @@ private boolean exists() {\n     private boolean updateReadState() {\n         if (revision != root.revision) {\n             assert(!isRoot()); // root never gets here since revision == root.revision\n-            if (!exists()) {\n-                return false;\n-            }\n-            parent.updateReadState();\n \n+            if (parent.updateReadState() && exists()) {\n                 // The builder could have been reset, need to re-get base state\n                 baseState = parent.getBaseState(name);\n \n@@ -218,6 +220,10 @@ private boolean updateReadState() {\n                 writeState = parent.getWriteState(name);\n \n                 revision = root.revision;\n+                return true;\n+            }\n+\n+            return false;\n         }\n         return writeState != null || baseState != null;\n     }\n@@ -238,8 +244,8 @@ private MutableNodeState write() {\n     private MutableNodeState write(long newRevision, boolean reconnect) {\n         // make sure that all revision numbers up to the root gets updated\n         if (!isRoot()) {\n-            checkState(reconnect || exists(), \"This node has been removed\");\n             parent.write(newRevision, reconnect);\n+            checkState(reconnect || exists(), \"This node has been removed\");\n         }\n \n         if (writeState == null || revision != root.revision) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 15,
        "jira_id": "678",
        "nb_skipped": 1,
        "commit": "6c54045d",
        "nb_failure": 1,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1229,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.security.user.UserImportHistoryTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/SysViewImportHandler.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/SysViewImportHandler.java\nindex d9cbf9c35f..121511a445 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/SysViewImportHandler.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/xml/SysViewImportHandler.java\n@@ -277,7 +277,8 @@ public void endElement(String namespaceURI, String localName, String qName)\n                 PropInfo prop = new PropInfo(\n                         currentPropName == null ? null : currentPropName.getRepoQualifiedName(),\n                         currentPropType,\n-                        currentPropValues);\n+                        currentPropValues,\n+                        currentPropMultipleStatus);\n                 state.props.add(prop);\n             }\n             // reset temp fields\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "3930",
        "nb_skipped": 1,
        "commit": "b939aa6e",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 399,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilderTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex ce13f08907..6600cc78a0 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -268,11 +267,12 @@ private boolean isRemoved(String name) {\n \n     @Override\n     public boolean isModified() {\n+        NodeState baseState = getBaseState();\n         if (writeState == null) {\n             return false;\n         }\n         else {\n-            NodeState baseState = getBaseState();\n+            Map<String, MutableNodeState> nodes = writeState.nodes;\n             for (Entry<String, MutableNodeState> n : writeState.nodes.entrySet()) {\n                 if (n.getValue() == null) {\n                     return true;\n@@ -308,6 +308,7 @@ public NodeState getNodeState() {\n \n     @Override\n     public NodeState getBaseState() {\n+        read();\n         return baseState;\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "448",
        "nb_skipped": 1,
        "commit": "999097e1",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 369,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\nindex 447e41f779..44408aa0bc 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n@@ -291,7 +291,7 @@ private Document makeDocument(String path, NodeState state, boolean isUpdate) th\n                 dirty |= addTypedOrderedFields(fields, property, pname, pd);\n             }\n \n-            dirty |= indexProperty(path, fields, state, property, pname, false, pd);\n+            dirty |= indexProperty(path, fields, state, property, pname, pd);\n         }\n \n         dirty |= indexAggregates(path, fields, state);\n@@ -335,7 +335,6 @@ private boolean indexProperty(String path,\n                                   NodeState state,\n                                   PropertyState property,\n                                   String pname,\n-                                  boolean aggregateMode,\n                                   PropertyDefinition pd) throws CommitFailedException {\n         boolean includeTypeForFullText = indexingRule.includePropertyType(property.getType().tag());\n         if (Type.BINARY.tag() == property.getType().tag()\n@@ -358,7 +357,7 @@ private boolean indexProperty(String path,\n                         fields.add(newPropertyField(analyzedPropName, value, !pd.skipTokenization(pname), pd.stored));\n                     }\n \n-                    if (pd.nodeScopeIndex && !aggregateMode) {\n+                    if (pd.nodeScopeIndex) {\n                         Field field = newFulltextField(value);\n                         field.setBoost(pd.boost);\n                         fields.add(field);\n@@ -533,7 +532,7 @@ public void onResult(Aggregate.PropertyIncludeResult result) throws CommitFailed\n                             result.propertyPath, result.pd);\n                 }\n                 dirty |= indexProperty(path, fields, state, result.propertyState,\n-                        result.propertyPath, true, result.pd);\n+                        result.propertyPath, result.pd);\n \n                 if (dirty) {\n                     dirtyFlag.set(true);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "2330",
        "nb_skipped": 1,
        "commit": "408a566e",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1752,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.name.NameValidatorTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\nindex 0ad6022935..3b4219c430 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/name/Namespaces.java\n@@ -244,8 +244,12 @@ public static boolean isValidLocalName(String local) {\n \n         for (int i = 0; i < local.length(); i++) {\n             char ch = local.charAt(i);\n-            if (\"/:[]|*\".indexOf(ch) != -1) { // TODO: XMLChar check\n-                return false;\n+            if (i == 0 && Character.isWhitespace(ch)) {\n+                return false; // leading whitespace\n+            } else if (i == local.length() - 1 && Character.isWhitespace(ch)) {\n+                return false; // trailing whitespace\n+            } else if (\"/:[]|*\".indexOf(ch) != -1) { // TODO: XMLChar check\n+                return false; // invalid name character\n             }\n         }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 6,
        "jira_id": "1624",
        "nb_skipped": 8,
        "commit": "6d8146f8",
        "nb_failure": 3,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1423,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.kernel.KernelNodeBuilderTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex c3b3885428..00136aa516 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -260,7 +260,7 @@ public boolean exists() {\n \n     @Override\n     public boolean isNew() {\n-        return !isRoot() && !parent.base().hasChildNode(name) && parent.hasChildNode(name);\n+        return exists() && !base.exists();\n     }\n \n     @Override\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "1178",
        "nb_skipped": 6,
        "commit": "84fb6b29",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1830,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.core.MutableTreeTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/tree/AbstractTree.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/tree/AbstractTree.java\nindex 51afd2e05a..30f70adfc7 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/tree/AbstractTree.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/tree/AbstractTree.java\n@@ -204,7 +204,7 @@ protected void buildPath(StringBuilder sb) {\n \n     @Override\n     public Status getStatus() {\n-        if (nodeBuilder.isNew()) {\n+        if (nodeBuilder.isNew() || nodeBuilder.isReplaced()) {\n             return NEW;\n         } else if (nodeBuilder.isModified()) {\n             return MODIFIED;\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "1674",
        "nb_skipped": 8,
        "commit": "073b814c",
        "nb_failure": 4,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 516,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.RepositoryTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\nindex f93c2148ee..752a3e8913 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n@@ -240,8 +240,7 @@ public Node perform() throws RepositoryException {\n                 String ntName = primaryNodeTypeName;\n                 if (ntName == null) {\n                     DefinitionProvider dp = getDefinitionProvider();\n-                    String childName = getOakName(PathUtils.getName(relPath));\n-                    NodeDefinition def = dp.getDefinition(parent.getTree(), childName);\n+                    NodeDefinition def = dp.getDefinition(parent.getTree(), oakName);\n                     ntName = def.getDefaultPrimaryTypeName();\n                     if (ntName == null) {\n                         throw new ConstraintViolationException(\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "738",
        "nb_skipped": 1,
        "commit": "8ed779dc",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1849,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdateTest",
            "org.apache.jackrabbit.oak.plugins.document.ConcurrentConflictTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\nindex c7538f7374..9ce60a39de 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n@@ -41,10 +41,15 @@\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.api.jmx.IndexStatsMBean;\n+import org.apache.jackrabbit.oak.plugins.commit.AnnotatingConflictHandler;\n+import org.apache.jackrabbit.oak.plugins.commit.ConflictHook;\n+import org.apache.jackrabbit.oak.plugins.commit.ConflictValidatorProvider;\n import org.apache.jackrabbit.oak.plugins.value.Conversions;\n import org.apache.jackrabbit.oak.spi.commit.CommitHook;\n import org.apache.jackrabbit.oak.spi.commit.CommitInfo;\n+import org.apache.jackrabbit.oak.spi.commit.CompositeHook;\n import org.apache.jackrabbit.oak.spi.commit.EditorDiff;\n+import org.apache.jackrabbit.oak.spi.commit.EditorHook;\n import org.apache.jackrabbit.oak.spi.commit.EmptyHook;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n@@ -226,7 +231,10 @@ public synchronized void run() {\n \n     private static CommitHook newCommitHook(final String name,\n             final PropertyState state) throws CommitFailedException {\n-        return new CommitHook() {\n+        return new CompositeHook(\n+                new ConflictHook(new AnnotatingConflictHandler()),\n+                new EditorHook(new ConflictValidatorProvider()),\n+                new CommitHook() {\n             @Override\n             @Nonnull\n             public NodeState processCommit(NodeState before, NodeState after,\n@@ -241,7 +249,7 @@ public NodeState processCommit(NodeState before, NodeState after,\n                     throw CONCURRENT_UPDATE;\n                 }\n             }\n-        };\n+        });\n     }\n \n     private static void preAsyncRun(NodeStore store, String name) throws CommitFailedException {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 10,
        "jira_id": "1784",
        "nb_skipped": 9,
        "commit": "2426deae",
        "nb_failure": 2,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 404,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest",
            "org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest",
            "org.apache.jackrabbit.oak.plugins.index.old.QueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/SQL2Parser.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/SQL2Parser.java\nindex a31fd0a714..4f70f1e5d8 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/SQL2Parser.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/SQL2Parser.java\n@@ -525,6 +525,23 @@ private PropertyValueImpl parsePropertyValue(String name) throws ParseException\n     private StaticOperandImpl parseStaticOperand() throws ParseException {\n         if (currentTokenType == PLUS) {\n             read();\n+            if (currentTokenType != VALUE) {\n+                throw getSyntaxError(\"number\");\n+            }\n+            int valueType = currentValue.getType().tag();\n+            switch (valueType) {\n+            case PropertyType.LONG:\n+                currentValue = PropertyValues.newLong(currentValue.getValue(Type.LONG));\n+                break;\n+            case PropertyType.DOUBLE:\n+                currentValue = PropertyValues.newDouble(currentValue.getValue(Type.DOUBLE));\n+                break;\n+            case PropertyType.DECIMAL:\n+                currentValue = PropertyValues.newDecimal(currentValue.getValue(Type.DECIMAL).negate());\n+                break;\n+            default:\n+                throw getSyntaxError(\"Illegal operation: + \" + currentValue);\n+            }\n         } else if (currentTokenType == MINUS) {\n             read();\n             if (currentTokenType != VALUE) {\n@@ -923,7 +940,10 @@ private void read() throws ParseException {\n             if (types[i] == CHAR_SPECIAL_2) {\n                 i++;\n             }\n-            // fall through\n+            currentToken = statement.substring(start, i);\n+            currentTokenType = KEYWORD;\n+            parseIndex = i;\n+            return;\n         case CHAR_SPECIAL_1:\n             currentToken = statement.substring(start, i);\n             switch (c) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 21,
        "jira_id": "499",
        "nb_skipped": 0,
        "commit": "61381ea2",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1951,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentSplitTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\nindex 3ca3e0840d..f6bbb19b77 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java\n@@ -21,7 +21,6 @@\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Comparator;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.NavigableMap;\n@@ -65,6 +64,7 @@\n class SplitOperations {\n \n     private static final Logger LOG = LoggerFactory.getLogger(SplitOperations.class);\n+    private static final int GARBAGE_LIMIT = Integer.getInteger(\"oak.documentMK.garbage.limit\", 10000);\n     private static final DocumentStore STORE = new MemoryDocumentStore();\n \n     private final NodeDocument doc;\n@@ -75,7 +75,9 @@\n     private Revision low;\n     private int numValues;\n     private Map<String, NavigableMap<Revision, String>> committedChanges;\n+    private Set<Revision> changes;\n     private Map<String, Set<Revision>> garbage;\n+    private int garbageCount = 0;\n     private Set<Revision> mostRecentRevs;\n     private Set<Revision> splitRevs;\n     private List<UpdateOp> splitOps;\n@@ -119,7 +121,10 @@ private SplitOperations(@Nonnull NodeDocument doc,\n         mostRecentRevs = Sets.newHashSet();\n         splitRevs = Sets.newHashSet();\n         garbage = Maps.newHashMap();\n-        committedChanges = getCommittedLocalChanges();\n+        changes = Sets.newHashSet();\n+        committedChanges = Maps.newHashMap();\n+        \n+        collectLocalChanges(committedChanges, changes);\n \n         // revisions of the most recent committed changes on this document\n         // these are kept in the main document. _revisions and _commitRoot\n@@ -215,9 +220,15 @@ private void collectRevisionsAndCommitRoot() {\n         NavigableMap<Revision, String> commitRoot =\n                 new TreeMap<Revision, String>(context.getRevisionComparator());\n         for (Map.Entry<Revision, String> entry : doc.getLocalCommitRoot().entrySet()) {\n-            if (splitRevs.contains(entry.getKey())) {\n-                commitRoot.put(entry.getKey(), entry.getValue());\n+            Revision r = entry.getKey();\n+            if (splitRevs.contains(r)) {\n+                commitRoot.put(r, entry.getValue());\n                 numValues++;\n+            } else if (r.getClusterId() == context.getClusterId() \n+                    && !changes.contains(r)) {\n+                // OAK-2528: _commitRoot entry without associated\n+                // change -> consider as garbage\n+                addGarbage(r, COMMIT_ROOT);\n             }\n         }\n         committedChanges.put(COMMIT_ROOT, commitRoot);\n@@ -350,15 +361,15 @@ private UpdateOp createSplitOps() {\n     }\n \n     /**\n-     * Returns a map of all local property changes committed by the current\n+     * Collects all local property changes committed by the current\n      * cluster node.\n      *\n-     * @return local changes committed by the current cluster node.\n+     * @param committedLocally local changes committed by the current cluster node.\n+     * @param changes all revisions of local changes (committed and uncommitted).\n      */\n-    @Nonnull\n-    private Map<String, NavigableMap<Revision, String>> getCommittedLocalChanges() {\n-        Map<String, NavigableMap<Revision, String>> committedLocally\n-                = new HashMap<String, NavigableMap<Revision, String>>();\n+    private void collectLocalChanges(\n+            Map<String, NavigableMap<Revision, String>> committedLocally,\n+            Set<Revision> changes) {\n         for (String property : filter(doc.keySet(), PROPERTY_OR_DELETED)) {\n             NavigableMap<Revision, String> splitMap\n                     = new TreeMap<Revision, String>(context.getRevisionComparator());\n@@ -370,6 +381,7 @@ private UpdateOp createSplitOps() {\n                 if (rev.getClusterId() != context.getClusterId()) {\n                     continue;\n                 }\n+                changes.add(rev);\n                 if (doc.isCommitted(rev)) {\n                     splitMap.put(rev, entry.getValue());\n                 } else if (isGarbage(rev)) {\n@@ -377,7 +389,6 @@ private UpdateOp createSplitOps() {\n                 }\n             }\n         }\n-        return committedLocally;\n     }\n     \n     private boolean isGarbage(Revision rev) {\n@@ -392,12 +403,17 @@ private boolean isGarbage(Revision rev) {\n     }\n     \n     private void addGarbage(Revision rev, String property) {\n+        if (garbageCount > GARBAGE_LIMIT) {\n+            return;\n+        }\n         Set<Revision> revisions = garbage.get(property);\n         if (revisions == null) {\n             revisions = Sets.newHashSet();\n             garbage.put(property, revisions);\n         }\n-        revisions.add(rev);\n+        if (revisions.add(rev)) {\n+            garbageCount++;\n+        }\n     }\n \n     private void disconnectStalePrevDocs() {\n@@ -444,11 +460,13 @@ private void removeGarbage() {\n         for (Map.Entry<String, Set<Revision>> entry : garbage.entrySet()) {\n             for (Revision r : entry.getValue()) {\n                 main.removeMapEntry(entry.getKey(), r);\n+                if (PROPERTY_OR_DELETED.apply(entry.getKey())) {\n                     NodeDocument.removeCommitRoot(main, r);\n                     NodeDocument.removeRevision(main, r);\n                 }\n             }\n         }\n+    }\n \n     private void trackHigh(Revision r) {\n         if (high == null || isRevisionNewer(context, r, high)) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 25,
        "jira_id": "2528",
        "nb_skipped": 9,
        "commit": "239de7b8",
        "nb_failure": 1,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 79,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.mk.MicroKernelImplTest"
        ],
        "patch": "diff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/tree/DiffBuilder.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/tree/DiffBuilder.java\nindex f023fb37a2..d450b4f93e 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/tree/DiffBuilder.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/tree/DiffBuilder.java\n@@ -60,7 +60,7 @@ public String build() throws Exception {\n         if (before == null) {\n             if (after != null) {\n                 buff.tag('+').key(path).object();\n-                toJson(buff, after);\n+                toJson(buff, after, depth);\n                 return buff.endObject().newline().toString();\n             } else {\n                 // path doesn't exist in the specified revisions\n@@ -117,7 +117,7 @@ public void childNodeAdded(String name, NodeState after) {\n                     addedNodes.put(after, p);\n                     buff.tag('+').\n                             key(p).object();\n-                    toJson(buff, after);\n+                    toJson(buff, after, depth);\n                     buff.endObject().newline();\n                 }\n             }\n@@ -215,7 +215,7 @@ public void childNodeAdded(String name, NodeState after) {\n                     if (p.startsWith(pathFilter)) {\n                         buff.tag('+').\n                                 key(p).object();\n-                        toJson(buff, after);\n+                        toJson(buff, after, depth);\n                         buff.endObject().newline();\n                     }\n                 }\n@@ -267,14 +267,16 @@ public void childNodeChanged(String name, NodeState before, NodeState after) {\n         return buff.toString();\n     }\n \n-    private void toJson(JsopBuilder builder, NodeState node) {\n+    private void toJson(JsopBuilder builder, NodeState node, int depth) {\n         for (PropertyState property : node.getProperties()) {\n             builder.key(property.getName()).encodedValue(property.getEncodedValue());\n         }\n+        if (depth != 0) {\n             for (ChildNode entry : node.getChildNodeEntries(0, -1)) {\n                 builder.key(entry.getName()).object();\n-            toJson(builder, entry.getNode());\n+                toJson(builder, entry.getNode(), depth < 0 ? depth : depth - 1);\n                 builder.endObject();\n             }\n         }\n     }\n+}\n",
        "project": "jackrabbit-oak",
        "linesAdd": 7,
        "jira_id": "548",
        "nb_skipped": 2,
        "commit": "717186d6",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 2438,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.JournalTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex b4aae75506..2c72ff48cc 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -2084,9 +2084,9 @@ private void backgroundSplit() {\n     BackgroundWriteStats backgroundWrite() {\n         return unsavedLastRevisions.persist(this, new UnsavedModifications.Snapshot() {\n             @Override\n-            public void acquiring() {\n+            public void acquiring(Revision mostRecent) {\n                 if (store.create(JOURNAL,\n-                        singletonList(changes.asUpdateOp(getHeadRevision())))) {\n+                        singletonList(changes.asUpdateOp(mostRecent)))) {\n                     changes = JOURNAL.newDocument(getDocumentStore());\n                 }\n             }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\nindex 69e8fe7a6a..25f0390949 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\n@@ -235,7 +235,7 @@ public int recover(Iterator<NodeDocument> suspects,\n             unsaved.persist(nodeStore, new UnsavedModifications.Snapshot() {\n \n                 @Override\n-                public void acquiring() {\n+                public void acquiring(Revision mostRecent) {\n                     if (lastRootRev == null) {\n                         // this should never happen - when unsaved has no changes\n                         // that is reflected in the 'map' to be empty - in that\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnsavedModifications.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnsavedModifications.java\nindex d5f6c1edd9..1d06fa73b4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnsavedModifications.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnsavedModifications.java\n@@ -159,7 +159,7 @@ public BackgroundWriteStats persist(@Nonnull DocumentNodeStore store,\n         time = clock.getTime();\n         Map<String, Revision> pending;\n         try {\n-            snapshot.acquiring();\n+            snapshot.acquiring(getMostRecentRevision());\n             pending = Maps.newTreeMap(PathComparator.INSTANCE);\n             pending.putAll(map);\n         } finally {\n@@ -234,14 +234,26 @@ public String toString() {\n         return map.toString();\n     }\n \n+    private Revision getMostRecentRevision() {\n+        // use revision of root document\n+        Revision rev = map.get(\"/\");\n+        // otherwise find most recent\n+        if (rev == null) {\n+            for (Revision r : map.values()) {\n+                rev = Utils.max(rev, r);\n+            }\n+        }\n+        return rev;\n+    }\n+\n     public interface Snapshot {\n \n         Snapshot IGNORE = new Snapshot() {\n             @Override\n-            public void acquiring() {\n+            public void acquiring(Revision mostRecent) {\n             }\n         };\n \n-        void acquiring();\n+        void acquiring(Revision mostRecent);\n     }\n }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 16,
        "jira_id": "3433",
        "nb_skipped": 1,
        "commit": "b76b31f7",
        "nb_failure": 1,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2004,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 043f3449bf..2de0d39970 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -459,8 +459,11 @@ private void checkLastRevRecovery() {\n     }\n \n     public void dispose() {\n-        runBackgroundOperations();\n-        if (!isDisposed.getAndSet(true)) {\n+        if (isDisposed.getAndSet(true)) {\n+            // only dispose once\n+            return;\n+        }\n+        // notify background threads waiting on isDisposed\n         synchronized (isDisposed) {\n             isDisposed.notifyAll();\n         }\n@@ -469,6 +472,11 @@ public void dispose() {\n         } catch (InterruptedException e) {\n             // ignore\n         }\n+\n+        // do a final round of background operations after\n+        // the background thread stopped\n+        internalRunBackgroundOperations();\n+\n         if (leaseUpdateThread != null) {\n             try {\n                 leaseUpdateThread.join();\n@@ -476,11 +484,13 @@ public void dispose() {\n                 // ignore\n             }\n         }\n+\n+        // now mark this cluster node as inactive by\n+        // disposing the clusterNodeInfo\n         if (clusterNodeInfo != null) {\n             clusterNodeInfo.dispose();\n         }\n         store.dispose();\n-            LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n \n         if (blobStore instanceof Closeable) {\n             try {\n@@ -489,10 +499,10 @@ public void dispose() {\n                 LOG.debug(\"Error closing blob store \" + blobStore, ex);\n             }\n         }\n-        }\n         if (persistentCache != null) {\n             persistentCache.close();\n         }\n+        LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n     }\n \n     Revision setHeadRevision(@Nonnull Revision newHead) {\n@@ -544,6 +554,7 @@ Commit newCommit(@Nullable Revision base,\n             base = headRevision;\n         }\n         backgroundOperationLock.readLock().lock();\n+        checkOpen();\n         boolean success = false;\n         Commit c;\n         try {\n@@ -573,6 +584,7 @@ MergeCommit newMergeCommit(@Nullable Revision base, int numBranchCommits) {\n             base = headRevision;\n         }\n         backgroundOperationLock.readLock().lock();\n+        checkOpen();\n         boolean success = false;\n         MergeCommit c;\n         try {\n@@ -1502,15 +1514,22 @@ public Revision getHeadRevision() {\n \n     //----------------------< background operations >---------------------------\n \n-    public synchronized void runBackgroundOperations() {\n+    public void runBackgroundOperations() {\n         if (isDisposed.get()) {\n             return;\n         }\n-        if (simpleRevisionCounter != null) {\n-            // only when using timestamp\n+        try {\n+            internalRunBackgroundOperations();\n+        } catch (RuntimeException e) {\n+            if (isDisposed.get()) {\n+                LOG.warn(\"Background operation failed: \" + e.toString(), e);\n                 return;\n             }\n-        try {\n+            throw e;\n+        }\n+    }\n+\n+    private synchronized void internalRunBackgroundOperations() {\n         long start = clock.getTime();\n         long time = start;\n         // clean orphaned branches and collisions\n@@ -1536,12 +1555,6 @@ public synchronized void runBackgroundOperations() {\n         } else {\n             LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n         }\n-        } catch (RuntimeException e) {\n-            if (isDisposed.get()) {\n-                return;\n-            }\n-            throw e;\n-        }\n     }\n \n     /**\n@@ -1771,6 +1784,19 @@ void backgroundWrite() {\n \n     //-----------------------------< internal >---------------------------------\n \n+    /**\n+     * Checks if this store is still open and throws an\n+     * {@link IllegalStateException} if it is already disposed (or a dispose\n+     * is in progress).\n+     *\n+     * @throws IllegalStateException if this store is disposed.\n+     */\n+    private void checkOpen() throws IllegalStateException {\n+        if (isDisposed.get()) {\n+            throw new IllegalStateException(\"This DocumentNodeStore is disposed\");\n+        }\n+    }\n+\n     private boolean dispatch(@Nonnull String jsonDiff,\n                              @Nonnull DocumentNodeState node,\n                              @Nonnull DocumentNodeState base,\n",
        "project": "jackrabbit-oak",
        "linesAdd": 27,
        "jira_id": "2642",
        "nb_skipped": 9,
        "commit": "36fe017c",
        "nb_failure": 1,
        "linesRem": 13,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1625,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentSplitTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 49c9d01f32..48f3bfb11c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -362,9 +362,7 @@ public boolean containsRevision(@Nonnull Revision revision) {\n      */\n     @CheckForNull\n     public String getCommitRootPath(Revision revision) {\n-        // check local map first\n-        Map<Revision, String> local = getLocalCommitRoot();\n-        String depth = local.get(revision);\n+        String depth = getCommitRootDepth(revision);\n         if (depth != null) {\n             if (depth.equals(\"0\")) {\n                 return \"/\";\n@@ -373,13 +371,6 @@ public String getCommitRootPath(Revision revision) {\n             return PathUtils.getAncestorPath(p,\n                     PathUtils.getDepth(p) - Integer.parseInt(depth));\n         }\n-        // check previous\n-        for (NodeDocument prev : getPreviousDocs(COMMIT_ROOT, revision)) {\n-            String path = prev.getCommitRootPath(revision);\n-            if (path != null) {\n-                return path;\n-            }\n-        }\n         return null;\n     }\n \n@@ -967,6 +958,31 @@ private NodeDocument getCommitRoot(@Nonnull Revision rev) {\n         return store.find(Collection.NODES, Utils.getIdFromPath(commitRootPath));\n     }\n \n+    /**\n+     * Returns the commit root depth for the given revision. This method also\n+     * takes previous documents into account.\n+     *\n+     * @param revision get the commit root depth for this revision.\n+     * @return the depth or <code>null</code> if there is no commit root entry\n+     *         for the given revision on this document or previous documents.\n+     */\n+    @CheckForNull\n+    private String getCommitRootDepth(@Nonnull Revision revision) {\n+        // check local map first\n+        Map<Revision, String> local = getLocalCommitRoot();\n+        String depth = local.get(revision);\n+        if (depth == null) {\n+            // check previous\n+            for (NodeDocument prev : getPreviousDocs(COMMIT_ROOT, revision)) {\n+                depth = prev.getCommitRootDepth(revision);\n+                if (depth != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        return depth;\n+    }\n+\n     /**\n      * Checks that revision x is newer than another revision.\n      *\n",
        "project": "jackrabbit-oak",
        "linesAdd": 16,
        "jira_id": "1429",
        "nb_skipped": 7,
        "commit": "279bb3ce",
        "nb_failure": 1,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1847,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollectorTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex d57f8759b9..35a5f773ec 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -589,6 +589,10 @@ public CacheStats getDocChildrenCacheStats() {\n         return docChildrenCacheStats;\n     }\n \n+    void invalidateDocChildrenCache() {\n+        docChildrenCache.invalidateAll();\n+    }\n+\n     public int getPendingWriteCount() {\n         return unsavedLastRevisions.getPaths().size();\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\nindex e671b66d0d..885f7218c5 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java\n@@ -121,6 +121,7 @@ private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision\n             log.debug(sb.toString());\n         }\n         nodeStore.getDocumentStore().remove(Collection.NODES, docIdsToDelete);\n+        nodeStore.invalidateDocChildrenCache();\n         stats.deletedDocGCCount += docIdsToDelete.size();\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 5,
        "jira_id": "1779",
        "nb_skipped": 9,
        "commit": "9d36bede",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 136,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.segment.RecordTest"
        ],
        "patch": "diff --git a/oak-segment-next/src/main/java/org/apache/jackrabbit/oak/segment/SegmentWriter.java b/oak-segment-next/src/main/java/org/apache/jackrabbit/oak/segment/SegmentWriter.java\nindex b2f44f2d59..ee320ed6b2 100644\n--- a/oak-segment-next/src/main/java/org/apache/jackrabbit/oak/segment/SegmentWriter.java\n+++ b/oak-segment-next/src/main/java/org/apache/jackrabbit/oak/segment/SegmentWriter.java\n@@ -608,8 +608,20 @@ private RecordId writeStream(InputStream stream) throws IOException {\n             boolean threw = true;\n             try {\n                 RecordId id = SegmentStream.getRecordIdIfAvailable(stream, store);\n-                if (id == null || isOldGen(id)) {\n+                if (id == null) {\n+                    // This is either not a segment stream or a one from another store:\n+                    // fully serialise the stream.\n                     id = internalWriteStream(stream);\n+                } else if (isOldGen(id)) {\n+                    // This is a segment stream from this store but from an old generation:\n+                    // try to link to the blocks if there are any.\n+                    SegmentStream segmentStream = (SegmentStream) stream;\n+                    List<RecordId> blockIds = segmentStream.getBlockIds();\n+                    if (blockIds == null) {\n+                        return internalWriteStream(stream);\n+                    } else {\n+                        return writeValueRecord(segmentStream.getLength(), writeList(blockIds));\n+                    }\n                 }\n                 threw = false;\n                 return id;\n@@ -619,14 +631,6 @@ private RecordId writeStream(InputStream stream) throws IOException {\n         }\n \n         private RecordId internalWriteStream(InputStream stream) throws IOException {\n-            if (stream instanceof SegmentStream) {\n-                SegmentStream segmentStream = (SegmentStream) stream;\n-                List<RecordId> blockIds = segmentStream.getBlockIds();\n-                if (blockIds != null) {\n-                    return writeValueRecord(segmentStream.getLength(), writeList(blockIds));\n-                }\n-            }\n-\n             // Special case for short binaries (up to about 16kB):\n             // store them directly as small- or medium-sized value records\n             byte[] data = new byte[Segment.MEDIUM_LIMIT];\n",
        "project": "jackrabbit-oak",
        "linesAdd": 9,
        "jira_id": "4307",
        "nb_skipped": 2,
        "commit": "f303c916",
        "nb_failure": 1,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 2920,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.CommitRootUpdateTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\nindex 3d854d9434..9074e68168 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n@@ -388,7 +388,7 @@ private void applyToDocumentStore(RevisionVector baseBranchRevision) {\n                     // only set revision on commit root when there is\n                     // no collision for this commit revision\n                     commit.containsMapEntry(COLLISIONS, revision, false);\n-                    NodeDocument before = nodeStore.updateCommitRoot(commit);\n+                    NodeDocument before = nodeStore.updateCommitRoot(commit, revision);\n                     if (before == null) {\n                         String msg = \"Conflicting concurrent change. \" +\n                                 \"Update operation failed: \" + commitRoot;\n@@ -425,7 +425,13 @@ private void applyToDocumentStore(RevisionVector baseBranchRevision) {\n             if (success) {\n                 LOG.error(\"Exception occurred after commit. Rollback will be suppressed.\", e);\n             } else {\n+                try {\n                     rollback(newNodes, opLog, commitRoot);\n+                } catch (Exception ex) {\n+                    // catch any exception caused by the rollback, log it\n+                    // and throw the original exception\n+                    LOG.warn(\"Rollback failed\", ex);\n+                }\n                 throw e;\n             }\n         }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 14e608ffc4..8a715acd43 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -73,7 +73,6 @@\n import com.google.common.base.Suppliers;\n import com.google.common.cache.Cache;\n import com.google.common.collect.Iterables;\n-import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.common.util.concurrent.UncheckedExecutionException;\n@@ -1164,12 +1163,14 @@ void revisionsMerged(@Nonnull Iterable<Revision> revisions) {\n      * Updates a commit root document.\n      *\n      * @param commit the updates to apply on the commit root document.\n+     * @param commitRev the commit revision.\n      * @return the document before the update was applied or <code>null</code>\n      *          if the update failed because of a collision.\n      * @throws DocumentStoreException if the update fails with an error.\n      */\n     @CheckForNull\n-    NodeDocument updateCommitRoot(UpdateOp commit) throws DocumentStoreException {\n+    NodeDocument updateCommitRoot(UpdateOp commit, Revision commitRev)\n+            throws DocumentStoreException {\n         // use batch commit when there are only revision and modified updates\n         boolean batch = true;\n         for (Map.Entry<Key, Operation> op : commit.getChanges().entrySet()) {\n@@ -1181,11 +1182,63 @@ NodeDocument updateCommitRoot(UpdateOp commit) throws DocumentStoreException {\n             batch = false;\n             break;\n         }\n+        try {\n             if (batch) {\n                 return batchUpdateCommitRoot(commit);\n             } else {\n                 return store.findAndUpdate(NODES, commit);\n             }\n+        } catch (DocumentStoreException e) {\n+            return verifyCommitRootUpdateApplied(commit, commitRev, e);\n+        }\n+    }\n+\n+    /**\n+     * Verifies if the {@code commit} update on the commit root was applied by\n+     * reading the affected document and checks if the {@code commitRev} is\n+     * set in the revisions map.\n+     *\n+     * @param commit the update operation on the commit root document.\n+     * @param commitRev the commit revision.\n+     * @param e the exception that will be thrown when this method determines\n+     *          that the update was not applied.\n+     * @return the before document.\n+     * @throws DocumentStoreException the exception passed to this document\n+     *      in case the commit update was not applied.\n+     */\n+    private NodeDocument verifyCommitRootUpdateApplied(UpdateOp commit,\n+                                                       Revision commitRev,\n+                                                       DocumentStoreException e)\n+            throws DocumentStoreException {\n+        LOG.info(\"Update of commit root failed with exception\", e);\n+        int numRetries = 10;\n+        for (int i = 0; i < numRetries; i++) {\n+            LOG.info(\"Checking if change made it to the DocumentStore anyway {}/{} ...\",\n+                    i + 1, numRetries);\n+            NodeDocument commitRootDoc;\n+            try {\n+                commitRootDoc = store.find(NODES, commit.getId(), 0);\n+            } catch (Exception ex) {\n+                LOG.info(\"Failed to read commit root document\", ex);\n+                continue;\n+            }\n+            if (commitRootDoc == null) {\n+                LOG.info(\"Commit root document missing for {}\", commit.getId());\n+                break;\n+            }\n+            if (commitRootDoc.getLocalRevisions().containsKey(commitRev)) {\n+                LOG.info(\"Update made it to the store even though the call \" +\n+                        \"failed with an exception. Previous exception will \" +\n+                        \"be suppressed. {}\", commit);\n+                NodeDocument before = NODES.newDocument(store);\n+                commitRootDoc.deepCopy(before);\n+                UpdateUtils.applyChanges(before, commit.getReverseOperation());\n+                return before;\n+            }\n+            break;\n+        }\n+        LOG.info(\"Update didn't make it to the store. Re-throwing the exception\");\n+        throw e;\n     }\n \n     private NodeDocument batchUpdateCommitRoot(UpdateOp commit)\n",
        "project": "jackrabbit-oak",
        "linesAdd": 46,
        "jira_id": "3903",
        "nb_skipped": 1,
        "commit": "690fb9f4",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1156,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.query.QueryTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/RowImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/RowImpl.java\nindex fd09cacd0d..e337f39e79 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/RowImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/RowImpl.java\n@@ -25,6 +25,10 @@\n \n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.api.ResultRow;\n+import org.apache.jackrabbit.oak.api.Type;\n+import org.apache.jackrabbit.oak.spi.query.PropertyValues;\n+\n+import com.google.common.base.Joiner;\n \n /**\n  * The implementation of the corresponding JCR interface.\n@@ -96,9 +100,20 @@ public Value getValue(String columnName) throws RepositoryException {\n         int len = values.length;\n         Value[] v2 = new Value[values.length];\n         for (int i = 0; i < len; i++) {\n+            if(values[i].isArray()){\n+                v2[i] = result.createValue(mvpToString(values[i]));\n+            }else{\n                 v2[i] = result.createValue(values[i]);\n             }\n+        }\n         return v2;\n     }\n \n+    private static PropertyValue mvpToString(PropertyValue pv) {\n+        String v = Joiner.on(' ')\n+                .appendTo(new StringBuilder(), pv.getValue(Type.STRINGS))\n+                .toString();\n+        return PropertyValues.newString(v);\n+    }\n+\n }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 15,
        "jira_id": "1093",
        "nb_skipped": 3,
        "commit": "d7f0f180",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1975,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\nindex 899995a0ae..cc57477a22 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java\n@@ -289,7 +289,8 @@ private Revision determineMissedLastRev(NodeDocument doc, int clusterId) {\n         // if found then lastRev needs to be fixed\n         for (Revision rev : revs) {\n             if (rev.compareRevisionTime(currentLastRev) > 0) {\n-                if (doc.isCommitted(rev)) {\n+                rev = doc.getCommitRevision(rev);\n+                if (rev != null) {\n                     return rev;\n                 }\n             } else {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 388cca2ec3..912237b92a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -544,6 +544,26 @@ public boolean isCommitted(@Nonnull Revision revision) {\n         return false;\n     }\n \n+    /**\n+     * Returns the commit revision for the change with the given revision.\n+     *\n+     * @param revision the revision of a change.\n+     * @return the commit revision of the change or {@code null} if the change\n+     *          is not committed or unknown.\n+     */\n+    @CheckForNull\n+    public Revision getCommitRevision(@Nonnull Revision revision) {\n+        NodeDocument commitRoot = getCommitRoot(checkNotNull(revision));\n+        if (commitRoot == null) {\n+            return null;\n+        }\n+        String value = commitRoot.getCommitValue(revision);\n+        if (Utils.isCommitted(value)) {\n+            return Utils.resolveCommitRevision(revision, value);\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Returns <code>true</code> if this document contains an entry for the\n      * given <code>revision</code> in the {@link #REVISIONS} map. Please note\n",
        "project": "jackrabbit-oak",
        "linesAdd": 15,
        "jira_id": "2308",
        "nb_skipped": 9,
        "commit": "f4d5bbe1",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 399,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilderTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex 6600cc78a0..68cc5f2c8a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -422,7 +422,9 @@ public NodeBuilder child(String name) {\n         read(); // shortcut when dealing with a read-only child node\n         if (baseState != null\n                 && baseState.hasChildNode(name)\n-                && (writeState == null || !writeState.nodes.containsKey(name))) {\n+                && (writeState == null\n+                    || (writeState.base == baseState\n+                        && !writeState.nodes.containsKey(name)))) {\n             return createChildBuilder(name);\n         }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "447",
        "nb_skipped": 0,
        "commit": "00df38d2",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 1312,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.mongomk.MongoMKRebaseTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java\nindex c92d4f5a44..4047727145 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java\n@@ -747,7 +747,7 @@ Revision rebase(@Nonnull Revision branchHead, @Nonnull Revision base) {\n             // empty branch\n             return base.asBranchRevision();\n         }\n-        if (b.getBase().equals(base)) {\n+        if (b.getBase(branchHead).equals(base)) {\n             return branchHead;\n         }\n         // add a pseudo commit to make sure current head of branch\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "1129",
        "nb_skipped": 6,
        "commit": "2f95b81f",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 4,
        "nb_test": 1802,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex e0eb8656b6..e63e2d8abd 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -1205,7 +1205,7 @@ public static void setChildrenFlag(@Nonnull UpdateOp op,\n \n     public static void setModified(@Nonnull UpdateOp op,\n                                    @Nonnull Revision revision) {\n-        checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\n+        checkNotNull(op).max(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));\n     }\n \n     public static void setRevision(@Nonnull UpdateOp op,\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\nindex f00df7a79d..b957c37b22 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n@@ -131,9 +131,7 @@ public boolean hasChanges() {\n      * @param value the value\n      */\n     void setMapEntry(@Nonnull String property, @Nonnull Revision revision, String value) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.SET_MAP_ENTRY;\n-        op.value = value;\n+        Operation op = new Operation(Operation.Type.SET_MAP_ENTRY, value);\n         changes.put(new Key(property, checkNotNull(revision)), op);\n     }\n \n@@ -145,8 +143,7 @@ void setMapEntry(@Nonnull String property, @Nonnull Revision revision, String va\n      * @param revision the revision\n      */\n     public void removeMapEntry(@Nonnull String property, @Nonnull Revision revision) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.REMOVE_MAP_ENTRY;\n+        Operation op = new Operation(Operation.Type.REMOVE_MAP_ENTRY, null);\n         changes.put(new Key(property, checkNotNull(revision)), op);\n     }\n \n@@ -157,9 +154,23 @@ public void removeMapEntry(@Nonnull String property, @Nonnull Revision revision)\n      * @param value the value\n      */\n     void set(String property, Object value) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.SET;\n-        op.value = value;\n+        Operation op = new Operation(Operation.Type.SET, value);\n+        changes.put(new Key(property, null), op);\n+    }\n+\n+    /**\n+     * Set the property to the given value if the new value is higher than the\n+     * existing value. The property is also set to the given value if the\n+     * property does not yet exist.\n+     * <p>\n+     * The result of a max operation with different types of values is\n+     * undefined.\n+     *\n+     * @param property the name of the property to set.\n+     * @param value the new value for the property.\n+     */\n+    <T> void max(String property, Comparable<T> value) {\n+        Operation op = new Operation(Operation.Type.MAX, value);\n         changes.put(new Key(property, null), op);\n     }\n \n@@ -187,9 +198,7 @@ void containsMapEntry(@Nonnull String property,\n         if (isNew) {\n             throw new IllegalStateException(\"Cannot use containsMapEntry() on new document\");\n         }\n-        Operation op = new Operation();\n-        op.type = Operation.Type.CONTAINS_MAP_ENTRY;\n-        op.value = exists;\n+        Operation op = new Operation(Operation.Type.CONTAINS_MAP_ENTRY, exists);\n         changes.put(new Key(property, checkNotNull(revision)), op);\n     }\n \n@@ -200,9 +209,7 @@ void containsMapEntry(@Nonnull String property,\n      * @param value the increment\n      */\n     public void increment(@Nonnull String property, long value) {\n-        Operation op = new Operation();\n-        op.type = Operation.Type.INCREMENT;\n-        op.value = value;\n+        Operation op = new Operation(Operation.Type.INCREMENT, value);\n         changes.put(new Key(property, null), op);\n     }\n \n@@ -238,6 +245,14 @@ public String toString() {\n              */\n             SET,\n \n+            /**\n+             * Set the value if the new value is higher than the existing value.\n+             * The new value is also considered higher, when there is no\n+             * existing value.\n+             * The sub-key is not used.\n+             */\n+            MAX,\n+\n             /**\n              * Increment the Long value with the provided Long value.\n              * The sub-key is not used.\n@@ -267,12 +282,17 @@ public String toString() {\n         /**\n          * The operation type.\n          */\n-        public Type type;\n+        public final Type type;\n \n         /**\n          * The value, if any.\n          */\n-        public Object value;\n+        public final Object value;\n+\n+        Operation(Type type, Object value) {\n+            this.type = checkNotNull(type);\n+            this.value = value;\n+        }\n \n         @Override\n         public String toString() {\n@@ -283,18 +303,16 @@ public Operation getReverse() {\n             Operation reverse = null;\n             switch (type) {\n             case INCREMENT:\n-                reverse = new Operation();\n-                reverse.type = Type.INCREMENT;\n-                reverse.value = -(Long) value;\n+                reverse = new Operation(Type.INCREMENT, -(Long) value);\n                 break;\n             case SET:\n+            case MAX:\n             case REMOVE_MAP_ENTRY:\n             case CONTAINS_MAP_ENTRY:\n                 // nothing to do\n                 break;\n             case SET_MAP_ENTRY:\n-                reverse = new Operation();\n-                reverse.type = Type.REMOVE_MAP_ENTRY;\n+                reverse = new Operation(Type.REMOVE_MAP_ENTRY, null);\n                 break;\n             }\n             return reverse;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java\nindex b8015ff100..240665d422 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java\n@@ -44,7 +44,9 @@\n      * @param comparator\n      *            the revision comparator.\n      */\n-    public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {\n+    public static void applyChanges(@Nonnull Document doc,\n+                                    @Nonnull UpdateOp update,\n+                                    @Nonnull Comparator<Revision> comparator) {\n         for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {\n             Key k = e.getKey();\n             Operation op = e.getValue();\n@@ -53,6 +55,15 @@ public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update,\n                     doc.put(k.toString(), op.value);\n                     break;\n                 }\n+                case MAX: {\n+                    Comparable newValue = (Comparable) op.value;\n+                    Object old = doc.get(k.toString());\n+                    //noinspection unchecked\n+                    if (old == null || newValue.compareTo(old) > 0) {\n+                        doc.put(k.toString(), op.value);\n+                    }\n+                    break;\n+                }\n                 case INCREMENT: {\n                     Object old = doc.get(k.toString());\n                     Long x = (Long) op.value;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\nindex 0266e388a1..684f39f3f1 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java\n@@ -29,6 +29,8 @@\n import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.locks.Lock;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n \n import javax.annotation.CheckForNull;\n import javax.annotation.Nonnull;\n@@ -127,6 +129,7 @@\n     private String lastReadWriteMode;\n \n     public MongoDocumentStore(DB db, DocumentMK.Builder builder) {\n+        checkVersion(db);\n         nodes = db.getCollection(\n                 Collection.NODES.toString());\n         clusterNodes = db.getCollection(\n@@ -179,6 +182,24 @@ public MongoDocumentStore(DB db, DocumentMK.Builder builder) {\n                 builder.getDocumentCacheSize());\n     }\n \n+    private static void checkVersion(DB db) {\n+        String version = db.command(\"buildInfo\").getString(\"version\");\n+        Matcher m = Pattern.compile(\"^(\\\\d+)\\\\.(\\\\d+)\\\\..*\").matcher(version);\n+        if (!m.matches()) {\n+            throw new IllegalArgumentException(\"Malformed MongoDB version: \" + version);\n+        }\n+        int major = Integer.parseInt(m.group(1));\n+        int minor = Integer.parseInt(m.group(2));\n+        if (major > 2) {\n+            return;\n+        }\n+        if (minor < 6) {\n+            String msg = \"MongoDB version 2.6.0 or higher required. \" +\n+                    \"Currently connected to a MongoDB with version: \" + version;\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+\n     private Cache<CacheValue, NodeDocument> createOffHeapCache(\n             DocumentMK.Builder builder) {\n         ForwardingListener<CacheValue, NodeDocument> listener = ForwardingListener.newInstance();\n@@ -570,6 +591,7 @@ public NodeDocument call() throws Exception {\n                 Operation op = entry.getValue();\n                 switch (op.type) {\n                     case SET:\n+                    case MAX:\n                     case INCREMENT: {\n                         inserts[i].put(k.toString(), op.value);\n                         break;\n@@ -965,6 +987,7 @@ private static QueryBuilder createQueryForUpdate(UpdateOp updateOp,\n     @Nonnull\n     private static DBObject createUpdate(UpdateOp updateOp) {\n         BasicDBObject setUpdates = new BasicDBObject();\n+        BasicDBObject maxUpdates = new BasicDBObject();\n         BasicDBObject incUpdates = new BasicDBObject();\n         BasicDBObject unsetUpdates = new BasicDBObject();\n \n@@ -980,16 +1003,17 @@ private static DBObject createUpdate(UpdateOp updateOp) {\n             }\n             Operation op = entry.getValue();\n             switch (op.type) {\n-                case SET: {\n+                case SET:\n+                case SET_MAP_ENTRY: {\n                     setUpdates.append(k.toString(), op.value);\n                     break;\n                 }\n-                case INCREMENT: {\n-                    incUpdates.append(k.toString(), op.value);\n+                case MAX: {\n+                    maxUpdates.append(k.toString(), op.value);\n                     break;\n                 }\n-                case SET_MAP_ENTRY: {\n-                    setUpdates.append(k.toString(), op.value);\n+                case INCREMENT: {\n+                    incUpdates.append(k.toString(), op.value);\n                     break;\n                 }\n                 case REMOVE_MAP_ENTRY: {\n@@ -1003,6 +1027,9 @@ private static DBObject createUpdate(UpdateOp updateOp) {\n         if (!setUpdates.isEmpty()) {\n             update.append(\"$set\", setUpdates);\n         }\n+        if (!maxUpdates.isEmpty()) {\n+            update.append(\"$max\", maxUpdates);\n+        }\n         if (!incUpdates.isEmpty()) {\n             update.append(\"$inc\", incUpdates);\n         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 66,
        "jira_id": "1822",
        "nb_skipped": 9,
        "commit": "3e83a4c1",
        "nb_failure": 1,
        "linesRem": 28,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1838,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.authentication.token.TokenProviderImplTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java\nindex 2d4600fb7d..a10b41daec 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java\n@@ -29,6 +29,7 @@\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n+import java.util.UUID;\n import javax.annotation.CheckForNull;\n import javax.annotation.Nonnull;\n import javax.jcr.AccessDeniedException;\n@@ -210,11 +211,7 @@ public TokenInfo createToken(String userId, Map<String, ?> attributes) {\n         if (tokenParent != null) {\n             try {\n                 long creationTime = new Date().getTime();\n-                Calendar creation = GregorianCalendar.getInstance();\n-                creation.setTimeInMillis(creationTime);\n-                String tokenName = Text.replace(ISO8601.format(creation), \":\", \".\");\n-\n-                NodeUtil tokenNode = tokenParent.addChild(tokenName, TOKEN_NT_NAME);\n+                NodeUtil tokenNode = createTokenNode(tokenParent, creationTime);\n                 tokenNode.setString(JcrConstants.JCR_UUID, IdentifierManager.generateUUID());\n \n                 String key = generateKey(options.getConfigValue(PARAM_TOKEN_LENGTH, DEFAULT_KEY_SIZE));\n@@ -397,6 +394,31 @@ private NodeUtil getTokenParent(String userId) {\n         return tokenParent;\n     }\n \n+    /**\n+     * Create a new token node below the specified {@code parent}.\n+     *\n+     * @param parent The parent node.\n+     * @param creationTime The creation time that is used as name hint.\n+     * @return The new token node\n+     * @throws AccessDeniedException\n+     */\n+    private NodeUtil createTokenNode(@Nonnull NodeUtil parent, @Nonnull long creationTime) throws AccessDeniedException {\n+        Calendar creation = GregorianCalendar.getInstance();\n+        creation.setTimeInMillis(creationTime);\n+        String tokenName = Text.replace(ISO8601.format(creation), \":\", \".\");\n+        NodeUtil tokenNode;\n+        try {\n+            tokenNode = parent.addChild(tokenName, TOKEN_NT_NAME);\n+            root.commit();\n+        } catch (CommitFailedException e) {\n+            // conflict while creating token node -> retry\n+            log.debug(\"Failed to create token node \" + tokenName + \". Using random name as fallback.\");\n+            root.refresh();\n+            tokenNode = parent.addChild(UUID.randomUUID().toString(), TOKEN_NT_NAME);\n+        }\n+        return tokenNode;\n+    }\n+\n     //--------------------------------------------------------------------------\n \n     /**\n",
        "project": "jackrabbit-oak",
        "linesAdd": 18,
        "jira_id": "1697",
        "nb_skipped": 8,
        "commit": "1552be04",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 509,
        "nb_error": 5,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.RepositoryTest",
            "org.apache.jackrabbit.oak.jcr.MoveRemoveTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemDelegate.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemDelegate.java\nindex 501cebbe15..426621f28b 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemDelegate.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/ItemDelegate.java\n@@ -83,8 +83,7 @@ public NodeDelegate getParent() throws InvalidItemStateException {\n      * @return  {@code true} iff stale\n      */\n     public boolean isStale() {\n-        Status status = getLocationOrNull().getStatus();\n-        return status == Status.DISCONNECTED || status == null;\n+        return !getLocationInternal().exists();\n     }\n \n     /**\n@@ -116,7 +115,7 @@ public final SessionDelegate getSessionDelegate() {\n      */\n     @Nonnull\n     public TreeLocation getLocation() throws InvalidItemStateException {\n-        TreeLocation location = getLocationOrNull();\n+        TreeLocation location = getLocationInternal();\n         if (!location.exists()) {\n             throw new InvalidItemStateException(\"Item is stale\");\n         }\n@@ -134,12 +133,12 @@ public String toString() {\n     /**\n      * The underlying {@link org.apache.jackrabbit.oak.api.TreeLocation} of this item.\n      * The location is only re-resolved when the revision of this item does not match\n-     * the revision of the session.\n+     * the revision of the session or when the location does not exist (anymore).\n      * @return  tree location of the underlying item.\n      */\n     @Nonnull\n-    private synchronized TreeLocation getLocationOrNull() {\n-        if (location.exists() && sessionDelegate.getRevision() != revision) {\n+    private synchronized TreeLocation getLocationInternal() {\n+        if (sessionDelegate.getRevision() != revision || !location.exists()) {\n             location = sessionDelegate.getLocation(location.getPath());\n             revision = sessionDelegate.getRevision();\n         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 4,
        "jira_id": "606",
        "nb_skipped": 1,
        "commit": "f0fbacab",
        "nb_failure": 0,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2654,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.CheckpointsTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Checkpoints.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Checkpoints.java\nindex e1d712d32a..8a6a98c80a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Checkpoints.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Checkpoints.java\n@@ -26,6 +26,7 @@\n import java.util.concurrent.atomic.AtomicInteger;\n \n import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n \n import org.apache.jackrabbit.oak.commons.json.JsopBuilder;\n import org.apache.jackrabbit.oak.commons.json.JsopReader;\n@@ -73,7 +74,14 @@\n     }\n \n     public Revision create(long lifetimeInMillis, Map<String, String> info) {\n-        Revision r = nodeStore.getHeadRevision();\n+        // create a unique dummy commit we can use as checkpoint revision\n+        Revision r = nodeStore.commitQueue.createRevision();\n+        nodeStore.commitQueue.done(r, new CommitQueue.Callback() {\n+            @Override\n+            public void headOfQueue(@Nonnull Revision revision) {\n+                // do nothing\n+            }\n+        });\n         createCounter.getAndIncrement();\n         performCleanupIfRequired();\n         UpdateOp op = new UpdateOp(ID, false);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 7,
        "jira_id": "1648",
        "nb_skipped": 1,
        "commit": "fdc54465",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 331,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.CRUDTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\nindex c3ff7d69d4..c1114a75f2 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeImpl.java\n@@ -302,19 +302,20 @@ public Property setProperty(String name, Value value) throws RepositoryException\n      * @see Node#setProperty(String, javax.jcr.Value, int)\n      */\n     @Override\n-    @CheckForNull\n+    @Nonnull\n     public Property setProperty(final String jcrName, final Value value, final int type)\n             throws RepositoryException {\n         checkStatus();\n \n-        return sessionDelegate.perform(new SessionOperation<PropertyImpl>() {\n+        return sessionDelegate.perform(new SessionOperation<Property>() {\n             @Override\n-            public PropertyImpl perform() throws RepositoryException {\n-                String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n+            public Property perform() throws RepositoryException {\n                 if (value == null) {\n-                    dlg.removeProperty(oakName);\n-                    return null;\n+                    Property property = getProperty(jcrName);\n+                    property.remove();\n+                    return property;\n                 } else {\n+                    String oakName = sessionDelegate.getOakPathOrThrow(jcrName);\n                     int targetType = getTargetType(value, type);\n                     Value targetValue =\n                             ValueHelper.convert(value, targetType, getValueFactory());\n",
        "project": "jackrabbit-oak",
        "linesAdd": 7,
        "jira_id": "395",
        "nb_skipped": 4,
        "commit": "4ed7bc8e",
        "nb_failure": 2,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1768,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.blob.ds.MongoDataStoreBlobStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/DataStoreBlobStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/DataStoreBlobStore.java\nindex 3ad49ad2fa..0880a194c2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/DataStoreBlobStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/DataStoreBlobStore.java\n@@ -267,7 +267,8 @@ public long getBlockSizeMin() {\n             public boolean apply(DataIdentifier input) {\n                 try {\n                     DataRecord dr = delegate.getRecord(input);\n-                    if(dr != null && dr.getLastModified() < maxLastModifiedTime){\n+                    if(dr != null && (maxLastModifiedTime <=0\n+                            || dr.getLastModified() < maxLastModifiedTime)){\n                         return true;\n                     }\n                 } catch (DataStoreException e) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "1655",
        "nb_skipped": 8,
        "commit": "c91bfa54",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1870,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.segment.ExternalBlobTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\nindex 0552b3342b..16c3f83777 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n@@ -219,7 +219,7 @@ public synchronized void flush() {\n                 data.put(buffer, buffer.length - length, length);\n                 data.rewind();\n             } else {\n-                data = ByteBuffer.wrap(buffer);\n+                data = ByteBuffer.wrap(buffer, buffer.length - length, length);\n             }\n             tracker.setSegment(id, new Segment(tracker, id, data));\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "1817",
        "nb_skipped": 9,
        "commit": "78c37386",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 9,
        "nb_test": 1899,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java\nindex 74cfd81f6f..0574916b5a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java\n@@ -44,6 +44,7 @@\n \n     private static final Logger LOG = LoggerFactory.getLogger(OrderedPropertyIndex.class);\n \n+    @Override\n     public String getIndexName() {\n         return TYPE;\n     }\n@@ -57,6 +58,7 @@ OrderedPropertyIndexLookup getLookup(NodeState root) {\n      * \n      * !!! for now we want to skip the use-case of NON range-queries !!!\n      */\n+    @Override\n     public double getCost(Filter filter, NodeState root) {\n         throw new UnsupportedOperationException(\"Not supported as implementing AdvancedQueryIndex\");\n     }\n@@ -181,6 +183,7 @@ public Cursor query(IndexPlan plan, NodeState root) {\n \n         Filter filter = plan.getFilter();\n         List<OrderEntry> sortOrder = plan.getSortOrder();\n+        String pathPrefix = plan.getPathPrefix();\n         Iterable<String> paths = null;\n         OrderedContentMirrorStoreStrategy strategy\n                 = OrderedPropertyIndexLookup.getStrategy(plan.getDefinition());\n@@ -190,7 +193,7 @@ public Cursor query(IndexPlan plan, NodeState root) {\n             String propertyName = PathUtils.getName(pr.propertyName);\n             depth = PathUtils.getDepth(propertyName);\n             paths = strategy.query(plan.getFilter(), propertyName,\n-                    plan.getDefinition(), pr);\n+                    plan.getDefinition(), pr, pathPrefix);\n         }\n         if (paths == null && sortOrder != null && !sortOrder.isEmpty()) {\n             // we could be here if we have a query where the ORDER BY makes us play it.\n@@ -198,7 +201,7 @@ public Cursor query(IndexPlan plan, NodeState root) {\n                 String propertyName = PathUtils.getName(oe.getPropertyName());\n                 depth = PathUtils.getDepth(oe.getPropertyName());\n                 paths = strategy.query(plan.getFilter(), propertyName,\n-                        plan.getDefinition(), new PropertyRestriction());\n+                        plan.getDefinition(), new PropertyRestriction(), pathPrefix);\n             }\n         }\n \n@@ -209,7 +212,6 @@ public Cursor query(IndexPlan plan, NodeState root) {\n                             + filter);\n         }\n         Cursor cursor = Cursors.newPathCursor(paths, filter.getQueryEngineSettings());\n-        cursor = Cursors.newPrefixCursor(cursor, plan.getPathPrefix());\n         if (depth > 1) {\n             cursor = Cursors.newAncestorCursor(cursor, depth - 1, filter.getQueryEngineSettings());\n         }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndexLookup.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndexLookup.java\nindex df940110ee..dc35da41a0 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndexLookup.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndexLookup.java\n@@ -203,7 +203,8 @@ public double getCost(Filter filter, String propertyName, PropertyValue value) {\n         if (indexMeta == null) {\n             throw new IllegalArgumentException(\"No index for \" + propertyName);\n         }\n-        return getStrategy(indexMeta).query(filter, propertyName, indexMeta, pr);\n+        return getStrategy(indexMeta).query(\n+                filter, propertyName, indexMeta, pr, \"\");\n     }\n \n     /**\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookup.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookup.java\nindex ae18d9bc55..cfd96e21d6 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookup.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookup.java\n@@ -129,7 +129,7 @@ public double getCost(Filter filter, String propertyName, PropertyValue value) {\n             return Double.POSITIVE_INFINITY;\n         }\n         return COST_OVERHEAD +\n-                getStrategy(indexMeta).count(indexMeta, encode(value), MAX_COST);\n+                getStrategy(indexMeta).count(filter, indexMeta, encode(value), MAX_COST);\n     }\n \n     /**\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\nindex 5cc398d074..8ace776a4e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\n@@ -135,7 +135,7 @@\n \n                 if (restriction != null) {\n                     Set<String> values = getValues(restriction);\n-                    double cost = strategy.count(definition, values, MAX_COST);\n+                    double cost = strategy.count(filter, definition, values, MAX_COST);\n                     if (cost < bestCost) {\n                         bestDepth = depth;\n                         bestValues = values;\n@@ -152,7 +152,7 @@\n                 if (constraint instanceof OrImpl) {\n                     Set<String> values = findMultiProperty((OrImpl) constraint);\n                     if (values != null) {\n-                        double cost = strategy.count(definition, values, MAX_COST);\n+                        double cost = strategy.count(filter, definition, values, MAX_COST);\n                         if (cost < bestCost) {\n                             bestDepth = 1;\n                             bestValues = values;\n@@ -208,7 +208,7 @@ private boolean isIndexed(DynamicOperandImpl operand) {\n         }\n     }\n \n-    private Set<String> getValues(PropertyRestriction restriction) {\n+    private static Set<String> getValues(PropertyRestriction restriction) {\n         if (restriction.firstIncluding\n                 && restriction.lastIncluding\n                 && restriction.first != null\n@@ -249,6 +249,7 @@ Cursor execute() {\n \n     //------------------------------------------------------------< Object >--\n \n+    @Override\n     public String toString() {\n         StringBuilder buffer = new StringBuilder(\"property \");\n         buffer.append(name);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\nindex be32205219..26eed1e0f8 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\n@@ -121,7 +121,7 @@ private void insert(NodeBuilder index, String key, String value) {\n         return new Iterable<String>() {\n             @Override\n             public Iterator<String> iterator() {\n-                PathIterator it = new PathIterator(filter, indexName);\n+                PathIterator it = new PathIterator(filter, indexName, \"\");\n                 if (values == null) {\n                     it.setPathContainsValue(true);\n                     it.enqueue(getChildNodeEntries(index).iterator());\n@@ -157,8 +157,18 @@ public long count(NodeState indexMeta, Set<String> values, int max) {\n         return count(indexMeta, INDEX_CONTENT_NODE_NAME, values, max);\n     }\n \n+    @Override\n+    public long count(final Filter filter, NodeState indexMeta, Set<String> values, int max) {\n+        return count(filter, indexMeta, INDEX_CONTENT_NODE_NAME, values, max);\n+    }\n+\n     public long count(NodeState indexMeta, final String indexStorageNodeName,\n             Set<String> values, int max) {\n+        return count(null, indexMeta, indexStorageNodeName, values, max);\n+    }\n+\n+    public long count(Filter filter, NodeState indexMeta, final String indexStorageNodeName,\n+            Set<String> values, int max) {\n         NodeState index = indexMeta.getChildNode(indexStorageNodeName);\n         int count = 0;\n         if (values == null) {\n@@ -196,6 +206,11 @@ public long count(NodeState indexMeta, final String indexStorageNodeName,\n             }\n             max = Math.max(10, max / size);\n             int i = 0;\n+            String filterRootPath = null;\n+            if (filter != null &&\n+                    filter.getPathRestriction().equals(Filter.PathRestriction.ALL_CHILDREN)) {\n+                filterRootPath = filter.getPath();\n+            }\n             for (String p : values) {\n                 if (count > max && i > 3) {\n                     // the total count is extrapolated from the the number \n@@ -204,6 +219,16 @@ public long count(NodeState indexMeta, final String indexStorageNodeName,\n                     break;\n                 }\n                 NodeState s = index.getChildNode(p);\n+                if (filterRootPath != null && s.exists()) {\n+                    // Descend directly to path restriction inside index tree\n+                    for (String pathFragment : PathUtils\n+                            .elements(filterRootPath)) {\n+                        s = s.getChildNode(pathFragment);\n+                        if (!s.exists()) {\n+                            break;\n+                        }\n+                    }\n+                }\n                 if (s.exists()) {\n                     CountingNodeVisitor v = new CountingNodeVisitor(max);\n                     v.visit(s);\n@@ -227,6 +252,8 @@ public long count(NodeState indexMeta, final String indexStorageNodeName,\n         private int readCount;\n         private boolean init;\n         private boolean closed;\n+        private String filterPath;\n+        private String pathPrefix;\n         private String parentPath;\n         private String currentPath;\n         private boolean pathContainsValue;\n@@ -237,9 +264,19 @@ public long count(NodeState indexMeta, final String indexStorageNodeName,\n         private final Set<String> knownPaths = Sets.newHashSet();\n         private final long maxMemoryEntries;\n \n-        PathIterator(Filter filter, String indexName) {\n+        PathIterator(Filter filter, String indexName, String pathPrefix) {\n             this.filter = filter;\n+            this.pathPrefix = pathPrefix;\n             this.indexName = indexName;\n+            boolean shouldDescendDirectly = filter.getPathRestriction().equals(Filter.PathRestriction.ALL_CHILDREN);\n+            if (shouldDescendDirectly) {            \n+                filterPath = filter.getPath();\n+                if (PathUtils.denotesRoot(filterPath)) {\n+                    filterPath = \"\";\n+                }\n+            } else {\n+                filterPath = \"\";\n+            }            \n             parentPath = \"\";\n             currentPath = \"/\";\n             this.maxMemoryEntries = filter.getQueryEngineSettings().getLimitInMemory();\n@@ -305,6 +342,25 @@ private void fetchNextPossiblyDuplicate() {\n                     }\n                     currentPath = PathUtils.concat(parentPath, name);\n \n+                    if (!\"\".equals(filterPath)) {\n+                        String p = currentPath;\n+                        if (pathContainsValue) {\n+                            String value = PathUtils.elements(p).iterator().next();\n+                            p = PathUtils.relativize(value, p);                        \n+                        }\n+                        if (\"\".equals(pathPrefix)) {\n+                            p = PathUtils.concat(\"/\", p);\n+                        } else {\n+                            p = PathUtils.concat(pathPrefix, p);\n+                        }\n+                        if (!\"\".equals(p) && \n+                                !p.equals(filterPath) && \n+                                !PathUtils.isAncestor(p, filterPath) && \n+                                !PathUtils.isAncestor(filterPath, p)) {\n+                            continue;\n+                        }\n+                    }\n+\n                     nodeIterators.addLast(node.getChildNodeEntries().iterator());\n                     parentPath = currentPath;\n \n@@ -330,7 +386,7 @@ public String next() {\n                 fetchNext();\n                 init = true;\n             }\n-            String result = currentPath;\n+            String result = PathUtils.concat(pathPrefix, currentPath);\n             fetchNext();\n             return result;\n         }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/IndexStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/IndexStoreStrategy.java\nindex 5864eef052..6438fc0062 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/IndexStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/IndexStoreStrategy.java\n@@ -43,7 +43,7 @@ void update(\n     /**\n      * Search for a given set of values.\n      * \n-     * @param filter the filter (used for logging)\n+     * @param filter the filter (can optionally be used for optimized query execution)\n      * @param indexName the name of the index (for logging)\n      * @param indexMeta the index metadata node (may not be null)\n      * @param values values to look for (null to check for property existence)\n@@ -62,4 +62,16 @@ void update(\n      */\n     long count(NodeState indexMeta, Set<String> values, int max);\n \n+    /**\n+     * Count the occurrence of a given set of values. Used in calculating the\n+     * cost of an index.\n+     *\n+     * @param filter the filter which can be used to estimate better cost\n+     * @param indexMeta the index metadata node (may not be null)\n+     * @param values values to look for (null to check for property existence)\n+     * @param max the maximum value to return\n+     * @return the aggregated count of occurrences for each provided value\n+     */\n+    long count(Filter filter, NodeState indexMeta, Set<String> values, int max);\n+\n }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\nindex 2445869ebe..411f734c33 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n@@ -265,6 +265,11 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n         return cne;\n     }\n     \n+    public Iterable<String> query(final Filter filter, final String indexName,\n+            final NodeState indexMeta, final PropertyRestriction pr) {\n+        return query(filter, indexName, indexMeta, pr, \"\");\n+    }\n+\n     /**\n      * search the index for the provided PropertyRestriction\n      * \n@@ -275,8 +280,9 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n      * @return the iterable\n      */\n     public Iterable<String> query(final Filter filter, final String indexName,\n-                                  final NodeState indexMeta, final PropertyRestriction pr) {\n-        return query(filter, indexName, indexMeta, INDEX_CONTENT_NODE_NAME, pr);\n+                                  final NodeState indexMeta, final PropertyRestriction pr,\n+                                  String pathPrefix) {\n+        return query(filter, indexName, indexMeta, INDEX_CONTENT_NODE_NAME, pr, pathPrefix);\n     }\n \n     /**\n@@ -292,7 +298,7 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n      */\n     public Iterable<String> query(final Filter filter, final String indexName,\n                                   final NodeState indexMeta, final String indexStorageNodeName,\n-                                  final PropertyRestriction pr) {\n+                                  final PropertyRestriction pr, String pathPrefix) {\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"query() - filter: {}\", filter);            \n             LOG.debug(\"query() - indexName: {}\", indexName);            \n@@ -325,11 +331,14 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n                         indexState.getChildNode(firstValuableItemKey));\n                     if (direction.isAscending()) {\n                         childrenIterable = new SeekedIterable(indexState, firstValueableItem);\n-                        it = new QueryResultsWrapper(filter, indexName, childrenIterable);\n+                        it = new QueryResultsWrapper(filter, indexName, \n+                                childrenIterable, pathPrefix);\n                     } else {\n-                        it = new QueryResultsWrapper(filter, indexName, new BetweenIterable(\n+                        it = new QueryResultsWrapper(filter, indexName, \n+                                new BetweenIterable(\n                                         indexState, firstValueableItem, firstEncoded,\n-                            pr.firstIncluding, direction));\n+                                        pr.firstIncluding, direction),\n+                                pathPrefix);\n                     }\n                 }\n             } else {\n@@ -362,7 +371,8 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n                         indexState.getChildNode(firstValuableItemKey));\n                     childrenIterable = new BetweenIterable(indexState, firstValueableItem, last,\n                         includeLast, direction);\n-                    it = new QueryResultsWrapper(filter, indexName, childrenIterable);\n+                    it = new QueryResultsWrapper(filter, indexName, \n+                            childrenIterable, pathPrefix);\n                 }\n             }\n \n@@ -387,18 +397,21 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n                 firstValueableItem = new OrderedChildNodeEntry(firstValueableItemKey,\n                     indexState.getChildNode(firstValueableItemKey));\n                 if (direction.isAscending()) {\n-                    it = new QueryResultsWrapper(filter, indexName, new BetweenIterable(indexState,\n-                        firstValueableItem, searchfor, include, direction));\n+                    it = new QueryResultsWrapper(filter, indexName, \n+                            new BetweenIterable(indexState, firstValueableItem, searchfor, include, direction),\n+                            pathPrefix);\n                 } else {\n-                    it = new QueryResultsWrapper(filter, indexName, new SeekedIterable(indexState,\n-                        firstValueableItem));\n+                    it = new QueryResultsWrapper(filter, indexName, \n+                            new SeekedIterable(indexState, firstValueableItem),\n+                            pathPrefix);\n                 }\n             }\n             return it;\n         } else {\n             // property is not null. AKA \"open query\"\n             LOG.debug(\"property is not null. AKA 'open query'. FullIterable\");\n-            return new QueryResultsWrapper(filter, indexName, new FullIterable(indexState, false));\n+            return new QueryResultsWrapper(filter, indexName, \n+                    new FullIterable(indexState, false), pathPrefix);\n         }\n     }\n     \n@@ -602,17 +615,20 @@ public String getSearchFor() {\n         private Iterable<ChildNodeEntry> children;\n         private String indexName;\n         private Filter filter;\n+        private String pathPrefix;\n \n         public QueryResultsWrapper(Filter filter, String indexName,\n-                                   Iterable<ChildNodeEntry> children) {\n+                                   Iterable<ChildNodeEntry> children,\n+                                   String pathPrefix) {\n             this.children = children;\n             this.indexName = indexName;\n             this.filter = filter;\n+            this.pathPrefix = pathPrefix;\n         }\n \n         @Override\n         public Iterator<String> iterator() {\n-            PathIterator pi = new PathIterator(filter, indexName);\n+            PathIterator pi = new PathIterator(filter, indexName, pathPrefix);\n             pi.setPathContainsValue(true);\n             pi.enqueue(children.iterator());\n             return pi;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/UniqueEntryStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/UniqueEntryStoreStrategy.java\nindex 15111ec0a4..ca80c7e22c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/UniqueEntryStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/UniqueEntryStoreStrategy.java\n@@ -166,4 +166,8 @@ public long count(NodeState indexMeta, Set<String> values, int max) {\n         return count;\n     }\n \n+    @Override\n+    public long count(final Filter filter, NodeState indexMeta, Set<String> values, int max) {\n+        return count(indexMeta, values, max);\n+    }\n }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java\nindex 4d851910c8..ff4a1abfb7 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java\n@@ -24,7 +24,6 @@\n \n import javax.annotation.Nullable;\n \n-import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.plugins.memory.MemoryChildNodeEntry;\n import org.apache.jackrabbit.oak.query.FilterIterators;\n@@ -73,23 +72,6 @@ public static Cursor newPathCursor(Iterable<String> paths, QueryEngineSettings s\n         return new PathCursor(paths.iterator(), true, settings);\n     }\n \n-    /**\n-     * Creates a cursor which wraps another cursor and adds a path prefix to\n-     * each of row of the wrapped cursor. This method will return the passed\n-     * cursor as is if {@code path} is the empty string or the root path (\"/\").\n-     *\n-     * @param c    the cursor to wrap.\n-     * @param path the path prefix.\n-     * @return the cursor.\n-     */\n-    public static Cursor newPrefixCursor(Cursor c, String path) {\n-        if (path.isEmpty() || PathUtils.denotesRoot(path)) {\n-            // no need to wrap\n-            return c;\n-        }\n-        return new PrefixCursor(c, path);\n-    }\n-    \n     /**\n      * Creates a {@link Cursor} over paths, and make the result distinct.\n      * The iterator might return duplicate paths\n@@ -219,48 +201,6 @@ public boolean hasNext() {\n         \n     }\n \n-    /**\n-     * A cursor which wraps another cursor and adds a path prefix to each of\n-     * row of the wrapped cursor.\n-     */\n-    private static final class PrefixCursor extends AbstractCursor {\n-\n-        private final Cursor c;\n-        private final String path;\n-\n-        PrefixCursor(Cursor c, String prefix) {\n-            this.c = c;\n-            this.path = prefix;\n-        }\n-\n-        @Override\n-        public IndexRow next() {\n-            final IndexRow r = c.next();\n-            return new IndexRow() {\n-\n-                @Override\n-                public String getPath() {\n-                    String sub = r.getPath();\n-                    if (PathUtils.isAbsolute(sub)) {\n-                        return path + sub;\n-                    } else {\n-                        return PathUtils.concat(path, r.getPath());\n-                    }\n-                }\n-\n-                @Override\n-                public PropertyValue getValue(String columnName) {\n-                    return r.getValue(columnName);\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public boolean hasNext() {\n-            return c.hasNext();\n-        }\n-    }\n-\n     /**\n      * A cursor that reads all nodes in a given subtree.\n      */\n",
        "project": "jackrabbit-oak",
        "linesAdd": 106,
        "jira_id": "1977",
        "nb_skipped": 9,
        "commit": "4bfbfcdd",
        "nb_failure": 2,
        "linesRem": 71,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 413,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.principal.PrincipalProviderImplTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/api/QueryEngine.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/api/QueryEngine.java\nindex c43f58e92c..96b3ef82c8 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/api/QueryEngine.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/api/QueryEngine.java\n@@ -52,8 +52,8 @@\n      *\n      * @param statement the query statement\n      * @param language the language\n-     * @param limit the maximum result set size\n-     * @param offset the number of rows to skip\n+     * @param limit the maximum result set size (may not be negative)\n+     * @param offset the number of rows to skip (may not be negative)\n      * @param bindings the bind variable value bindings\n      * @param namePathMapper the name and path mapper to use\n      * @return the result\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java\nindex 4dcb86b704..e5d4adb954 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java\n@@ -138,6 +138,12 @@ private Query parseQuery(String statement, String language) throws ParseExceptio\n     public Result executeQuery(String statement, String language, long limit,\n             long offset, Map<String, ? extends PropertyValue> bindings,\n             NamePathMapper namePathMapper) throws ParseException {\n+        if (limit < 0) {\n+            throw new IllegalArgumentException(\"Limit may not be negative, is: \" + limit);\n+        }\n+        if (offset < 0) {\n+            throw new IllegalArgumentException(\"Offset may not be negative, is: \" + offset);\n+        }\n         Query q = parseQuery(statement, language);\n         q.setRootTree(getRootTree());\n         q.setRootState(getRootState());\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/query/XPathQueryBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/query/XPathQueryBuilder.java\nindex 893738bf0a..d1dd992d5f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/query/XPathQueryBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/query/XPathQueryBuilder.java\n@@ -35,7 +35,7 @@\n     private boolean sortIgnoreCase;\n     private Value bound;\n     private long offset;\n-    private long maxCount = -1;\n+    private long maxCount = Long.MAX_VALUE;\n \n     //-------------------------------------------------------< QueryBuilder >---\n     @Override\n",
        "project": "jackrabbit-oak",
        "linesAdd": 7,
        "jira_id": "546",
        "nb_skipped": 1,
        "commit": "428e32c6",
        "nb_failure": 3,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1936,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.IndexUpdateTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/Oak.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/Oak.java\nindex 04020c1365..9399ae992e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/Oak.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/Oak.java\n@@ -60,6 +61,7 @@\n import org.apache.jackrabbit.oak.plugins.commit.ConflictHook;\n import org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate;\n import org.apache.jackrabbit.oak.plugins.index.CompositeIndexEditorProvider;\n+import org.apache.jackrabbit.oak.plugins.index.IndexConstants;\n import org.apache.jackrabbit.oak.plugins.index.IndexEditorProvider;\n import org.apache.jackrabbit.oak.plugins.index.IndexUpdateProvider;\n import org.apache.jackrabbit.oak.plugins.index.property.jmx.PropertyIndexAsyncReindex;\n@@ -528,11 +530,11 @@ public ContentRepository createContentRepository() {\n                     task.getIndexStats(), IndexStatsMBean.TYPE, name));\n \n             PropertyIndexAsyncReindex asyncPI = new PropertyIndexAsyncReindex(\n-                    new AsyncIndexUpdate(\"async-reindex\", store, indexEditors,\n-                            true), getExecutor()\n-            );\n-            regs.add(registerMBean(whiteboard, PropertyIndexAsyncReindexMBean.class,\n-                    asyncPI, PropertyIndexAsyncReindexMBean.TYPE, name));\n+                    new AsyncIndexUpdate(IndexConstants.ASYNC_REINDEX_VALUE,\n+                            store, indexEditors, true), getExecutor());\n+            regs.add(registerMBean(whiteboard,\n+                    PropertyIndexAsyncReindexMBean.class, asyncPI,\n+                    PropertyIndexAsyncReindexMBean.TYPE, name));\n         }\n \n         regs.add(registerMBean(whiteboard, QueryEngineSettingsMBean.class,\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\nindex c8879d08de..ea8dd803ae 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n@@ -357,9 +357,10 @@ private void updateIndex(\n                 } else {\n                     postAsyncRunStatsStatus(indexStats);\n                 }\n-            } else if (switchOnSync) {\n-                log.debug(\"No changes detected after diff; will try to\"\n-                        + \" switch to synchronous updates on {}\",\n+            } else {\n+                if (switchOnSync) {\n+                    log.debug(\n+                            \"No changes detected after diff; will try to switch to synchronous updates on {}\",\n                             reindexedDefinitions);\n \n                     // no changes after diff, switch to sync on the async defs\n@@ -374,12 +375,12 @@ private void updateIndex(\n                     }\n                     reindexedDefinitions.clear();\n                 }\n+                postAsyncRunStatsStatus(indexStats);\n+            }\n             mergeWithConcurrencyCheck(builder, beforeCheckpoint, callback.lease);\n         } finally {\n             callback.close();\n         }\n-\n-        postAsyncRunStatsStatus(indexStats);\n     }\n \n     private void mergeWithConcurrencyCheck(\n",
        "project": "jackrabbit-oak",
        "linesAdd": 12,
        "jira_id": "2174",
        "nb_skipped": 9,
        "commit": "5931a4a7",
        "nb_failure": 1,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 204,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.segment.CompareAgainstBaseStateTest"
        ],
        "patch": "diff --git a/oak-segment/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeState.java b/oak-segment/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeState.java\nindex cb42af2f07..6df8c3859f 100644\n--- a/oak-segment/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeState.java\n+++ b/oak-segment/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeState.java\n@@ -555,9 +555,11 @@ public boolean compareAgainstBaseState(NodeState base, NodeStateDiff diff) {\n                 }\n             }\n         } else if (beforeChildName != Template.MANY_CHILD_NODES) {\n+            boolean beforeChildStillExists = false;\n             for (ChildNodeEntry entry\n                     : afterTemplate.getChildNodeEntries(afterId)) {\n                 String childName = entry.getName();\n+                beforeChildStillExists |= childName.equals(beforeChildName);\n                 NodeState afterChild = entry.getNodeState();\n                 if (beforeChildName.equals(childName)) {\n                     NodeState beforeChild =\n@@ -577,6 +579,13 @@ public boolean compareAgainstBaseState(NodeState base, NodeStateDiff diff) {\n                     return false;\n                 }\n             }\n+            if (!beforeChildStillExists) {\n+                NodeState beforeChild =\n+                        beforeTemplate.getChildNode(beforeChildName, beforeId);\n+                if (!diff.childNodeDeleted(beforeChildName, beforeChild)) {\n+                    return false;\n+                }\n+            }\n         } else {\n             MapRecord afterMap = afterTemplate.getChildNodeMap(afterId);\n             MapRecord beforeMap = beforeTemplate.getChildNodeMap(beforeId);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 9,
        "jira_id": "4153",
        "nb_skipped": 7,
        "commit": "9120fd1b",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 2190,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.UpdateOpTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\nindex a76466969d..7f09df6882 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java\n@@ -383,7 +383,7 @@ private void applyToDocumentStore(Revision baseBranchRevision) {\n                     // to set isNew to false. If we get here the\n                     // commitRoot document already exists and\n                     // only needs an update\n-                    UpdateOp commit = commitRoot.shallowCopy(commitRoot.getId());\n+                    UpdateOp commit = commitRoot.copy();\n                     commit.setNew(false);\n                     // only set revision on commit root when there is\n                     // no collision for this commit revision\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 3455f4be4c..65f79f3595 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -1170,13 +1170,11 @@ void revisionsMerged(@Nonnull Iterable<Revision> revisions) {\n     @CheckForNull\n     NodeDocument updateCommitRoot(UpdateOp commit) throws DocumentStoreException {\n         // use batch commit when there are only revision and modified updates\n-        // and collision checks\n         boolean batch = true;\n         for (Map.Entry<Key, Operation> op : commit.getChanges().entrySet()) {\n             String name = op.getKey().getName();\n             if (NodeDocument.isRevisionsEntry(name)\n-                    || NodeDocument.MODIFIED_IN_SECS.equals(name)\n-                    || NodeDocument.COLLISIONS.equals(name)) {\n+                    || NodeDocument.MODIFIED_IN_SECS.equals(name)) {\n                 continue;\n             }\n             batch = false;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\nindex f72a7ae4fb..0196878119 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java\n@@ -50,23 +50,32 @@\n      * @param isNew whether this is a new document\n      */\n     UpdateOp(String id, boolean isNew) {\n-        this(id, isNew, false, new HashMap<Key, Operation>());\n+        this(id, isNew, false, new HashMap<Key, Operation>(), null);\n     }\n \n-    private UpdateOp(String id, boolean isNew, boolean isDelete,\n-                     Map<Key, Operation> changes) {\n-        this.id = id;\n+    private UpdateOp(@Nonnull String id, boolean isNew, boolean isDelete,\n+                     @Nonnull Map<Key, Operation> changes,\n+                     @Nullable Map<Key, Condition> conditions) {\n+        this.id = checkNotNull(id);\n         this.isNew = isNew;\n         this.isDelete = isDelete;\n-        this.changes = changes;\n+        this.changes = checkNotNull(changes);\n+        this.conditions = conditions;\n     }\n \n     static UpdateOp combine(String id, Iterable<UpdateOp> ops) {\n         Map<Key, Operation> changes = Maps.newHashMap();\n+        Map<Key, Condition> conditions = Maps.newHashMap();\n         for (UpdateOp op : ops) {\n             changes.putAll(op.getChanges());\n+            if (op.conditions != null) {\n+                conditions.putAll(op.conditions);\n             }\n-        return new UpdateOp(id, false, false, changes);\n+        }\n+        if (conditions.isEmpty()) {\n+            conditions = null;\n+        }\n+        return new UpdateOp(id, false, false, changes, conditions);\n     }\n \n     /**\n@@ -76,7 +85,7 @@ static UpdateOp combine(String id, Iterable<UpdateOp> ops) {\n      * @param id the primary key.\n      */\n     public UpdateOp shallowCopy(String id) {\n-        return new UpdateOp(id, isNew, isDelete, changes);\n+        return new UpdateOp(id, isNew, isDelete, changes, conditions);\n     }\n \n     /**\n@@ -86,8 +95,12 @@ public UpdateOp shallowCopy(String id) {\n      * @return a copy of this operation.\n      */\n     public UpdateOp copy() {\n+        Map<Key, Condition> conditionMap = null;\n+        if (conditions != null) {\n+            conditionMap = new HashMap<Key, Condition>(conditions);\n+        }\n         return new UpdateOp(id, isNew, isDelete,\n-                new HashMap<Key, Operation>(changes));\n+                new HashMap<Key, Operation>(changes), conditionMap);\n     }\n \n     public String getId() {\n@@ -254,7 +267,11 @@ public UpdateOp getReverseOperation() {\n \n     @Override\n     public String toString() {\n-        return \"key: \" + id + \" \" + (isNew ? \"new\" : \"update\") + \" \" + changes;\n+        String s = \"key: \" + id + \" \" + (isNew ? \"new\" : \"update\") + \" \" + changes;\n+        if (conditions != null) {\n+            s += \" conditions \" + conditions;\n+        }\n+        return s;\n     }\n \n     private Map<Key, Condition> getOrCreateConditions() {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 28,
        "jira_id": "3028",
        "nb_skipped": 9,
        "commit": "89317b28",
        "nb_failure": 3,
        "linesRem": 12,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 347,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.RepositoryTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeDelegate.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeDelegate.java\nindex 644096bcd5..6fd4a9ce64 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeDelegate.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/NodeDelegate.java\n@@ -33,6 +33,7 @@\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Tree;\n import org.apache.jackrabbit.oak.api.TreeLocation;\n+import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.plugins.memory.PropertyStates;\n \n /**\n@@ -93,7 +94,7 @@ public long getPropertyCount() throws InvalidItemStateException {\n      * no such property exists\n      */\n     @CheckForNull\n-    public PropertyDelegate getProperty(String relPath) throws InvalidItemStateException {\n+    public PropertyDelegate getProperty(String relPath) throws RepositoryException {\n         TreeLocation propertyLocation = getChildLocation(relPath);\n         PropertyState propertyState = propertyLocation.getProperty();\n         return propertyState == null\n@@ -126,7 +127,7 @@ public long getChildCount() throws InvalidItemStateException {\n      * no such node exists\n      */\n     @CheckForNull\n-    public NodeDelegate getChild(String relPath) throws InvalidItemStateException {\n+    public NodeDelegate getChild(String relPath) throws RepositoryException {\n         return create(sessionDelegate, getChildLocation(relPath));\n     }\n \n@@ -241,8 +242,20 @@ Tree getTree() throws InvalidItemStateException {\n \n     // -----------------------------------------------------------< private >---\n \n-    private TreeLocation getChildLocation(String relPath) throws InvalidItemStateException {\n-        return getLocation().getChild(relPath);\n+    private TreeLocation getChildLocation(String relPath) throws RepositoryException {\n+        if (PathUtils.isAbsolute(relPath)) {\n+            throw new RepositoryException(\"Not a relative path: \" + relPath);\n+        }\n+\n+        TreeLocation loc = getLocation();\n+        for (String element : PathUtils.elements(relPath)) {\n+            if (PathUtils.denotesParent(element)) {\n+                loc = loc.getParent();\n+            } else if (!PathUtils.denotesCurrent(element)) {\n+                loc = loc.getChild(element);\n+            }  // else . -> skip to next element\n+        }\n+        return loc;\n     }\n \n     private Iterator<NodeDelegate> nodeDelegateIterator(\n",
        "project": "jackrabbit-oak",
        "linesAdd": 17,
        "jira_id": "369",
        "nb_skipped": 4,
        "commit": "4e245a76",
        "nb_failure": 2,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2012,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.blob.ClusterRepositoryInfoTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/ClusterRepositoryInfo.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/ClusterRepositoryInfo.java\nindex 7b5f4da5fd..d2755eb335 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/ClusterRepositoryInfo.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/ClusterRepositoryInfo.java\n@@ -23,8 +23,11 @@\n import org.apache.jackrabbit.oak.spi.commit.CommitInfo;\n import org.apache.jackrabbit.oak.spi.commit.EmptyHook;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n+import org.apache.jackrabbit.oak.spi.state.NodeState;\n import org.apache.jackrabbit.oak.spi.state.NodeStore;\n \n+import javax.annotation.CheckForNull;\n+\n /**\n  * Utility class to manage a unique cluster/repository id for the cluster.\n  */\n@@ -57,8 +60,13 @@ public static String createId(NodeStore store) throws CommitFailedException {\n      * @param store the NodeStore instance\n      * @return the repository id\n      */\n+    @CheckForNull\n     public static String getId(NodeStore store) {\n-        return store.getRoot().getChildNode(CLUSTER_CONFIG_NODE).getProperty(CLUSTER_ID_PROP).getValue(Type.STRING);\n+        NodeState state = store.getRoot().getChildNode(CLUSTER_CONFIG_NODE);\n+        if (state.hasProperty(CLUSTER_ID_PROP)) {\n+            return state.getProperty(CLUSTER_ID_PROP).getValue(Type.STRING);\n+        }\n+        return null;\n     }\n }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 9,
        "jira_id": "2691",
        "nb_skipped": 9,
        "commit": "d2da7499",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1809,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.OrphanedBranchTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex aa67c4a6fe..c5d5094d58 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -802,8 +802,13 @@ public DocumentNodeState getNodeAtRevision(@Nonnull DocumentNodeStore nodeStore,\n             if (!Utils.isPropertyName(key)) {\n                 continue;\n             }\n+            // ignore when local map is empty (OAK-2442)\n+            SortedMap<Revision, String> local = getLocalMap(key);\n+            if (local.isEmpty()) {\n+                continue;\n+            }\n             // first check local map, which contains most recent values\n-            Value value = getLatestValue(nodeStore, getLocalMap(key),\n+            Value value = getLatestValue(nodeStore, local,\n                     min, readRevision, validRevisions, lastRevs);\n \n             // check if there may be more recent values in a previous document\n",
        "project": "jackrabbit-oak",
        "linesAdd": 5,
        "jira_id": "2442",
        "nb_skipped": 9,
        "commit": "ea7a6199",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 13,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.upgrade.RepositoryUpgradeTest"
        ],
        "patch": "diff --git a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\nindex 72899ea61e..7ba64cbc41 100644\n--- a/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n+++ b/oak-upgrade/src/main/java/org/apache/jackrabbit/oak/upgrade/RepositoryUpgrade.java\n@@ -16,18 +16,83 @@\n  */\n package org.apache.jackrabbit.oak.upgrade;\n \n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Lists.newArrayList;\n+import static com.google.common.collect.Lists.newArrayListWithCapacity;\n+import static com.google.common.collect.Maps.newHashMap;\n+import static java.util.Arrays.asList;\n+import static org.apache.jackrabbit.JcrConstants.JCR_AUTOCREATED;\n+import static org.apache.jackrabbit.JcrConstants.JCR_CHILDNODEDEFINITION;\n+import static org.apache.jackrabbit.JcrConstants.JCR_DEFAULTPRIMARYTYPE;\n+import static org.apache.jackrabbit.JcrConstants.JCR_DEFAULTVALUES;\n+import static org.apache.jackrabbit.JcrConstants.JCR_HASORDERABLECHILDNODES;\n+import static org.apache.jackrabbit.JcrConstants.JCR_ISMIXIN;\n+import static org.apache.jackrabbit.JcrConstants.JCR_MANDATORY;\n+import static org.apache.jackrabbit.JcrConstants.JCR_MULTIPLE;\n+import static org.apache.jackrabbit.JcrConstants.JCR_NAME;\n+import static org.apache.jackrabbit.JcrConstants.JCR_NODETYPENAME;\n+import static org.apache.jackrabbit.JcrConstants.JCR_ONPARENTVERSION;\n+import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYITEMNAME;\n+import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYTYPE;\n+import static org.apache.jackrabbit.JcrConstants.JCR_PROPERTYDEFINITION;\n+import static org.apache.jackrabbit.JcrConstants.JCR_PROTECTED;\n+import static org.apache.jackrabbit.JcrConstants.JCR_REQUIREDPRIMARYTYPES;\n+import static org.apache.jackrabbit.JcrConstants.JCR_REQUIREDTYPE;\n+import static org.apache.jackrabbit.JcrConstants.JCR_SAMENAMESIBLINGS;\n+import static org.apache.jackrabbit.JcrConstants.JCR_SUPERTYPES;\n+import static org.apache.jackrabbit.JcrConstants.JCR_SYSTEM;\n+import static org.apache.jackrabbit.JcrConstants.JCR_VALUECONSTRAINTS;\n+import static org.apache.jackrabbit.JcrConstants.JCR_VERSIONSTORAGE;\n+import static org.apache.jackrabbit.JcrConstants.NT_CHILDNODEDEFINITION;\n+import static org.apache.jackrabbit.JcrConstants.NT_NODETYPE;\n+import static org.apache.jackrabbit.JcrConstants.NT_PROPERTYDEFINITION;\n+import static org.apache.jackrabbit.core.RepositoryImpl.ACTIVITIES_NODE_ID;\n+import static org.apache.jackrabbit.core.RepositoryImpl.ROOT_NODE_ID;\n+import static org.apache.jackrabbit.core.RepositoryImpl.VERSION_STORAGE_NODE_ID;\n+import static org.apache.jackrabbit.oak.api.Type.BOOLEANS;\n+import static org.apache.jackrabbit.oak.api.Type.DECIMALS;\n+import static org.apache.jackrabbit.oak.api.Type.DOUBLES;\n+import static org.apache.jackrabbit.oak.api.Type.LONGS;\n+import static org.apache.jackrabbit.oak.api.Type.NAME;\n+import static org.apache.jackrabbit.oak.api.Type.NAMES;\n+import static org.apache.jackrabbit.oak.api.Type.PATHS;\n+import static org.apache.jackrabbit.oak.api.Type.STRINGS;\n+import static org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty;\n+import static org.apache.jackrabbit.oak.plugins.name.Namespaces.addCustomMapping;\n+import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_AVAILABLE_QUERY_OPERATORS;\n+import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_ABSTRACT;\n+import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_FULLTEXT_SEARCHABLE;\n+import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_QUERYABLE;\n+import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_QUERY_ORDERABLE;\n+import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_NODE_TYPES;\n+import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.NT_REP_PRIVILEGE;\n+import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.NT_REP_PRIVILEGES;\n+import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_AGGREGATES;\n+import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_BITS;\n+import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_IS_ABSTRACT;\n+import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_NEXT;\n+import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_PRIVILEGES;\n+import static org.apache.jackrabbit.spi.commons.name.NameConstants.ANY_NAME;\n+\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.math.BigDecimal;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.Properties;\n \n import javax.jcr.NamespaceException;\n+import javax.jcr.PropertyType;\n import javax.jcr.RepositoryException;\n+import javax.jcr.UnsupportedRepositoryOperationException;\n import javax.jcr.security.Privilege;\n import javax.jcr.version.OnParentVersionAction;\n \n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n import org.apache.jackrabbit.core.RepositoryContext;\n import org.apache.jackrabbit.core.config.BeanConfig;\n import org.apache.jackrabbit.core.config.LoginModuleConfig;\n@@ -41,6 +106,8 @@\n import org.apache.jackrabbit.core.security.user.UserManagerImpl;\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.Type;\n+import org.apache.jackrabbit.oak.namepath.GlobalNameMapper;\n+import org.apache.jackrabbit.oak.namepath.NameMapper;\n import org.apache.jackrabbit.oak.plugins.index.CompositeIndexEditorProvider;\n import org.apache.jackrabbit.oak.plugins.index.IndexUpdateProvider;\n import org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexEditorProvider;\n@@ -68,6 +135,8 @@\n import org.apache.jackrabbit.oak.upgrade.security.GroupEditorProvider;\n import org.apache.jackrabbit.oak.upgrade.security.RestrictionEditorProvider;\n import org.apache.jackrabbit.spi.Name;\n+import org.apache.jackrabbit.spi.Path;\n+import org.apache.jackrabbit.spi.Path.Element;\n import org.apache.jackrabbit.spi.QItemDefinition;\n import org.apache.jackrabbit.spi.QNodeDefinition;\n import org.apache.jackrabbit.spi.QNodeTypeDefinition;\n@@ -77,59 +146,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.google.common.collect.ImmutableMap;\n-\n-import static com.google.common.base.Preconditions.checkState;\n-import static com.google.common.collect.Lists.newArrayList;\n-import static com.google.common.collect.Lists.newArrayListWithCapacity;\n-import static com.google.common.collect.Maps.newHashMap;\n-import static java.util.Arrays.asList;\n-import static org.apache.jackrabbit.JcrConstants.JCR_AUTOCREATED;\n-import static org.apache.jackrabbit.JcrConstants.JCR_CHILDNODEDEFINITION;\n-import static org.apache.jackrabbit.JcrConstants.JCR_DEFAULTPRIMARYTYPE;\n-import static org.apache.jackrabbit.JcrConstants.JCR_HASORDERABLECHILDNODES;\n-import static org.apache.jackrabbit.JcrConstants.JCR_ISMIXIN;\n-import static org.apache.jackrabbit.JcrConstants.JCR_MANDATORY;\n-import static org.apache.jackrabbit.JcrConstants.JCR_MULTIPLE;\n-import static org.apache.jackrabbit.JcrConstants.JCR_NAME;\n-import static org.apache.jackrabbit.JcrConstants.JCR_NODETYPENAME;\n-import static org.apache.jackrabbit.JcrConstants.JCR_ONPARENTVERSION;\n-import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYITEMNAME;\n-import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYTYPE;\n-import static org.apache.jackrabbit.JcrConstants.JCR_PROPERTYDEFINITION;\n-import static org.apache.jackrabbit.JcrConstants.JCR_PROTECTED;\n-import static org.apache.jackrabbit.JcrConstants.JCR_REQUIREDPRIMARYTYPES;\n-import static org.apache.jackrabbit.JcrConstants.JCR_REQUIREDTYPE;\n-import static org.apache.jackrabbit.JcrConstants.JCR_SAMENAMESIBLINGS;\n-import static org.apache.jackrabbit.JcrConstants.JCR_SUPERTYPES;\n-import static org.apache.jackrabbit.JcrConstants.JCR_SYSTEM;\n-import static org.apache.jackrabbit.JcrConstants.JCR_VALUECONSTRAINTS;\n-import static org.apache.jackrabbit.JcrConstants.JCR_VERSIONSTORAGE;\n-import static org.apache.jackrabbit.JcrConstants.NT_CHILDNODEDEFINITION;\n-import static org.apache.jackrabbit.JcrConstants.NT_NODETYPE;\n-import static org.apache.jackrabbit.JcrConstants.NT_PROPERTYDEFINITION;\n-import static org.apache.jackrabbit.core.RepositoryImpl.ACTIVITIES_NODE_ID;\n-import static org.apache.jackrabbit.core.RepositoryImpl.ROOT_NODE_ID;\n-import static org.apache.jackrabbit.core.RepositoryImpl.VERSION_STORAGE_NODE_ID;\n-import static org.apache.jackrabbit.oak.api.Type.NAME;\n-import static org.apache.jackrabbit.oak.api.Type.NAMES;\n-import static org.apache.jackrabbit.oak.api.Type.STRINGS;\n-import static org.apache.jackrabbit.oak.plugins.name.Namespaces.addCustomMapping;\n-import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_AVAILABLE_QUERY_OPERATORS;\n-import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_ABSTRACT;\n-import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_FULLTEXT_SEARCHABLE;\n-import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_QUERYABLE;\n-import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_QUERY_ORDERABLE;\n-import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_NODE_TYPES;\n-import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.NT_REP_PRIVILEGE;\n-import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.NT_REP_PRIVILEGES;\n-import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_AGGREGATES;\n-import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_BITS;\n-import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_IS_ABSTRACT;\n-import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_NEXT;\n-import static org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConstants.REP_PRIVILEGES;\n-import static org.apache.jackrabbit.spi.commons.name.NameConstants.ANY_NAME;\n-\n public class RepositoryUpgrade {\n \n     /**\n@@ -236,10 +252,10 @@ public void copy(RepositoryInitializer initializer) throws RepositoryException {\n                 sc.getWorkspaceInitializer().initialize(builder, workspace);\n             }\n \n-            Map<String, String> uriToPrefix = newHashMap();\n+            HashBiMap<String, String> uriToPrefix = HashBiMap.create();\n             Map<Integer, String> idxToPrefix = newHashMap();\n             copyNamespaces(builder, uriToPrefix, idxToPrefix);\n-            copyNodeTypes(builder);\n+            copyNodeTypes(builder, uriToPrefix.inverse());\n             copyPrivileges(builder);\n \n             NodeState root = builder.getNodeState();\n@@ -458,7 +474,8 @@ private PrivilegeBits resolvePrivilegeBits(\n         return bits;\n     }\n \n-    private void copyNodeTypes(NodeBuilder root) throws RepositoryException {\n+    private void copyNodeTypes(NodeBuilder root, Map<String, String> prefixToUri)\n+            throws RepositoryException {\n         NodeTypeRegistry sourceRegistry = source.getNodeTypeRegistry();\n         NodeBuilder system = root.child(JCR_SYSTEM);\n         NodeBuilder types = system.child(JCR_NODE_TYPES);\n@@ -470,13 +487,14 @@ private void copyNodeTypes(NodeBuilder root) throws RepositoryException {\n             if (!types.hasChildNode(oakName)) {\n                 QNodeTypeDefinition def = sourceRegistry.getNodeTypeDef(name);\n                 NodeBuilder type = types.child(oakName);\n-                copyNodeType(def, type);\n+                copyNodeType(def, type, prefixToUri);\n             }\n         }\n     }\n \n-    private void copyNodeType(QNodeTypeDefinition def, NodeBuilder builder)\n-            throws NamespaceException {\n+    private void copyNodeType(\n+            QNodeTypeDefinition def, NodeBuilder builder, Map<String, String> prefixToUri)\n+            throws RepositoryException {\n         builder.setProperty(JCR_PRIMARYTYPE, NT_NODETYPE, NAME);\n \n         // - jcr:nodeTypeName (NAME) protected mandatory\n@@ -510,7 +528,7 @@ private void copyNodeType(QNodeTypeDefinition def, NodeBuilder builder)\n         QPropertyDefinition[] properties = def.getPropertyDefs();\n         for (int i = 0; i < properties.length; i++) {\n             String name = JCR_PROPERTYDEFINITION + '[' + (i + 1) + ']';\n-            copyPropertyDefinition(properties[i], builder.child(name));\n+            copyPropertyDefinition(properties[i], builder.child(name), prefixToUri);\n         }\n \n         // + jcr:childNodeDefinition (nt:childNodeDefinition) = nt:childNodeDefinition protected sns\n@@ -522,8 +540,8 @@ private void copyNodeType(QNodeTypeDefinition def, NodeBuilder builder)\n     }\n \n     private void copyPropertyDefinition(\n-            QPropertyDefinition def, NodeBuilder builder)\n-            throws NamespaceException {\n+            QPropertyDefinition def, NodeBuilder builder, Map<String, String> prefixToUri)\n+            throws RepositoryException {\n         builder.setProperty(JCR_PRIMARYTYPE, NT_PROPERTYDEFINITION, NAME);\n \n         copyItemDefinition(def, builder);\n@@ -545,9 +563,9 @@ private void copyPropertyDefinition(\n             builder.setProperty(JCR_VALUECONSTRAINTS, strings, STRINGS);\n         }\n         // - jcr:defaultValues (UNDEFINED) protected multiple\n-        QValue[] values = def.getDefaultValues();\n-        if (values != null) {\n-            // TODO\n+        QValue[] qValues = def.getDefaultValues();\n+        if (qValues != null) {\n+            copyDefaultValues(qValues, builder, new GlobalNameMapper(prefixToUri));\n         }\n         // - jcr:multiple (BOOLEAN) protected mandatory\n         builder.setProperty(JCR_MULTIPLE, def.isMultiple());\n@@ -561,6 +579,99 @@ private void copyPropertyDefinition(\n         builder.setProperty(JCR_IS_QUERY_ORDERABLE, def.isQueryOrderable());\n     }\n \n+    private static void copyDefaultValues(QValue[] qValues, NodeBuilder builder,\n+            NameMapper nameMapper) throws RepositoryException {\n+        if (qValues.length == 0) {\n+            builder.setProperty(JCR_DEFAULTVALUES, Collections.<String>emptyList(), STRINGS);\n+        } else {\n+            int type = qValues[0].getType();\n+            switch (type) {\n+                case PropertyType.STRING:\n+                    List<String> strings = newArrayListWithCapacity(qValues.length);\n+                    for (QValue qValue : qValues) {\n+                        strings.add(qValue.getString());\n+                    }\n+                    builder.setProperty(createProperty(JCR_DEFAULTVALUES, strings, STRINGS));\n+                    return;\n+                case PropertyType.LONG:\n+                    List<Long> longs = newArrayListWithCapacity(qValues.length);\n+                    for (QValue qValue : qValues) {\n+                        longs.add(qValue.getLong());\n+                    }\n+                    builder.setProperty(createProperty(JCR_DEFAULTVALUES, longs, LONGS));\n+                    return;\n+                case PropertyType.DOUBLE:\n+                    List<Double> doubles = newArrayListWithCapacity(qValues.length);\n+                    for (QValue qValue : qValues) {\n+                        doubles.add(qValue.getDouble());\n+                    }\n+                    builder.setProperty(createProperty(JCR_DEFAULTVALUES, doubles, DOUBLES));\n+                    return;\n+                case PropertyType.BOOLEAN:\n+                    List<Boolean> booleans = Lists.newArrayListWithCapacity(qValues.length);\n+                    for (QValue qValue : qValues) {\n+                        booleans.add(qValue.getBoolean());\n+                    }\n+                    builder.setProperty(createProperty(JCR_DEFAULTVALUES, booleans, BOOLEANS));\n+                    return;\n+                case PropertyType.NAME:\n+                    List<String> names = Lists.newArrayListWithCapacity(qValues.length);\n+                    for (QValue qValue : qValues) {\n+                        names.add(nameMapper.getOakName(qValue.getName().toString()));\n+                    }\n+                    builder.setProperty(createProperty(JCR_DEFAULTVALUES, names, NAMES));\n+                    return;\n+                case PropertyType.PATH:\n+                    List<String> paths = Lists.newArrayListWithCapacity(qValues.length);\n+                    for (QValue qValue : qValues) {\n+                        paths.add(getOakPath(qValue.getPath(), nameMapper));\n+                    }\n+                    builder.setProperty(createProperty(JCR_DEFAULTVALUES, paths, PATHS));\n+                    return;\n+                case PropertyType.DECIMAL:\n+                    List<BigDecimal> decimals = Lists.newArrayListWithCapacity(qValues.length);\n+                    for (QValue qValue : qValues) {\n+                        decimals.add(qValue.getDecimal());\n+                    }\n+                    builder.setProperty(createProperty(JCR_DEFAULTVALUES, decimals, DECIMALS));\n+                    return;\n+                case PropertyType.DATE:\n+                case PropertyType.URI:\n+                    List<String> values = newArrayListWithCapacity(qValues.length);\n+                    for (QValue qValue : qValues) {\n+                        values.add(qValue.getString());\n+                    }\n+                    builder.setProperty(createProperty(JCR_DEFAULTVALUES, values, Type.fromTag(type, true)));\n+                    return;\n+                default:\n+                    throw new UnsupportedRepositoryOperationException(\n+                            \"Cannot copy default value of type \" + Type.fromTag(type, true));\n+            }\n+        }\n+    }\n+\n+    private static String getOakPath(Path path, NameMapper nameMapper)\n+            throws RepositoryException {\n+        StringBuilder oakPath = new StringBuilder();\n+        String sep = \"\";\n+        for (Element element: path.getElements()) {\n+            if (element.denotesRoot()) {\n+                oakPath.append('/');\n+                continue;\n+            } else if (element.denotesName()) {\n+                oakPath.append(sep).append(nameMapper.getOakName(element.getString()));\n+            } else if (element.denotesCurrent()) {\n+                oakPath.append(sep).append('.');\n+            } else if (element.denotesParent()) {\n+                oakPath.append(sep).append(\"..\");\n+            } else {\n+                throw new UnsupportedRepositoryOperationException(\"Cannot copy default value \" + path);\n+            }\n+            sep = \"/\";\n+        }\n+        return oakPath.toString();\n+    }\n+\n     private void copyChildNodeDefinition(\n             QNodeDefinition def, NodeBuilder builder)\n             throws NamespaceException {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 176,
        "jira_id": "1731",
        "nb_skipped": 0,
        "commit": "024e5d37",
        "nb_failure": 1,
        "linesRem": 64,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 459,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexTest",
            "org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\nindex ea255df759..2e60d8d221 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n@@ -461,6 +461,14 @@ private boolean addTypedOrderedFields(List<Field> fields,\n                                           PropertyState property,\n                                           String pname,\n                                           PropertyDefinition pd) throws CommitFailedException {\n+        // Ignore and warn if property multi-valued as not supported\n+        if (property.getType().isArray()) {\n+            log.warn(\n+                \"Ignoring ordered property {} of type {} for path {} as multivalued ordered property not supported\",\n+                pname, Type.fromTag(property.getType().tag(), true), getPath());\n+            return false;\n+        }\n+\n         int tag = property.getType().tag();\n         int idxDefinedTag = pd.getType();\n         // Try converting type to the defined type in the index definition\n@@ -475,24 +483,23 @@ private boolean addTypedOrderedFields(List<Field> fields,\n \n         String name = FieldNames.createDocValFieldName(pname);\n         boolean fieldAdded = false;\n-        for (int i = 0; i < property.count(); i++) {\n         Field f = null;\n         try {\n             if (tag == Type.LONG.tag()) {\n                 //TODO Distinguish fields which need to be used for search and for sort\n                 //If a field is only used for Sort then it can be stored with less precision\n-                    f = new NumericDocValuesField(name, property.getValue(Type.LONG, i));\n+                f = new NumericDocValuesField(name, property.getValue(Type.LONG));\n             } else if (tag == Type.DATE.tag()) {\n-                    String date = property.getValue(Type.DATE, i);\n+                String date = property.getValue(Type.DATE);\n                 f = new NumericDocValuesField(name, FieldFactory.dateToLong(date));\n             } else if (tag == Type.DOUBLE.tag()) {\n-                    f = new DoubleDocValuesField(name, property.getValue(Type.DOUBLE, i));\n+                f = new DoubleDocValuesField(name, property.getValue(Type.DOUBLE));\n             } else if (tag == Type.BOOLEAN.tag()) {\n                 f = new SortedDocValuesField(name,\n-                        new BytesRef(property.getValue(Type.BOOLEAN, i).toString()));\n+                    new BytesRef(property.getValue(Type.BOOLEAN).toString()));\n             } else if (tag == Type.STRING.tag()) {\n                 f = new SortedDocValuesField(name,\n-                        new BytesRef(property.getValue(Type.STRING, i)));\n+                    new BytesRef(property.getValue(Type.STRING)));\n             }\n \n             if (f != null) {\n@@ -506,7 +513,6 @@ private boolean addTypedOrderedFields(List<Field> fields,\n                 pname, Type.fromTag(property.getType().tag(), false),\n                 Type.fromTag(tag, false), getPath(), e);\n         }\n-        }\n         return fieldAdded;\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 12,
        "jira_id": "3020",
        "nb_skipped": 3,
        "commit": "147515ae",
        "nb_failure": 1,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1461,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\nindex fa01dc5840..3b0bf7b448 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\n@@ -344,19 +344,6 @@ public void remove() {\n          */\n         int depth;\n \n-        /**\n-         * The total number of child nodes per node, for those nodes that were\n-         * fully traversed and do have child nodes. This value is used to\n-         * calculate the average width.\n-         */\n-        long widthTotal;\n-        \n-        /**\n-         * The number of nodes that were fully traversed and do have child\n-         * nodes. This value is used to calculate the average width.\n-         */\n-        int widthCount;\n-        \n         /**\n          * The sum of the depth of all matching nodes. This value is used to\n          * calculate the average depth.\n@@ -375,20 +362,12 @@ public void visit(NodeState state) {\n             }\n             if (count < maxCount) {\n                 depth++;\n-                int width = 0;\n-                boolean finished = true;\n                 for (ChildNodeEntry entry : state.getChildNodeEntries()) {\n                     if (count >= maxCount) {\n-                        finished = false;\n                         break;\n                     }\n-                    width++;\n                     visit(entry.getNodeState());\n                 }\n-                if (finished && width > 0) {\n-                    widthTotal += width;\n-                    widthCount++;\n-                }\n                 depth--;\n             }\n         }\n@@ -415,15 +394,9 @@ int getEstimatedCount() {\n                 return count;\n             }\n             double averageDepth = (int) (depthTotal / count);\n-            double averageWidth = 2;\n-            if (widthCount > 0) {\n-                averageWidth = (int) (widthTotal / widthCount);\n-            }\n-            // calculate with an average width of at least 2\n-            averageWidth = Math.max(2, averageWidth);\n-            // the number of estimated matches is calculated as the\n-            // of a estimated\n-            long estimatedNodes = (long) Math.pow(averageWidth, 2 * averageDepth);\n+            // the number of estimated matches is higher\n+            // the higher the average depth of the first hits\n+            long estimatedNodes = (long) (count * Math.pow(1.1, averageDepth));\n             estimatedNodes = Math.min(estimatedNodes, Integer.MAX_VALUE);\n             return Math.max(count, (int) estimatedNodes);\n         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "1155",
        "nb_skipped": 6,
        "commit": "f64e8adc",
        "nb_failure": 1,
        "linesRem": 18,
        "singleLine": false
    },
    {
        "files": 0,
        "nb_test": 128,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.upgrade.cli.blob.CopyReferencesTest",
            "org.apache.jackrabbit.oak.upgrade.cli.SegmentToSegmentTest",
            "org.apache.jackrabbit.oak.upgrade.cli.blob.FdsToFbsTest",
            "org.apache.jackrabbit.oak.upgrade.cli.blob.FbsToFdsTest",
            "org.apache.jackrabbit.oak.upgrade.cli.SegmentToSegmentTarTest",
            "org.apache.jackrabbit.oak.upgrade.cli.blob.FbsToFbsTest",
            "org.apache.jackrabbit.oak.upgrade.cli.SegmentTarToSegmentTest"
        ],
        "patch": "",
        "project": "jackrabbit-oak",
        "linesAdd": 0,
        "jira_id": "4420",
        "nb_skipped": 7,
        "commit": "d645112f",
        "nb_failure": 7,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 308,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.NodeStateAnalyzerFactoryTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/NodeStateAnalyzerFactory.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/NodeStateAnalyzerFactory.java\nindex 589fc63163..a02983fa19 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/NodeStateAnalyzerFactory.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/NodeStateAnalyzerFactory.java\n@@ -41,6 +41,7 @@\n import org.apache.jackrabbit.oak.plugins.index.lucene.util.TokenizerChain;\n import org.apache.jackrabbit.oak.plugins.tree.TreeFactory;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n+import org.apache.jackrabbit.oak.spi.state.NodeStateUtils;\n import org.apache.lucene.analysis.Analyzer;\n import org.apache.lucene.analysis.util.AbstractAnalysisFactory;\n import org.apache.lucene.analysis.util.CharArraySet;\n@@ -201,6 +202,7 @@ private void init(AbstractAnalysisFactory o, NodeState state) {\n             String name = ps.getName();\n             if (ps.getType() != Type.BINARY\n                     && !ps.isArray()\n+                    && !(name != null && NodeStateUtils.isHidden(name))\n                     && !IGNORE_PROP_NAMES.contains(name)) {\n                 result.put(name, ps.getValue(Type.STRING));\n             }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "3817",
        "nb_skipped": 3,
        "commit": "2a02a138",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 17,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.spi.security.authentication.external.ExternalIdentityRefTest"
        ],
        "patch": "diff --git a/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/ExternalIdentityRef.java b/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/ExternalIdentityRef.java\nindex ae67498f95..f3ffd6f74a 100644\n--- a/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/ExternalIdentityRef.java\n+++ b/oak-auth-external/src/main/java/org/apache/jackrabbit/oak/spi/security/authentication/external/ExternalIdentityRef.java\n@@ -39,13 +39,13 @@\n      */\n     public ExternalIdentityRef(@Nonnull String id, @CheckForNull String providerName) {\n         this.id = id;\n-        this.providerName = providerName;\n+        this.providerName = (providerName == null || providerName.isEmpty()) ? null : providerName;\n \n         StringBuilder b = new StringBuilder();\n         escape(b, id);\n-        if (providerName != null && providerName.length() > 0) {\n+        if (this.providerName != null) {\n             b.append(';');\n-            escape(b, providerName);\n+            escape(b, this.providerName);\n         }\n         string =  b.toString();\n     }\n@@ -82,6 +82,7 @@ public String getString() {\n      * @param str the string\n      * @return the reference\n      */\n+    @Nonnull\n     public static ExternalIdentityRef fromString(@Nonnull String str) {\n         int idx = str.indexOf(';');\n         if (idx < 0) {\n@@ -99,7 +100,7 @@ public static ExternalIdentityRef fromString(@Nonnull String str) {\n      * @param builder the builder\n      * @param str the string\n      */\n-    private void escape(StringBuilder builder, CharSequence str) {\n+    private static void escape(@Nonnull StringBuilder builder, @Nonnull CharSequence str) {\n         final int len = str.length();\n         for (int i=0; i<len; i++) {\n             char c = str.charAt(i);\n@@ -119,16 +120,20 @@ public String toString() {\n     }\n \n     /**\n-     * Tests if the given object is an external identity reference and if it's getString() is equal to this.\n+     * Tests if the given object is an external identity reference and if it's\n+     * getString() is equal to this. Note, that there is no need to\n+     * include {@code id} and {@code provider} fields in the comparison as\n+     * the string representation already incorporates both.\n      */\n     @Override\n     public boolean equals(Object o) {\n-        try {\n-            // assuming that we never compare other types of classes\n-            return this == o || string.equals(((ExternalIdentityRef) o).string);\n-        } catch (Exception e) {\n-            return false;\n+        if (this == o) {\n+            return true;\n         }\n+        if (o instanceof ExternalIdentityRef) {\n+            return string.equals(((ExternalIdentityRef) o).string);\n+        }\n+        return false;\n     }\n \n     /**\n",
        "project": "jackrabbit-oak",
        "linesAdd": 11,
        "jira_id": "3510",
        "nb_skipped": 0,
        "commit": "01f5a26f",
        "nb_failure": 1,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 397,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.kernel.TypeCodesTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/TypeCodes.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/TypeCodes.java\nindex 48142abbf8..dd0580a2a2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/TypeCodes.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/TypeCodes.java\n@@ -34,7 +34,9 @@\n \n     static {\n         for (int type = PropertyType.UNDEFINED; type <= PropertyType.DECIMAL; type++) {\n-            String code = PropertyType.nameFromValue(type).substring(0, 3).toLowerCase(Locale.ENGLISH);\n+            String code = type == PropertyType.BINARY\n+                    ? \":blobId\"  // See class comment for MicroKernel and OAK-428\n+                    : PropertyType.nameFromValue(type).substring(0, 3).toLowerCase(Locale.ENGLISH);\n             TYPE2CODE.put(type, code);\n             CODE2TYPE.put(code, type);\n         }\n@@ -61,7 +63,10 @@ public static String encode(int propertyType, String propertyName) {\n      * @return  the location where the prefix ends or -1 if no prefix is present\n      */\n     public static int split(String jsonString) {\n-        if (jsonString.length() >= 4 && jsonString.charAt(3) == ':') {\n+        if (jsonString.startsWith(\":blobId:\")) {  // See OAK-428\n+            return 7;\n+        }\n+        else if (jsonString.length() >= 4 && jsonString.charAt(3) == ':') {\n             return 3;\n         }\n         else {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 7,
        "jira_id": "428",
        "nb_skipped": 1,
        "commit": "916cd92f",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2184,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.query.UnionQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java\nindex 90cb3ff8a0..2f9bf8d4e7 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java\n@@ -91,13 +91,19 @@ public void setOrderings(OrderingImpl[] orderings) {\n     @Override\n     public void setLimit(long limit) {\n         this.limit = limit;\n-        left.setLimit(limit);\n-        right.setLimit(limit);\n+        applyLimitOffset();\n     }\n \n     @Override\n     public void setOffset(long offset) {\n         this.offset = offset;\n+        applyLimitOffset();\n+    }\n+\n+    private void applyLimitOffset() {\n+        long subqueryLimit = QueryImpl.saturatedAdd(limit, offset);\n+        left.setLimit(subqueryLimit);\n+        right.setLimit(subqueryLimit);\n     }\n \n     @Override\n",
        "project": "jackrabbit-oak",
        "linesAdd": 8,
        "jira_id": "3013",
        "nb_skipped": 9,
        "commit": "eabb4066",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2887,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.blob.datastore.OakFileDataStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/OakFileDataStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/OakFileDataStore.java\nindex a55d100f8b..5e8688161d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/OakFileDataStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/blob/datastore/OakFileDataStore.java\n@@ -38,7 +38,6 @@\n import com.google.common.io.Closeables;\n import com.google.common.io.Files;\n \n-import org.apache.commons.io.FilenameUtils;\n import org.apache.commons.io.IOUtils;\n import org.apache.commons.io.filefilter.FileFilterUtils;\n import org.apache.jackrabbit.core.data.DataIdentifier;\n@@ -50,6 +49,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.commons.io.FilenameUtils.normalizeNoEndSeparator;\n+\n /**\n  *  Oak specific extension of JR2 FileDataStore which enables\n  *  provisioning the signing key via OSGi config\n@@ -67,12 +68,13 @@ public OakFileDataStore() {\n \n     @Override\n     public Iterator<DataIdentifier> getAllIdentifiers() {\n-        final String path = FilenameUtils.normalizeNoEndSeparator(getPath());\n+        final String path = normalizeNoEndSeparator(getPath());\n         return Files.fileTreeTraverser().postOrderTraversal(new File(getPath()))\n                 .filter(new Predicate<File>() {\n                     @Override\n                     public boolean apply(File input) {\n-                        return input.isFile() && !input.getParent().equals(path);\n+                        return input.isFile() &&\n+                            !normalizeNoEndSeparator(input.getParent()).equals(path);\n                     }\n                 })\n                 .transform(new Function<File, DataIdentifier>() {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 5,
        "jira_id": "4432",
        "nb_skipped": 1,
        "commit": "c9765c21",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 245,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.jcr.query.QueryFulltextTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\nindex 8be3395d27..8889094627 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndex.java\n@@ -475,6 +475,13 @@ private static void addNonFullTextConstraints(List<Query> qs,\n         }\n \n         for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n+\n+            if (pr.first == null && pr.last == null) {\n+                // ignore property existence checks, Lucene can't to 'property\n+                // is not null' queries (OAK-1208)\n+                continue;\n+            }\n+\n             String name = pr.propertyName;\n             if (name.contains(\"/\")) {\n                 // lucene cannot handle child-level property restrictions\n",
        "project": "jackrabbit-oak",
        "linesAdd": 5,
        "jira_id": "1208",
        "nb_skipped": 1,
        "commit": "cb3ac20d",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2201,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.cache.CacheTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\nindex 6eb74dcc3c..26e44e70d1 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java\n@@ -409,8 +409,8 @@ public long getUsedMemory() {\n      * @param maxMemory the maximum size (1 or larger)\n      */\n     public void setMaxMemory(long maxMemory) {\n-        if (maxMemory <= 0) {\n-            throw new IllegalArgumentException(\"Max memory must be larger than 0\");\n+        if (maxMemory < 0) {\n+            throw new IllegalArgumentException(\"Max memory must not be negative\");\n         }\n         this.maxMemory = maxMemory;\n         if (segments != null) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "3089",
        "nb_skipped": 1,
        "commit": "ba38c380",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 2982,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.ClusterInfoTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfo.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfo.java\nindex 92208a1eb3..59d5f75ed4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfo.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfo.java\n@@ -374,7 +374,7 @@ public static ClusterNodeInfo getInstance(DocumentStore store, String machineId,\n \n         int retries = 10;\n         for (int i = 0; i < retries; i++) {\n-            ClusterNodeInfo clusterNode = createInstance(store, machineId, instanceId, configuredClusterId);\n+            ClusterNodeInfo clusterNode = createInstance(store, machineId, instanceId, configuredClusterId, i == 0);\n             String key = String.valueOf(clusterNode.id);\n             UpdateOp update = new UpdateOp(key, true);\n             update.set(ID, key);\n@@ -409,7 +409,7 @@ public static ClusterNodeInfo getInstance(DocumentStore store, String machineId,\n     }\n \n     private static ClusterNodeInfo createInstance(DocumentStore store, String machineId,\n-            String instanceId, int configuredClusterId) {\n+            String instanceId, int configuredClusterId, boolean waitForLease) {\n \n         long now = getCurrentTime();\n         int clusterNodeId = 0;\n@@ -447,16 +447,25 @@ private static ClusterNodeInfo createInstance(DocumentStore store, String machin\n             }\n \n             Long leaseEnd = (Long) doc.get(LEASE_END_KEY);\n+            String mId = \"\" + doc.get(MACHINE_ID_KEY);\n+            String iId = \"\" + doc.get(INSTANCE_ID_KEY);\n \n             if (leaseEnd != null && leaseEnd > now) {\n-                // TODO wait for lease end, see OAK-3449\n+                // wait if (a) instructed to, and (b) also the remaining time\n+                // time is not much bigger than the lease interval (in which\n+                // case something is very very wrong anyway)\n+                if (waitForLease && (leaseEnd - now) < (DEFAULT_LEASE_DURATION_MILLIS + 5000) && mId.equals(machineId)\n+                        && iId.equals(instanceId)) {\n+                    boolean worthRetrying = waitForLeaseExpiry(store, doc, leaseEnd.longValue(), machineId, instanceId);\n+                    if (worthRetrying) {\n+                        return createInstance(store, machineId, instanceId, configuredClusterId, false);\n+                    }\n+                }\n+\n                 reuseFailureReason = \"leaseEnd \" + leaseEnd + \" > \" + now + \" - \" + (leaseEnd - now) + \"ms in the future\";\n                 continue;\n             }\n \n-            String mId = \"\" + doc.get(MACHINE_ID_KEY);\n-            String iId = \"\" + doc.get(INSTANCE_ID_KEY);\n-\n             // remove entries with \"random:\" keys if not in use (no lease at all) \n             if (mId.startsWith(RANDOM_PREFIX) && leaseEnd == null) {\n                 store.remove(Collection.CLUSTER_NODES, key);\n@@ -506,6 +515,51 @@ private static ClusterNodeInfo createInstance(DocumentStore store, String machin\n                 RecoverLockState.NONE, prevLeaseEnd, newEntry);\n     }\n \n+    private static boolean waitForLeaseExpiry(DocumentStore store, ClusterNodeInfoDocument cdoc, long leaseEnd, String machineId,\n+            String instanceId) {\n+        String key = cdoc.getId();\n+        LOG.info(\"Found an existing possibly active cluster node info (\" + key + \") for this instance: \" + machineId + \"/\"\n+                + instanceId + \", will try use it.\");\n+\n+        // wait until lease expiry plus 2s\n+        long waitUntil = leaseEnd + 2000;\n+\n+        while (getCurrentTime() < waitUntil) {\n+            LOG.info(\"Waiting for cluster node \" + key + \"'s lease to expire: \" + (waitUntil - getCurrentTime()) / 1000 + \"s left\");\n+\n+            try {\n+                Thread.sleep(5000);\n+            } catch (InterruptedException e) {\n+                // ignored\n+            }\n+\n+            try {\n+                // check state of cluster node info\n+                ClusterNodeInfoDocument reread = store.find(Collection.CLUSTER_NODES, key);\n+                if (reread == null) {\n+                    LOG.info(\"Cluster node info \" + key + \": gone; continueing.\");\n+                    return true;\n+                } else {\n+                    Long newLeaseEnd = (Long) reread.get(LEASE_END_KEY);\n+                    if (newLeaseEnd == null) {\n+                        LOG.info(\"Cluster node \" + key + \": lease end information missing, aborting.\");\n+                        return false;\n+                    } else {\n+                        if (newLeaseEnd.longValue() != leaseEnd) {\n+                            LOG.info(\"Cluster node \" + key + \" seems to be still active (lease end changed from \" + leaseEnd\n+                                    + \" to \" + newLeaseEnd + \", will not try to use it.\");\n+                            return false;\n+                        }\n+                    }\n+                }\n+            } catch (DocumentStoreException ex) {\n+                LOG.info(\"Error reading cluster node info for key \" + key, ex);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n     public void performLeaseCheck() {\n         if (leaseCheckDisabled || !renewed) {\n             // if leaseCheckDisabled is set we never do the check, so return fast\n",
        "project": "jackrabbit-oak",
        "linesAdd": 54,
        "jira_id": "3424",
        "nb_skipped": 1,
        "commit": "f4349a96",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1803,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.IndexUpdateTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\nindex 2116cee2c9..75f0f3195c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\n@@ -19,6 +19,7 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.collect.Lists.newArrayList;\n import static com.google.common.collect.Lists.newArrayListWithCapacity;\n+import static org.apache.jackrabbit.oak.api.Type.BOOLEAN;\n import static org.apache.jackrabbit.oak.commons.PathUtils.concat;\n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.ASYNC_PROPERTY_NAME;\n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.ASYNC_REINDEX_VALUE;\n@@ -108,7 +109,7 @@ private IndexUpdate(IndexUpdate parent, String name) {\n     @Override\n     public void enter(NodeState before, NodeState after)\n             throws CommitFailedException {\n-        collectIndexEditors(builder.getChildNode(INDEX_DEFINITIONS_NAME));\n+        collectIndexEditors(builder.getChildNode(INDEX_DEFINITIONS_NAME), before);\n \n         // no-op when reindex is empty\n         CommitFailedException exception = EditorDiff.process(\n@@ -122,17 +123,30 @@ public void enter(NodeState before, NodeState after)\n         }\n     }\n \n-    private void collectIndexEditors(NodeBuilder definitions)\n-            throws CommitFailedException {\n+    private boolean shouldReindex(NodeBuilder definition, NodeState before,\n+            String name) {\n+        PropertyState ps = definition.getProperty(REINDEX_PROPERTY_NAME);\n+        if (ps != null && ps.getValue(BOOLEAN)) {\n+            return true;\n+        }\n+        // reindex in the case this is a new node, even though the reindex flag\n+        // might be set to 'false' (possible via content import)\n+        return !before.getChildNode(INDEX_DEFINITIONS_NAME).hasChildNode(name);\n+    }\n+\n+    private void collectIndexEditors(NodeBuilder definitions,\n+            NodeState before) throws CommitFailedException {\n         for (String name : definitions.getChildNodeNames()) {\n             NodeBuilder definition = definitions.getChildNode(name);\n             if (Objects.equal(async, definition.getString(ASYNC_PROPERTY_NAME))) {\n                 String type = definition.getString(TYPE_PROPERTY_NAME);\n+                boolean shouldReindex = shouldReindex(definition,\n+                        before, name);\n                 Editor editor = provider.getIndexEditor(type, definition, root, updateCallback);\n                 if (editor == null) {\n                     // trigger reindexing when an indexer becomes available\n                     definition.setProperty(REINDEX_PROPERTY_NAME, true);\n-                } else if (definition.getBoolean(REINDEX_PROPERTY_NAME)) {\n+                } else if (shouldReindex) {\n                     if (definition.getBoolean(REINDEX_ASYNC_PROPERTY_NAME)\n                             && definition.getString(ASYNC_PROPERTY_NAME) == null) {\n                         // switch index to an async update mode\n",
        "project": "jackrabbit-oak",
        "linesAdd": 16,
        "jira_id": "1874",
        "nb_skipped": 9,
        "commit": "3ae276c1",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1836,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest",
            "org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\nindex 74218703fc..8434fb2be6 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n@@ -42,6 +42,7 @@\n import org.apache.jackrabbit.oak.api.Tree;\n import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n+import org.apache.jackrabbit.oak.plugins.memory.PropertyBuilder;\n import org.apache.jackrabbit.oak.query.QueryImpl;\n import org.apache.jackrabbit.oak.query.fulltext.FullTextExpression;\n import org.apache.jackrabbit.oak.query.index.FilterImpl;\n@@ -533,13 +534,34 @@ private PropertyValue currentOakProperty(String oakPropertyName, Integer propert\n             readOakProperties(list, t, oakPropertyName, propertyType);\n             if (list.size() == 0) {\n                 return null;\n+            } else if (list.size() == 1) {\n+                return list.get(0);\n+            }\n+            Type<?> type = list.get(0).getType();\n+            for (int i = 1; i < list.size(); i++) {\n+                Type<?> t2 = list.get(i).getType();\n+                if (t2 != type) {\n+                    // types don't match\n+                    type = Type.STRING;\n+                    break;\n+                }\n             }\n+            if (type == Type.STRING) {\n                 ArrayList<String> strings = new ArrayList<String>();\n                 for (PropertyValue p : list) {\n                     Iterables.addAll(strings, p.getValue(Type.STRINGS));\n                 }\n                 return PropertyValues.newString(strings);\n             }\n+            @SuppressWarnings(\"unchecked\")\n+            PropertyBuilder<Object> builder = (PropertyBuilder<Object>) PropertyBuilder.array(type);\n+            builder.setName(\"\");\n+            for (PropertyValue v : list) {\n+                builder.addValue(v.getValue(type));\n+            }\n+            PropertyState s = builder.getPropertyState();\n+            return PropertyValues.create(s);\n+        }\n         boolean relative = oakPropertyName.indexOf('/') >= 0;\n         Tree t = currentTree();\n         if (relative) {\n@@ -590,6 +612,7 @@ private PropertyValue currentOakProperty(Tree t, String oakPropertyName, Integer\n     }\n     \n     private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String oakPropertyName, Integer propertyType) {\n+        boolean skipCurrentNode = false;\n         while (true) {\n             if (t == null || !t.exists()) {\n                 return;\n@@ -608,10 +631,14 @@ private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String o\n                 for (Tree child : t.getChildren()) {\n                     readOakProperties(target, child, oakPropertyName, propertyType);\n                 }\n+                skipCurrentNode = true;\n             } else {\n                 t = t.getChild(parent);\n             }\n         }\n+        if (skipCurrentNode) {\n+            return;\n+        }\n         if (!\"*\".equals(oakPropertyName)) {\n             PropertyValue value = currentOakProperty(t, oakPropertyName, propertyType);\n             if (value != null) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 26,
        "jira_id": "1076",
        "nb_skipped": 8,
        "commit": "9238264d",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 135,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.segment.RecordTest"
        ],
        "patch": "diff --git a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/Segment.java b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/Segment.java\nindex d1c0f0c354..2f38496aa9 100644\n--- a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/Segment.java\n+++ b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/Segment.java\n@@ -26,6 +26,7 @@\n import static com.google.common.collect.Maps.newConcurrentMap;\n import static java.lang.Boolean.getBoolean;\n import static org.apache.jackrabbit.oak.commons.IOUtils.closeQuietly;\n+import static org.apache.jackrabbit.oak.segment.SegmentId.isDataSegmentId;\n import static org.apache.jackrabbit.oak.segment.SegmentVersion.isValid;\n import static org.apache.jackrabbit.oak.segment.SegmentWriter.BLOCK_SIZE;\n \n@@ -38,6 +39,7 @@\n import java.nio.channels.WritableByteChannel;\n import java.util.Arrays;\n import java.util.List;\n+import java.util.UUID;\n import java.util.concurrent.ConcurrentMap;\n \n import javax.annotation.CheckForNull;\n@@ -314,12 +316,27 @@ public int getRootCount() {\n         return data.getShort(ROOT_COUNT_OFFSET) & 0xffff;\n     }\n \n-    public static int getGcGen(ByteBuffer data) {\n-        return data.getInt(GC_GEN_OFFSET);\n+    /**\n+     * Determine the gc generation a segment from its data. Note that bulk segments don't have\n+     * generations (i.e. stay at 0).\n+     *\n+     * @param data         the date of the segment\n+     * @param segmentId    the id of the segment\n+     * @return  the gc generation of this segment or 0 if this is bulk segment.\n+     */\n+    public static int getGcGen(ByteBuffer data, UUID segmentId) {\n+        return isDataSegmentId(segmentId.getLeastSignificantBits())\n+            ? data.getInt(GC_GEN_OFFSET)\n+            : 0;\n     }\n \n+    /**\n+     * Determine the gc generation of this segment. Note that bulk segments don't have\n+     * generations (i.e. stay at 0).\n+     * @return  the gc generation of this segment or 0 if this is bulk segment.\n+     */\n     public int getGcGen() {\n-        return getGcGen(data);\n+        return getGcGen(data, id.asUUID());\n     }\n \n     public RecordType getRootType(int index) {\ndiff --git a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/file/FileStore.java b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/file/FileStore.java\nindex 84d61a7e0b..e8954f412e 100644\n--- a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/file/FileStore.java\n+++ b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/file/FileStore.java\n@@ -1368,7 +1368,7 @@ public Segment readSegment(SegmentId id) {\n     public void writeSegment(SegmentId id, byte[] data, int offset, int length) throws IOException {\n         fileStoreLock.writeLock().lock();\n         try {\n-            int generation = Segment.getGcGen(wrap(data, offset, length));\n+            int generation = Segment.getGcGen(wrap(data, offset, length), id.asUUID());\n             long size = writer.writeEntry(\n                     id.getMostSignificantBits(),\n                     id.getLeastSignificantBits(),\ndiff --git a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/file/TarReader.java b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/file/TarReader.java\nindex 8fcdcc2949..5c7ee7d603 100644\n--- a/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/file/TarReader.java\n+++ b/oak-segment-tar/src/main/java/org/apache/jackrabbit/oak/segment/file/TarReader.java\n@@ -218,7 +218,7 @@ private static void generateTarFile(LinkedHashMap<UUID, byte[]> entries,\n         for (Map.Entry<UUID, byte[]> entry : entries.entrySet()) {\n             UUID uuid = entry.getKey();\n             byte[] data = entry.getValue();\n-            int generation = getGcGen(wrap(data));\n+            int generation = getGcGen(wrap(data), uuid);\n             writer.writeEntry(\n                     uuid.getMostSignificantBits(),\n                     uuid.getLeastSignificantBits(),\n",
        "project": "jackrabbit-oak",
        "linesAdd": 9,
        "jira_id": "4353",
        "nb_skipped": 2,
        "commit": "b0014b7d",
        "nb_failure": 0,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1846,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentSplitTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex bb5984c169..bd753f7d7f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -969,7 +969,8 @@ boolean isConflicting(@Nonnull UpdateOp op,\n             UpdateUtils.applyChanges(oldDoc, old, context.getRevisionComparator());\n             setSplitDocProps(this, oldDoc, old, high);\n             // only split if enough of the data can be moved to old document\n-            if (oldDoc.getMemory() > getMemory() * SPLIT_RATIO) {\n+            if (oldDoc.getMemory() > getMemory() * SPLIT_RATIO\n+                    || numValues >= NUM_REVS_THRESHOLD) {\n                 splitOps.add(old);\n             } else {\n                 main = null;\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "1770",
        "nb_skipped": 9,
        "commit": "192ee9e4",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 4,
        "nb_test": 3065,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentMKResetTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\nindex 8643bf7ed7..7fb76bba88 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\n@@ -335,7 +335,7 @@ public String reset(@Nonnull String branchRevisionId,\n             throw new DocumentStoreException(\"Not a branch revision: \" + ancestorRevisionId);\n         }\n         try {\n-            return nodeStore.reset(branch, ancestor, null).toString();\n+            return nodeStore.reset(branch, ancestor).toString();\n         } catch (DocumentStoreException e) {\n             throw new DocumentStoreException(e);\n         }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex fcc6bf9549..14e608ffc4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -22,6 +22,8 @@\n import static com.google.common.collect.Iterables.filter;\n import static com.google.common.collect.Iterables.toArray;\n import static com.google.common.collect.Iterables.transform;\n+import static com.google.common.collect.Lists.newArrayList;\n+import static com.google.common.collect.Lists.reverse;\n import static java.util.Collections.singletonList;\n import static org.apache.jackrabbit.oak.commons.PathUtils.concat;\n import static org.apache.jackrabbit.oak.plugins.document.Collection.JOURNAL;\n@@ -81,6 +83,7 @@\n import org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob;\n import org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector;\n import org.apache.jackrabbit.oak.plugins.blob.ReferencedBlob;\n+import org.apache.jackrabbit.oak.plugins.document.Branch.BranchCommit;\n import org.apache.jackrabbit.oak.plugins.document.cache.CacheInvalidationStats;\n import org.apache.jackrabbit.oak.plugins.document.persistentCache.PersistentCache;\n import org.apache.jackrabbit.oak.plugins.document.persistentCache.broadcast.DynamicBroadcastConfig;\n@@ -1249,8 +1252,7 @@ RevisionVector rebase(@Nonnull RevisionVector branchHead,\n \n     @Nonnull\n     RevisionVector reset(@Nonnull RevisionVector branchHead,\n-                         @Nonnull RevisionVector ancestor,\n-                         @Nullable DocumentNodeStoreBranch branch) {\n+                         @Nonnull RevisionVector ancestor) {\n         checkNotNull(branchHead);\n         checkNotNull(ancestor);\n         Branch b = getBranches().getBranch(branchHead);\n@@ -1261,61 +1263,44 @@ RevisionVector reset(@Nonnull RevisionVector branchHead,\n             throw new DocumentStoreException(branchHead + \" is not the head \" +\n                     \"of a branch\");\n         }\n-        if (!b.containsCommit(ancestor.getBranchRevision())) {\n+        if (!b.containsCommit(ancestor.getBranchRevision())\n+                && !b.getBase().asBranchRevision(getClusterId()).equals(ancestor)) {\n             throw new DocumentStoreException(ancestor + \" is not \" +\n                     \"an ancestor revision of \" + branchHead);\n         }\n-        if (branchHead.equals(ancestor)) {\n+        // tailSet is inclusive -> use an ancestorRev with a\n+        // counter incremented by one to make the call exclusive\n+        Revision ancestorRev = ancestor.getBranchRevision();\n+        ancestorRev = new Revision(ancestorRev.getTimestamp(),\n+                ancestorRev.getCounter() + 1, ancestorRev.getClusterId(), true);\n+        List<Revision> revs = newArrayList(b.getCommits().tailSet(ancestorRev));\n+        if (revs.isEmpty()) {\n             // trivial\n             return branchHead;\n         }\n-        boolean success = false;\n-        Commit commit = newCommit(branchHead, branch);\n-        try {\n-            Iterator<Revision> it = b.getCommits().tailSet(ancestor.getBranchRevision()).iterator();\n-            // first revision is the ancestor (tailSet is inclusive)\n-            // do not undo changes for this revision\n-            it.next();\n+        UpdateOp rootOp = new UpdateOp(Utils.getIdFromPath(\"/\"), false);\n+        // reset each branch commit in reverse order\n         Map<String, UpdateOp> operations = Maps.newHashMap();\n-            if (it.hasNext()) {\n-                Revision reset = it.next();\n-                // TODO: correct?\n-                getRoot(b.getCommit(reset).getBase().update(reset))\n-                        .compareAgainstBaseState(getRoot(ancestor),\n-                                new ResetDiff(reset.asTrunkRevision(), operations));\n-                UpdateOp rootOp = operations.get(\"/\");\n-                if (rootOp == null) {\n-                    rootOp = new UpdateOp(Utils.getIdFromPath(\"/\"), false);\n-                    NodeDocument.setModified(rootOp, commit.getRevision());\n-                    operations.put(\"/\", rootOp);\n-                }\n-                NodeDocument.removeCollision(rootOp, reset.asTrunkRevision());\n-                NodeDocument.removeRevision(rootOp, reset.asTrunkRevision());\n-            }\n-            // update root document first\n-            if (store.findAndUpdate(Collection.NODES, operations.get(\"/\")) != null) {\n-                // clean up in-memory branch data\n-                // first revision is the ancestor (tailSet is inclusive)\n-                List<Revision> revs = Lists.newArrayList(b.getCommits().tailSet(ancestor.getBranchRevision()));\n-                for (Revision r : revs.subList(1, revs.size())) {\n-                    b.removeCommit(r);\n-                }\n-                // successfully updating the root document can be considered\n-                // as success because the changes are not marked as committed\n-                // anymore\n-                success = true;\n+        for (Revision r : reverse(revs)) {\n+            NodeDocument.removeCollision(rootOp, r.asTrunkRevision());\n+            NodeDocument.removeRevision(rootOp, r.asTrunkRevision());\n+            operations.clear();\n+            BranchCommit bc = b.getCommit(r);\n+            if (bc.isRebase()) {\n+                continue;\n             }\n-            operations.remove(\"/\");\n-            // update remaining documents\n+            getRoot(bc.getBase().update(r))\n+                    .compareAgainstBaseState(getRoot(bc.getBase()),\n+                            new ResetDiff(r.asTrunkRevision(), operations));\n+            // apply reset operations\n             for (UpdateOp op : operations.values()) {\n                 store.findAndUpdate(Collection.NODES, op);\n             }\n-        } finally {\n-            if (!success) {\n-                canceled(commit);\n-            } else {\n-                done(commit, true, null);\n         }\n+        store.findAndUpdate(Collection.NODES, rootOp);\n+        // clean up in-memory branch data\n+        for (Revision r : revs) {\n+            b.removeCommit(r);\n         }\n         return ancestor;\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranch.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranch.java\nindex 4a022136fc..6e994221aa 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranch.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranch.java\n@@ -620,8 +620,7 @@ private void resetBranch(DocumentNodeState branchHead, DocumentNodeState ancesto\n             try {\n                 head = store.getRoot(\n                         store.reset(branchHead.getRevision(), \n-                                ancestor.getRevision(), \n-                                DocumentNodeStoreBranch.this));\n+                                ancestor.getRevision()));\n             } catch (Exception e) {\n                 CommitFailedException ex = new CommitFailedException(\n                         OAK, 100, \"Branch reset failed\", e);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ResetDiff.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ResetDiff.java\nindex 239928fdd3..cc086354c4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ResetDiff.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ResetDiff.java\n@@ -74,6 +74,7 @@ public boolean propertyDeleted(PropertyState before) {\n \n     @Override\n     public boolean childNodeAdded(String name, NodeState after) {\n+        NodeDocument.removeCommitRoot(getUpdateOp(), revision);\n         String p = PathUtils.concat(path, name);\n         ResetDiff diff = new ResetDiff(revision, p, operations);\n         UpdateOp op = diff.getUpdateOp();\n",
        "project": "jackrabbit-oak",
        "linesAdd": 28,
        "jira_id": "3897",
        "nb_skipped": 1,
        "commit": "94c6c575",
        "nb_failure": 1,
        "linesRem": 38,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3025,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex ada87d0363..8511e3713b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -68,6 +68,8 @@\n \n import com.google.common.base.Function;\n import com.google.common.base.Predicates;\n+import com.google.common.base.Supplier;\n+import com.google.common.base.Suppliers;\n import com.google.common.cache.Cache;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n@@ -2561,18 +2563,35 @@ public long determineServerTimeDifferenceMillis() {\n     static abstract class NodeStoreTask implements Runnable {\n         final WeakReference<DocumentNodeStore> ref;\n         private final AtomicBoolean isDisposed;\n-        private int delay;\n+        private final Supplier<Integer> delaySupplier;\n \n-        NodeStoreTask(DocumentNodeStore nodeStore, AtomicBoolean isDisposed) {\n-            ref = new WeakReference<DocumentNodeStore>(nodeStore);\n-            delay = nodeStore.getAsyncDelay();\n+        NodeStoreTask(final DocumentNodeStore nodeStore,\n+                      final AtomicBoolean isDisposed,\n+                      Supplier<Integer> delay) {\n+            this.ref = new WeakReference<DocumentNodeStore>(nodeStore);\n             this.isDisposed = isDisposed;\n+            if (delay == null) {\n+                delay = new Supplier<Integer>() {\n+                    @Override\n+                    public Integer get() {\n+                        DocumentNodeStore ns = ref.get();\n+                        return ns != null ? ns.getAsyncDelay() : 0;\n+                    }\n+                };\n+            }\n+            this.delaySupplier = delay;\n+        }\n+\n+        NodeStoreTask(final DocumentNodeStore nodeStore,\n+                      final AtomicBoolean isDisposed) {\n+            this(nodeStore, isDisposed, null);\n         }\n \n         protected abstract void execute(@Nonnull DocumentNodeStore nodeStore);\n \n         @Override\n         public void run() {\n+            int delay = delaySupplier.get();\n             while (delay != 0 && !isDisposed.get()) {\n                 synchronized (isDisposed) {\n                     try {\n@@ -2588,7 +2607,7 @@ public void run() {\n                     } catch (Throwable t) {\n                         LOG.warn(\"Background operation failed: \" + t.toString(), t);\n                     }\n-                    delay = nodeStore.getAsyncDelay();\n+                    delay = delaySupplier.get();\n                 } else {\n                     // node store not in use anymore\n                     break;\n@@ -2633,7 +2652,7 @@ protected void execute(@Nonnull DocumentNodeStore nodeStore) {\n \n         BackgroundLeaseUpdate(DocumentNodeStore nodeStore,\n                               AtomicBoolean isDisposed) {\n-            super(nodeStore, isDisposed);\n+            super(nodeStore, isDisposed, Suppliers.ofInstance(1000));\n         }\n \n         @Override\n",
        "project": "jackrabbit-oak",
        "linesAdd": 25,
        "jira_id": "3579",
        "nb_skipped": 1,
        "commit": "2565d74a",
        "nb_failure": 1,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1596,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.core.query.SelectClauseTest"
        ],
        "patch": "diff --git a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/RowImpl.java b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/RowImpl.java\nindex e337f39e79..e50d30dfc5 100644\n--- a/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/RowImpl.java\n+++ b/oak-jcr/src/main/java/org/apache/jackrabbit/oak/jcr/query/RowImpl.java\n@@ -100,7 +100,7 @@ public Value getValue(String columnName) throws RepositoryException {\n         int len = values.length;\n         Value[] v2 = new Value[values.length];\n         for (int i = 0; i < len; i++) {\n-            if(values[i].isArray()){\n+            if (values[i] != null && values[i].isArray()) {\n                 v2[i] = result.createValue(mvpToString(values[i]));\n             } else {\n                 v2[i] = result.createValue(values[i]);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "1093",
        "nb_skipped": 3,
        "commit": "531aca78",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 460,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditorTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\nindex e17f580836..ea6b0ed9af 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexCopier.java\n@@ -56,7 +56,6 @@\n import com.google.common.collect.Sets;\n import com.google.common.hash.Hashing;\n import org.apache.commons.io.FileUtils;\n-import org.apache.jackrabbit.oak.commons.IOUtils;\n import org.apache.jackrabbit.oak.commons.concurrent.NotifyingFutureTask;\n import org.apache.jackrabbit.oak.util.PerfLogger;\n import org.apache.lucene.store.Directory;\n@@ -65,6 +64,7 @@\n import org.apache.lucene.store.IOContext;\n import org.apache.lucene.store.IndexInput;\n import org.apache.lucene.store.IndexOutput;\n+import org.apache.lucene.store.NoLockFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -147,7 +147,10 @@ protected Directory createLocalDirForIndexWriter(IndexDefinition definition) thr\n             String newVersion = String.valueOf(definition.getReindexCount());\n             indexWriterDir = getVersionedDir(indexPath, indexDir, newVersion);\n         }\n-        Directory dir = FSDirectory.open(indexWriterDir);\n+\n+        //By design indexing in Oak is single threaded so Lucene locking\n+        //can be disabled\n+        Directory dir = FSDirectory.open(indexWriterDir, NoLockFactory.getNoLockFactory());\n \n         log.debug(\"IndexWriter would use {}\", indexWriterDir);\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "3053",
        "nb_skipped": 3,
        "commit": "7552a10b",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 6,
        "nb_test": 1815,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.segment.file.FileStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/CompactionMap.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/CompactionMap.java\nindex a33cba562d..bbf5d30f36 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/CompactionMap.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/CompactionMap.java\n@@ -93,6 +93,19 @@ boolean wasCompactedTo(RecordId before, RecordId after) {\n         return after.equals(get(before));\n     }\n \n+    /**\n+     * Checks whether content in the segment with the given identifier was\n+     * compacted to new segments.\n+     *\n+     * @param id segment identifier\n+     * @return whether the identified segment was compacted\n+     */\n+    boolean wasCompacted(SegmentId id) {\n+        long msb = id.getMostSignificantBits();\n+        long lsb = id.getLeastSignificantBits();\n+        return findEntry(msb, lsb) != -1;\n+    }\n+\n     public RecordId get(RecordId before) {\n         RecordId after = recent.get(before);\n         if (after != null) {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Compactor.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Compactor.java\nindex 45bbbcc9d7..14278ca97e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Compactor.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Compactor.java\n@@ -75,7 +75,8 @@\n \n     public Compactor(SegmentWriter writer) {\n         this.writer = writer;\n-        this.builder = writer.writeNode(EMPTY_NODE).builder();\n+        this.builder =\n+                new SegmentNodeBuilder(writer.writeNode(EMPTY_NODE), writer);\n     }\n \n     public SegmentNodeState compact(NodeState before, NodeState after) {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Record.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Record.java\nindex f65a168170..ec8fbfdfbb 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Record.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Record.java\n@@ -64,6 +64,15 @@ protected boolean wasCompactedTo(Record after) {\n         return map.wasCompactedTo(getRecordId(), after.getRecordId());\n     }\n \n+    /**\n+     * Returns the tracker of the segment that contains this record.\n+     *\n+     * @return segment tracker\n+     */\n+    protected SegmentTracker getTracker() {\n+        return segmentId.getTracker();\n+    }\n+\n     /**\n      * Returns the segment that contains this record.\n      *\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeBuilder.java\nindex 7fc474ff0e..d532bdf803 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeBuilder.java\n@@ -33,8 +33,12 @@\n     private long updateCount = 0;\n \n     SegmentNodeBuilder(SegmentNodeState base) {\n+        this(base, base.getTracker().getWriter());\n+    }\n+\n+    SegmentNodeBuilder(SegmentNodeState base, SegmentWriter writer) {\n         super(base);\n-        this.writer = base.getRecordId().getSegmentId().getTracker().getWriter();\n+        this.writer = writer;\n     }\n \n     //-------------------------------------------------< MemoryNodeBuilder >--\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\nindex 41fc1ef110..a11b93194a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n@@ -940,10 +940,22 @@ public synchronized RecordId writeTemplate(Template template) {\n         return id;\n     }\n \n+    private SegmentNodeState uncompact(SegmentNodeState state) {\n+        RecordId id = tracker.getCompactionMap().get(state.getRecordId());\n+        if (id != null) {\n+            return new SegmentNodeState(id);\n+        } else {\n+            return state;\n+        }\n+    }\n+\n     public SegmentNodeState writeNode(NodeState state) {\n-        if (state instanceof SegmentNodeState\n-                && store.containsSegment(((SegmentNodeState) state).getRecordId().getSegmentId())) {\n-            return (SegmentNodeState) state;\n+        if (state instanceof SegmentNodeState) {\n+            SegmentNodeState sns = uncompact((SegmentNodeState) state);\n+            if (sns != state || store.containsSegment(\n+                    sns.getRecordId().getSegmentId())) {\n+                return sns;\n+            }\n         }\n \n         SegmentNodeState before = null;\n@@ -952,12 +964,15 @@ public SegmentNodeState writeNode(NodeState state) {\n         if (state instanceof ModifiedNodeState) {\n             after = (ModifiedNodeState) state;\n             NodeState base = after.getBaseState();\n-            if (base instanceof SegmentNodeState\n-                    && store.containsSegment(((SegmentNodeState) base).getRecordId().getSegmentId())) {\n-                before = (SegmentNodeState) base;\n+            if (base instanceof SegmentNodeState) {\n+                SegmentNodeState sns = uncompact((SegmentNodeState) base);\n+                if (sns != base || store.containsSegment(\n+                        sns.getRecordId().getSegmentId())) {\n+                    before = sns;\n                     beforeTemplate = before.getTemplate();\n                 }\n             }\n+        }\n \n         Template template = new Template(state);\n         RecordId templateId;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/file/FileStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/file/FileStore.java\nindex 324357266a..f378247dc6 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/file/FileStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/file/FileStore.java\n@@ -415,6 +415,7 @@ public void compact() {\n \n         SegmentNodeState before = getHead();\n         SegmentNodeState after = compactor.compact(EMPTY_NODE, before);\n+        writer.flush();\n         while (!setHead(before, after)) {\n             // Some other concurrent changes have been made.\n             // Rebase (and compact) those changes on top of the\n@@ -422,9 +423,16 @@ public void compact() {\n             SegmentNodeState head = getHead();\n             after = compactor.compact(before, head);\n             before = head;\n+            writer.flush();\n         }\n         tracker.setCompactionMap(compactor.getCompactionMap());\n \n+        // Drop the SegmentWriter caches and flush any existing state\n+        // in an attempt to prevent new references to old pre-compacted\n+        // content. TODO: There should be a cleaner way to do this.\n+        tracker.getWriter().dropCache();\n+        tracker.getWriter().flush();\n+\n         log.info(\"TarMK compaction completed in {}ms\", MILLISECONDS\n                 .convert(System.nanoTime() - start, NANOSECONDS));\n         cleanupNeeded.set(true);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 43,
        "jira_id": "1932",
        "nb_skipped": 9,
        "commit": "913c2f53",
        "nb_failure": 1,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1843,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdateTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\nindex 88eb0f78ed..6401f23dde 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n@@ -318,7 +318,7 @@ public NodeState processCommit(\n                     throws CommitFailedException {\n                 // check for concurrent updates by this async task\n                 NodeState async = before.getChildNode(ASYNC);\n-                if (Objects.equal(checkpoint, async.getString(name))\n+                if (checkpoint == null || Objects.equal(checkpoint, async.getString(name))\n                         && lease == async.getLong(name + \"-lease\")) {\n                     return after;\n                 } else {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "1959",
        "nb_skipped": 9,
        "commit": "93c1aa40",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 637,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilderTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex 38544661e5..9faa23f69b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -254,7 +254,9 @@ private MutableNodeState write(long newRevision, boolean reconnect) {\n             writeState = parent.getWriteState(name);\n             if (writeState == null) {\n                 if (exists()) {\n-                    writeState = new MutableNodeState(baseState);\n+                    NodeState writeBase =\n+                            parent.writeState.base.getChildNode(name);\n+                    writeState = new MutableNodeState(writeBase);\n                 }\n                 else {\n                     writeState = new MutableNodeState(null);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "782",
        "nb_skipped": 2,
        "commit": "45b110e1",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 453,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.OakDirectoryTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\nindex 946d0c1133..056ddf799c 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\n@@ -21,6 +21,7 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.Collection;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n \n@@ -33,6 +34,7 @@\n import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n import org.apache.jackrabbit.oak.util.PerfLogger;\n+import org.apache.lucene.store.AlreadyClosedException;\n import org.apache.lucene.store.Directory;\n import org.apache.lucene.store.IOContext;\n import org.apache.lucene.store.IndexInput;\n@@ -40,6 +42,7 @@\n import org.apache.lucene.store.Lock;\n import org.apache.lucene.store.LockFactory;\n import org.apache.lucene.store.NoLockFactory;\n+import org.apache.lucene.util.WeakIdentityMap;\n import org.slf4j.LoggerFactory;\n \n import static com.google.common.base.Preconditions.checkArgument;\n@@ -364,29 +367,41 @@ public String toString() {\n     private static class OakIndexInput extends IndexInput {\n \n         private final OakIndexFile file;\n+        private boolean isClone = false;\n+        private final WeakIdentityMap<OakIndexInput, Boolean> clones;\n \n         public OakIndexInput(String name, NodeBuilder file) {\n             super(name);\n             this.file = new OakIndexFile(name, file);\n+            clones = WeakIdentityMap.newConcurrentHashMap();\n         }\n \n         private OakIndexInput(OakIndexInput that) {\n             super(that.toString());\n             this.file = new OakIndexFile(that.file);\n+            clones = null;\n         }\n \n         @Override\n         public OakIndexInput clone() {\n-            return new OakIndexInput(this);\n+            // TODO : shouldn't we call super#clone ?\n+            OakIndexInput clonedIndexInput = new OakIndexInput(this);\n+            clonedIndexInput.isClone = true;\n+            if (clones != null) {\n+                clones.put(clonedIndexInput, Boolean.TRUE);\n+            }\n+            return clonedIndexInput;\n         }\n \n         @Override\n         public void readBytes(byte[] b, int o, int n) throws IOException {\n+            checkNotClosed();\n             file.readBytes(b, o, n);\n         }\n \n         @Override\n         public byte readByte() throws IOException {\n+            checkNotClosed();\n             byte[] b = new byte[1];\n             readBytes(b, 0, 1);\n             return b[0];\n@@ -394,16 +409,19 @@ public byte readByte() throws IOException {\n \n         @Override\n         public void seek(long pos) throws IOException {\n+            checkNotClosed();\n             file.seek(pos);\n         }\n \n         @Override\n         public long length() {\n+            checkNotClosed();\n             return file.length;\n         }\n \n         @Override\n         public long getFilePointer() {\n+            checkNotClosed();\n             return file.position;\n         }\n \n@@ -411,6 +429,20 @@ public long getFilePointer() {\n         public void close() {\n             file.blob = null;\n             file.data = null;\n+\n+            if (clones != null) {\n+                for (Iterator<OakIndexInput> it = clones.keyIterator(); it.hasNext();) {\n+                    final OakIndexInput clone = it.next();\n+                    assert clone.isClone;\n+                    clone.close();\n+                }\n+            }\n+        }\n+\n+        private void checkNotClosed() {\n+            if (file.blob == null && file.data == null) {\n+                throw new AlreadyClosedException(\"Already closed: \" + this);\n+            }\n         }\n \n     }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 32,
        "jira_id": "2799",
        "nb_skipped": 3,
        "commit": "3979fa8d",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2656,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.segment.CompactionMapTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/PersistedCompactionMap.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/PersistedCompactionMap.java\nindex ae5c14b0af..51a065b3c0 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/PersistedCompactionMap.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/PersistedCompactionMap.java\n@@ -229,9 +229,9 @@ private void compress(@Nonnull Set<UUID> removed) {\n                     \", baseId=\" + previousBaseId + '}';\n             writer.writeString(mapInfo);\n             writer.flush();\n-            recent.clear();\n         }\n \n+        recent.clear();\n         if (recordCount == 0) {\n             entries = null;\n         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "3511",
        "nb_skipped": 1,
        "commit": "5138a1e2",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1849,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.UnmergedBranchTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex 92e0b0aa0a..9e721a0cfa 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -556,30 +556,40 @@ public boolean containsRevision(@Nonnull Revision revision) {\n     }\n \n     /**\n-     * Gets a sorted map of uncommitted revisions of this document with the\n+     * Purge the  uncommitted revisions of this document with the\n      * local cluster node id as returned by the {@link RevisionContext}. These\n      * are the {@link #REVISIONS} entries where {@link Utils#isCommitted(String)}\n      * returns false.\n      *\n+     * <p>\n+     *     <bold>Note</bold> - This method should only be invoked upon startup\n+     *     as then only we can safely assume that these revisions would not be\n+     *     committed\n+     * </p>\n+     *\n      * @param context the revision context.\n-     * @return the uncommitted revisions of this document.\n+     * @return count of the revision entries purged\n      */\n-    public SortedMap<Revision, Revision> getUncommittedRevisions(RevisionContext context) {\n+    public int purgeUncommittedRevisions(RevisionContext context) {\n         // only look at revisions in this document.\n         // uncommitted revisions are not split off\n         Map<Revision, String> valueMap = getLocalRevisions();\n-        SortedMap<Revision, Revision> revisions =\n-                new TreeMap<Revision, Revision>(context.getRevisionComparator());\n+        UpdateOp op = new UpdateOp(getId(), false);\n+        int purgeCount = 0;\n         for (Map.Entry<Revision, String> commit : valueMap.entrySet()) {\n             if (!Utils.isCommitted(commit.getValue())) {\n                 Revision r = commit.getKey();\n                 if (r.getClusterId() == context.getClusterId()) {\n-                    Revision b = Revision.fromString(commit.getValue());\n-                    revisions.put(r, b);\n+                    purgeCount++;\n+                    op.removeMapEntry(REVISIONS, r);\n                 }\n             }\n         }\n-        return revisions;\n+\n+        if (op.hasChanges()) {\n+            store.findAndUpdate(Collection.NODES, op);\n+        }\n+        return purgeCount;\n     }\n \n     /**\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnmergedBranches.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnmergedBranches.java\nindex b39b8dfb48..9573cb7948 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnmergedBranches.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnmergedBranches.java\n@@ -21,7 +21,6 @@\n \n import java.util.Comparator;\n import java.util.List;\n-import java.util.SortedMap;\n import java.util.SortedSet;\n import java.util.TreeSet;\n import java.util.concurrent.CopyOnWriteArrayList;\n@@ -31,6 +30,8 @@\n import javax.annotation.Nonnull;\n \n import org.apache.jackrabbit.oak.plugins.document.util.Utils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * <code>UnmergedBranches</code> contains all un-merged branches of a DocumentMK\n@@ -38,6 +39,8 @@\n  */\n class UnmergedBranches {\n \n+    private final Logger log = LoggerFactory.getLogger(getClass());\n+\n     /**\n      * Map of branches with the head of the branch as key.\n      */\n@@ -72,17 +75,9 @@ void init(DocumentStore store, RevisionContext context) {\n         if (doc == null) {\n             return;\n         }\n-        SortedMap<Revision, Revision> revisions = doc.getUncommittedRevisions(context);\n-        while (!revisions.isEmpty()) {\n-            SortedSet<Revision> commits = new TreeSet<Revision>(comparator);\n-            Revision head = revisions.lastKey();\n-            commits.add(head);\n-            Revision base = revisions.remove(head).asTrunkRevision();\n-            while (revisions.containsKey(base)) {\n-                commits.add(base);\n-                base = revisions.remove(base).asTrunkRevision();\n-            }\n-            branches.add(new Branch(commits, base));\n+        int purgeCount = doc.purgeUncommittedRevisions(context);\n+        if (purgeCount > 0) {\n+            log.info(\"Purged [{}] uncommitted branch revision entries\", purgeCount);\n         }\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 17,
        "jira_id": "1926",
        "nb_skipped": 9,
        "commit": "9225a3e2",
        "nb_failure": 1,
        "linesRem": 18,
        "singleLine": false
    },
    {
        "files": 5,
        "nb_test": 195,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.mongomk.ConflictTest"
        ],
        "patch": "diff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Collision.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Collision.java\nindex 61652953e5..f9c1466f95 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Collision.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Collision.java\n@@ -20,6 +20,8 @@\n \n import javax.annotation.Nonnull;\n \n+import org.apache.jackrabbit.mk.api.MicroKernelException;\n+import org.apache.jackrabbit.mongomk.DocumentStore.Collection;\n import org.apache.jackrabbit.mongomk.util.Utils;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.slf4j.Logger;\n@@ -29,7 +31,16 @@\n \n /**\n  * A <code>Collision</code> happens when a commit modifies a node, which was\n- * also modified in a branch commit, but the branch commit is not yet merged.\n+ * also modified in another branch not visible to the current session. This\n+ * includes the following situations:\n+ * <ul>\n+ * <li>Our commit goes to trunk and another session committed to a branch\n+ * not yet merged back.</li>\n+ * <li>Our commit goes to a branch and another session committed to trunk\n+ * or some other branch.</li>\n+ * </ul>\n+ * Other collisions like concurrent commits to trunk are handled earlier and\n+ * do not require collision marking. See {@link Commit#createOrUpdateNode()}.\n  */\n class Collision {\n \n@@ -50,47 +61,115 @@\n         this.ourRev = checkNotNull(ourRev).toString();\n     }\n \n-    boolean mark(DocumentStore store) {\n+    /**\n+     * Marks the collision in the document store. Either our or their\n+     * revision is annotated with a collision marker. Their revision is\n+     * marked if it is not yet committed, otherwise our revision is marked.\n+     * \n+     * @param store the document store.\n+     * @throws MicroKernelException if the mark operation fails.\n+     */\n+    void mark(DocumentStore store) throws MicroKernelException {\n+        // first try to mark their revision\n         if (markCommitRoot(document, theirRev, store)) {\n-            return true;\n+            return;\n         }\n-        @SuppressWarnings(\"unchecked\")\n-        Map<String, String> revisions = (Map<String, String>) document.get(UpdateOp.REVISIONS);\n-        if (revisions.containsKey(theirRev)) {\n-            String value = revisions.get(theirRev);\n-            if (\"true\".equals(value)) {\n         // their commit wins, we have to mark ourRev\n         Map<String, Object> newDoc = Utils.newMap();\n         Utils.deepCopyMap(document, newDoc);\n         MemoryDocumentStore.applyChanges(newDoc, ourOp);\n-                if (markCommitRoot(newDoc, ourRev, store)) {\n-                    return true;\n-                }\n+        if (!markCommitRoot(newDoc, ourRev, store)) {\n+            throw new MicroKernelException(\"Unable to annotate our revision \"\n+                    + \"with collision marker. Our revision: \" + ourRev\n+                    + \", document:\\n\" + Utils.formatDocument(newDoc));\n         }\n     }\n-        return true;\n-    }\n \n+    /**\n+     * Marks the commit root of the change to the given <code>document</code> in\n+     * <code>revision</code>.\n+     * \n+     * @param document the MongoDB document.\n+     * @param revision the revision of the commit to annotated with a collision\n+     *            marker.\n+     * @param store the document store.\n+     * @return <code>true</code> if the commit for the given revision was marked\n+     *         successfully; <code>false</code> otherwise.\n+     */\n     private static boolean markCommitRoot(@Nonnull Map<String, Object> document,\n                                           @Nonnull String revision,\n                                           @Nonnull DocumentStore store) {\n+        String p = Utils.getPathFromId((String) document.get(UpdateOp.ID));\n+        String commitRootPath = null;\n+        // first check if we can mark the commit with the given revision\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, String> revisions = (Map<String, String>) document.get(UpdateOp.REVISIONS);\n+        if (revisions != null && revisions.containsKey(revision)) {\n+            String value = revisions.get(revision);\n+            if (\"true\".equals(value)) {\n+                // already committed\n+                return false;\n+            } else {\n+                // node is also commit root, but not yet committed\n+                // i.e. a branch commit, which is not yet merged\n+                commitRootPath = p;\n+            }\n+        } else {\n+            // next look at commit root\n             @SuppressWarnings(\"unchecked\")\n             Map<String, Integer> commitRoots = (Map<String, Integer>) document.get(UpdateOp.COMMIT_ROOT);\n             if (commitRoots != null) {\n                 Integer depth = commitRoots.get(revision);\n                 if (depth != null) {\n-                String p = Utils.getPathFromId((String) document.get(UpdateOp.ID));\n-                String commitRootPath = PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - depth);\n+                    commitRootPath = PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - depth);\n+                } else {\n+                    throwNoCommitRootException(revision, document);\n+                }\n+            } else {\n+                throwNoCommitRootException(revision, document);\n+            }\n+        }\n+        // at this point we have a commitRootPath\n         UpdateOp op = new UpdateOp(commitRootPath,\n                 Utils.getIdFromPath(commitRootPath), false);\n+        document = store.find(Collection.NODES, op.getKey());\n+        // check commit status of revision\n+        if (isCommitted(revision, document)) {\n+            return false;\n+        }\n         op.setMapEntry(UpdateOp.COLLISIONS, revision, true);\n-                // TODO: detect concurrent commit of previously un-merged changes\n-                // TODO: check _commitRoot for revision is not 'true'\n-                store.createOrUpdate(DocumentStore.Collection.NODES, op);\n+        document = store.createOrUpdate(DocumentStore.Collection.NODES, op);\n+        // check again on old document right before our update was applied\n+        if (isCommitted(revision, document)) {\n+            return false;\n+        }\n+        // otherwise collision marker was set successfully\n         LOG.debug(\"Marked collision on: {} for {} ({})\",\n                 new Object[]{commitRootPath, p, revision});\n         return true;\n     }\n+    \n+    private static void throwNoCommitRootException(@Nonnull String revision,\n+                                                   @Nonnull Map<String, Object> document)\n+                                                           throws MicroKernelException {\n+        throw new MicroKernelException(\"No commit root for revision: \"\n+                + revision + \", document: \" + Utils.formatDocument(document));\n+    }\n+    \n+    /**\n+     * Returns <code>true</code> if the given <code>revision</code> is marked\n+     * committed on the given <code>document</code>.\n+     * \n+     * @param revision the revision.\n+     * @param document a MongoDB document.\n+     * @return <code>true</code> if committed; <code>false</code> otherwise.\n+     */\n+    private static boolean isCommitted(String revision, Map<String, Object> document) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, String> revisions = (Map<String, String>) document.get(UpdateOp.REVISIONS);\n+        if (revisions != null && revisions.containsKey(revision)) {\n+            String value = revisions.get(revision);\n+            return \"true\".equals(value);\n         }\n         return false;\n     }\ndiff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/CollisionHandler.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/CollisionHandler.java\nindex 869512602c..b311ec9edc 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/CollisionHandler.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/CollisionHandler.java\n@@ -23,16 +23,16 @@\n \n     static final CollisionHandler DEFAULT = new CollisionHandler() {\n         @Override\n-        void uncommittedModification(Revision uncommitted) {\n+        void concurrentModification(Revision other) {\n             // do nothing\n         }\n     };\n \n     /**\n-     * Callback for an uncommitted modification in {@link Revision}\n-     * <code>uncommitted</code>.\n+     * Callback for an concurrent modification in {@link Revision}\n+     * <code>other</code>.\n      *\n-     * @param uncommitted the uncommitted revision of the change.\n+     * @param other the revision of the concurrent change.\n      */\n-    abstract void uncommittedModification(Revision uncommitted);\n+    abstract void concurrentModification(Revision other);\n }\ndiff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Commit.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Commit.java\nindex 5922f7eaf9..b565658e56 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Commit.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Commit.java\n@@ -268,11 +268,11 @@ private void createOrUpdateNode(DocumentStore store, UpdateOp op) {\n             Revision newestRev = mk.getNewestRevision(map, revision,\n                     new CollisionHandler() {\n                 @Override\n-                void uncommittedModification(Revision uncommitted) {\n+                void concurrentModification(Revision other) {\n                     if (collisions.get() == null) {\n                         collisions.set(new ArrayList<Revision>());\n                     }\n-                    collisions.get().add(uncommitted);\n+                    collisions.get().add(other);\n                 }\n             });\n             String conflictMessage = null;\n@@ -296,7 +296,7 @@ void uncommittedModification(Revision uncommitted) {\n             }\n             if (conflictMessage != null) {\n                 conflictMessage += \", before\\n\" + revision + \n-                        \"; document:\\n\" + map.toString().replaceAll(\", _\", \",\\n_\").replaceAll(\"}, \", \"},\\n\") + \n+                        \"; document:\\n\" + Utils.formatDocument(map) + \n                         \",\\nrevision order:\\n\" + mk.getRevisionComparator();\n                 throw new MicroKernelException(conflictMessage);\n             }\n@@ -306,11 +306,7 @@ void uncommittedModification(Revision uncommitted) {\n             if (collisions.get() != null && isConflicting(map, op)) {\n                 for (Revision r : collisions.get()) {\n                     // mark collisions on commit root\n-                    Collision c = new Collision(map, r, op, revision);\n-                    boolean success = c.mark(store);\n-                    if (!success) {\n-                        // TODO: fail this commit\n-                    }\n+                    new Collision(map, r, op, revision).mark(store);\n                 }\n             }\n         }\ndiff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MongoMK.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MongoMK.java\nindex a77ac51736..57f1fcc919 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MongoMK.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MongoMK.java\n@@ -1117,7 +1117,7 @@ private Revision getLiveRevision(Map<String, Object> nodeMap,\n      * \n      * @param nodeMap the document\n      * @param changeRev the revision of the current change\n-     * @param handler the conflict handler, which is called for un-committed revisions\n+     * @param handler the conflict handler, which is called for concurrent changes\n      *                preceding <code>before</code>.\n      * @return the revision, or null if deleted\n      */\n@@ -1152,7 +1152,7 @@ private Revision getLiveRevision(Map<String, Object> nodeMap,\n                 if (!propRev.equals(changeRev)) {\n                     if (!isValidRevision(\n                             propRev, changeRev, nodeMap, new HashSet<Revision>())) {\n-                        handler.uncommittedModification(propRev);\n+                        handler.concurrentModification(propRev);\n                     } else {\n                         newestRev = propRev;\n                     }\ndiff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/util/Utils.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/util/Utils.java\nindex 79eb21dab9..3fe75f34ce 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/util/Utils.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/util/Utils.java\n@@ -182,4 +182,14 @@ public static String getPathFromId(String id) {\n         }\n     }\n     \n+    /**\n+     * Formats a MongoDB document for use in a log message.\n+     * \n+     * @param document the MongoDB document.\n+     * @return\n+     */\n+    public static String formatDocument(Map<String, Object> document) {\n+    \treturn document.toString().replaceAll(\", _\", \",\\n_\").replaceAll(\"}, \", \"},\\n\");\n+    }\n+\n }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 61,
        "jira_id": "846",
        "nb_skipped": 4,
        "commit": "7acb091a",
        "nb_failure": 1,
        "linesRem": 25,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 315,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinitionTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\nindex 9dd4b009c3..a89b6ae40b 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/IndexDefinition.java\n@@ -285,7 +285,8 @@ boolean hasRelativeProperty(String name) {\n     private Map<String, PropertyDefinition> collectPropertyDefns(NodeBuilder defn) {\n         Map<String, PropertyDefinition> propDefns = newHashMap();\n         NodeBuilder propNode = defn.getChildNode(LuceneIndexConstants.PROP_NODE);\n-        for (String propName : Iterables.concat(includes, orderedProps)) {\n+        //Include all immediate child nodes to 'properties' node by default\n+        for (String propName : Iterables.concat(includes, orderedProps, propNode.getChildNodeNames())) {\n             NodeBuilder propDefnNode;\n             if (relativeProps.containsKey(propName)) {\n                 propDefnNode = relativeProps.get(propName).getPropDefnNode(propNode);\n@@ -293,7 +294,7 @@ boolean hasRelativeProperty(String name) {\n                 propDefnNode = propNode.getChildNode(propName);\n             }\n \n-            if (propDefnNode.exists()) {\n+            if (propDefnNode.exists() && !propDefns.containsKey(propName)) {\n                 propDefns.put(propName, new PropertyDefinition(this, propName, propDefnNode));\n             }\n         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "2250",
        "nb_skipped": 2,
        "commit": "08b25cb0",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 0,
        "nb_test": 126,
        "nb_error": 5,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.upgrade.CopyVersionHistoryTest"
        ],
        "patch": "",
        "project": "jackrabbit-oak",
        "linesAdd": 0,
        "jira_id": "4166",
        "nb_skipped": 7,
        "commit": "374e3f3d",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1807,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdateTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\nindex d52c43090d..74755fe40e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java\n@@ -21,11 +21,9 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.MISSING_NODE;\n import static org.apache.jackrabbit.oak.api.jmx.IndexStatsMBean.STATUS_DONE;\n-import static org.apache.jackrabbit.oak.api.jmx.IndexStatsMBean.STATUS_RUNNING;\n import static org.apache.jackrabbit.oak.commons.PathUtils.elements;\n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.REINDEX_PROPERTY_NAME;\n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.ASYNC_PROPERTY_NAME;\n-import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.INDEX_DEFINITIONS_NAME;\n \n import java.util.Calendar;\n import java.util.HashSet;\n@@ -36,18 +34,15 @@\n \n import org.apache.jackrabbit.oak.api.CommitFailedException;\n import org.apache.jackrabbit.oak.api.PropertyState;\n-import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.api.jmx.IndexStatsMBean;\n import org.apache.jackrabbit.oak.plugins.commit.AnnotatingConflictHandler;\n import org.apache.jackrabbit.oak.plugins.commit.ConflictHook;\n import org.apache.jackrabbit.oak.plugins.commit.ConflictValidatorProvider;\n-import org.apache.jackrabbit.oak.plugins.value.Conversions;\n import org.apache.jackrabbit.oak.spi.commit.CommitHook;\n import org.apache.jackrabbit.oak.spi.commit.CommitInfo;\n import org.apache.jackrabbit.oak.spi.commit.CompositeHook;\n import org.apache.jackrabbit.oak.spi.commit.EditorDiff;\n import org.apache.jackrabbit.oak.spi.commit.EditorHook;\n-import org.apache.jackrabbit.oak.spi.commit.EmptyHook;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n import org.apache.jackrabbit.oak.spi.state.NodeStateDiff;\n@@ -75,8 +70,9 @@\n             \"Async\", 1, \"Concurrent update detected\");\n \n     /**\n-     * Timeout in minutes after which an async job would be considered as timed out. Another\n-     * node in cluster would wait for timeout before taking over a running job\n+     * Timeout in minutes after which an async job would be considered as\n+     * timed out. Another node in cluster would wait for timeout before\n+     * taking over a running job\n      */\n     private static final int ASYNC_TIMEOUT = 15;\n \n@@ -125,13 +121,55 @@ public AsyncIndexUpdate(@Nonnull String name, @Nonnull NodeStore store,\n      */\n     private class AsyncUpdateCallback implements IndexUpdateCallback {\n \n-        private boolean dirty = false;\n+        /** The base checkpoint */\n+        private final String checkpoint;\n+\n+        /** Expiration time of the last lease we committed */\n+        private long lease;\n+\n+        private long updates = 0;\n+\n+        public AsyncUpdateCallback(String checkpoint)\n+                throws CommitFailedException {\n+            long now = System.currentTimeMillis();\n+            this.checkpoint = checkpoint;\n+            this.lease = now + 2 * ASYNC_TIMEOUT;\n+\n+            String leaseName = name + \"-lease\";\n+            NodeState root = store.getRoot();\n+            long beforeLease = root.getChildNode(ASYNC).getLong(leaseName);\n+            if (beforeLease > now) {\n+                throw CONCURRENT_UPDATE;\n+            }\n+\n+            NodeBuilder builder = root.builder();\n+            builder.child(ASYNC).setProperty(leaseName, lease);\n+            mergeWithConcurrencyCheck(builder, checkpoint, beforeLease);\n+        }\n+\n+        boolean isDirty() {\n+            return updates > 0;\n+        }\n+\n+        void close() throws CommitFailedException {\n+            NodeBuilder builder = store.getRoot().builder();\n+            NodeBuilder async = builder.child(ASYNC);\n+            async.removeProperty(name + \"-lease\");\n+            mergeWithConcurrencyCheck(builder, async.getString(name), lease);\n+        }\n \n         @Override\n         public void indexUpdate() throws CommitFailedException {\n-            if (!dirty) {\n-                dirty = true;\n-                preAsyncRun(store, name);\n+            updates++;\n+            if (updates % 100 == 0) {\n+                long now = System.currentTimeMillis();\n+                if (now + ASYNC_TIMEOUT > lease) {\n+                    long newLease = now + 2 * ASYNC_TIMEOUT;\n+                    NodeBuilder builder = store.getRoot().builder();\n+                    builder.child(ASYNC).setProperty(name + \"-lease\", newLease);\n+                    mergeWithConcurrencyCheck(builder, checkpoint, lease);\n+                    lease = newLease;\n+                }\n             }\n         }\n \n@@ -141,20 +179,26 @@ public void indexUpdate() throws CommitFailedException {\n     public synchronized void run() {\n         log.debug(\"Running background index task {}\", name);\n \n-        if (isAlreadyRunning(store, name)) {\n-            log.debug(\"The {} indexer is already running; skipping this update\", name);\n+        NodeState root = store.getRoot();\n+\n+        // check for concurrent updates\n+        NodeState async = root.getChildNode(ASYNC);\n+        if (async.getLong(name + \"-lease\") > System.currentTimeMillis()) {\n+            log.debug(\"Another copy of the {} index update is already running;\"\n+                    + \" skipping this update\", name);\n             return;\n         }\n \n+        // find the last indexed state, and check if there are recent changes\n         NodeState before;\n-        NodeState root = store.getRoot();\n-        String refCheckpoint = root.getChildNode(ASYNC).getString(name);\n-        if (refCheckpoint != null) {\n-            NodeState state = store.retrieve(refCheckpoint);\n+        String beforeCheckpoint = async.getString(name);\n+        if (beforeCheckpoint != null) {\n+            NodeState state = store.retrieve(beforeCheckpoint);\n             if (state == null) {\n                 log.warn(\"Failed to retrieve previously indexed checkpoint {};\"\n-                        + \" rerunning the initial {} index update\",\n-                        refCheckpoint, name);\n+                        + \" re-running the initial {} index update\",\n+                        beforeCheckpoint, name);\n+                beforeCheckpoint = null;\n                 before = MISSING_NODE;\n             } else if (noVisibleChanges(state, root)) {\n                 log.debug(\"No changes since last checkpoint;\"\n@@ -168,43 +212,84 @@ public synchronized void run() {\n             before = MISSING_NODE;\n         }\n \n-        String checkpoint = store.checkpoint(lifetime);\n-        NodeState after = store.retrieve(checkpoint);\n+        // there are some recent changes, so let's create a new checkpoint\n+        String afterCheckpoint = store.checkpoint(lifetime);\n+        NodeState after = store.retrieve(afterCheckpoint);\n         if (after == null) {\n             log.warn(\"Unable to retrieve newly created checkpoint {},\"\n-                    + \" skipping the {} index update\", checkpoint, name);\n+                    + \" skipping the {} index update\", afterCheckpoint, name);\n             return;\n         }\n \n-        NodeBuilder builder = store.getRoot().builder();\n-        NodeBuilder async = builder.child(ASYNC);\n-\n-        AsyncUpdateCallback callback = new AsyncUpdateCallback();\n-        preAsyncRunStatsStats(indexStats);\n-        IndexUpdate indexUpdate = new IndexUpdate(\n-                provider, name, after, builder, callback);\n-\n-        CommitFailedException exception = EditorDiff.process(\n-                indexUpdate, before, after);\n-        if (exception == null) {\n-            if (callback.dirty) {\n-                async.setProperty(name, checkpoint);\n+        String checkpointToRelease = afterCheckpoint;\n         try {\n-                    store.merge(builder, newCommitHook(name, refCheckpoint),\n-                            CommitInfo.EMPTY);\n+            updateIndex(before, beforeCheckpoint, after, afterCheckpoint);\n+\n+            // the update succeeded, i.e. it no longer fails\n+            if (failing) {\n+                log.info(\"Index update {} no longer fails\", name);\n+                failing = false;\n+            }\n+\n+            // the update succeeded, so we can release the earlier checkpoint\n+            // otherwise the new checkpoint associated with the failed update\n+            // will get released in the finally block\n+            checkpointToRelease = beforeCheckpoint;\n+\n         } catch (CommitFailedException e) {\n-                    if (e != CONCURRENT_UPDATE) {\n-                        exception = e;\n+            if (e == CONCURRENT_UPDATE) {\n+                log.debug(\"Concurrent update detected in the {} index update\", name);\n+            } else if (failing) {\n+                log.debug(\"The {} index update is still failing\", name, e);\n+            } else {\n+                log.warn(\"The {} index update failed\", name, e);\n+                failing = true;\n             }\n+\n+        } finally {\n+            if (checkpointToRelease != null) { // null during initial indexing\n+                store.release(checkpointToRelease);\n+            }\n+        }\n+    }\n+\n+    private void updateIndex(\n+            NodeState before, String beforeCheckpoint,\n+            NodeState after, String afterCheckpoint)\n+            throws CommitFailedException {\n+        // start collecting runtime statistics\n+        preAsyncRunStatsStats(indexStats);\n+\n+        // create an update callback for tracking index updates\n+        // and maintaining the update lease\n+        AsyncUpdateCallback callback =\n+                new AsyncUpdateCallback(beforeCheckpoint);\n+        try {\n+            NodeBuilder builder = store.getRoot().builder();\n+\n+            IndexUpdate indexUpdate =\n+                    new IndexUpdate(provider, name, after, builder, callback);\n+            CommitFailedException exception =\n+                    EditorDiff.process(indexUpdate, before, after);\n+            if (exception != null) {\n+                throw exception;\n             }\n+\n+            if (callback.isDirty() || before == MISSING_NODE) {\n+                builder.child(ASYNC).setProperty(name, afterCheckpoint);\n+                mergeWithConcurrencyCheck(\n+                        builder, beforeCheckpoint, callback.lease);\n+\n                 if (switchOnSync) {\n                     reindexedDefinitions.addAll(\n                             indexUpdate.getReindexedDefinitions());\n+                } else {\n+                    postAsyncRunStatsStatus(indexStats);\n                 }\n             } else if (switchOnSync) {\n-                log.debug(\"No changes detected after diff, will try to switch to synchronous updates on \"\n-                        + reindexedDefinitions);\n-                async.setProperty(name, checkpoint);\n+                log.debug(\"No changes detected after diff; will try to\"\n+                        + \" switch to synchronous updates on {}\",\n+                        reindexedDefinitions);\n \n                 // no changes after diff, switch to sync on the async defs\n                 for (String path : reindexedDefinitions) {\n@@ -217,125 +302,48 @@ public synchronized void run() {\n                     }\n                 }\n \n-                try {\n-                    store.merge(builder, newCommitHook(name, refCheckpoint),\n-                            CommitInfo.EMPTY);\n+                mergeWithConcurrencyCheck(\n+                        builder, beforeCheckpoint, callback.lease);\n                 reindexedDefinitions.clear();\n-                } catch (CommitFailedException e) {\n-                    if (e != CONCURRENT_UPDATE) {\n-                        exception = e;\n             }\n+        } finally {\n+            callback.close();\n         }\n-            }\n-        }\n-        postAsyncRunStatsStatus(indexStats);\n \n-        // checkpoints cleanup\n-        if (exception != null || (exception == null && !callback.dirty)) {\n-            log.debug(\"The {} index update failed; releasing the related checkpoint {}\",\n-                    name, checkpoint);\n-            store.release(checkpoint);\n-        } else {\n-            if (refCheckpoint != null) {\n-                log.debug(\n-                        \"The {} index update succeeded; releasing the previous checkpoint {}\",\n-                        name, refCheckpoint);\n-                store.release(refCheckpoint);\n-            }\n-        }\n-\n-        if (exception != null) {\n-            if (!failing) {\n-                log.warn(\"Index update {} failed\", name, exception);\n-            }\n-            failing = true;\n-        } else {\n-            if (failing) {\n-                log.info(\"Index update {} no longer fails\", name);\n-            }\n-            failing = false;\n-        }\n+        postAsyncRunStatsStatus(indexStats);\n     }\n \n-    private static CommitHook newCommitHook(\n-            final String name, final String checkpoint) {\n-        return new CompositeHook(\n-                new ConflictHook(new AnnotatingConflictHandler()),\n-                new EditorHook(new ConflictValidatorProvider()),\n-                new CommitHook() {\n+    private void mergeWithConcurrencyCheck(\n+            NodeBuilder builder, final String checkpoint, final long lease)\n+            throws CommitFailedException {\n+        CommitHook concurrentUpdateCheck = new CommitHook() {\n             @Override @Nonnull\n             public NodeState processCommit(\n                     NodeState before, NodeState after, CommitInfo info)\n                     throws CommitFailedException {\n                 // check for concurrent updates by this async task\n-                String checkpointAfterRebase =\n-                        before.getChildNode(ASYNC).getString(name);\n-                if (Objects.equal(checkpoint, checkpointAfterRebase)) {\n-                    return postAsyncRunNodeStatus(after.builder(), name)\n-                            .getNodeState();\n+                NodeState async = before.getChildNode(ASYNC);\n+                if (Objects.equal(checkpoint, async.getString(name))\n+                        && lease == async.getLong(name + \"-lease\")) {\n+                    return after;\n                 } else {\n+                    new Exception(checkpoint + \" - \" + async.getString(name)\n+                            + \" / \" + lease + \" - \" + async.getLong(name + \"-lease\")).printStackTrace();\n                     throw CONCURRENT_UPDATE;\n                 }\n             }\n-        });\n-    }\n-\n-    private static void preAsyncRun(NodeStore store, String name) throws CommitFailedException {\n-        NodeBuilder builder = store.getRoot().builder();\n-        preAsyncRunNodeStatus(builder, name);\n-        store.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n-    }\n-\n-    private static boolean isAlreadyRunning(NodeStore store, String name) {\n-        NodeState indexState = store.getRoot().getChildNode(INDEX_DEFINITIONS_NAME);\n-\n-        //Probably the first run\n-        if (!indexState.exists()) {\n-            return false;\n-        }\n-\n-        //Check if already running or timed out\n-        if (STATUS_RUNNING.equals(indexState.getString(name + \"-status\"))) {\n-            PropertyState startTime = indexState.getProperty(name + \"-start\");\n-            Calendar start = Conversions.convert(startTime.getValue(Type.DATE)).toCalendar();\n-            Calendar now = Calendar.getInstance();\n-            long delta = now.getTimeInMillis() - start.getTimeInMillis();\n-\n-            //Check if the job has timed out and we need to take over\n-            if (TimeUnit.MILLISECONDS.toMinutes(delta) > ASYNC_TIMEOUT) {\n-                log.info(\"Async job found which stated on {} has timed out in {} minutes. \" +\n-                        \"This node would take over the job.\",\n-                        startTime.getValue(Type.DATE), ASYNC_TIMEOUT);\n-                return false;\n-            }\n-            return true;\n-        }\n-\n-        return false;\n-    }\n-\n-    private static void preAsyncRunNodeStatus(NodeBuilder builder, String name) {\n-        String now = now();\n-        builder.getChildNode(INDEX_DEFINITIONS_NAME)\n-                .setProperty(name + \"-status\", STATUS_RUNNING)\n-                .setProperty(name + \"-start\", now, Type.DATE)\n-                .removeProperty(name + \"-done\");\n+        };\n+        CompositeHook hooks = new CompositeHook(\n+                new ConflictHook(new AnnotatingConflictHandler()),\n+                new EditorHook(new ConflictValidatorProvider()),\n+                concurrentUpdateCheck);\n+        store.merge(builder, hooks, CommitInfo.EMPTY);\n     }\n \n     private static void preAsyncRunStatsStats(AsyncIndexStats stats) {\n         stats.start(now());\n     }\n \n-    private static NodeBuilder postAsyncRunNodeStatus(\n-            NodeBuilder builder, String name) {\n-        String now = now();\n-        builder.getChildNode(INDEX_DEFINITIONS_NAME)\n-                .setProperty(name + \"-status\", STATUS_DONE)\n-                .setProperty(name + \"-done\", now, Type.DATE)\n-                .removeProperty(name + \"-start\");\n-        return builder;\n-    }\n-\n      private static void postAsyncRunStatsStatus(AsyncIndexStats stats) {\n         stats.done(now());\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\nindex 75f0f3195c..914f23fda6 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\n@@ -102,7 +102,7 @@ private IndexUpdate(IndexUpdate parent, String name) {\n         this.provider = parent.provider;\n         this.async = parent.async;\n         this.root = parent.root;\n-        this.builder = parent.builder.child(checkNotNull(name));\n+        this.builder = parent.builder.getChildNode(checkNotNull(name));\n         this.updateCallback = parent.updateCallback;\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 134,
        "jira_id": "1877",
        "nb_skipped": 9,
        "commit": "716e1237",
        "nb_failure": 1,
        "linesRem": 135,
        "singleLine": false
    },
    {
        "files": 6,
        "nb_test": 1425,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.kernel.KernelNodeBuilderTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/MutableTree.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/MutableTree.java\nindex a1aa87d122..1b02d0a414 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/MutableTree.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/MutableTree.java\n@@ -18,8 +18,22 @@\n  */\n package org.apache.jackrabbit.oak.core;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.filter;\n+import static com.google.common.collect.Iterables.indexOf;\n+import static org.apache.jackrabbit.oak.api.Tree.Status.EXISTING;\n+import static org.apache.jackrabbit.oak.api.Tree.Status.MODIFIED;\n+import static org.apache.jackrabbit.oak.api.Tree.Status.NEW;\n+import static org.apache.jackrabbit.oak.api.Type.STRING;\n+import static org.apache.jackrabbit.oak.commons.PathUtils.elements;\n+import static org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute;\n+import static org.apache.jackrabbit.oak.spi.state.NodeStateUtils.isHidden;\n+\n import java.util.Collections;\n import java.util.Set;\n+\n import javax.annotation.CheckForNull;\n import javax.annotation.Nonnull;\n \n@@ -36,19 +50,6 @@\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n import org.apache.jackrabbit.oak.spi.state.PropertyBuilder;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n-import static com.google.common.base.Preconditions.checkNotNull;\n-import static com.google.common.base.Preconditions.checkState;\n-import static com.google.common.collect.Iterables.filter;\n-import static com.google.common.collect.Iterables.indexOf;\n-import static org.apache.jackrabbit.oak.api.Tree.Status.EXISTING;\n-import static org.apache.jackrabbit.oak.api.Tree.Status.MODIFIED;\n-import static org.apache.jackrabbit.oak.api.Tree.Status.NEW;\n-import static org.apache.jackrabbit.oak.api.Type.STRING;\n-import static org.apache.jackrabbit.oak.commons.PathUtils.elements;\n-import static org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute;\n-import static org.apache.jackrabbit.oak.spi.state.NodeStateUtils.isHidden;\n-\n public class MutableTree extends AbstractTree {\n \n     /**\n@@ -86,7 +87,7 @@ protected MutableTree createChild(String name) {\n \n     @Override\n     protected boolean isNew() {\n-        return !getBase().exists();\n+        return nodeBuilder.isNew();\n     }\n \n     @Override\n@@ -335,15 +336,6 @@ public String toString() {\n     }\n \n     //---------------------------------------------------------< internal >---\n-\n-    private NodeState getBase() {\n-        if (parent == null) {\n-            return root.getBaseState();\n-        } else {\n-            return parent.getBase().getChildNode(name);\n-        }\n-    }\n-\n     /**\n      * Set the parent and name of this tree.\n      * @param parent  parent of this tree\n@@ -480,7 +472,7 @@ private void beforeWrite() throws IllegalStateException {\n      * Internal method for checking whether this node exists and is visible\n      * (i.e. not hidden).\n      *\n-     * @return {@true} if the node is visible, {@code false} if not\n+     * @return {@code true} if the node is visible, {@code false} if not\n      */\n     private boolean isVisible() {\n         return !isHidden(name) && nodeBuilder.exists();\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeBuilder.java\nindex aa9d7d8126..5058a8b4a2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeBuilder.java\n@@ -34,7 +34,7 @@\n \n     private NodeState base = null;\n \n-    protected NodeState rootBase = null;\n+    private NodeState rootBase = null;\n \n     KernelNodeBuilder(MemoryNodeBuilder parent, String name, KernelRootBuilder root) {\n         super(parent, name);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRootBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRootBuilder.java\nindex dfe75969fd..87b2a0d392 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRootBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRootBuilder.java\n@@ -117,7 +117,8 @@ NodeState rebase() {\n         purge();\n         branch.rebase();\n         NodeState head = branch.getHead();\n-        reset(head);\n+        reset(branch.getBase());\n+        super.reset(head);\n         return head;\n     }\n \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex 00136aa516..a83ca87e47 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -260,7 +260,7 @@ public boolean exists() {\n \n     @Override\n     public boolean isNew() {\n-        return exists() && !base.exists();\n+        return exists() && !getBaseState().exists();\n     }\n \n     @Override\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeBuilder.java\nindex 4b10bd0e32..383797495e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeBuilder.java\n@@ -18,11 +18,13 @@\n \n import org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilder;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n+import org.apache.jackrabbit.oak.spi.state.NodeState;\n \n /**\n  * A node builder implementation for MongoMK.\n  */\n class MongoNodeBuilder extends MemoryNodeBuilder {\n+    private NodeState base;\n \n     protected MongoNodeBuilder(MongoNodeState base) {\n         super(base);\n@@ -32,6 +34,14 @@ private MongoNodeBuilder(MongoNodeBuilder parent, String name) {\n         super(parent, name);\n     }\n \n+    @Override\n+    public NodeState getBaseState() {\n+        if (base == null) {\n+            base = getParent().getBaseState().getChildNode(getName());\n+        }\n+        return base;\n+    }\n+\n     @Override\n     protected MongoNodeBuilder createChildBuilder(String name) {\n         return new MongoNodeBuilder(this, name);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoRootBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoRootBuilder.java\nindex 7a1d81517b..aa6460ea56 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoRootBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoRootBuilder.java\n@@ -98,7 +98,8 @@ NodeState rebase() {\n         purge();\n         branch.rebase();\n         NodeState head = branch.getHead();\n-        reset(head);\n+        reset(branch.getBase());\n+        super.reset(head);\n         return head;\n     }\n \n",
        "project": "jackrabbit-oak",
        "linesAdd": 31,
        "jira_id": "1178",
        "nb_skipped": 6,
        "commit": "f2bb1a17",
        "nb_failure": 1,
        "linesRem": 27,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1819,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.segment.CompactorTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Compactor.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Compactor.java\nindex 14278ca97e..18cb0687a1 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Compactor.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/Compactor.java\n@@ -20,7 +20,6 @@\n import static com.google.common.collect.Maps.newHashMap;\n import static org.apache.jackrabbit.oak.api.Type.BINARIES;\n import static org.apache.jackrabbit.oak.api.Type.BINARY;\n-import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.EMPTY_NODE;\n \n import java.io.IOException;\n import java.io.InputStream;\n@@ -62,8 +61,6 @@\n \n     private final SegmentWriter writer;\n \n-    private final SegmentNodeBuilder builder;\n-\n     private CompactionMap map = new CompactionMap(100000);\n \n     /**\n@@ -75,11 +72,11 @@\n \n     public Compactor(SegmentWriter writer) {\n         this.writer = writer;\n-        this.builder =\n-                new SegmentNodeBuilder(writer.writeNode(EMPTY_NODE), writer);\n     }\n \n     public SegmentNodeState compact(NodeState before, NodeState after) {\n+        SegmentNodeBuilder builder = new SegmentNodeBuilder(\n+                writer.writeNode(before), writer);\n         after.compareAgainstBaseState(before, new CompactDiff(builder));\n         return builder.getNodeState();\n     }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "1932",
        "nb_skipped": 9,
        "commit": "c215b267",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1844,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.BlobTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 36b242a28c..cc5ea66911 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -280,7 +280,17 @@ public String serialize(Blob blob) {\n             if (blob instanceof BlobStoreBlob) {\n                 return ((BlobStoreBlob) blob).getBlobId();\n             }\n+\n             String id;\n+\n+            String reference = blob.getReference();\n+            if(reference != null){\n+                id = blobStore.getBlobId(reference);\n+                if(id != null){\n+                    return id;\n+                }\n+            }\n+\n             try {\n                 id = createBlob(blob.getNewStream()).getBlobId();\n             } catch (IOException e) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 10,
        "jira_id": "1761",
        "nb_skipped": 9,
        "commit": "f37ce716",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 7,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.commons.PathUtilsTest"
        ],
        "patch": "diff --git a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/PathUtils.java b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/PathUtils.java\nindex 6e68cb07ba..f82ec9339d 100644\n--- a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/PathUtils.java\n+++ b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/PathUtils.java\n@@ -185,6 +185,9 @@ public static String dropIndexFromName(@Nonnull String name) {\n     public static int getDepth(String path) {\n         assert isValid(path);\n \n+        if (path.isEmpty()) {\n+            return 0;\n+        }\n         int count = 1, i = 0;\n         if (isAbsolutePath(path)) {\n             if (denotesRootPath(path)) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "888",
        "nb_skipped": 0,
        "commit": "6d82cb64",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 229,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.namepath.NamePathMapperImplTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\nindex 7bce77d992..65639f1dcb 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java\n@@ -151,9 +151,6 @@ public boolean name(String name, int index) {\n     }\n \n     private String getOakPath(String jcrPath, final boolean keepIndex) {\n-        final List<String> elements = new ArrayList<String>();\n-        final StringBuilder parseErrors = new StringBuilder();\n-\n         if (\"/\".equals(jcrPath)) {\n             // avoid the need to special case the root path later on\n             return \"/\";\n@@ -180,6 +177,7 @@ private String getOakPath(String jcrPath, final boolean keepIndex) {\n         boolean hasIndexBrackets = false;\n         boolean hasColon = false;\n         boolean hasNameStartingWithDot = false;\n+        boolean hasTrailingSlash = false;\n \n         char prev = 0;\n         for (int i = 0; i < length; i++) {\n@@ -193,6 +191,8 @@ private String getOakPath(String jcrPath, final boolean keepIndex) {\n                 hasColon = true;\n             } else if (c == '.' && (prev == 0 || prev == '/')) {\n                 hasNameStartingWithDot = true;\n+            } else if(c == '/' && i == (length - 1)){\n+                hasTrailingSlash = true;\n             }\n \n             prev = c;\n@@ -202,6 +202,9 @@ private String getOakPath(String jcrPath, final boolean keepIndex) {\n         if (!hasNameStartingWithDot && !hasClarkBrackets && !hasIndexBrackets) {\n             if (!hasColon || !hasSessionLocalMappings()) {\n                 if (JcrPathParser.validate(jcrPath)) {\n+                    if(hasTrailingSlash){\n+                        return jcrPath.substring(0, length - 1);\n+                    }\n                     return jcrPath;\n                 }\n                 else {\n@@ -211,6 +214,9 @@ private String getOakPath(String jcrPath, final boolean keepIndex) {\n             }\n         }\n \n+        final List<String> elements = new ArrayList<String>();\n+        final StringBuilder parseErrors = new StringBuilder();\n+\n         JcrPathParser.Listener listener = new JcrPathParser.Listener() {\n \n             @Override\n",
        "project": "jackrabbit-oak",
        "linesAdd": 9,
        "jira_id": "313",
        "nb_skipped": 1,
        "commit": "e115fd90",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 2968,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.document.ClusterNodeRestartTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\nindex 49496ee3f0..9e3eac27f4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\n@@ -127,7 +127,7 @@ public void dispose() {\n     }\n \n     void backgroundRead() {\n-        nodeStore.backgroundRead(true);\n+        nodeStore.backgroundRead();\n     }\n \n     void backgroundWrite() {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 061a3645fb..347d694fa2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -18,6 +18,7 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n import static com.google.common.collect.Iterables.filter;\n import static com.google.common.collect.Iterables.toArray;\n import static com.google.common.collect.Iterables.transform;\n@@ -487,27 +488,29 @@ public int getMemory() {\n             setHeadRevision(commit.getRevision());\n             // make sure _lastRev is written back to store\n             backgroundWrite();\n-        } else {\n-            // initialize branchCommits\n-            branches.init(store, this);\n-            // initial reading of the revisions of other cluster nodes\n-            backgroundRead(false);\n-            if (headRevision == null) {\n-                // no revision read from other cluster nodes\n-                setHeadRevision(newRevision());\n+            rootDoc = store.find(NODES, Utils.getIdFromPath(\"/\"));\n+            // at this point the root document must exist\n+            if (rootDoc == null) {\n+                throw new IllegalStateException(\"Root document does not exist\");\n             }\n+        } else {\n+            checkLastRevRecovery();\n+            initializeHeadRevision(rootDoc);\n             // check if _lastRev for our clusterId exists\n             if (!rootDoc.getLastRev().containsKey(clusterId)) {\n                 unsavedLastRevisions.put(\"/\", headRevision);\n                 backgroundWrite();\n             }\n         }\n-        checkLastRevRecovery();\n+\n         // Renew the lease because it may have been stale\n         renewClusterIdLease();\n \n         getRevisionComparator().add(headRevision, Revision.newRevision(0));\n \n+        // initialize branchCommits\n+        branches.init(store, this);\n+\n         dispatcher = new ChangeDispatcher(getRoot());\n         commitQueue = new CommitQueue(this);\n         String threadNamePostfix = \"(\" + clusterId + \")\";\n@@ -1693,7 +1696,7 @@ private void internalRunBackgroundReadOperations() {\n         synchronized (backgroundReadMonitor) {\n             long start = clock.getTime();\n             // pull in changes from other cluster nodes\n-            BackgroundReadStats readStats = backgroundRead(true);\n+            BackgroundReadStats readStats = backgroundRead();\n             long readTime = clock.getTime() - start;\n             String msg = \"Background read operations stats (read:{} {})\";\n             if (clock.getTime() - start > TimeUnit.SECONDS.toMillis(10)) {\n@@ -1762,11 +1765,8 @@ boolean updateClusterState() {\n \n     /**\n      * Perform a background read and make external changes visible.\n-     *\n-     * @param dispatchChange whether to dispatch external changes\n-     *                       to {@link #dispatcher}.\n      */\n-    BackgroundReadStats backgroundRead(boolean dispatchChange) {\n+    BackgroundReadStats backgroundRead() {\n         BackgroundReadStats stats = new BackgroundReadStats();\n         long time = clock.getTime();\n         String id = Utils.getIdFromPath(\"/\");\n@@ -1774,30 +1774,7 @@ BackgroundReadStats backgroundRead(boolean dispatchChange) {\n         if (doc == null) {\n             return stats;\n         }\n-        Map<Integer, Revision> lastRevMap = doc.getLastRev();\n-        try {\n-            long externalTime = Utils.getMaxExternalTimestamp(lastRevMap.values(), clusterId);\n-            long localTime = clock.getTime();\n-            if (localTime < externalTime) {\n-                LOG.warn(\"Detected clock differences. Local time is '{}', \" +\n-                                \"while most recent external time is '{}'. \" +\n-                                \"Current _lastRev entries: {}\",\n-                        new Date(localTime), new Date(externalTime), lastRevMap.values());\n-                double delay = ((double) externalTime - localTime) / 1000d;\n-                String msg = String.format(\"Background read will be delayed by %.1f seconds. \" +\n-                        \"Please check system time on cluster nodes.\", delay);\n-                LOG.warn(msg);\n-                clock.waitUntil(externalTime + 1);\n-            } else if (localTime == externalTime) {\n-                // make sure local time is past external time\n-                // but only log at debug\n-                LOG.debug(\"Local and external time are equal. Waiting until local\" +\n-                        \"time is more recent than external reported time.\");\n-                clock.waitUntil(externalTime + 1);\n-            }\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(\"Background read interrupted\", e);\n-        }\n+        alignWithExternalRevisions(doc);\n \n         Revision.RevisionComparator revisionComparator = getRevisionComparator();\n         // the (old) head occurred first\n@@ -1807,6 +1784,7 @@ BackgroundReadStats backgroundRead(boolean dispatchChange) {\n \n         StringSort externalSort = JournalEntry.newSorter();\n \n+        Map<Integer, Revision> lastRevMap = doc.getLastRev();\n         try {\n             Map<Revision, Revision> externalChanges = Maps.newHashMap();\n             for (Map.Entry<Integer, Revision> e : lastRevMap.entrySet()) {\n@@ -1899,7 +1877,6 @@ BackgroundReadStats backgroundRead(boolean dispatchChange) {\n                     Revision oldHead = headRevision;\n                     // the new head revision is after other revisions\n                     setHeadRevision(newRevision());\n-                    if (dispatchChange) {\n                     commitQueue.headRevisionChanged();\n                     time = clock.getTime();\n                     if (externalSort != null) {\n@@ -1915,7 +1892,6 @@ BackgroundReadStats backgroundRead(boolean dispatchChange) {\n                     time = clock.getTime();\n \n                     dispatcher.contentChanged(getRoot().fromExternalChange(), null);\n-                    }\n                 } finally {\n                     backgroundOperationLock.writeLock().unlock();\n                 }\n@@ -2054,6 +2030,68 @@ public void acquiring(Revision mostRecent) {\n \n     //-----------------------------< internal >---------------------------------\n \n+    /**\n+     * Performs an initial read of the _lastRevs on the root document,\n+     * initializes the {@link #revisionComparator} and sets the head revision.\n+     *\n+     * @param rootDoc the current root document.\n+     */\n+    private void initializeHeadRevision(NodeDocument rootDoc) {\n+        checkState(headRevision == null);\n+\n+        alignWithExternalRevisions(rootDoc);\n+        Map<Integer, Revision> lastRevMap = rootDoc.getLastRev();\n+        Revision seenAt = Revision.newRevision(0);\n+        long purgeMillis = revisionPurgeMillis();\n+        for (Map.Entry<Integer, Revision> entry : lastRevMap.entrySet()) {\n+            Revision r = entry.getValue();\n+            if (r.getTimestamp() > purgeMillis) {\n+                revisionComparator.add(r, seenAt);\n+            }\n+            if (entry.getKey() == clusterId) {\n+                continue;\n+            }\n+            lastKnownRevision.put(entry.getKey(), entry.getValue());\n+        }\n+        revisionComparator.purge(purgeMillis);\n+        setHeadRevision(newRevision());\n+    }\n+\n+    /**\n+     * Makes sure the current time is after the most recent external revision\n+     * timestamp in the _lastRev map of the given root document. If necessary\n+     * the current thread waits until {@link #clock} is after the external\n+     * revision timestamp.\n+     *\n+     * @param rootDoc the root document.\n+     */\n+    private void alignWithExternalRevisions(@Nonnull NodeDocument rootDoc) {\n+        Map<Integer, Revision> lastRevMap = checkNotNull(rootDoc).getLastRev();\n+        try {\n+            long externalTime = Utils.getMaxExternalTimestamp(lastRevMap.values(), clusterId);\n+            long localTime = clock.getTime();\n+            if (localTime < externalTime) {\n+                LOG.warn(\"Detected clock differences. Local time is '{}', \" +\n+                                \"while most recent external time is '{}'. \" +\n+                                \"Current _lastRev entries: {}\",\n+                        new Date(localTime), new Date(externalTime), lastRevMap.values());\n+                double delay = ((double) externalTime - localTime) / 1000d;\n+                String msg = String.format(\"Background read will be delayed by %.1f seconds. \" +\n+                        \"Please check system time on cluster nodes.\", delay);\n+                LOG.warn(msg);\n+                clock.waitUntil(externalTime + 1);\n+            } else if (localTime == externalTime) {\n+                // make sure local time is past external time\n+                // but only log at debug\n+                LOG.debug(\"Local and external time are equal. Waiting until local\" +\n+                        \"time is more recent than external reported time.\");\n+                clock.waitUntil(externalTime + 1);\n+            }\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"Background read interrupted\", e);\n+        }\n+    }\n+\n     @Nonnull\n     private Commit newTrunkCommit(@Nonnull Revision base) {\n         checkArgument(!checkNotNull(base).isBranch(),\n",
        "project": "jackrabbit-oak",
        "linesAdd": 61,
        "jira_id": "3549",
        "nb_skipped": 1,
        "commit": "9772f5b2",
        "nb_failure": 1,
        "linesRem": 33,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3093,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.memory.EmptyNodeStateTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/EmptyNodeState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/EmptyNodeState.java\nindex 62c757d99f..54415d42b3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/EmptyNodeState.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/EmptyNodeState.java\n@@ -186,7 +186,8 @@ public boolean equals(Object object) {\n         } else if (object instanceof NodeState) {\n             NodeState that = (NodeState) object;\n             return that.getPropertyCount() == 0\n-                    && that.getChildNodeCount(1) == 0;\n+                    && that.getChildNodeCount(1) == 0\n+                    && (exists == that.exists());\n         } else {\n             return false;\n         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 2,
        "jira_id": "3763",
        "nb_skipped": 1,
        "commit": "ab1a0cc2",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1506,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.spi.state.MoveDetectorTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\nindex 75d6c457d3..31f62366e0 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilder.java\n@@ -374,11 +374,9 @@ protected static void annotateSourcePath(NodeBuilder builder, String path) {\n         PropertyState base = builder.getBaseState().getProperty(MoveDetector.SOURCE_PATH);\n         PropertyState head = builder.getNodeState().getProperty(MoveDetector.SOURCE_PATH);\n         if (Objects.equal(base, head)) {\n-            if (!builder.hasProperty(MoveDetector.SOURCE_PATH)) {\n             builder.setProperty(MoveDetector.SOURCE_PATH, path);\n         }\n     }\n-    }\n \n     @Override\n     public boolean copyTo(NodeBuilder newParent, String newName) {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 0,
        "jira_id": "1297",
        "nb_skipped": 6,
        "commit": "73cc2442",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 53,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.commons.json.JsopTest"
        ],
        "patch": "diff --git a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\nindex a9a8b9a777..8489197562 100644\n--- a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\n+++ b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\n@@ -285,6 +285,7 @@ public static void escape(String s, StringBuilder buff) {\n     private static void escape(String s, int length, StringBuilder buff) {\n         for (int i = 0; i < length; i++) {\n             char c = s.charAt(i);\n+            int ic = (int)c;\n             switch (c) {\n             case '\"':\n                 // quotation mark\n@@ -316,10 +317,18 @@ private static void escape(String s, int length, StringBuilder buff) {\n                 break;\n             default:\n                 if (c < ' ') {\n-                    buff.append(\"\\\\u00\");\n-                    // guaranteed to be 1 or 2 hex digits only\n-                    buff.append(Character.forDigit(c >>> 4, 16));\n-                    buff.append(Character.forDigit(c & 15, 16));\n+                    buff.append(String.format(\"\\\\u%04x\", ic));\n+                } else if (ic >= 0xD800 && ic <= 0xDBFF) {\n+                    // isSurrogate(), only available in Java 7\n+                    if (i < length - 1 && Character.isSurrogatePair(c, s.charAt(i + 1))) {\n+                        // ok surrogate\n+                        buff.append(c);\n+                        buff.append(s.charAt(i + 1));\n+                        i += 1;\n+                    } else {\n+                        // broken surrogate -> escape\n+                        buff.append(String.format(\"\\\\u%04x\", ic));\n+                    }\n                 } else {\n                     buff.append(c);\n                 }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 10,
        "jira_id": "2389",
        "nb_skipped": 0,
        "commit": "8079f7b5",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 301,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndexTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\nindex 5277652558..e13e7efa41 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditor.java\n@@ -38,6 +38,7 @@\n import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.plugins.index.IndexEditor;\n import org.apache.jackrabbit.oak.plugins.index.IndexUpdateCallback;\n+import org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState;\n import org.apache.jackrabbit.oak.plugins.nodetype.TypePredicate;\n import org.apache.jackrabbit.oak.spi.commit.Editor;\n import org.apache.jackrabbit.oak.spi.state.NodeBuilder;\n@@ -122,6 +123,9 @@ public String getPath() {\n     @Override\n     public void enter(NodeState before, NodeState after)\n             throws CommitFailedException {\n+        if (EmptyNodeState.MISSING_NODE == before && parent == null){\n+            context.enableReindexMode();\n+        }\n     }\n \n     @Override\ndiff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\nindex 686db73afc..a25bc41d14 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/LuceneIndexEditorContext.java\n@@ -101,6 +101,8 @@ private static Directory newIndexDirectory(NodeBuilder definition)\n \n     private final IndexUpdateCallback updateCallback;\n \n+    private boolean reindex;\n+\n     LuceneIndexEditorContext(NodeBuilder definition, Analyzer analyzer, IndexUpdateCallback updateCallback) {\n         this.definitionBuilder = definition;\n         this.definition = new IndexDefinition(definitionBuilder);\n@@ -132,6 +134,14 @@ IndexWriter getWriter() throws IOException {\n      * close writer if it's not null\n      */\n     void closeWriter() throws IOException {\n+        //If reindex or fresh index and write is null on close\n+        //it indicates that the index is empty. In such a case trigger\n+        //creation of write such that an empty Lucene index state is persisted\n+        //in directory\n+        if (reindex && writer == null){\n+            getWriter();\n+        }\n+\n         if (writer != null) {\n             writer.close();\n \n@@ -144,6 +154,10 @@ void closeWriter() throws IOException {\n         }\n     }\n \n+    public void enableReindexMode(){\n+        reindex = true;\n+    }\n+\n     public long incIndexedNodes() {\n         indexedNodes++;\n         return indexedNodes;\n",
        "project": "jackrabbit-oak",
        "linesAdd": 14,
        "jira_id": "2235",
        "nb_skipped": 1,
        "commit": "29d3d8f1",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 374,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.lucene.OakDirectoryTest"
        ],
        "patch": "diff --git a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\nindex 8e573399f1..8256394ddf 100644\n--- a/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\n+++ b/oak-lucene/src/main/java/org/apache/jackrabbit/oak/plugins/index/lucene/OakDirectory.java\n@@ -187,7 +187,7 @@ public OakIndexFile(String name, NodeBuilder file) {\n                 this.data = newArrayList();\n             }\n \n-            this.length = data.size() * blobSize;\n+            this.length = (long)data.size() * blobSize;\n             if (!data.isEmpty()) {\n                 Blob last = data.get(data.size() - 1);\n                 this.length -= blobSize - last.length();\n@@ -253,7 +253,9 @@ public void readBytes(byte[] b, int offset, int len)\n             checkPositionIndexes(offset, offset + len, checkNotNull(b).length);\n \n             if (len < 0 || position + len > length) {\n-                throw new IOException(\"Invalid byte range request\");\n+                String msg = String.format(\"Invalid byte range request [%s] : position : %d, length : \" +\n+                                \"%d, len : %d\", name, position, length, len);\n+                throw new IOException(msg);\n             }\n \n             int i = (int) (position / blobSize);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 4,
        "jira_id": "2388",
        "nb_skipped": 0,
        "commit": "487de751",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 649,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.authorization.AccessControlManagerImplTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/AccessControlConfigurationImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/AccessControlConfigurationImpl.java\nindex aa7b8d8e21..753158070a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/AccessControlConfigurationImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/AccessControlConfigurationImpl.java\n@@ -70,7 +70,8 @@ public CommitHookProvider getSecurityHooks() {\n         return new CommitHookProvider() {\n             @Override\n             public CommitHook getCommitHook(String workspaceName) {\n-                return new CompositeHook(new PermissionHook(workspaceName), new VersionablePathHook(workspaceName));\n+                //FIXME return new CompositeHook(new PermissionHook(workspaceName), new VersionablePathHook(workspaceName));\n+                return new CompositeHook(new VersionablePathHook(workspaceName));\n             }\n         };\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/privilege/PrivilegeDefinitionStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/privilege/PrivilegeDefinitionStore.java\nindex 6ae510c2ca..2fa44f7bc2 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/privilege/PrivilegeDefinitionStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/privilege/PrivilegeDefinitionStore.java\n@@ -38,6 +38,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n /**\n  * Reads and writes privilege definitions from and to the repository content\n  * without applying any validation.\n@@ -110,7 +112,7 @@ public PrivilegeBits getBits(@Nonnull String... privilegeNames) {\n         }\n         PrivilegeBits bits = PrivilegeBits.getInstance();\n         for (String privilegeName : privilegeNames) {\n-            Tree defTree = privilegesTree.getChild(privilegeName);\n+            Tree defTree = privilegesTree.getChild(checkNotNull(privilegeName));\n             if (defTree != null) {\n                 bits.add(PrivilegeBits.getInstance(defTree));\n             }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 4,
        "jira_id": "644",
        "nb_skipped": 1,
        "commit": "55a4f738",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 77,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.mk.model.IdTest"
        ],
        "patch": "diff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/Id.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/Id.java\nindex a263ddb345..021b5ef6f3 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/Id.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/model/Id.java\n@@ -113,7 +113,9 @@ public int compareTo(Id o) {\n         \n         for (int i = 0; i < len; i++) {\n             if (raw[i] != other[i]) {\n-                return raw[i] - other[i];\n+                final int rawValue = raw[i] & 0xFF; // unsigned value\n+                final int otherValue = other[i] & 0xFF; // unsigned value\n+                return rawValue - otherValue;\n             }\n         }\n         return raw.length - other.length;\n",
        "project": "jackrabbit-oak",
        "linesAdd": 3,
        "jira_id": "539",
        "nb_skipped": 2,
        "commit": "ffa818f3",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 404,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.p2.Property2IndexTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexLookup.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexLookup.java\nindex bbf71e30fa..7a31ae6197 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexLookup.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexLookup.java\n@@ -18,6 +18,7 @@\n \n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.INDEX_DEFINITIONS_NAME;\n \n+import java.util.Iterator;\n import java.util.Set;\n \n import javax.annotation.Nullable;\n@@ -25,6 +26,7 @@\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.api.Type;\n+import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.plugins.index.IndexConstants;\n import org.apache.jackrabbit.oak.plugins.index.p2.strategy.ContentMirrorStoreStrategy;\n import org.apache.jackrabbit.oak.plugins.index.p2.strategy.IndexStoreStrategy;\n@@ -72,22 +74,22 @@ public Property2IndexLookup(NodeState root) {\n      * @return true if the property is indexed\n      */\n     public boolean isIndexed(String name, String path) {\n-        if (getIndexDefinitionNode(name) != null) {\n-            return true;\n+        return isIndexed(root, name, path);\n     }\n     \n-        // TODO use PathUtils\n-        if (path.startsWith(\"/\")) {\n-            path = path.substring(1);\n+    private static boolean isIndexed(NodeState root, String name, String path) {\n+        NodeState node = root;\n+        Iterator<String> it = PathUtils.elements(path).iterator();\n+        while (true) {\n+            if (getIndexDefinitionNode(node, name) != null) {\n+                return true;\n             }\n-        int slash = path.indexOf('/');\n-        if (slash == -1) {\n-            return false;\n+            if (!it.hasNext()) {\n+                break;\n             }\n-\n-        NodeState child = root.getChildNode(path.substring(0, slash));\n-        return new Property2IndexLookup(child).isIndexed(\n-                name, path.substring(slash));\n+            node = node.getChildNode(it.next());\n+        }\n+        return false;\n     }\n     \n     /**\n@@ -112,69 +114,33 @@ public boolean isIndexed(String name, String path) {\n      * @return the set of matched paths\n      */\n     public Set<String> find(String name, PropertyValue value) {\n+        NodeState state = getIndexDefinitionNode(root, name);\n+        if (state == null || state.getChildNode(\":index\") == null) {\n+            throw new IllegalArgumentException(\"No index for \" + name);\n+        }\n         Set<String> paths = Sets.newHashSet();\n-\n-        NodeState state = getIndexDefinitionNode(name);\n-        if (state != null && state.getChildNode(\":index\") != null) {\n         state = state.getChildNode(\":index\");\n         if (value == null) {\n             paths.addAll(store.find(state, null));\n         } else {\n             paths.addAll(store.find(state, Property2Index.encode(value)));\n         }\n-        } else {\n-            // No index available, so first check this node for a match\n-            PropertyState property = root.getProperty(name);\n-            if (property != null) {\n-                if (value == null || value.isArray()) {\n-                    // let query engine handle property existence and\n-                    // multi-valued look ups;\n-                    // simply return all nodes that have this property\n-                    paths.add(\"\");\n-                } else {\n-                    // does it match any of the values of this property?\n-                    for (int i = 0; i < property.count(); i++) {\n-                        if (property.getValue(value.getType(), i).equals(value.getValue(value.getType()))) {\n-                            paths.add(\"\");\n-                            // no need to check for more matches in this property\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // ... and then recursively look up from the rest of the tree\n-            for (ChildNodeEntry entry : root.getChildNodeEntries()) {\n-                String base = entry.getName();\n-                Property2IndexLookup lookup =\n-                        new Property2IndexLookup(entry.getNodeState());\n-                for (String path : lookup.find(name, value)) {\n-                    if (path.isEmpty()) {\n-                        paths.add(base);\n-                    } else {\n-                        paths.add(base + \"/\" + path);\n-                    }\n-                }\n-            }\n-        }\n-\n         return paths;\n     }\n \n     public double getCost(String name, PropertyValue value) {\n-        double cost = 0.0;\n         // TODO the cost method is currently reading all the data - \n         // is not supposed to do that, it is only supposed to estimate\n-        NodeState state = getIndexDefinitionNode(name);\n-        if (state != null && state.getChildNode(\":index\") != null) {\n+        NodeState state = getIndexDefinitionNode(root, name);\n+        if (state == null || state.getChildNode(\":index\") == null) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n         state = state.getChildNode(\":index\");\n+        double cost;\n         if (value == null) {\n-                cost += store.count(state, null);\n-            } else {\n-                cost += store.count(state, Property2Index.encode(value));\n-            }\n+            cost = store.count(state, null);\n         } else {\n-            cost = Double.POSITIVE_INFINITY;\n+            cost = store.count(state, Property2Index.encode(value));\n         }\n         return cost;\n     }\n@@ -187,8 +153,8 @@ public double getCost(String name, PropertyValue value) {\n      *         index definition node was found\n      */\n     @Nullable\n-    private NodeState getIndexDefinitionNode(String name) {\n-        NodeState state = root.getChildNode(INDEX_DEFINITIONS_NAME);\n+    private static NodeState getIndexDefinitionNode(NodeState node, String name) {\n+        NodeState state = node.getChildNode(INDEX_DEFINITIONS_NAME);\n         if (state != null) {\n             for (ChildNodeEntry entry : state.getChildNodeEntries()) {\n                 PropertyState type = entry.getNodeState().getProperty(IndexConstants.TYPE_PROPERTY_NAME);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 27,
        "jira_id": "537",
        "nb_skipped": 1,
        "commit": "a8493efc",
        "nb_failure": 1,
        "linesRem": 53,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1275,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextTerm.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextTerm.java\nindex 78a672f840..cd974c27ae 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextTerm.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/FullTextTerm.java\n@@ -67,7 +67,7 @@ public FullTextTerm(String propertyName, String text, boolean not, boolean escap\n                 } else if (c == '_') {\n                     buff.append(\"\\\\_\");\n                     pattern = true;\n-                } else if (Character.isLetterOrDigit(c) || \" +-:&/\".indexOf(c) >= 0) {\n+                } else if (Character.isLetterOrDigit(c) || \" +-:&/.\".indexOf(c) >= 0) {\n                     buff.append(c);\n                 }\n             }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "1024",
        "nb_skipped": 8,
        "commit": "e39b4d96",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1505,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.mongomk.MongoNodeStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java\nindex ecd48c61a0..6fee0d657d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoNodeStore.java\n@@ -1135,8 +1135,15 @@ void backgroundRead() {\n             Revision r = e.getValue();\n             Revision last = lastKnownRevision.get(machineId);\n             if (last == null || r.compareRevisionTime(last) > 0) {\n-                lastKnownRevision.put(machineId, r);\n+                if (!hasNewRevisions) {\n+                    // publish our revision once before any foreign revision\n+\n+                    // the latest revisions of the current cluster node\n+                    // happened before the latest revisions of other cluster nodes\n+                    revisionComparator.add(Revision.newRevision(clusterId), headSeen);\n+                }\n                 hasNewRevisions = true;\n+                lastKnownRevision.put(machineId, r);\n                 revisionComparator.add(r, otherSeen);\n             }\n         }\n@@ -1144,11 +1151,6 @@ void backgroundRead() {\n             store.invalidateCache();\n             // TODO only invalidate affected items\n             docChildrenCache.invalidateAll();\n-            // add a new revision, so that changes are visible\n-            Revision r = Revision.newRevision(clusterId);\n-            // the latest revisions of the current cluster node\n-            // happened before the latest revisions of other cluster nodes\n-            revisionComparator.add(r, headSeen);\n             // the head revision is after other revisions\n             setHeadRevision(Revision.newRevision(clusterId));\n         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 5,
        "jira_id": "1254",
        "nb_skipped": 6,
        "commit": "25a70439",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1890,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.authorization.permission.PermissionEntryProviderImplTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntryProviderImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntryProviderImpl.java\nindex cce6a71406..d77fe973cc 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntryProviderImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntryProviderImpl.java\n@@ -28,10 +29,14 @@\n \n import com.google.common.base.Strings;\n import com.google.common.collect.Iterators;\n+import com.google.common.math.LongMath;\n+\n import org.apache.jackrabbit.commons.iterator.AbstractLazyIterator;\n import org.apache.jackrabbit.oak.api.Tree;\n import org.apache.jackrabbit.oak.spi.security.ConfigurationParameters;\n import org.apache.jackrabbit.oak.spi.security.authorization.accesscontrol.AccessControlConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n class PermissionEntryProviderImpl implements PermissionEntryProvider {\n \n@@ -39,18 +44,31 @@\n \n     private static final long DEFAULT_SIZE = 250;\n \n+    private static final Logger log = LoggerFactory.getLogger(PermissionEntryProviderImpl.class);\n+\n+    /**\n+     * The set of principal names for which this {@code PermissionEntryProvider}\n+     * has been created.\n+     */\n     private final Set<String> principalNames;\n \n+    /**\n+     * The set of principal names for which the store contains any permission\n+     * entries. This set is equals or just a subset of the {@code principalNames}\n+     * defined above. The methods collecting the entries will shortcut in case\n+     * this set is empty and thus no permission entries exist for the specified\n+     * set of principal.\n+     */\n     private final Set<String> existingNames = new HashSet<String>();\n \n-    private Map<String, Collection<PermissionEntry>> pathEntryMap;\n-\n     private final PermissionStore store;\n \n     private final PermissionEntryCache cache;\n \n     private final long maxSize;\n \n+    private Map<String, Collection<PermissionEntry>> pathEntryMap;\n+\n     PermissionEntryProviderImpl(@Nonnull PermissionStore store, @Nonnull PermissionEntryCache cache,\n                                 @Nonnull Set<String> principalNames, @Nonnull ConfigurationParameters options) {\n         this.store = store;\n@@ -65,15 +83,40 @@ private void init() {\n         existingNames.clear();\n         for (String name : principalNames) {\n             long n = cache.getNumEntries(store, name, maxSize);\n-            cnt+= n;\n+            /*\n+            if cache.getNumEntries (n) returns a number bigger than 0, we\n+            remember this principal name int the 'existingNames' set\n+            */\n             if (n > 0) {\n                 existingNames.add(name);\n             }\n+            /*\n+            Calculate the total number of permission entries (cnt) defined for the\n+            given set of principals in order to be able to determine if the cache\n+            should be loaded upfront.\n+            Note however that cache.getNumEntries (n) may return Long.MAX_VALUE\n+            if the underlying implementation does not know the exact value, and\n+            the child node count is higher than maxSize (see OAK-2465).\n+            */                        \n+            if (cnt < Long.MAX_VALUE) {\n+                if (Long.MAX_VALUE == n) {\n+                    cnt = Long.MAX_VALUE;\n+                } else {\n+                    try {\n+                        cnt = LongMath.checkedAdd(cnt, n);\n+                    } catch (ArithmeticException ae) {\n+                        log.warn(\"Long overflow while calculate the total number of permission entries\");\n+                        cnt = Long.MAX_VALUE;\n+                    }\n                 }\n-        if (cnt < maxSize) {\n-            // cache all entries of all principals\n+            }\n+        }\n+\n+        if (cnt > 0 && cnt < maxSize) {\n+            // the total number of entries is smaller that maxSize, so we can\n+            // cache all entries for all principals having any entries right away\n             pathEntryMap = new HashMap<String, Collection<PermissionEntry>>();\n-            for (String name: principalNames) {\n+            for (String name : existingNames) {\n                 cache.load(store, pathEntryMap, name);\n             }\n         } else {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 31,
        "jira_id": "2465",
        "nb_skipped": 9,
        "commit": "60186813",
        "nb_failure": 3,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 5,
        "nb_test": 1562,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AstElement.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AstElement.java\nindex 40786b4470..963865d278 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AstElement.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AstElement.java\n@@ -52,9 +52,10 @@ public void setQuery(QueryImpl query) {\n     \n     /**\n      * Normalize the property name (including namespace remapping).\n+     * Asterisks are kept.\n      *\n      * @param propertyName the property name to normalize\n-     * @return the normalized property name\n+     * @return the normalized (oak-) property name\n      */\n     protected String normalizePropertyName(String propertyName) {\n         // TODO normalize the path (remove superfluous \"..\" and \".\" \n@@ -71,7 +72,23 @@ protected String normalizePropertyName(String propertyName) {\n         }\n         // relative properties\n         String relativePath = PathUtils.getParentPath(propertyName);\n+        if (relativePath.indexOf('*') >= 0) {\n+            StringBuilder buff = new StringBuilder();\n+            for (String p : PathUtils.elements(relativePath)) {\n+                if (!p.equals(\"*\")) {\n+                    p = query.getOakPath(p);\n+                }\n+                if (p.length() > 0) {\n+                    if (buff.length() > 0) {\n+                        buff.append('/');\n+                    }\n+                    buff.append(p);\n+                }\n+            }\n+            relativePath = buff.toString();\n+        } else {\n             relativePath = query.getOakPath(relativePath);\n+        }\n         propertyName = PathUtils.getName(propertyName);\n         propertyName = normalizeNonRelativePropertyName(propertyName);\n         return PathUtils.concat(relativePath, propertyName);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/PropertyValueImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/PropertyValueImpl.java\nindex f1eb90711e..88d56100df 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/PropertyValueImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/PropertyValueImpl.java\n@@ -18,7 +18,6 @@\n  */\n package org.apache.jackrabbit.oak.query.ast;\n \n-import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Locale;\n@@ -26,17 +25,10 @@\n \n import javax.jcr.PropertyType;\n \n-import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.PropertyValue;\n-import org.apache.jackrabbit.oak.api.Tree;\n-import org.apache.jackrabbit.oak.api.Type;\n-import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.query.QueryImpl;\n import org.apache.jackrabbit.oak.query.SQL2Parser;\n import org.apache.jackrabbit.oak.query.index.FilterImpl;\n-import org.apache.jackrabbit.oak.spi.query.PropertyValues;\n-\n-import com.google.common.collect.Iterables;\n \n /**\n  * A property expression.\n@@ -107,58 +99,13 @@ public PropertyExistenceImpl getPropertyExistence() {\n \n     @Override\n     public PropertyValue currentProperty() {\n-        boolean asterisk = PathUtils.getName(propertyName).equals(\"*\");\n-        if (!asterisk) {\n-            PropertyValue p = selector.currentProperty(propertyName);\n-            return matchesPropertyType(p) ? p : null;\n-        }\n-        Tree tree = selector.currentTree();\n-        if (tree == null || !tree.exists()) {\n-            return null;\n-        }\n-        if (!asterisk) {\n-            String name = PathUtils.getName(propertyName);\n-            name = normalizePropertyName(name);\n-            PropertyState p = tree.getProperty(name);\n-            if (p == null) {\n-                return null;\n-            }\n-            return matchesPropertyType(p) ? PropertyValues.create(p) : null;\n-        }\n-        // asterisk - create a multi-value property\n-        // warning: the returned property state may have a mixed type\n-        // (not all values may have the same type)\n-\n-        // TODO currently all property values are converted to strings - \n-        // this doesn't play well with the idea that the types may be different\n-        List<String> values = new ArrayList<String>();\n-        for (PropertyState p : tree.getProperties()) {\n-            if (matchesPropertyType(p)) {\n-                Iterables.addAll(values, p.getValue(Type.STRINGS));\n-            }\n-        }\n-        // \"*\"\n-        return PropertyValues.newString(values);\n-    }\n-\n-    private boolean matchesPropertyType(PropertyValue value) {\n-        if (value == null) {\n-            return false;\n-        }\n-        if (propertyType == PropertyType.UNDEFINED) {\n-            return true;\n-        }\n-        return value.getType().tag() == propertyType;\n-    }\n-\n-    private boolean matchesPropertyType(PropertyState state) {\n-        if (state == null) {\n-            return false;\n-        }\n+        PropertyValue p;\n         if (propertyType == PropertyType.UNDEFINED) {\n-            return true;\n+            p = selector.currentProperty(propertyName);\n+        } else {\n+            p = selector.currentProperty(propertyName, propertyType);\n         }\n-        return state.getType().tag() == propertyType;\n+        return p;        \n     }\n \n     public void bindSelector(SourceImpl source) {\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\nindex 4d99f0f201..a9c22fd9e3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java\n@@ -40,6 +40,7 @@\n import org.apache.jackrabbit.oak.api.PropertyState;\n import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.api.Tree;\n+import org.apache.jackrabbit.oak.api.Type;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.query.QueryImpl;\n import org.apache.jackrabbit.oak.query.fulltext.FullTextExpression;\n@@ -53,6 +54,7 @@\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n \n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n \n /**\n  * A selector within a query.\n@@ -385,6 +387,19 @@ public PropertyValue currentProperty(String propertyName) {\n         return currentOakProperty(pn);\n     }\n \n+    /**\n+     * The value for the given selector for the current node, filtered by\n+     * property type.\n+     * \n+     * @param propertyName the JCR (not normalized) property name\n+     * @param propertyType only include properties of this type\n+     * @return the property value (possibly null)\n+     */\n+    public PropertyValue currentProperty(String propertyName, int propertyType) {\n+        String pn = normalizePropertyName(propertyName);\n+        return currentOakProperty(pn, propertyType);\n+    }\n+\n     /**\n      * Get the property value. The property name may be relative. The special\n      * property names \"jcr:path\", \"jcr:score\" and \"rep:excerpt\" are supported.\n@@ -393,6 +408,24 @@ public PropertyValue currentProperty(String propertyName) {\n      * @return the property value or null if not found\n      */\n     public PropertyValue currentOakProperty(String oakPropertyName) {\n+        return currentOakProperty(oakPropertyName, null);\n+    }\n+\n+    private PropertyValue currentOakProperty(String oakPropertyName, Integer propertyType) {\n+        boolean asterisk = oakPropertyName.indexOf('*') >= 0;\n+        if (asterisk) {\n+            Tree t = currentTree();\n+            ArrayList<PropertyValue> list = new ArrayList<PropertyValue>();\n+            readOakProperties(list, t, oakPropertyName, propertyType);\n+            if (list.size() == 0) {\n+                return null;\n+            }\n+            ArrayList<String> strings = new ArrayList<String>();\n+            for (PropertyValue p : list) {\n+                Iterables.addAll(strings, p.getValue(Type.STRINGS));\n+            }\n+            return PropertyValues.newString(strings);                    \n+        }\n         boolean relative = oakPropertyName.indexOf('/') >= 0;\n         Tree t = currentTree();\n         if (relative) {\n@@ -410,6 +443,11 @@ public PropertyValue currentOakProperty(String oakPropertyName) {\n             }\n             oakPropertyName = PathUtils.getName(oakPropertyName);\n         }\n+        return currentOakProperty(t, oakPropertyName, propertyType);\n+    }\n+    \n+    private PropertyValue currentOakProperty(Tree t, String oakPropertyName, Integer propertyType) {\n+        PropertyValue result;\n         if (t == null || !t.exists()) {\n             return null;\n         }\n@@ -420,13 +458,59 @@ public PropertyValue currentOakProperty(String oakPropertyName) {\n                 // not a local path\n                 return null;\n             }\n-            return PropertyValues.newString(local);\n+            result = PropertyValues.newString(local);\n         } else if (oakPropertyName.equals(QueryImpl.JCR_SCORE)) {\n-            return currentRow.getValue(QueryImpl.JCR_SCORE);\n+            result = currentRow.getValue(QueryImpl.JCR_SCORE);\n         } else if (oakPropertyName.equals(QueryImpl.REP_EXCERPT)) {\n-            return currentRow.getValue(QueryImpl.REP_EXCERPT);\n+            result = currentRow.getValue(QueryImpl.REP_EXCERPT);\n+        } else {\n+            result = PropertyValues.create(t.getProperty(oakPropertyName));\n+        }\n+        if (result == null) {\n+            return null;\n+        }\n+        if (propertyType != null && result.getType().tag() != propertyType) {\n+            return null;\n+        }\n+        return result;\n+    }\n+    \n+    private void readOakProperties(ArrayList<PropertyValue> target, Tree t, String oakPropertyName, Integer propertyType) {\n+        while (true) {\n+            if (t == null || !t.exists()) {\n+                return;\n+            }\n+            int slash = oakPropertyName.indexOf('/');\n+            if (slash < 0) {\n+                break;\n+            }\n+            String parent = oakPropertyName.substring(0, slash);\n+            oakPropertyName = oakPropertyName.substring(slash + 1);\n+            if (parent.equals(\"..\")) {\n+                t = t.isRoot() ? null : t.getParent();\n+            } else if (parent.equals(\".\")) {\n+                // same node\n+            } else if (parent.equals(\"*\")) {\n+                for (Tree child : t.getChildren()) {\n+                    readOakProperties(target, child, oakPropertyName, propertyType);\n+                }\n+            } else {\n+                t = t.getChild(parent);\n+            }\n+        }\n+        if (!\"*\".equals(oakPropertyName)) {\n+            PropertyValue value = currentOakProperty(t, oakPropertyName, propertyType);\n+            if (value != null) {\n+                target.add(value);\n+            }\n+            return;\n+        }\n+          for (PropertyState p : t.getProperties()) {\n+              if (propertyType == null || p.getType().tag() == propertyType) {\n+                  PropertyValue v = PropertyValues.create(p);\n+                  target.add(v);\n+              }\n           }\n-        return PropertyValues.create(t.getProperty(oakPropertyName));\n     }\n \n     @Override\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\nindex 7b95deced0..a545ba88ef 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java\n@@ -176,7 +176,9 @@ public SelectorImpl getExistingSelector(String selectorName) {\n      * \n      * this creates a filter for the given query\n      * \n+     * @param preparing whether this this the prepare phase\n+     * @return a new filter\n      */\n-    abstract public Filter createFilter(boolean preparing);\n+    public abstract Filter createFilter(boolean preparing);\n \n }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/SimpleExcerptProvider.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/SimpleExcerptProvider.java\nindex aa56db06bd..e6ed3a9267 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/SimpleExcerptProvider.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/fulltext/SimpleExcerptProvider.java\n@@ -35,6 +35,9 @@\n \n import com.google.common.collect.ImmutableSet;\n \n+/**\n+ * This class can extract excerpts from node.\n+ */\n public class SimpleExcerptProvider {\n \n     private static final String REP_EXCERPT_FN = \"rep:excerpt(.)\";\n",
        "project": "jackrabbit-oak",
        "linesAdd": 101,
        "jira_id": "1215",
        "nb_skipped": 6,
        "commit": "a9efe3c4",
        "nb_failure": 0,
        "linesRem": 57,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 52,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.commons.json.JsopTest",
            "org.apache.jackrabbit.oak.commons.json.JsopStreamTest"
        ],
        "patch": "diff --git a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\nindex b42beffe75..a9a8b9a777 100644\n--- a/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\n+++ b/oak-commons/src/main/java/org/apache/jackrabbit/oak/commons/json/JsopBuilder.java\n@@ -254,7 +254,7 @@ public static String encode(String s) {\n         }\n         for (int i = 0; i < length; i++) {\n             char c = s.charAt(i);\n-            if (c == '\\\"' || c == '\\\\' || c < ' ' || c >= 127) {\n+            if (c == '\\\"' || c == '\\\\' || c < ' ') {\n                 StringBuilder buff = new StringBuilder(length + 2 + length / 8);\n                 buff.append('\\\"');\n                 escape(s, length, buff);\n@@ -265,6 +265,16 @@ public static String encode(String s) {\n         return buff.append('\\\"').append(s).append('\\\"').toString();\n     }\n \n+    /**\n+     * Escape a string into the target buffer.\n+     *\n+     * @param s      the string to escape\n+     * @param buff   the target buffer\n+     */\n+    public static void escape(String s, StringBuilder buff) {\n+        escape(s, s.length(), buff);\n+    }\n+\n     /**\n      * Escape a string into the target buffer.\n      *\n@@ -272,10 +282,7 @@ public static String encode(String s) {\n      * @param length the number of characters.\n      * @param buff   the target buffer\n      */\n-    public static void escape(String s, int length, StringBuilder buff) {\n-        // TODO only backslashes, double quotes, and characters < 32 need to be\n-        // escaped - but currently all special characters are escaped, which\n-        // needs more time, memory, and storage space\n+    private static void escape(String s, int length, StringBuilder buff) {\n         for (int i = 0; i < length; i++) {\n             char c = s.charAt(i);\n             switch (c) {\n@@ -309,21 +316,10 @@ public static void escape(String s, int length, StringBuilder buff) {\n                 break;\n             default:\n                 if (c < ' ') {\n-                    // guaranteed to be 1 or 2 hex digits only\n                     buff.append(\"\\\\u00\");\n-                    String hex = Integer.toHexString(c);\n-                    if (hex.length() == 1) {\n-                        buff.append('0');\n-                    }\n-                    buff.append(hex);\n-                } else if (c >= 127) {\n-                    // ascii only mode\n-                    buff.append(\"\\\\u\");\n-                    String hex = Integer.toHexString(c);\n-                    for (int len = hex.length(); len < 4; len++) {\n-                        buff.append('0');\n-                    }\n-                    buff.append(hex);\n+                    // guaranteed to be 1 or 2 hex digits only\n+                    buff.append(Character.forDigit(c >>> 4, 16));\n+                    buff.append(Character.forDigit(c & 15, 16));\n                 } else {\n                     buff.append(c);\n                 }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 8,
        "jira_id": "2389",
        "nb_skipped": 0,
        "commit": "7c320b1e",
        "nb_failure": 3,
        "linesRem": 14,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1422,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.authorization.evaluation.VersionStorageTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/CompiledPermissionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/CompiledPermissionImpl.java\nindex dc1b9c2c9e..c9d0fa0f2b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/CompiledPermissionImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/CompiledPermissionImpl.java\n@@ -157,7 +157,10 @@ public TreePermission getTreePermission(@Nonnull ImmutableTree tree, @Nonnull Tr\n                 // TODO: OAK-753 decide on where to filter out hidden items.\n                 return TreePermission.ALL;\n             case TreeTypeProvider.TYPE_VERSION:\n-                String ntName = checkNotNull(TreeUtil.getPrimaryTypeName(tree));\n+                String ntName = TreeUtil.getPrimaryTypeName(tree);\n+                if (ntName == null) {\n+                    return TreePermission.EMPTY;\n+                }\n                 if (VersionConstants.VERSION_STORE_NT_NAMES.contains(ntName) || VersionConstants.NT_ACTIVITY.equals(ntName)) {\n                     return new TreePermissionImpl(tree, TreeTypeProvider.TYPE_VERSION, parentPermission);\n                 } else {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 4,
        "jira_id": "1173",
        "nb_skipped": 6,
        "commit": "61c877d8",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1900,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.segment.file.FileStoreTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\nindex 84ac11a4bb..62811a07a3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java\n@@ -46,6 +46,7 @@\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashSet;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n@@ -191,6 +192,8 @@ public synchronized void flush() {\n                     refcount * 16 + rootcount * 3 + blobrefcount * 2 + length,\n                     16);\n \n+            checkState(length <= buffer.length);\n+\n             int pos = refcount * 16;\n             if (pos + length <= buffer.length) {\n                 // the whole segment fits to the space *after* the referenced\n@@ -291,14 +294,23 @@ private RecordId prepare(\n             refcount -= idcount;\n \n             Set<SegmentId> segmentIds = newIdentityHashSet();\n+            \n+            // The set of old record ids in this segment\n+            // that were previously root record ids, but will no longer be,\n+            // because the record to be written references them.\n+            // This needs to be a set, because the list of ids can\n+            // potentially reference the same record multiple times\n+            Set<RecordId> notRoots = new HashSet<RecordId>();\n             for (RecordId recordId : ids) {\n                 SegmentId segmentId = recordId.getSegmentId();\n                 if (segmentId != segment.getSegmentId()) {\n                     segmentIds.add(segmentId);\n                 } else if (roots.containsKey(recordId)) {\n-                    rootcount--;\n+                    notRoots.add(recordId);\n                 }\n             }\n+            rootcount -= notRoots.size();\n+\n             if (!segmentIds.isEmpty()) {\n                 for (int refid = 1; refid < refcount; refid++) {\n                     segmentIds.remove(segment.getRefId(refid));\n",
        "project": "jackrabbit-oak",
        "linesAdd": 8,
        "jira_id": "2049",
        "nb_skipped": 9,
        "commit": "4af0d4ee",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 100,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.mk.MicroKernelImplTest"
        ],
        "patch": "diff --git a/oak-mk/src/main/java/org/apache/jackrabbit/mk/core/MicroKernelImpl.java b/oak-mk/src/main/java/org/apache/jackrabbit/mk/core/MicroKernelImpl.java\nindex 35126ae551..05b6309ab6 100644\n--- a/oak-mk/src/main/java/org/apache/jackrabbit/mk/core/MicroKernelImpl.java\n+++ b/oak-mk/src/main/java/org/apache/jackrabbit/mk/core/MicroKernelImpl.java\n@@ -411,7 +411,7 @@ public String commit(String path, String jsonDiff, String revisionId, String mes\n             throw new IllegalArgumentException(\"absolute path expected: \" + path);\n         }\n         if (jsonDiff == null || jsonDiff.length() == 0) {\n-            return getHeadRevision();\n+            return revisionId != null ? revisionId : getHeadRevision();\n         }\n \n         Id revId = revisionId == null ? getHeadRevisionId() : Id.fromString(revisionId);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 1,
        "jira_id": "1122",
        "nb_skipped": 3,
        "commit": "5286861d",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1809,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.strategy.OrderedContentMirrorStorageStrategyTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\nindex 3f78b784b5..abb7e5a690 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n@@ -23,6 +23,7 @@\n import java.util.Collections;\n import java.util.Deque;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.NoSuchElementException;\n import java.util.Random;\n \n@@ -47,6 +48,7 @@\n import com.google.common.base.Strings;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n \n /**\n  * Same as for {@link ContentMirrorStoreStrategy} but the order of the keys is kept by using the\n@@ -149,6 +151,7 @@ NodeBuilder fetchKeyNode(@Nonnull NodeBuilder index, @Nonnull String key) {\n                                         \n     @Override\n     void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final String key) {\n+        LOG.debug(\"prune() - deleting: {}\", key);\n         for (NodeBuilder node : builders) {\n             if (node.hasProperty(\"match\") || node.getChildNodeCount(1) > 0) {\n                 return;\n@@ -166,11 +169,25 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n                             walkedLanes\n                             );\n                         lane0Next = getPropertyNext(walkedLanes[0]);\n+                        if (LOG.isDebugEnabled()) {\n+                            for (int i = 0; i < walkedLanes.length; i++) {\n+                                LOG.debug(\"prune() - walkedLanes[{}]: {}\", i,\n+                                    walkedLanes[i].getName());\n+                            }\n+                        }\n                         for (int lane = walkedLanes.length - 1; lane >= 0; lane--) {\n                             prevNext = getPropertyNext(walkedLanes[lane], lane);\n                             if (key.equals(prevNext)) {\n                                 // if it's actually pointing to us let's deal with it\n                                 currNext = getPropertyNext(node, lane);\n+                                if (LOG.isDebugEnabled()) {\n+                                    LOG.debug(\n+                                        \"prune() - setting next for '{}' on lane '{}' with '{}'\",\n+                                        new Object[] {\n+                                        walkedLanes[lane].getName(),\n+                                        lane,\n+                                        currNext});\n+                                }\n                                 setPropertyNext(index.getChildNode(walkedLanes[lane].getName()),\n                                     currNext, lane);\n                             }\n@@ -997,7 +1014,23 @@ static void setPropertyNext(@Nonnull final NodeBuilder node,\n         if (node != null && value != null && lane >= 0 && lane < OrderedIndex.LANES) {\n             PropertyState next = node.getProperty(NEXT);\n             if (next != null) {\n-                String[] values = Iterables.toArray(next.getValue(Type.STRINGS), String.class);\n+                String[] values;\n+                if (next.isArray()) {\n+                    values = Iterables.toArray(next.getValue(Type.STRINGS), String.class);\n+                    if (values.length < OrderedIndex.LANES) {\n+                        // it could be we increased the number of lanes and running on some existing\n+                        // content\n+                        LOG.debug(\"topping-up the number of lanes.\");\n+                        List<String> vv = Lists.newArrayList(values);\n+                        for (int i = vv.size(); i <= OrderedIndex.LANES; i++) {\n+                            vv.add(\"\");\n+                        }\n+                        values = vv.toArray(new String[0]);\n+                    }\n+                } else {\n+                    values = Iterables.toArray(EMPTY_NEXT, String.class);\n+                    values[0] = next.getValue(Type.STRING);\n+                }\n                 values[lane] = value;\n                 setPropertyNext(node, values);\n             }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 32,
        "jira_id": "1899",
        "nb_skipped": 9,
        "commit": "df59fb45",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 1963,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest",
            "org.apache.jackrabbit.oak.plugins.index.property.OrderedIndexQueryTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\nindex f9220078de..f93ed0ee2f 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/FullTextSearchImpl.java\n@@ -251,8 +251,12 @@ public void bindSelector(SourceImpl source) {\n     public void restrict(FilterImpl f) {\n         if (propertyName != null) {\n             if (f.getSelector().equals(selector)) {\n-                String pn = normalizePropertyName(propertyName);\n-                f.restrictProperty(pn, Operator.NOT_EQUAL, null);\n+                String p = propertyName;\n+                if (relativePath != null) {\n+                    p = PathUtils.concat(p, relativePath);\n+                }                \n+                p = normalizePropertyName(p);\n+                f.restrictProperty(p, Operator.NOT_EQUAL, null);\n             }\n         }\n         f.restrictFulltextCondition(fullTextSearchExpression.currentValue().getValue(Type.STRING));\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\nindex 6113c0cc09..9763c13173 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java\n@@ -83,9 +83,7 @@ public Statement optimize() {\n     }\n     \n     private static void addToUnionList(Expression condition,  ArrayList<Expression> unionList) {\n-        if (condition.containsFullTextCondition()) {\n-            // do not use union\n-        } else if (condition instanceof OrCondition) {\n+        if (condition instanceof OrCondition) {\n             OrCondition or = (OrCondition) condition;\n             // conditions of type                \n             // @x = 1 or @y = 2\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java\nindex 74060a1f40..10a459e389 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java\n@@ -439,8 +439,13 @@ private void markSeen(String path) {\n         ConcatCursor(List<Cursor> cursors, QueryEngineSettings settings) {\n             this.cursors = cursors;\n             this.settings = settings;\n+            if (cursors.size() == 0) {\n+                init = true;\n+                closed = true;\n+            } else {\n                 this.currentCursor = cursors.remove(0);\n             }\n+        }\n \n         @Override\n         public IndexRow next() {\n",
        "project": "jackrabbit-oak",
        "linesAdd": 12,
        "jira_id": "2249",
        "nb_skipped": 9,
        "commit": "6dde8e9d",
        "nb_failure": 0,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2033,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.kernel.CheckpointTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex 4efc6cb132..5c519c2e69 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -39,6 +39,7 @@\n import java.util.Map;\n import java.util.NavigableSet;\n import java.util.Set;\n+import java.util.SortedMap;\n import java.util.TimeZone;\n import java.util.concurrent.Callable;\n import java.util.concurrent.ConcurrentHashMap;\n@@ -70,6 +71,7 @@\n import org.apache.jackrabbit.oak.commons.json.JsopTokenizer;\n import org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob;\n import org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector;\n+import org.apache.jackrabbit.oak.plugins.document.Checkpoints.Info;\n import org.apache.jackrabbit.oak.plugins.document.mongo.MongoBlobReferenceIterator;\n import org.apache.jackrabbit.oak.plugins.document.mongo.MongoDocumentStore;\n import org.apache.jackrabbit.oak.plugins.document.persistentCache.PersistentCache;\n@@ -1404,7 +1406,8 @@ public String checkpoint(long lifetime) {\n     @Override\n     public NodeState retrieve(@Nonnull String checkpoint) {\n         Revision r = Revision.fromString(checkpoint);\n-        if (checkpoints.getCheckpoints().containsKey(r)) {\n+        SortedMap<Revision, Info> checkpoints = this.checkpoints.getCheckpoints();\n+        if (checkpoints != null && checkpoints.containsKey(r)) {\n             return getRoot(r);\n         } else {\n             return null;\n",
        "project": "jackrabbit-oak",
        "linesAdd": 4,
        "jira_id": "2363",
        "nb_skipped": 9,
        "commit": "90ea7aa5",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1260,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.plugins.segment.MapRecordTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/MapEntry.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/MapEntry.java\nindex ad93d4ba11..93f798db04 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/MapEntry.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/MapEntry.java\n@@ -18,6 +18,7 @@\n \n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.base.Preconditions.checkState;\n+import static org.apache.jackrabbit.oak.plugins.segment.MapRecord.HASH_MASK;\n \n import java.util.Map;\n \n@@ -87,7 +88,7 @@ public RecordId setValue(RecordId value) {\n     @Override\n     public int compareTo(MapEntry that) {\n         return ComparisonChain.start()\n-                .compare(getHash(), that.getHash())\n+                .compare(getHash() & HASH_MASK, that.getHash() & HASH_MASK)\n                 .compare(name, that.name)\n                 .compare(value, that.value)\n                 .result();\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/MapRecord.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/MapRecord.java\nindex 9e0c76e6e0..e39b928f50 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/MapRecord.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/MapRecord.java\n@@ -37,6 +37,7 @@\n \n     private static final long M = 0x5DEECE66DL;\n     private static final long A = 0xBL;\n+    static final long HASH_MASK = 0xFFFFFFFFL;\n \n     static int getHash(String name) {\n         return (int) (((name.hashCode() ^ M) * M + A) >> 16);\n@@ -153,7 +154,7 @@ MapEntry getEntry(String key) {\n             int bitmap = segment.readInt(getOffset(4));\n             int mask = BUCKETS_PER_LEVEL - 1;\n             int shift = 32 - (level + 1) * LEVEL_BITS;\n-            int index = (hash >> shift) & mask;\n+            int index = (int) (hash >> shift) & mask;\n             int bit = 1 << index;\n             if ((bitmap & bit) != 0) {\n                 int ids = bitCount(bitmap & (bit - 1));\n@@ -167,8 +168,8 @@ MapEntry getEntry(String key) {\n         // this is a leaf record; scan the list to find a matching entry\n         int d = -1;\n         for (int i = 0; i < size && d < 0; i++) {\n-            d = Integer.valueOf(segment.readInt(getOffset(4 + i * 4)))\n-                    .compareTo(Integer.valueOf(hash));\n+            d = Long.valueOf(segment.readInt(getOffset(4 + i * 4)) & HASH_MASK)\n+                    .compareTo(Long.valueOf(hash & HASH_MASK));\n             if (d == 0) {\n                 RecordId keyId = segment.readRecordId(\n                         getOffset(4 + size * 4, i));\n@@ -379,7 +380,7 @@ private static int compare(MapEntry before, MapEntry after) {\n             return -1;  // see above\n         } else {\n             return ComparisonChain.start()\n-                    .compare(before.getHash(), after.getHash())\n+                    .compare(before.getHash() & HASH_MASK, after.getHash() & HASH_MASK)\n                     .compare(before.getName(), after.getName())\n                     .result();\n         }\n",
        "project": "jackrabbit-oak",
        "linesAdd": 7,
        "jira_id": "1104",
        "nb_skipped": 5,
        "commit": "7ae92779",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 2196,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.jackrabbit.oak.security.authorization.accesscontrol.AccessControlValidatorTest",
            "org.apache.jackrabbit.oak.security.user.UserValidatorTest"
        ],
        "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/AccessControlValidator.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/AccessControlValidator.java\nindex 3aa11f985b..0721f2bc11 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/AccessControlValidator.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/accesscontrol/AccessControlValidator.java\n@@ -42,6 +42,7 @@\n import org.apache.jackrabbit.oak.plugins.tree.impl.TreeConstants;\n import org.apache.jackrabbit.oak.spi.commit.DefaultValidator;\n import org.apache.jackrabbit.oak.spi.commit.Validator;\n+import org.apache.jackrabbit.oak.spi.commit.VisibleValidator;\n import org.apache.jackrabbit.oak.spi.security.authorization.accesscontrol.AccessControlConstants;\n import org.apache.jackrabbit.oak.spi.security.authorization.restriction.Restriction;\n import org.apache.jackrabbit.oak.spi.security.authorization.restriction.RestrictionProvider;\n@@ -122,7 +123,7 @@ public Validator childNodeAdded(String name, NodeState after) throws CommitFaile\n         Tree treeAfter = checkNotNull(parentAfter.getChild(name));\n \n         checkValidTree(parentAfter, treeAfter, after);\n-        return new AccessControlValidator(this, treeAfter);\n+        return newValidator(this, treeAfter);\n     }\n \n     @Override\n@@ -130,7 +131,7 @@ public Validator childNodeChanged(String name, NodeState before, NodeState after\n         Tree treeAfter = checkNotNull(parentAfter.getChild(name));\n \n         checkValidTree(parentAfter, treeAfter, after);\n-        return new AccessControlValidator(this, treeAfter);\n+        return newValidator(this, treeAfter);\n     }\n \n     @Override\n@@ -141,6 +142,14 @@ public Validator childNodeDeleted(String name, NodeState before) throws CommitFa\n \n     //------------------------------------------------------------< private >---\n \n+    private static Validator newValidator(AccessControlValidator parent,\n+                                          Tree parentAfter) {\n+        return new VisibleValidator(\n+                new AccessControlValidator(parent, parentAfter),\n+                true,\n+                true);\n+    }\n+\n     private void checkValidTree(Tree parentAfter, Tree treeAfter, NodeState nodeAfter) throws CommitFailedException {\n         if (isPolicy(treeAfter)) {\n             checkValidPolicy(parentAfter, treeAfter, nodeAfter);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserValidator.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserValidator.java\nindex 975f5ebc9b..7d6a2e989d 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserValidator.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserValidator.java\n@@ -139,12 +139,13 @@ public Validator childNodeAdded(String name, NodeState after) throws CommitFaile\n         Tree tree = checkNotNull(parentAfter.getChild(name));\n \n         validateAuthorizable(tree, UserUtil.getType(tree));\n-        return new VisibleValidator(new UserValidator(null, tree, provider), true, true);\n+        return newValidator(null, tree, provider);\n     }\n \n     @Override\n     public Validator childNodeChanged(String name, NodeState before, NodeState after) throws CommitFailedException {\n-        return new UserValidator(parentBefore.getChild(name), parentAfter.getChild(name), provider);\n+        return newValidator(parentBefore.getChild(name),\n+                parentAfter.getChild(name), provider);\n     }\n \n     @Override\n@@ -158,12 +159,21 @@ public Validator childNodeDeleted(String name, NodeState before) throws CommitFa\n             }\n             return null;\n         } else {\n-            return new VisibleValidator(new UserValidator(tree, null, provider), true, true);\n+            return newValidator(tree, null, provider);\n         }\n     }\n \n     //------------------------------------------------------------< private >---\n \n+    private static Validator newValidator(Tree parentBefore,\n+                                          Tree parentAfter,\n+                                          UserValidatorProvider provider) {\n+        return new VisibleValidator(\n+                new UserValidator(parentBefore, parentAfter, provider),\n+                true,\n+                true);\n+    }\n+\n     private boolean isAdminUser(@Nonnull Tree userTree) {\n         if (userTree.exists() && isUser(userTree)) {\n             String id = UserUtil.getAuthorizableId(userTree);\n",
        "project": "jackrabbit-oak",
        "linesAdd": 24,
        "jira_id": "3021",
        "nb_skipped": 9,
        "commit": "494da6de",
        "nb_failure": 4,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 525,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.web.Log4jServletContainerInitializerTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\nindex 7d3ce0540..84dbdb38a 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\n@@ -41,7 +41,7 @@ public void onStartup(final Set<Class<?>> classes, final ServletContext servletC\n             servletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\");\n \n             final FilterRegistration.Dynamic filter =\n-                    servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\n+                    servletContext.addFilter(\"log4jServletFilter\", Log4jServletFilter.class);\n             if (filter == null) {\n                 servletContext.log(\"WARNING: In a Servlet 3.0+ application, you should not define a \" +\n                         \"log4jServletFilter in web.xml. Log4j 2 normally does this for you automatically. Log4j 2 \" +\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "344",
        "nb_skipped": 1,
        "commit": "8dead3bb",
        "nb_failure": 6,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 537,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.appender.rolling.PatternProcessorTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessor.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessor.java\nindex 5a10f1a98..82fc0ca25 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessor.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessor.java\n@@ -102,6 +102,7 @@ public long getNextTime(final long current, final int increment, final boolean m\n             nextFileTime = cal.getTimeInMillis();\n             return nextTime;\n         }\n+        cal.set(Calendar.MONTH, currentCal.get(Calendar.MONTH));\n         if (frequency == RolloverFrequency.MONTHLY) {\n             increment(cal, Calendar.MONTH, increment, modulus);\n             nextTime = cal.getTimeInMillis();\n@@ -110,7 +111,9 @@ public long getNextTime(final long current, final int increment, final boolean m\n             return nextTime;\n         }\n         if (frequency == RolloverFrequency.WEEKLY) {\n+            cal.set(Calendar.WEEK_OF_YEAR, currentCal.get(Calendar.WEEK_OF_YEAR));\n             increment(cal, Calendar.WEEK_OF_YEAR, increment, modulus);\n+            cal.set(Calendar.DAY_OF_WEEK, currentCal.getFirstDayOfWeek());\n             nextTime = cal.getTimeInMillis();\n             cal.add(Calendar.WEEK_OF_YEAR, -1);\n             nextFileTime = cal.getTimeInMillis();\n@@ -124,11 +127,11 @@ public long getNextTime(final long current, final int increment, final boolean m\n             nextFileTime = cal.getTimeInMillis();\n             return nextTime;\n         }\n-        cal.set(Calendar.HOUR, currentCal.get(Calendar.HOUR));\n+        cal.set(Calendar.HOUR_OF_DAY, currentCal.get(Calendar.HOUR_OF_DAY));\n         if (frequency == RolloverFrequency.HOURLY) {\n-            increment(cal, Calendar.HOUR, increment, modulus);\n+            increment(cal, Calendar.HOUR_OF_DAY, increment, modulus);\n             nextTime = cal.getTimeInMillis();\n-            cal.add(Calendar.HOUR, -1);\n+            cal.add(Calendar.HOUR_OF_DAY, -1);\n             nextFileTime = cal.getTimeInMillis();\n             return nextTime;\n         }\n@@ -148,6 +151,7 @@ public long getNextTime(final long current, final int increment, final boolean m\n             nextFileTime = cal.getTimeInMillis();\n             return nextTime;\n         }\n+        cal.set(Calendar.MILLISECOND, currentCal.get(Calendar.MILLISECOND));\n         increment(cal, Calendar.MILLISECOND, increment, modulus);\n         nextTime = cal.getTimeInMillis();\n         cal.add(Calendar.MILLISECOND, -1);\n",
        "project": "logging-log4j2",
        "linesAdd": 7,
        "jira_id": "385",
        "nb_skipped": 1,
        "commit": "7c2ce5cf",
        "nb_failure": 8,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 919,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.config.properties.PropertiesConfigurationRootLoggerOnlyTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationFactory.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationFactory.java\nindex 50f928585..27644d8e5 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationFactory.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationFactory.java\n@@ -130,7 +130,7 @@ public PropertiesConfiguration getConfiguration(ConfigurationSource source) {\n             }\n         }\n         String loggerProp = properties.getProperty(\"loggers\");\n-        if (appenderProp != null) {\n+        if (loggerProp != null) {\n             String[] loggerNames = loggerProp.split(\",\");\n             for (String loggerName : loggerNames) {\n                 String name = loggerName.trim();\n@@ -343,7 +343,6 @@ private LayoutComponentBuilder createLayout(ConfigurationBuilder<PropertiesConfi\n         return componentBuilder;\n     }\n \n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n     private void processRemainingProperties(ComponentBuilder<?> builder, String name, Properties properties) {\n         while (properties.size() > 0) {\n             String propertyName = properties.stringPropertyNames().iterator().next();\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "1153",
        "nb_skipped": 3,
        "commit": "9f924f10",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 47,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.AbstractLoggerTest"
        ],
        "patch": "diff --git a/api/src/main/java/org/apache/logging/log4j/spi/AbstractLogger.java b/api/src/main/java/org/apache/logging/log4j/spi/AbstractLogger.java\nindex 8e50b5b71..675d58c18 100644\n--- a/api/src/main/java/org/apache/logging/log4j/spi/AbstractLogger.java\n+++ b/api/src/main/java/org/apache/logging/log4j/spi/AbstractLogger.java\n@@ -1157,7 +1157,7 @@ public void error(Message msg, Throwable t) {\n      */\n     public void error(Marker marker, Message msg) {\n         if (isEnabled(Level.ERROR, marker, msg, null)) {\n-            log(null, FQCN, Level.ERROR, msg, null);\n+            log(marker, FQCN, Level.ERROR, msg, null);\n         }\n     }\n \n@@ -1354,7 +1354,7 @@ public void fatal(Message msg, Throwable t) {\n      */\n     public void fatal(Marker marker, Message msg) {\n         if (isEnabled(Level.FATAL, marker, msg, null)) {\n-            log(null, FQCN, Level.FATAL, msg, null);\n+            log(marker, FQCN, Level.FATAL, msg, null);\n         }\n     }\n \n",
        "project": "logging-log4j2",
        "linesAdd": 2,
        "jira_id": "127",
        "nb_skipped": 0,
        "commit": "029e79da",
        "nb_failure": 2,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 531,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.lookup.InterpolatorTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\nindex a768f4e7d..f50293ffb 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\n@@ -71,6 +71,8 @@ public Interpolator(Map<String, String> properties) {\n         lookups.put(\"sys\", new SystemPropertiesLookup());\n         lookups.put(\"env\", new EnvironmentLookup());\n         lookups.put(\"jndi\", new JndiLookup());\n+        lookups.put(\"date\", new DateLookup());\n+        lookups.put(\"ctx\", new ContextMapLookup());\n         try {\n             if (Class.forName(\"javax.servlet.ServletContext\") != null) {\n                 lookups.put(\"web\", new WebLookup());\n",
        "project": "logging-log4j2",
        "linesAdd": 2,
        "jira_id": "378",
        "nb_skipped": 1,
        "commit": "ef8517e4",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 767,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.pattern.ExtendedThrowablePatternConverterTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/ExtendedThrowablePatternConverter.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/ExtendedThrowablePatternConverter.java\nindex 389772183..235709303 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/ExtendedThrowablePatternConverter.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/ExtendedThrowablePatternConverter.java\n@@ -64,7 +64,7 @@ public void format(final LogEvent event, final StringBuilder toAppendTo) {\n             proxy = ((Log4jLogEvent) event).getThrownProxy();\n         }\n         final Throwable throwable = event.getThrown();\n-        if (throwable != null && options.anyLines()) {\n+        if ((throwable != null || proxy != null) && options.anyLines()) {\n             if (proxy == null) {\n                 super.format(event, toAppendTo);\n                 return;\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "1068",
        "nb_skipped": 2,
        "commit": "e7bbeceb",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 136,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.spi.MutableThreadContextStackTest",
            "org.apache.logging.log4j.spi.DefaultThreadContextMapTest",
            "org.apache.logging.log4j.spi.DefaultThreadContextStackTest"
        ],
        "patch": "diff --git a/api/src/main/java/org/apache/logging/log4j/spi/DefaultThreadContextMap.java b/api/src/main/java/org/apache/logging/log4j/spi/DefaultThreadContextMap.java\nindex eca71264a..953d1e57a 100644\n--- a/api/src/main/java/org/apache/logging/log4j/spi/DefaultThreadContextMap.java\n+++ b/api/src/main/java/org/apache/logging/log4j/spi/DefaultThreadContextMap.java\n@@ -139,4 +139,10 @@ public boolean isEmpty() {\n         final Map<String, String> map = localMap.get();\n         return map == null || map.size() == 0;\n     }\n+\n+    @Override\n+    public String toString() {\n+        Map<String, String> map = localMap.get();\n+        return map == null ? \"{}\" : map.toString();\n+    }\n }\ndiff --git a/api/src/main/java/org/apache/logging/log4j/spi/DefaultThreadContextStack.java b/api/src/main/java/org/apache/logging/log4j/spi/DefaultThreadContextStack.java\nindex 20f5afbab..54ea2567e 100644\n--- a/api/src/main/java/org/apache/logging/log4j/spi/DefaultThreadContextStack.java\n+++ b/api/src/main/java/org/apache/logging/log4j/spi/DefaultThreadContextStack.java\n@@ -251,4 +251,10 @@ public boolean retainAll(final Collection<?> objects) {\n         stack.set(Collections.unmodifiableList(copy));\n         return result;\n     }\n+    \n+    @Override\n+    public String toString() {\n+        final List<String> list = stack.get();\n+        return list == null ? \"[]\" : list.toString();\n+    }\n }\ndiff --git a/api/src/main/java/org/apache/logging/log4j/spi/MutableThreadContextStack.java b/api/src/main/java/org/apache/logging/log4j/spi/MutableThreadContextStack.java\nindex 164c5c0f7..1c1e65488 100644\n--- a/api/src/main/java/org/apache/logging/log4j/spi/MutableThreadContextStack.java\n+++ b/api/src/main/java/org/apache/logging/log4j/spi/MutableThreadContextStack.java\n@@ -161,4 +161,9 @@ public boolean removeAll(final Collection<?> objects) {\n     public boolean retainAll(final Collection<?> objects) {\n         return list.retainAll(objects);\n     }\n+    \n+    @Override\n+    public String toString() {\n+        return String.valueOf(list);\n+    }\n }\n",
        "project": "logging-log4j2",
        "linesAdd": 17,
        "jira_id": "302",
        "nb_skipped": 0,
        "commit": "300bc575",
        "nb_failure": 3,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 95,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.pattern.PatternParserTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/pattern/PatternParser.java b/core/src/main/java/org/apache/logging/log4j/core/pattern/PatternParser.java\nindex 99fd17d99..fd53a004b 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/pattern/PatternParser.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/pattern/PatternParser.java\n@@ -210,13 +210,13 @@ private static int extractConverter(\n      */\n     private static int extractOptions(String pattern, int i, List<String> options) {\n         while ((i < pattern.length()) && (pattern.charAt(i) == '{')) {\n-            int begin = i;\n+            int begin = i++;\n             int end;\n             int depth = 0;\n             do {\n                 end = pattern.indexOf('}', i);\n                 if (end != -1) {\n-                    int next = pattern.indexOf(\"{\", i + 1);\n+                    int next = pattern.indexOf(\"{\", i);\n                     if (next != -1 && next < end) {\n                         i = end + 1;\n                         ++depth;\n",
        "project": "logging-log4j2",
        "linesAdd": 2,
        "jira_id": "107",
        "nb_skipped": 0,
        "commit": "88641f49",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 527,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.jmx.ServerTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\nindex 898e5e177..e2c03f99a 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\n@@ -88,12 +88,12 @@ public static String escape(final String name) {\n                 needsQuotes = true;\n                 break;\n             case '\\r':\n-                // replace by \\\\r, no need to quote\n-                sb.append(\"\\\\r\");\n+                // drop \\r characters: \\\\r gives \"invalid escape sequence\"\n                 continue;\n             case '\\n':\n-                // replace by \\\\n, no need to quote\n+                // replace \\n characters with \\\\n sequence\n                 sb.append(\"\\\\n\");\n+                needsQuotes = true;\n                 continue;\n             }\n             sb.append(c);\n@@ -260,13 +260,14 @@ public static void unregisterContext(String loggerContextName) {\n      */\n     public static void unregisterContext(String contextName, MBeanServer mbs) {\n         final String pattern = LoggerContextAdminMBean.PATTERN;\n-        final String search = String.format(pattern, contextName, \"*\");\n+        final String safeContextName = escape(contextName);\n+        final String search = String.format(pattern, safeContextName, \"*\");\n         unregisterAllMatching(search, mbs); // unregister context mbean\n-        unregisterLoggerConfigs(contextName, mbs);\n-        unregisterAppenders(contextName, mbs);\n-        unregisterAsyncAppenders(contextName, mbs);\n-        unregisterAsyncLoggerRingBufferAdmins(contextName, mbs);\n-        unregisterAsyncLoggerConfigRingBufferAdmins(contextName, mbs);\n+        unregisterLoggerConfigs(safeContextName, mbs);\n+        unregisterAppenders(safeContextName, mbs);\n+        unregisterAsyncAppenders(safeContextName, mbs);\n+        unregisterAsyncLoggerRingBufferAdmins(safeContextName, mbs);\n+        unregisterAsyncLoggerConfigRingBufferAdmins(safeContextName, mbs);\n     }\n \n     private static void registerStatusLogger(final MBeanServer mbs, final Executor executor)\n",
        "project": "logging-log4j2",
        "linesAdd": 8,
        "jira_id": "492",
        "nb_skipped": 1,
        "commit": "61ccbb95",
        "nb_failure": 2,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 915,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.config.properties.PropertiesConfigurationRootLoggerOnlyTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationFactory.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationFactory.java\nindex 58094f0ce..6be86833f 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationFactory.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationFactory.java\n@@ -151,7 +151,7 @@ public PropertiesConfiguration getConfiguration(ConfigurationSource source) {\n             }\n         }\n         String loggerProp = properties.getProperty(\"loggers\");\n-        if (appenderProp != null) {\n+        if (loggerProp != null) {\n             String[] loggerNames = loggerProp.split(\",\");\n             for (String loggerName : loggerNames) {\n                 String name = loggerName.trim();\n@@ -400,7 +400,6 @@ private LayoutComponentBuilder createLayout(ConfigurationBuilder<PropertiesConfi\n         return componentBuilder;\n     }\n \n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n     private void processRemainingProperties(ComponentBuilder<?> builder, String name, Properties properties) {\n         while (properties.size() > 0) {\n             String propertyName = properties.stringPropertyNames().iterator().next();\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "1153",
        "nb_skipped": 3,
        "commit": "8acedb4e",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 744,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.impl.ThrowableProxyTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\nindex 75c85649d..3aadf6c73 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n@@ -451,14 +451,22 @@ private boolean ignoreElement(final StackTraceElement element, final List<String\n         try {\n             clazz = Loader.loadClass(className);\n         } catch (final ClassNotFoundException ignored) {\n+            return initializeClass(className);\n+        } catch (final NoClassDefFoundError ignored) {\n+            return initializeClass(className);\n+        }\n+        return clazz;\n+    }\n+\n+    private Class<?> initializeClass(final String className) {\n         try {\n-                clazz = Loader.initializeClass(className, this.getClass().getClassLoader());\n+            return Loader.initializeClass(className, this.getClass().getClassLoader());\n         } catch (final ClassNotFoundException ignore) {\n             return null;\n+        } catch (final NoClassDefFoundError ignore) {\n+            return null;\n         }\n     }\n-        return clazz;\n-    }\n \n     /**\n      * Construct the CacheEntry from the Class's information.\n",
        "project": "logging-log4j2",
        "linesAdd": 11,
        "jira_id": "834",
        "nb_skipped": 2,
        "commit": "d3989b40",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 491,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.helpers.FileUtilsTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/helpers/FileUtils.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/helpers/FileUtils.java\nindex 5752f777e..2e38b5275 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/helpers/FileUtils.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/helpers/FileUtils.java\n@@ -63,7 +63,11 @@ public static File fileFromURI(URI uri) {\n             }\n         }\n         try {\n-            return new File(URLDecoder.decode(uri.toURL().getFile(), \"UTF8\"));\n+            String fileName = uri.toURL().getFile();\n+            if (new File(fileName).exists()) {\n+                return new File(fileName);\n+            }\n+            return new File(URLDecoder.decode(fileName, \"UTF8\"));\n         } catch (final MalformedURLException ex) {\n             LOGGER.warn(\"Invalid URL \" + uri, ex);\n         } catch (final UnsupportedEncodingException uee) {\n",
        "project": "logging-log4j2",
        "linesAdd": 5,
        "jira_id": "466",
        "nb_skipped": 8,
        "commit": "7b9e48e8",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 516,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.jmx.ServerTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\nindex 537b029ad..898e5e177 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\n@@ -87,6 +87,14 @@ public static String escape(final String name) {\n                 // no need to escape these, but value must be quoted\n                 needsQuotes = true;\n                 break;\n+            case '\\r':\n+                // replace by \\\\r, no need to quote\n+                sb.append(\"\\\\r\");\n+                continue;\n+            case '\\n':\n+                // replace by \\\\n, no need to quote\n+                sb.append(\"\\\\n\");\n+                continue;\n             }\n             sb.append(c);\n         }\n",
        "project": "logging-log4j2",
        "linesAdd": 6,
        "jira_id": "492",
        "nb_skipped": 1,
        "commit": "24a3bed4",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 18,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.LevelTest"
        ],
        "patch": "diff --git a/log4j2-api/src/main/java/org/apache/logging/log4j/Level.java b/log4j2-api/src/main/java/org/apache/logging/log4j/Level.java\nindex 5d5641710..4fd311528 100644\n--- a/log4j2-api/src/main/java/org/apache/logging/log4j/Level.java\n+++ b/log4j2-api/src/main/java/org/apache/logging/log4j/Level.java\n@@ -96,9 +96,12 @@ public static Level toLevel(String sArg, Level defaultLevel) {\n         if (sArg == null) {\n             return defaultLevel;\n         }\n-\n-        Level level = valueOf(sArg);\n-        return (level == null) ? defaultLevel : level;\n+        for (Level level : values()) {\n+            if (level.name().equals(sArg)) {\n+                return level;\n+            }\n+        }\n+        return defaultLevel;\n     }\n \n     /**\n",
        "project": "logging-log4j2",
        "linesAdd": 6,
        "jira_id": "56",
        "nb_skipped": 0,
        "commit": "3eb44094",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 204,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.message.ObjectMessageTest"
        ],
        "patch": "diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/ObjectMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/ObjectMessage.java\nindex 021adcc21..3441edbe4 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/ObjectMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/ObjectMessage.java\n@@ -83,7 +83,11 @@ public boolean equals(final Object o) {\n         }\n \n         final ObjectMessage that = (ObjectMessage) o;\n-        return obj == null ? that.obj == null : obj.equals(that.obj);\n+        return obj == null ? that.obj == null : equalObjectsOrStrings(obj, that.obj);\n+    }\n+    \n+    private boolean equalObjectsOrStrings(Object left, Object right) {\n+        return left.equals(right) || String.valueOf(left).equals(String.valueOf(right));\n     }\n \n     @Override\n",
        "project": "logging-log4j2",
        "linesAdd": 5,
        "jira_id": "763",
        "nb_skipped": 2,
        "commit": "b2ec5106",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 214,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.message.LocalizedMessageTest"
        ],
        "patch": "diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/LocalizedMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/LocalizedMessage.java\nindex 8889d5fef..40e3324a9 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/LocalizedMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/LocalizedMessage.java\n@@ -265,6 +265,7 @@ private void writeObject(final ObjectOutputStream out) throws IOException {\n             stringArgs[i] = obj.toString();\n             ++i;\n         }\n+        out.writeObject(stringArgs);\n     }\n \n     private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n@@ -273,10 +274,7 @@ private void readObject(final ObjectInputStream in) throws IOException, ClassNot\n         messagePattern = in.readUTF();\n         baseName = in.readUTF();\n         final int length = in.readInt();\n-        stringArgs = new String[length];\n-        for (int i = 0; i < length; ++i) {\n-            stringArgs[i] = in.readUTF();\n-        }\n+        stringArgs = (String[]) in.readObject();\n         logger = StatusLogger.getLogger();\n         resourceBundle = null;\n         argArray = null;\n",
        "project": "logging-log4j2",
        "linesAdd": 2,
        "jira_id": "523",
        "nb_skipped": 0,
        "commit": "837dcd89",
        "nb_failure": 0,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 55,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.jul.DefaultLevelConverterCustomJulLevelsTest"
        ],
        "patch": "diff --git a/log4j-jul/src/main/java/org/apache/logging/log4j/jul/DefaultLevelConverter.java b/log4j-jul/src/main/java/org/apache/logging/log4j/jul/DefaultLevelConverter.java\nindex 5d84de452..c2d8eb321 100644\n--- a/log4j-jul/src/main/java/org/apache/logging/log4j/jul/DefaultLevelConverter.java\n+++ b/log4j-jul/src/main/java/org/apache/logging/log4j/jul/DefaultLevelConverter.java\n@@ -17,24 +17,38 @@\n \n package org.apache.logging.log4j.jul;\n \n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n import java.util.IdentityHashMap;\n+import java.util.List;\n import java.util.Map;\n \n import org.apache.logging.log4j.Level;\n \n /**\n  * Default implementation of LevelConverter strategy.\n- *\n+ * <p>\n+ * Supports custom JUL levels by mapping them to their closest mapped neighbour. \n+ * </p>\n  * @since 2.1\n  */\n public class DefaultLevelConverter implements LevelConverter {\n \n+    static final class JulLevelComparator implements Comparator<java.util.logging.Level> {\n+        @Override\n+        public int compare(java.util.logging.Level level1, java.util.logging.Level level2) {\n+            return Integer.compare(level1.intValue(), level2.intValue());\n+        }\n+    }\n+\n     private final Map<java.util.logging.Level, Level> julToLog4j = new IdentityHashMap<>(9);\n     private final Map<Level, java.util.logging.Level> log4jToJul = new IdentityHashMap<>(10);\n+    private final List<java.util.logging.Level> sortedJulLevels = new ArrayList<>(9);\n \n     public DefaultLevelConverter() {\n         // Map JUL to Log4j\n-        mapJulToLog4j(java.util.logging.Level.OFF, Level.OFF);\n+        mapJulToLog4j(java.util.logging.Level.ALL, Level.ALL);\n         mapJulToLog4j(java.util.logging.Level.FINEST, LevelTranslator.FINEST);\n         mapJulToLog4j(java.util.logging.Level.FINER, Level.TRACE);\n         mapJulToLog4j(java.util.logging.Level.FINE, Level.DEBUG);\n@@ -42,9 +56,9 @@ public DefaultLevelConverter() {\n         mapJulToLog4j(java.util.logging.Level.INFO, Level.INFO);\n         mapJulToLog4j(java.util.logging.Level.WARNING, Level.WARN);\n         mapJulToLog4j(java.util.logging.Level.SEVERE, Level.ERROR);\n-        mapJulToLog4j(java.util.logging.Level.ALL, Level.ALL);\n+        mapJulToLog4j(java.util.logging.Level.OFF, Level.OFF);\n         // Map Log4j to JUL\n-        mapLog4jToJul(Level.OFF, java.util.logging.Level.OFF);\n+        mapLog4jToJul(Level.ALL, java.util.logging.Level.ALL);\n         mapLog4jToJul(LevelTranslator.FINEST, java.util.logging.Level.FINEST);\n         mapLog4jToJul(Level.TRACE, java.util.logging.Level.FINER);\n         mapLog4jToJul(Level.DEBUG, java.util.logging.Level.FINE);\n@@ -53,18 +67,46 @@ public DefaultLevelConverter() {\n         mapLog4jToJul(Level.WARN, java.util.logging.Level.WARNING);\n         mapLog4jToJul(Level.ERROR, java.util.logging.Level.SEVERE);\n         mapLog4jToJul(Level.FATAL, java.util.logging.Level.SEVERE);\n-        mapLog4jToJul(Level.ALL, java.util.logging.Level.ALL);\n+        mapLog4jToJul(Level.OFF, java.util.logging.Level.OFF);\n+        // Sorted Java levels\n+        sortedJulLevels.addAll(julToLog4j.keySet());\n+        Collections.sort(sortedJulLevels, new JulLevelComparator());\n+\n+    }\n+\n+    private Level addCustomJulLevel(java.util.logging.Level customJavaLevel) {\n+        long prevDist = Long.MAX_VALUE;\n+        java.util.logging.Level prevLevel = null;\n+        for (java.util.logging.Level mappedJavaLevel : sortedJulLevels) {\n+            long distance = distance(customJavaLevel, mappedJavaLevel);\n+            if (distance > prevDist) {\n+                return mapCustomJulLevel(customJavaLevel, prevLevel);\n+            }\n+            prevDist = distance;\n+            prevLevel = mappedJavaLevel;\n+        }\n+        return mapCustomJulLevel(customJavaLevel, prevLevel);\n+    }\n+\n+    private long distance(java.util.logging.Level javaLevel, java.util.logging.Level customJavaLevel) {\n+        return Math.abs((long) customJavaLevel.intValue() - (long) javaLevel.intValue());\n+    }\n+\n+    private Level mapCustomJulLevel(java.util.logging.Level customJavaLevel, java.util.logging.Level stdJavaLevel) {\n+        final Level level = julToLog4j.get(stdJavaLevel);\n+        julToLog4j.put(customJavaLevel, level);\n+        return level;\n     }\n \n     /*\n-     * TODO consider making public.\n+     * TODO consider making public for advanced configuration.\n      */\n     private void mapJulToLog4j(java.util.logging.Level julLevel, Level level) {\n         julToLog4j.put(julLevel, level);\n     }\n \n     /*\n-     * TODO consider making public.\n+     * TODO consider making public for advanced configuration.\n      */\n     private void mapLog4jToJul(Level level, java.util.logging.Level julLevel) {\n         log4jToJul.put(level, julLevel);\n@@ -77,6 +119,7 @@ private void mapLog4jToJul(Level level, java.util.logging.Level julLevel) {\n \n     @Override\n     public Level toLevel(final java.util.logging.Level javaLevel) {\n-        return julToLog4j.get(javaLevel);\n+        final Level level = julToLog4j.get(javaLevel);\n+        return level != null ? level : addCustomJulLevel(javaLevel);\n     }\n }\n",
        "project": "logging-log4j2",
        "linesAdd": 45,
        "jira_id": "1025",
        "nb_skipped": 0,
        "commit": "a96b455c",
        "nb_failure": 9,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 476,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.layout.JSONLayoutTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/helpers/Transform.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/helpers/Transform.java\nindex 6c68e4dd3..a50224569 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/helpers/Transform.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/helpers/Transform.java\n@@ -139,7 +139,7 @@ public static String escapeJsonControlCharacters(final String input) {\n         final int len = input.length();\n         for (int i = 0; i < len; i++) {\n             final char ch = input.charAt(i);\n-            final String escBs = \"\\\\\\\\\";\n+            final String escBs = \"\\\\\";\n             switch (ch) {\n             case '\"':\n                 buf.append(escBs);\ndiff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JSONLayout.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JSONLayout.java\nindex a6a8af089..a9005d1cb 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JSONLayout.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JSONLayout.java\n@@ -189,7 +189,7 @@ public String toSerializable(final LogEvent event) {\n             if (jsonSupported) {\n                 buf.append(((MultiformatMessage) msg).getFormattedMessage(FORMATS));\n             } else {\n-                Transform.appendEscapingCDATA(buf, event.getMessage().getFormattedMessage());\n+                buf.append(Transform.escapeJsonControlCharacters(event.getMessage().getFormattedMessage()));\n             }\n             buf.append('\\\"');\n         }\n@@ -198,7 +198,7 @@ public String toSerializable(final LogEvent event) {\n             buf.append(\",\");\n             buf.append(this.eol);\n             buf.append(\"\\\"ndc\\\":\");\n-            Transform.appendEscapingCDATA(buf, event.getContextStack().toString());\n+            buf.append(Transform.escapeJsonControlCharacters(event.getContextStack().toString()));\n             buf.append(\"\\\"\");\n         }\n \n",
        "project": "logging-log4j2",
        "linesAdd": 3,
        "jira_id": "478",
        "nb_skipped": 8,
        "commit": "11763dee",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 184,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.config.BaseConfigurationTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java b/core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\nindex dcdb9881f..8821f7615 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\n@@ -206,9 +206,9 @@ protected void doConfigure() {\n             setToDefault();\n             return;\n         } else if (!setRoot) {\n-            LOGGER.warn(\"No Root logger was configured, using default\");\n+            LOGGER.warn(\"No Root logger was configured, creating default ERROR-level Root logger with Console appender\");\n             setToDefault();\n-            return;\n+            // return; // LOG4J2-219: creating default root=ok, but don't exclude configured Loggers\n         }\n \n         for (final Map.Entry<String, LoggerConfig> entry : loggers.entrySet()) {\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "219",
        "nb_skipped": 0,
        "commit": "ed951c76",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 18,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.MarkerTest"
        ],
        "patch": "diff --git a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\nindex 50d126c59..c2273f5c9 100644\n--- a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\n+++ b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\n@@ -85,6 +85,9 @@ public boolean hasChildren() {\n \r\n     @Override\r\n \tpublic boolean contains(final org.slf4j.Marker marker) {\r\n+\t\tif (marker == null) {\r\n+\t\t\tthrow new IllegalArgumentException();\r\n+\t\t}\r\n \t\treturn this.marker.isInstanceOf(marker.getName());\r\n \t}\r\n \r\n",
        "project": "logging-log4j2",
        "linesAdd": 3,
        "jira_id": "1058",
        "nb_skipped": 0,
        "commit": "c8fd3c53",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 75,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.message.MapMessageTest"
        ],
        "patch": "diff --git a/api/src/main/java/org/apache/logging/log4j/message/MapMessage.java b/api/src/main/java/org/apache/logging/log4j/message/MapMessage.java\nindex de1bb98b5..cbcd2ca8a 100644\n--- a/api/src/main/java/org/apache/logging/log4j/message/MapMessage.java\n+++ b/api/src/main/java/org/apache/logging/log4j/message/MapMessage.java\n@@ -193,7 +193,7 @@ private String asString(final MapFormat format) {\n     public void asXML(final StringBuilder sb) {\n         sb.append(\"<Map>\\n\");\n         for (final Map.Entry<String, String> entry : data.entrySet()) {\n-            sb.append(\"  <Entry key=\").append(entry.getKey()).append(\">\").append(entry.getValue()).append(\"</Entry>\\n\");\n+            sb.append(\"  <Entry key=\\\"\").append(entry.getKey()).append(\"\\\">\").append(entry.getValue()).append(\"</Entry>\\n\");\n         }\n         sb.append(\"</Map>\");\n     }\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "210",
        "nb_skipped": 0,
        "commit": "aeb6fc9d",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 183,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.filter.RegexFilterTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/filter/RegexFilter.java b/core/src/main/java/org/apache/logging/log4j/core/filter/RegexFilter.java\nindex ae41b8685..56d8ec658 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/filter/RegexFilter.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/filter/RegexFilter.java\n@@ -57,12 +57,18 @@ public Result filter(final Logger logger, final Level level, final Marker marker\n     @Override\n     public Result filter(final Logger logger, final Level level, final Marker marker, final Object msg,\n                          final Throwable t) {\n+        if (msg == null) {\n+            return onMismatch;\n+        }\n         return filter(msg.toString());\n     }\n \n     @Override\n     public Result filter(final Logger logger, final Level level, final Marker marker, final Message msg,\n                          final Throwable t) {\n+        if (msg == null) {\n+            return onMismatch;\n+        }\n         final String text = useRawMessage ? msg.getFormat() : msg.getFormattedMessage();\n         return filter(text);\n     }\n",
        "project": "logging-log4j2",
        "linesAdd": 6,
        "jira_id": "234",
        "nb_skipped": 0,
        "commit": "2d7d6311",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 119,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.net.SocketReconnectTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/appender/OutputStreamManager.java b/core/src/main/java/org/apache/logging/log4j/core/appender/OutputStreamManager.java\nindex 8d6b3a332..54fde20be 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/appender/OutputStreamManager.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/appender/OutputStreamManager.java\n@@ -28,6 +28,7 @@\n     private OutputStream os;\n \n     private byte[] footer = null;\n+    private byte[] header = null;\n \n     protected OutputStreamManager(final OutputStream os, final String streamName) {\n         super(streamName);\n@@ -54,6 +55,7 @@ protected OutputStreamManager(final OutputStream os, final String streamName) {\n      */\n     public synchronized void setHeader(final byte[] header) {\n         if (header != null) {\n+            this.header = header;\n             try {\n                 this.os.write(header, 0, header.length);\n             } catch (final IOException ioe) {\n@@ -97,6 +99,13 @@ protected OutputStream getOutputStream() {\n \n     protected void setOutputStream(final OutputStream os) {\n         this.os = os;\n+        if (header != null) {\n+            try {\n+                this.os.write(header, 0, header.length);\n+            } catch (final IOException ioe) {\n+                LOGGER.error(\"Unable to write header\", ioe);\n+            }\n+        }\n     }\n \n     /**\ndiff --git a/core/src/main/java/org/apache/logging/log4j/core/net/DatagramOutputStream.java b/core/src/main/java/org/apache/logging/log4j/core/net/DatagramOutputStream.java\nindex bf2a2e6c0..2fe3d9a1b 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/net/DatagramOutputStream.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/net/DatagramOutputStream.java\n@@ -89,7 +89,7 @@ public synchronized void write(final byte[] bytes) throws IOException {\n \n     @Override\n     public synchronized void flush() throws IOException {\n-        if (this.ds != null && this.address != null) {\n+        if (this.data != null && this.ds != null && this.address != null) {\n             final DatagramPacket packet = new DatagramPacket(data, data.length, address, port);\n             ds.send(packet);\n         }\n",
        "project": "logging-log4j2",
        "linesAdd": 10,
        "jira_id": "177",
        "nb_skipped": 0,
        "commit": "f91ce934",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 112,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.filter.ThreadContextMapFilterTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/filter/ThreadContextMapFilter.java b/core/src/main/java/org/apache/logging/log4j/core/filter/ThreadContextMapFilter.java\nindex 9ad6cab59..b3f38381b 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/filter/ThreadContextMapFilter.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/filter/ThreadContextMapFilter.java\n@@ -96,7 +96,7 @@ private Result filter() {\n                 }\n             }\n         } else {\n-            match = key.equals(ThreadContext.get(key));\n+            match = value.equals(ThreadContext.get(key));\n         }\n         return match ? onMatch : onMismatch;\n     }\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "147",
        "nb_skipped": 0,
        "commit": "17296089",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 659,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.LoggerTest",
            "org.apache.logging.log4j.core.config.TestConfigurator",
            "org.apache.logging.log4j.core.FileConfigTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/xml/XmlConfiguration.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/xml/XmlConfiguration.java\nindex fb7efa7c8..747f809a2 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/xml/XmlConfiguration.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/xml/XmlConfiguration.java\n@@ -242,9 +242,7 @@ public Configuration reconfigure() {\n                 final ConfigurationFactory.ConfigurationSource source =\n                     new ConfigurationFactory.ConfigurationSource(new FileInputStream(configFile), configFile);\n                 final XmlConfiguration config = new XmlConfiguration(source);\n-                if (config.rootElement == null) {\n-                    return null;\n-                }\n+                return (config.rootElement == null) ? null : config;\n             } catch (final FileNotFoundException ex) {\n                 LOGGER.error(\"Cannot locate file \" + configFile, ex);\n             }\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "619",
        "nb_skipped": 2,
        "commit": "3b4b370e",
        "nb_failure": 3,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 112,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.pattern.MessagePatternConverterTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/pattern/MessagePatternConverter.java b/core/src/main/java/org/apache/logging/log4j/core/pattern/MessagePatternConverter.java\nindex 8db9313d0..c3850b381 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/pattern/MessagePatternConverter.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/pattern/MessagePatternConverter.java\n@@ -67,8 +67,12 @@ public void format(final LogEvent event, final StringBuilder toAppendTo) {\n             } else {\n                 result = msg.getFormattedMessage();\n             }\n+            if (result != null) {\n                 toAppendTo.append(config != null && result.contains(\"${\") ?\n                     config.getSubst().replace(event, result) : result);\n+            } else {\n+                toAppendTo.append(\"null\");\n+            }\n         }\n     }\n }\n",
        "project": "logging-log4j2",
        "linesAdd": 4,
        "jira_id": "143",
        "nb_skipped": 0,
        "commit": "1461f1f6",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 526,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.web.Log4jServletContainerInitializerTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\nindex 50b082066..7d3ce0540 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\n@@ -25,6 +25,9 @@\n import javax.servlet.ServletException;\n import javax.servlet.UnavailableException;\n \n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.status.StatusLogger;\n+\n /**\n  * In a Servlet 3.0 or newer environment, this initializer is responsible for starting up Log4j logging before anything\n  * else happens in application initialization. For consistency across all containers, if the effective Servlet major\n@@ -34,21 +37,23 @@\n \n     @Override\n     public void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {\n-        if (servletContext.getMajorVersion() > 2) {\n+        if (servletContext.getMajorVersion() > 2 && servletContext.getEffectiveMajorVersion() > 2) {\n             servletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\");\n \n+            final FilterRegistration.Dynamic filter =\n+                    servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\n+            if (filter == null) {\n+                servletContext.log(\"WARNING: In a Servlet 3.0+ application, you should not define a \" +\n+                        \"log4jServletFilter in web.xml. Log4j 2 normally does this for you automatically. Log4j 2 \" +\n+                        \"web auto-initialization has been canceled.\");\n+                return;\n+            }\n+\n             final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);\n             initializer.initialize();\n             initializer.setLoggerContext(); // the application is just now starting to start up\n \n             servletContext.addListener(new Log4jServletContextListener());\n-\n-            final FilterRegistration.Dynamic filter =\n-                    servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\n-            if (filter == null) {\n-                throw new UnavailableException(\"In a Servlet 3.0+ application, you must not define a \" +\n-                        \"log4jServletFilter in web.xml. Log4j 2 defines this for you automatically.\");\n-            }\n             filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, \"/*\");\n         }\n     }\n",
        "project": "logging-log4j2",
        "linesAdd": 13,
        "jira_id": "359",
        "nb_skipped": 1,
        "commit": "296ea4a5",
        "nb_failure": 8,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 19,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.MarkerTest"
        ],
        "patch": "diff --git a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\nindex c2273f5c9..d57cf1907 100644\n--- a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\n+++ b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\n@@ -56,7 +56,7 @@ public void add(final Marker marker) {\n \r\n     @Override\r\n \tpublic boolean remove(final Marker marker) {\r\n-        return this.marker.remove(MarkerManager.getMarker(marker.getName()));\r\n+\t\treturn marker != null ? this.marker.remove(MarkerManager.getMarker(marker.getName())) : false;\r\n \t}\r\n \r\n     @Override\r\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "1061",
        "nb_skipped": 0,
        "commit": "86d8944f",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1114,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.lookup.JndiLookupTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/JndiLookup.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/JndiLookup.java\nindex d7d50cb67..1cd4290d3 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/JndiLookup.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/JndiLookup.java\n@@ -52,7 +52,7 @@ public String lookup(final LogEvent event, final String key) {\n         final String jndiName = convertJndiName(key);\n         final JndiManager jndiManager = JndiManager.getDefaultManager();\n         try {\n-            return jndiManager.lookup(jndiName);\n+            return String.valueOf(jndiManager.lookup(jndiName));\n         } catch (final NamingException e) {\n             LOGGER.warn(LOOKUP, \"Error looking up JNDI resource [{}].\", jndiName, e);\n             return null;\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "1310",
        "nb_skipped": 3,
        "commit": "c6318b63",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 660,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.appender.rolling.RollingRandomAccessFileManagerHeaderFooterTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/OutputStreamManager.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/OutputStreamManager.java\nindex 246abba57..006558549 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/OutputStreamManager.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/OutputStreamManager.java\n@@ -28,8 +28,7 @@\n public class OutputStreamManager extends AbstractManager {\n \n     private volatile OutputStream os;\n-\n-    private final Layout<?> layout;\n+    protected final Layout<?> layout;\n \n     protected OutputStreamManager(final OutputStream os, final String streamName, final Layout<?> layout) {\n         super(streamName);\n@@ -66,11 +65,21 @@ protected OutputStreamManager(final OutputStream os, final String streamName, fi\n      */\n     @Override\n     public void releaseSub() {\n+        writeFooter();\n+        close();\n+    }\n+\n+    /**\n+     * Writes the footer.\n+     */\n+    protected void writeFooter() {\n+        if (layout == null) {\n+            return;\n+        }\n         byte[] footer = layout.getFooter();\n         if (footer != null) {\n             write(footer);\n         }\n-        close();\n     }\n \n     /**\ndiff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingFileManager.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingFileManager.java\nindex c58b18cb3..318470219 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingFileManager.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingFileManager.java\n@@ -167,6 +167,7 @@ private boolean rollover(final RolloverStrategy strategy) {\n         try {\n             final RolloverDescription descriptor = strategy.rollover(this);\n             if (descriptor != null) {\n+                writeFooter();\n                 close();\n                 if (descriptor.getSynchronous() != null) {\n                     LOGGER.debug(\"RollingFileManager executing synchronous {}\", descriptor.getSynchronous());\ndiff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingRandomAccessFileManager.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingRandomAccessFileManager.java\nindex cc63bfe5a..992ab0962 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingRandomAccessFileManager.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingRandomAccessFileManager.java\n@@ -55,6 +55,26 @@ public RollingRandomAccessFileManager(final RandomAccessFile raf, final String f\n         this.randomAccessFile = raf;\n         isEndOfBatch.set(Boolean.FALSE);\n         this.buffer = ByteBuffer.allocate(bufferSize);\n+        writeHeader();\n+    }\n+\n+    /**\n+     * Writes the layout's header to the file if it exists.\n+     */\n+    private void writeHeader() {\n+        if (layout == null) {\n+            return;\n+        }\n+        byte[] header = layout.getHeader();\n+        if (header == null) {\n+            return;\n+        }\n+        try {\n+            // write to the file, not to the buffer: the buffer may not be empty\n+            randomAccessFile.write(header, 0, header.length);\n+        } catch (final IOException ioe) {\n+            LOGGER.error(\"Unable to write header\", ioe);\n+        }\n     }\n \n     public static RollingRandomAccessFileManager getRollingRandomAccessFileManager(final String fileName,\n@@ -99,6 +119,7 @@ protected void createFileAfterRollover() throws IOException {\n         if (isAppend()) {\n             randomAccessFile.seek(randomAccessFile.length());\n         }\n+        writeHeader();\n     }\n \n     @Override\n",
        "project": "logging-log4j2",
        "linesAdd": 27,
        "jira_id": "581",
        "nb_skipped": 2,
        "commit": "bb02fa15",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 334,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.layout.HTMLLayoutTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/layout/HTMLLayout.java b/core/src/main/java/org/apache/logging/log4j/core/layout/HTMLLayout.java\nindex 76dfdfea6..bfb49398c 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/layout/HTMLLayout.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/layout/HTMLLayout.java\n@@ -208,7 +208,7 @@ public String toSerializable(final LogEvent event) {\n      * @return The content type.\n      */\n     public String getContentType() {\n-        return \"text/html\";\n+        return \"text/html; charset=\" + this.getCharset();\n     }\n \n     private void appendThrowableAsHTML(final Throwable throwable, final StringBuilder sbuf) {\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "259",
        "nb_skipped": 3,
        "commit": "09175c8b",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 759,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.impl.ThrowableProxyTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\nindex dbbc808f3..75aa5b44c 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n@@ -121,7 +121,8 @@ public ThrowableProxy(final Throwable throwable, Set<Throwable> visited) {\n         final Stack<Class<?>> stack = ReflectionUtil.getCurrentStackTrace();\n         this.extendedStackTrace = this.toExtendedStackTrace(stack, map, null, throwable.getStackTrace());\n         final Throwable throwableCause = throwable.getCause();\n-        this.causeProxy = throwableCause == null ? null : new ThrowableProxy(throwable, stack, map, throwableCause, visited);\n+        final Set<Throwable> causeVisited = new HashSet<>(1);\n+        this.causeProxy = throwableCause == null ? null : new ThrowableProxy(throwable, stack, map, throwableCause, visited, causeVisited);\n         this.suppressedProxies = this.toSuppressedProxies(throwable, visited);\n     }\n \n@@ -137,15 +138,19 @@ public ThrowableProxy(final Throwable throwable, Set<Throwable> visited) {\n      * @param cause\n      *        The Throwable to wrap.\n      * @param suppressedVisited TODO\n+     * @param causeVisited TODO\n      */\n     private ThrowableProxy(final Throwable parent, final Stack<Class<?>> stack, final Map<String, CacheEntry> map,\n-            final Throwable cause, Set<Throwable> suppressedVisited) {\n+            final Throwable cause, Set<Throwable> suppressedVisited, Set<Throwable> causeVisited) {\n+        causeVisited.add(cause);\n         this.throwable = cause;\n         this.name = cause.getClass().getName();\n         this.message = this.throwable.getMessage();\n         this.localizedMessage = this.throwable.getLocalizedMessage();\n         this.extendedStackTrace = this.toExtendedStackTrace(stack, map, parent.getStackTrace(), cause.getStackTrace());\n-        this.causeProxy = cause.getCause() == null ? null : new ThrowableProxy(parent, stack, map, cause.getCause(), suppressedVisited);\n+        final Throwable causeCause = cause.getCause();\n+        this.causeProxy = causeCause == null || causeVisited.contains(causeCause) ? null : new ThrowableProxy(parent,\n+                stack, map, causeCause, suppressedVisited, causeVisited);\n         this.suppressedProxies = this.toSuppressedProxies(cause, suppressedVisited);\n     }\n \n",
        "project": "logging-log4j2",
        "linesAdd": 7,
        "jira_id": "1046",
        "nb_skipped": 2,
        "commit": "11960820",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 89,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.net.PriorityTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/net/Priority.java b/core/src/main/java/org/apache/logging/log4j/core/net/Priority.java\nindex 0e83dfa70..00144e2e2 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/net/Priority.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/net/Priority.java\n@@ -43,7 +43,7 @@ public Priority(Facility facility, Severity severity) {\n      * @return The integer value of the priority.\n      */\n     public static int getPriority(Facility facility, Level level) {\n-        return facility.getCode() << 3 + Severity.getSeverity(level).getCode();\n+        return (facility.getCode() << 3) + Severity.getSeverity(level).getCode();\n     }\n \n     /**\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "102",
        "nb_skipped": 0,
        "commit": "7f391872",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 418,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.LateConfigTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/selector/ClassLoaderContextSelector.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/selector/ClassLoaderContextSelector.java\nindex 058b630f3..13ba4ba8f 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/selector/ClassLoaderContextSelector.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/selector/ClassLoaderContextSelector.java\n@@ -28,6 +28,7 @@\n import java.util.concurrent.atomic.AtomicReference;\n \n import org.apache.logging.log4j.core.LoggerContext;\n+import org.apache.logging.log4j.core.config.Configuration;\n import org.apache.logging.log4j.core.helpers.Loader;\n import org.apache.logging.log4j.core.impl.ContextAnchor;\n import org.apache.logging.log4j.core.impl.ReflectiveCallerClassUtility;\n@@ -224,6 +225,13 @@ private LoggerContext locateContext(final ClassLoader loader, final URI configLo\n         final WeakReference<LoggerContext> r = ref.get();\n         LoggerContext ctx = r.get();\n         if (ctx != null) {\n+            if (ctx.getConfigLocation() == null && configLocation != null) {\n+                LOGGER.debug(\"Setting configuration to {}\", configLocation);\n+                ctx.setConfigLocation(configLocation);\n+            } else if (ctx.getConfigLocation() != null && !ctx.getConfigLocation().equals(configLocation)) {\n+                LOGGER.warn(\"locateContext called with URI {}. Existing LoggerContext has URI {}\", configLocation,\n+                    ctx.getConfigLocation());\n+            }\n             return ctx;\n         }\n         ctx = new LoggerContext(name, null, configLocation);\n",
        "project": "logging-log4j2",
        "linesAdd": 8,
        "jira_id": "293",
        "nb_skipped": 5,
        "commit": "ca59ece6",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 64,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.log4j.VelocityTest"
        ],
        "patch": "diff --git a/log4j-1.2-api/src/main/java/org/apache/log4j/PatternLayout.java b/log4j-1.2-api/src/main/java/org/apache/log4j/PatternLayout.java\nindex 7595f75d5..a1d77c7c4 100644\n--- a/log4j-1.2-api/src/main/java/org/apache/log4j/PatternLayout.java\n+++ b/log4j-1.2-api/src/main/java/org/apache/log4j/PatternLayout.java\n@@ -23,6 +23,10 @@\n  */\n public class PatternLayout extends Layout {\n \n+    public PatternLayout(String pattern) {\n+\n+    }\n+\n     @Override\n     public String format(final LoggingEvent event) {\n         return \"\";\n",
        "project": "logging-log4j2",
        "linesAdd": 4,
        "jira_id": "368",
        "nb_skipped": 0,
        "commit": "a8a24357",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 731,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.impl.ThrowableProxyTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\nindex 2320ad7db..51a924e6c 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n@@ -500,7 +500,7 @@ private boolean ignoreElement(final StackTraceElement element, final List<String\n                 if (clazz != null) {\n                     return clazz;\n                 }\n-            } catch (final Exception ignore) {\n+            } catch (final Throwable ignore) {\n                 // Ignore exception.\n             }\n         }\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "832",
        "nb_skipped": 2,
        "commit": "411dad65",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 341,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.appender.SocketAppenderTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/appender/SocketAppender.java b/core/src/main/java/org/apache/logging/log4j/core/appender/SocketAppender.java\nindex f9d066592..01701f6cd 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/appender/SocketAppender.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/appender/SocketAppender.java\n@@ -115,8 +115,7 @@ public void stop() {\n             return null;\n         }\n \n-        final String prot = protocol != null ? protocol : Protocol.TCP.name();\n-        final Protocol p = EnglishEnums.valueOf(Protocol.class, protocol);\n+        final Protocol p = EnglishEnums.valueOf(Protocol.class, protocol != null ? protocol : Protocol.TCP.name());\n         if (p.equals(Protocol.UDP)) {\n             isFlush = true;\n         }\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "139",
        "nb_skipped": 2,
        "commit": "50e19247",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 217,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.MarkerTest"
        ],
        "patch": "diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/MarkerManager.java b/log4j-api/src/main/java/org/apache/logging/log4j/MarkerManager.java\nindex 2dea94e8d..5bf38e15d 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/MarkerManager.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/MarkerManager.java\n@@ -228,7 +228,7 @@ public String getName() {\n \n         @Override\n         public boolean hasParents() {\n-            return this.parents == null;\n+            return this.parents != null;\n         }\n \n         @Override\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "813",
        "nb_skipped": 3,
        "commit": "0bea17d7",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 466,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.config.TestConfigurator"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationFactory.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationFactory.java\nindex 849019675..c9355128b 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationFactory.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationFactory.java\n@@ -37,6 +37,8 @@\n import org.apache.logging.log4j.core.config.plugins.PluginType;\n import org.apache.logging.log4j.core.helpers.FileUtils;\n import org.apache.logging.log4j.core.helpers.Loader;\n+import org.apache.logging.log4j.core.lookup.Interpolator;\n+import org.apache.logging.log4j.core.lookup.StrSubstitutor;\n import org.apache.logging.log4j.status.StatusLogger;\n import org.apache.logging.log4j.util.PropertiesUtil;\n \n@@ -104,6 +106,8 @@\n \n     private static ConfigurationFactory configFactory = new Factory();\n \n+    protected final StrSubstitutor substitutor = new StrSubstitutor(new Interpolator());\n+\n     /**\n      * Returns the ConfigurationFactory.\n      * @return the ConfigurationFactory.\n@@ -362,10 +366,19 @@ public int compareTo(final WeightedFactory wf) {\n         public Configuration getConfiguration(final String name, final URI configLocation) {\n \n             if (configLocation == null) {\n-                final String config = PropertiesUtil.getProperties().getStringProperty(CONFIGURATION_FILE_PROPERTY);\n+                final String config = this.substitutor.replace(\n+                    PropertiesUtil.getProperties().getStringProperty(CONFIGURATION_FILE_PROPERTY));\n                 if (config != null) {\n+                    ConfigurationSource source = null;\n+                    try {\n+                        source = getInputFromURI(new URI(config));\n+                    } catch (Exception ex) {\n+                        // Ignore the error and try as a String.\n+                    }\n+                    if (source == null) {\n                         final ClassLoader loader = this.getClass().getClassLoader();\n-                    final ConfigurationSource source = getInputFromString(config, loader);\n+                        source = getInputFromString(config, loader);\n+                    }\n                     if (source != null) {\n                         for (final ConfigurationFactory factory : factories) {\n                             final String[] types = factory.getSupportedTypes();\n",
        "project": "logging-log4j2",
        "linesAdd": 14,
        "jira_id": "395",
        "nb_skipped": 6,
        "commit": "a19ecc9e",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 755,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.async.AsyncLoggerConfigTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfig.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfig.java\nindex 9e1cd9a29..f87d4e357 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfig.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfig.java\n@@ -236,7 +236,7 @@ public static LoggerConfig createLogger(\n \n             return new AsyncLoggerConfig(LogManager.ROOT_LOGGER_NAME,\n                     appenderRefs, filter, level, additive, properties, config,\n-                    includeLocation(includeLocation));\n+                    AsyncLoggerConfig.includeLocation(includeLocation));\n         }\n     }\n }\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "991",
        "nb_skipped": 2,
        "commit": "3cee912e",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 46,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.jul.Log4jLevelTranslatorTest"
        ],
        "patch": "diff --git a/log4j-jul/src/main/java/org/apache/logging/log4j/jul/DefaultLevelConverter.java b/log4j-jul/src/main/java/org/apache/logging/log4j/jul/DefaultLevelConverter.java\nindex 01d5aa337..b79478b32 100644\n--- a/log4j-jul/src/main/java/org/apache/logging/log4j/jul/DefaultLevelConverter.java\n+++ b/log4j-jul/src/main/java/org/apache/logging/log4j/jul/DefaultLevelConverter.java\n@@ -32,7 +32,7 @@\n     private final Map<java.util.logging.Level, Level> JDK_TO_LOG4J =\n         new IdentityHashMap<java.util.logging.Level, Level>(9);\n     private final Map<Level, java.util.logging.Level> LOG4J_TO_JDK =\n-        new IdentityHashMap<Level, java.util.logging.Level>(9);\n+        new IdentityHashMap<Level, java.util.logging.Level>(10);\n \n     public DefaultLevelConverter() {\n         JDK_TO_LOG4J.put(java.util.logging.Level.OFF, Level.OFF);\n@@ -52,6 +52,7 @@ public DefaultLevelConverter() {\n         LOG4J_TO_JDK.put(Level.INFO, java.util.logging.Level.INFO);\n         LOG4J_TO_JDK.put(Level.WARN, java.util.logging.Level.WARNING);\n         LOG4J_TO_JDK.put(Level.ERROR, java.util.logging.Level.SEVERE);\n+        LOG4J_TO_JDK.put(Level.FATAL, java.util.logging.Level.SEVERE);\n         LOG4J_TO_JDK.put(Level.ALL, java.util.logging.Level.ALL);\n     }\n \n",
        "project": "logging-log4j2",
        "linesAdd": 2,
        "jira_id": "892",
        "nb_skipped": 0,
        "commit": "f9b0bbee",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 104,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.filter.StructuredDataFilterTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/filter/StructuredDataFilter.java b/core/src/main/java/org/apache/logging/log4j/core/filter/StructuredDataFilter.java\nindex 26e12a69b..6c9a86298 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/filter/StructuredDataFilter.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/filter/StructuredDataFilter.java\n@@ -22,6 +22,7 @@\n import org.apache.logging.log4j.core.Logger;\n import org.apache.logging.log4j.core.config.plugins.Plugin;\n import org.apache.logging.log4j.core.config.plugins.PluginAttr;\n+import org.apache.logging.log4j.core.config.plugins.PluginElement;\n import org.apache.logging.log4j.core.config.plugins.PluginFactory;\n import org.apache.logging.log4j.core.helpers.KeyValuePair;\n import org.apache.logging.log4j.message.Message;\n@@ -98,7 +99,7 @@ private String getValue(StructuredDataMessage data, String key) {\n      * @return The StructuredDataFilter.\n      */\n     @PluginFactory\n-    public static StructuredDataFilter createFilter(@PluginAttr(\"pairs\") KeyValuePair[] pairs,\n+    public static StructuredDataFilter createFilter(@PluginElement(\"pairs\") KeyValuePair[] pairs,\n                                                     @PluginAttr(\"operator\") String oper,\n                                                     @PluginAttr(\"onmatch\") String match,\n                                                     @PluginAttr(\"onmismatch\") String mismatch) {\n",
        "project": "logging-log4j2",
        "linesAdd": 2,
        "jira_id": "113",
        "nb_skipped": 0,
        "commit": "fc3e9d2d",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 774,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.net.server.UdpJsonSocketServerTest",
            "org.apache.logging.log4j.core.net.server.TcpJsonSocketServerTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/JsonInputStreamLogEventBridge.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/JsonInputStreamLogEventBridge.java\nindex 1b8164426..8ed273248 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/JsonInputStreamLogEventBridge.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/JsonInputStreamLogEventBridge.java\n@@ -55,8 +55,10 @@ public JsonInputStreamLogEventBridge(final int bufferSize, final Charset charset\n         boolean inEsc = false;\n         for (int i = start; i < charArray.length; i++) {\n             final char c = charArray[i];\n-            if (!inEsc) {\n+            if (inEsc) {\n+            \t// Skip this char and continue\n             \tinEsc = false;\n+            } else { \n                 switch (c) {\n                 case EVENT_START_MARKER:\n                     if (!inStr) {\n",
        "project": "logging-log4j2",
        "linesAdd": 2,
        "jira_id": "1069",
        "nb_skipped": 2,
        "commit": "e9b628ec",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 72,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.appender.rolling.RollingAppenderTimeAndSizeTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/appender/rolling/helper/FileRenameAction.java b/core/src/main/java/org/apache/logging/log4j/core/appender/rolling/helper/FileRenameAction.java\nindex 0f6c367ff..5d1cff9bd 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/appender/rolling/helper/FileRenameAction.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/appender/rolling/helper/FileRenameAction.java\n@@ -16,6 +16,9 @@\n  */\n package org.apache.logging.log4j.core.appender.rolling.helper;\n \n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.status.StatusLogger;\n+\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileOutputStream;\n@@ -27,6 +30,9 @@\n  * File rename action.\n  */\n public final class FileRenameAction extends ActionBase {\n+\n+    private static final Logger LOGGER = StatusLogger.getLogger();\n+\n     /**\n      * Source.\n      */\n@@ -74,17 +80,31 @@ public boolean execute() {\n      */\n     public static boolean execute(final File source, final File destination, boolean renameEmptyFiles) {\n         if (renameEmptyFiles || (source.length() > 0)) {\n+            File parent = destination.getParentFile();\n+            if (!parent.exists()) {\n+                if (!parent.mkdirs()) {\n+                    LOGGER.error(\"Unable to create directory {}\", parent.getAbsolutePath());\n+                    return false;\n+                }\n+            }\n             try {\n-\n-                boolean result = source.renameTo(destination);\n-                //System.out.println(\"Rename of \" + source.getName() + \" to \" + destination.getName() + \": \" + result);\n-                return result;\n+                if (!source.renameTo(destination)) {\n+                    try {\n+                        copyFile(source, destination);\n+                        return source.delete();\n+                    } catch (IOException iex) {\n+                        LOGGER.error(\"Unable to rename file {} to {} - {}\", source.getAbsolutePath(),\n+                            destination.getAbsolutePath(), iex.getMessage());\n+                    }\n+                }\n+                return true;\n             } catch (Exception ex) {\n                 try {\n                     copyFile(source, destination);\n                     return source.delete();\n                 } catch (IOException iex) {\n-                    iex.printStackTrace();\n+                    LOGGER.error(\"Unable to rename file {} to {} - {}\", source.getAbsolutePath(),\n+                        destination.getAbsolutePath(), iex.getMessage());\n                 }\n             }\n         }\n",
        "project": "logging-log4j2",
        "linesAdd": 25,
        "jira_id": "71",
        "nb_skipped": 0,
        "commit": "2afe3dff",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 88,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.appender.SyslogAppenderTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/appender/SyslogAppender.java b/core/src/main/java/org/apache/logging/log4j/core/appender/SyslogAppender.java\nindex d2392e9ec..39fbd3871 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/appender/SyslogAppender.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/appender/SyslogAppender.java\n@@ -111,7 +111,7 @@ public static SyslogAppender createAppender(@PluginAttr(\"host\") String host,\n                 LOGGER.error(\"Charset \" + charset + \" is not supported for layout, using \" + c.displayName());\n             }\n         }\n-        Layout layout = (format.equalsIgnoreCase(RFC5424)) ?\n+        Layout layout = (RFC5424.equalsIgnoreCase(format)) ?\n             RFC5424Layout.createLayout(facility, id, ein, includeMDC, mdcId, includeNL, appName,  msgId,\n                 excludes, includes, required, charset, config) :\n             SyslogLayout.createLayout(facility, includeNL, charset);\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "101",
        "nb_skipped": 0,
        "commit": "c79a743b",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 740,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.appender.ConsoleAppenderTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/ConsoleAppender.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/ConsoleAppender.java\nindex 760db2c12..c318d37c6 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/ConsoleAppender.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/ConsoleAppender.java\n@@ -182,23 +182,28 @@ private static OutputStream getOutputStream(final boolean follow, final Target t\n         final String enc = Charset.defaultCharset().name();\n         PrintStream printStream = null;\n         try {\n+            // Cannot use a CloseShieldOutputStream here;\n+            // see org.apache.logging.log4j.core.appender.ConsoleAppenderTest\n+            // @formatter:off\n             printStream = target == Target.SYSTEM_OUT ?\n-            follow ? new PrintStream(new CloseShieldOutputStream(System.out), true, enc) : System.out :\n-            follow ? new PrintStream(new CloseShieldOutputStream(System.err), true, enc) : System.err;\n+            follow ? new PrintStream(new SystemOutStream(), true, enc) : System.out :\n+            follow ? new PrintStream(new SystemErrStream(), true, enc) : System.err;\n+            // @formatter:on\n         } catch (final UnsupportedEncodingException ex) { // should never happen\n             throw new IllegalStateException(\"Unsupported default encoding \" + enc, ex);\n         }\n         final PropertiesUtil propsUtil = PropertiesUtil.getProperties();\n-        if (!propsUtil.getStringProperty(\"os.name\").startsWith(\"Windows\") ||\n-            propsUtil.getBooleanProperty(\"log4j.skipJansi\")) {\n+        if (!propsUtil.getStringProperty(\"os.name\").startsWith(\"Windows\")\n+                || propsUtil.getBooleanProperty(\"log4j.skipJansi\")) {\n             return printStream;\n         }\n         try {\n             // We type the parameter as a wildcard to avoid a hard reference to Jansi.\n             final Class<?> clazz = Loader.loadClass(JANSI_CLASS);\n             final Constructor<?> constructor = clazz.getConstructor(OutputStream.class);\n+            OutputStream newInstance = (OutputStream) constructor.newInstance(printStream);\n             // LOG4J-965\n-            return new CloseShieldOutputStream((OutputStream) constructor.newInstance(printStream));\n+            return follow ? new CloseShieldOutputStream(newInstance) : newInstance;\n         } catch (final ClassNotFoundException cnfe) {\n             LOGGER.debug(\"Jansi is not installed, cannot find {}\", JANSI_CLASS);\n         } catch (final NoSuchMethodException nsme) {\n@@ -209,6 +214,74 @@ private static OutputStream getOutputStream(final boolean follow, final Target t\n         return printStream;\n     }\n \n+    /**\n+     * An implementation of OutputStream that redirects to the current System.err.\n+     */\n+    private static class SystemErrStream extends OutputStream {\n+        public SystemErrStream() {\n+        }\n+\n+        @Override\n+        public void close() {\n+            // do not close sys err!\n+        }\n+\n+        @Override\n+        public void flush() {\n+            System.err.flush();\n+        }\n+\n+        @Override\n+        public void write(final byte[] b) throws IOException {\n+            System.err.write(b);\n+        }\n+\n+        @Override\n+        public void write(final byte[] b, final int off, final int len)\n+            throws IOException {\n+            System.err.write(b, off, len);\n+        }\n+\n+        @Override\n+        public void write(final int b) {\n+            System.err.write(b);\n+        }\n+    }\n+\n+    /**\n+     * An implementation of OutputStream that redirects to the current System.out.\n+     */\n+    private static class SystemOutStream extends OutputStream {\n+        public SystemOutStream() {\n+        }\n+\n+        @Override\n+        public void close() {\n+            // do not close sys out!\n+        }\n+\n+        @Override\n+        public void flush() {\n+            System.out.flush();\n+        }\n+\n+        @Override\n+        public void write(final byte[] b) throws IOException {\n+            System.out.write(b);\n+        }\n+\n+        @Override\n+        public void write(final byte[] b, final int off, final int len)\n+            throws IOException {\n+            System.out.write(b, off, len);\n+        }\n+\n+        @Override\n+        public void write(final int b) throws IOException {\n+            System.out.write(b);\n+        }\n+    }\n+    \n     /**\n      * A delegating OutputStream that does not close its delegate.\n      */\n",
        "project": "logging-log4j2",
        "linesAdd": 66,
        "jira_id": "965",
        "nb_skipped": 2,
        "commit": "43517f15",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1168,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.appender.XmlCompleteFileAppenderTest",
            "org.apache.logging.log4j.core.appender.XmlFileAppenderTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java\nindex 763f42ab7..3b34957c5 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java\n@@ -19,12 +19,15 @@\n import java.util.HashSet;\n import java.util.Set;\n \n+import javax.xml.stream.XMLStreamException;\n+\n import org.apache.logging.log4j.core.impl.Log4jLogEvent;\n import org.apache.logging.log4j.core.jackson.JsonConstants;\n import org.apache.logging.log4j.core.jackson.Log4jJsonObjectMapper;\n import org.apache.logging.log4j.core.jackson.Log4jXmlObjectMapper;\n import org.apache.logging.log4j.core.jackson.Log4jYamlObjectMapper;\n import org.apache.logging.log4j.core.jackson.XmlConstants;\n+import org.codehaus.stax2.XMLStreamWriter2;\n \n import com.fasterxml.jackson.core.PrettyPrinter;\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n@@ -72,6 +75,8 @@ protected PrettyPrinter newPrettyPrinter() {\n \n     static class XML extends JacksonFactory {\n \n+        static final int DEFAULT_INDENT = 1;\n+        \n         @Override\n         protected String getPropertNameForContextMap() {\n             return XmlConstants.ELT_CONTEXT_MAP;\n@@ -100,7 +105,7 @@ protected ObjectMapper newObjectMapper() {\n \n         @Override\n         protected PrettyPrinter newPrettyPrinter() {\n-            return new DefaultXmlPrettyPrinter();\n+            return new Log4jXmlPrettyPrinter(DEFAULT_INDENT);\n         }\n     }\n \n@@ -137,6 +142,38 @@ protected PrettyPrinter newPrettyPrinter() {\n         }\n     }\n \n+    /**\n+     * When &lt;Event&gt;s are written into a XML file; the \"Event\" object is not the root element, but an element named\n+     * &lt;Events&gt; created using {@link #getHeader()} and {@link #getFooter()} methods.<br/>\n+     * {@link com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter} is used to print the Event object into\n+     * XML; hence it assumes &lt;Event&gt; tag as the root element, so it prints the &lt;Event&gt; tag without any\n+     * indentation. To add an indentation to the &lt;Event&gt; tag; hence an additional indentation for any\n+     * sub-elements, this class is written. As an additional task, to avoid the blank line printed after the ending\n+     * &lt;/Event&gt; tag, {@link #writePrologLinefeed(XMLStreamWriter2)} method is also overridden.\n+     */\n+    static class Log4jXmlPrettyPrinter extends DefaultXmlPrettyPrinter {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        Log4jXmlPrettyPrinter(int nesting) {\n+            _nesting = nesting;\n+        }\n+\n+        @Override\n+        public void writePrologLinefeed(XMLStreamWriter2 sw) throws XMLStreamException {\n+            // nothing\n+        }\n+\n+        /**\n+         * Sets the nesting level to 1 rather than 0, so the \"Event\" tag will get indentation of next level below root.\n+         */\n+        @Override\n+        public DefaultXmlPrettyPrinter createInstance() {\n+            return new Log4jXmlPrettyPrinter(XML.DEFAULT_INDENT);\n+        }\n+\n+    }\n+\n     abstract protected String getPropertNameForContextMap();\n \n     abstract protected String getPropertNameForSource();\n",
        "project": "logging-log4j2",
        "linesAdd": 25,
        "jira_id": "1372",
        "nb_skipped": 3,
        "commit": "1d12bf0e",
        "nb_failure": 3,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 413,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.appender.SMTPAppenderTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/SMTPManager.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/SMTPManager.java\nindex dd0b7fb84..ebd45e19c 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/SMTPManager.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/SMTPManager.java\n@@ -136,9 +136,8 @@ public void sendEvents(final Layout<?> layout, final LogEvent appendEvent) {\n         }\n         try {\n             final LogEvent[] priorEvents = buffer.removeAll();\n-            if (priorEvents == null || priorEvents.length == 0) {\n-                return; // nothing to do, another thread already took all events\n-            }\n+            // LOG4J-310: log appendEvent even if priorEvents is empty\n+            \n             final byte[] rawBytes = formatContentToBytes(priorEvents, appendEvent, layout);\n \n             final String contentType = layout.getContentType();\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "310",
        "nb_skipped": 5,
        "commit": "3f1e0fdc",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 659,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.appender.XmlCompleteFileAppenderTest",
            "org.apache.logging.log4j.core.appender.XmlCompactFileAppenderTest",
            "org.apache.logging.log4j.core.appender.XmlFileAppenderTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/AbstractConfiguration.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/AbstractConfiguration.java\nindex 7e577bbbd..509f6c723 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/AbstractConfiguration.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/AbstractConfiguration.java\n@@ -151,13 +151,17 @@ public void start() {\n         setup();\n         setupAdvertisement();\n         doConfigure();\n+        final Set<LoggerConfig> alreadyStarted = new HashSet<LoggerConfig>();\n         for (final LoggerConfig logger : loggers.values()) {\n             logger.start();\n+            alreadyStarted.add(logger);\n         }\n         for (final Appender appender : appenders.values()) {\n             appender.start();\n         }\n+        if (!alreadyStarted.contains(root)) { // LOG4J2-392\n             root.start(); // LOG4J2-336\n+        }\n         super.start();\n         LOGGER.debug(\"Started configuration {} OK.\", this);\n     }\n@@ -185,7 +189,7 @@ public void stop() {\n             }\n         }\n         // similarly, first stop AsyncLoggerConfig Disruptor thread(s)\n-        Set<LoggerConfig> alreadyStopped = new HashSet<LoggerConfig>();\n+        final Set<LoggerConfig> alreadyStopped = new HashSet<LoggerConfig>();\n         int asyncLoggerConfigCount = 0;\n         for (final LoggerConfig logger : loggers.values()) {\n             if (logger instanceof AsyncLoggerConfig) {\n",
        "project": "logging-log4j2",
        "linesAdd": 5,
        "jira_id": "392",
        "nb_skipped": 2,
        "commit": "731c84b5",
        "nb_failure": 3,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 209,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.simple.SimpleLoggerTest"
        ],
        "patch": "diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/simple/SimpleLogger.java b/log4j-api/src/main/java/org/apache/logging/log4j/simple/SimpleLogger.java\nindex a47494074..90fc5985a 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/simple/SimpleLogger.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/simple/SimpleLogger.java\n@@ -154,7 +154,7 @@ public void logMessage(final String fqcn, final Level level, final Marker marker\n         }\n         final Object[] params = msg.getParameters();\n         Throwable t;\n-        if (throwable == null && params != null && params[params.length - 1] instanceof Throwable) {\n+        if (throwable == null && params != null && params.length > 0 && params[params.length - 1] instanceof Throwable) {\n             t = (Throwable) params[params.length - 1];\n         } else {\n             t = throwable;\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "811",
        "nb_skipped": 2,
        "commit": "7bb1ad47",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 331,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.layout.HTMLLayoutTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/layout/HTMLLayout.java b/core/src/main/java/org/apache/logging/log4j/core/layout/HTMLLayout.java\nindex 7adce603d..76dfdfea6 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/layout/HTMLLayout.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/layout/HTMLLayout.java\n@@ -258,6 +258,7 @@ private void appendThrowableAsHTML(final Throwable throwable, final StringBuilde\n         sbuf.append(Constants.LINE_SEP);\n         sbuf.append(\"<html>\").append(Constants.LINE_SEP);\n         sbuf.append(\"<head>\").append(Constants.LINE_SEP);\n+        sbuf.append(\"<meta charset=\\\"\").append(getCharset()).append(\"\\\"/>\").append(Constants.LINE_SEP);\n         sbuf.append(\"<title>\").append(title).append(\"</title>\").append(Constants.LINE_SEP);\n         sbuf.append(\"<style type=\\\"text/css\\\">\").append(Constants.LINE_SEP);\n         sbuf.append(\"<!--\").append(Constants.LINE_SEP);\n@@ -317,7 +318,7 @@ public static HTMLLayout createLayout(@PluginAttr(\"locationInfo\") final String l\n                                           @PluginAttr(\"charset\") final String charsetName,\n                                           @PluginAttr(\"fontSize\") String fontSize,\n                                           @PluginAttr(\"fontName\") String font) {\n-        final Charset charset = Charsets.getSupportedCharset(charsetName);\n+        final Charset charset = Charsets.getSupportedCharset(charsetName, Charsets.UTF_8);\n         if (font == null) {\n             font = \"arial,sans-serif\";\n         }\n",
        "project": "logging-log4j2",
        "linesAdd": 2,
        "jira_id": "258",
        "nb_skipped": 3,
        "commit": "7b38965d",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 766,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.impl.ThrowableProxyTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\nindex 67d55ece6..d0800cc5a 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n@@ -207,8 +207,8 @@ private void formatCause(final StringBuilder sb, final ThrowableProxy cause, fin\n \t\t\treturn;\n \t\t}\n \t\tsb.append(\"Caused by: \").append(cause).append(EOL);\n-        this.formatElements(sb, cause.commonElementCount, cause.getThrowable().getStackTrace(),\n-                cause.extendedStackTrace, ignorePackages);\n+\t\tthis.formatElements(sb, cause.commonElementCount, cause.getStackTrace(), cause.extendedStackTrace,\n+\t\t\t\tignorePackages);\n \t\tthis.formatCause(sb, cause.causeProxy, ignorePackages);\n \t}\n \n",
        "project": "logging-log4j2",
        "linesAdd": 2,
        "jira_id": "1067",
        "nb_skipped": 2,
        "commit": "4786a739",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 9,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "",
            "org.apache.logging.log4j.nosql.appender.NoSQLDatabaseManagerTest"
        ],
        "patch": "diff --git a/log4j-nosql/src/main/java/org/apache/logging/log4j/nosql/appender/NoSQLDatabaseManager.java b/log4j-nosql/src/main/java/org/apache/logging/log4j/nosql/appender/NoSQLDatabaseManager.java\nindex 6f2ea2620..d3c5b37ca 100644\n--- a/log4j-nosql/src/main/java/org/apache/logging/log4j/nosql/appender/NoSQLDatabaseManager.java\n+++ b/log4j-nosql/src/main/java/org/apache/logging/log4j/nosql/appender/NoSQLDatabaseManager.java\n@@ -51,6 +51,7 @@ protected void startupInternal() {\n \n     @Override\n     protected void shutdownInternal() {\n+        // NoSQL doesn't use transactions, so all we need to do here is simply close the client\n         Closer.closeSilent(this.connection);\n     }\n \n@@ -155,13 +156,10 @@ protected void writeInternal(final LogEvent event) {\n \n     @Override\n     protected void commitAndClose() {\n-        try {\n-            if (this.connection != null && !this.connection.isClosed()) {\n-                this.connection.close();\n-            }\n-        } catch (Exception e) {\n-            throw new AppenderLoggingException(\"Failed to commit and close NoSQL connection in manager.\", e);\n-        }\n+        // all NoSQL drivers auto-commit (since NoSQL doesn't generally use the concept of transactions).\n+        // also, all our NoSQL drivers use internal connection pooling and provide clients, not connections.\n+        // thus, we should not be closing the client until shutdown as NoSQL is very different from SQL.\n+        // see LOG4J2-591 and LOG4J2-676\n     }\n \n     private NoSQLObject<W>[] convertStackTrace(final StackTraceElement[] stackTrace) {\n",
        "project": "logging-log4j2",
        "linesAdd": 0,
        "jira_id": "676",
        "nb_skipped": 0,
        "commit": "3b2e880e",
        "nb_failure": 1,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 479,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.AppenderRefLevelJsonTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/JSONConfiguration.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/JSONConfiguration.java\nindex be6250929..892c45bc3 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/JSONConfiguration.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/JSONConfiguration.java\n@@ -232,14 +232,25 @@ private Node constructNode(final String name, final Node parent, final JsonNode\n                             if (itemEntry.getValue().isObject()) {\n                                 LOGGER.debug(\"Processing node for object \" + itemEntry.getKey());\n                                 itemChildren.add(constructNode(itemEntry.getKey(), item, itemEntry.getValue()));\n+                            } else if (itemEntry.getValue().isArray()) {\n+                                JsonNode array = itemEntry.getValue();\n+                                String entryName = itemEntry.getKey();\n+                                LOGGER.debug(\"Processing array for object \" + entryName);\n+                                final PluginType<?> itemEntryType = pluginManager.getPluginType(entryName);\n+                                for (int j = 0; j < array.size(); ++j) {\n+                                    itemChildren.add(constructNode(entryName, item, array.get(j)));\n                                 }\n                             }\n+\n+                        }\n                         children.add(item);\n                     }\n                 } else {\n                     LOGGER.debug(\"Processing node for object \" + entry.getKey());\n                     children.add(constructNode(entry.getKey(), node, n));\n                 }\n+            } else {\n+                LOGGER.debug(\"Node {} is of type {}\", entry.getKey(), n.getNodeType());\n             }\n         }\n \n",
        "project": "logging-log4j2",
        "linesAdd": 11,
        "jira_id": "464",
        "nb_skipped": 8,
        "commit": "484c865f",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 18,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.flume.appender.FlumePersistentAppenderTest"
        ],
        "patch": "diff --git a/flume-ng/src/main/java/org/apache/logging/log4j/flume/appender/FlumeEvent.java b/flume-ng/src/main/java/org/apache/logging/log4j/flume/appender/FlumeEvent.java\nindex c8e45474b..d448a6603 100644\n--- a/flume-ng/src/main/java/org/apache/logging/log4j/flume/appender/FlumeEvent.java\n+++ b/flume-ng/src/main/java/org/apache/logging/log4j/flume/appender/FlumeEvent.java\n@@ -128,11 +128,14 @@ public FlumeEvent(final LogEvent event, final String includes, final String excl\n         final String guid =  UUIDUtil.getTimeBasedUUID().toString();\n         final Message message = event.getMessage();\n         if (message instanceof MapMessage) {\n+            // Add the guid to the Map so that it can be included in the Layout.\n             ((MapMessage) message).put(GUID, guid);\n             if (message instanceof StructuredDataMessage) {\n                 addStructuredData(eventPrefix, headers, (StructuredDataMessage) message);\n             }\n             addMapData(eventPrefix, headers, (MapMessage) message);\n+        } else {\n+            headers.put(GUID, guid);\n         }\n \n         addContextData(mdcPrefix, headers, ctx);\n",
        "project": "logging-log4j2",
        "linesAdd": 2,
        "jira_id": "268",
        "nb_skipped": 0,
        "commit": "8faf7f77",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 5,
        "nb_test": 515,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.HostNameTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/LoggerContext.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/LoggerContext.java\nindex 0759bc450..a8af6aec9 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/LoggerContext.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/LoggerContext.java\n@@ -334,10 +334,9 @@ private synchronized Configuration setConfiguration(final Configuration config)\n         }\n         final Configuration prev = this.config;\n         config.addListener(this);\n-        final Map<String, String> map = new HashMap<String, String>();\n-        map.put(\"hostName\", NetUtils.getLocalHostname());\n-        map.put(\"contextName\", name);\n-        config.addComponent(Configuration.CONTEXT_PROPERTIES, map);\n+        final ConcurrentMap<String, String> map = config.getComponent(Configuration.CONTEXT_PROPERTIES);\n+        map.putIfAbsent(\"hostName\", NetUtils.getLocalHostname());\n+        map.putIfAbsent(\"contextName\", name);\n         config.start();\n         this.config = config;\n         updateLoggers();\ndiff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\nindex 2b5c41f26..986d2b921 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\n@@ -104,7 +104,9 @@\n \n     private ConcurrentMap<String, LoggerConfig> loggers = new ConcurrentHashMap<String, LoggerConfig>();\n \n-    private final StrLookup tempLookup = new Interpolator();\n+    private ConcurrentMap<String, String> properties = new ConcurrentHashMap<String, String>();\n+\n+    private final StrLookup tempLookup = new Interpolator(properties);\n \n     private final StrSubstitutor subst = new StrSubstitutor(tempLookup);\n \n@@ -120,6 +122,7 @@\n      * Constructor.\n      */\n     protected BaseConfiguration() {\n+        componentMap.put(Configuration.CONTEXT_PROPERTIES, properties);\n         pluginManager = new PluginManager(\"Core\");\n         rootNode = new Node();\n     }\n@@ -127,7 +130,7 @@ protected BaseConfiguration() {\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public Map<String, String> getProperties() {\n-        return (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);\n+        return properties;\n     }\n \n     /**\ndiff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/PropertiesPlugin.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/PropertiesPlugin.java\nindex b804d4515..6c5c3f3a7 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/PropertiesPlugin.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/PropertiesPlugin.java\n@@ -44,7 +44,7 @@ private PropertiesPlugin() {\n     public static StrLookup configureSubstitutor(@PluginElement(\"Properties\") final Property[] properties,\n                                                  @PluginConfiguration final Configuration config) {\n         if (properties == null) {\n-            return new Interpolator(null);\n+            return new Interpolator(config.getProperties());\n         }\n         final Map<String, String> map = new HashMap<String, String>(config.getProperties());\n \ndiff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\nindex bf463de8c..a768f4e7d 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\n@@ -60,7 +60,14 @@ public Interpolator(final StrLookup defaultLookup) {\n      * Create the default Interpolator using only Lookups that work without an event.\n      */\n     public Interpolator() {\n-        this.defaultLookup = new MapLookup(new HashMap<String, String>());\n+        this((Map<String, String>) null);\n+    }\n+\n+    /**\n+     * Create the dInterpolator using only Lookups that work without an event and initial properties.\n+     */\n+    public Interpolator(Map<String, String> properties) {\n+        this.defaultLookup = new MapLookup(properties == null ? new HashMap<String, String>() : properties);\n         lookups.put(\"sys\", new SystemPropertiesLookup());\n         lookups.put(\"env\", new EnvironmentLookup());\n         lookups.put(\"jndi\", new JndiLookup());\ndiff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jWebInitializerImpl.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jWebInitializerImpl.java\nindex 7d14a1406..78708dce8 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jWebInitializerImpl.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jWebInitializerImpl.java\n@@ -17,12 +17,15 @@\n package org.apache.logging.log4j.core.web;\n \n import java.net.URI;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n import javax.servlet.ServletContext;\n import javax.servlet.UnavailableException;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.core.LoggerContext;\n import org.apache.logging.log4j.core.config.Configurator;\n+import org.apache.logging.log4j.core.helpers.NetUtils;\n import org.apache.logging.log4j.core.impl.ContextAnchor;\n import org.apache.logging.log4j.core.impl.Log4jContextFactory;\n import org.apache.logging.log4j.core.lookup.Interpolator;\n@@ -48,7 +51,8 @@\n         }\n     }\n \n-    private final StrSubstitutor substitutor = new StrSubstitutor(new Interpolator());\n+    private final Map<String, String> map = new ConcurrentHashMap<String, String>();\n+    private final StrSubstitutor substitutor = new StrSubstitutor(new Interpolator(map));\n     private final ServletContext servletContext;\n \n     private String name;\n@@ -60,6 +64,7 @@\n \n     private Log4jWebInitializerImpl(final ServletContext servletContext) {\n         this.servletContext = servletContext;\n+        map.put(\"hostName\", NetUtils.getLocalHostname());\n     }\n \n     @Override\n",
        "project": "logging-log4j2",
        "linesAdd": 20,
        "jira_id": "470",
        "nb_skipped": 1,
        "commit": "50340d0c",
        "nb_failure": 1,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 225,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.message.StringFormattedMessageTest"
        ],
        "patch": "diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/StringFormattedMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/StringFormattedMessage.java\nindex f6007e4ce..4c8429a48 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/StringFormattedMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/StringFormattedMessage.java\n@@ -133,7 +133,9 @@ private void writeObject(final ObjectOutputStream out) throws IOException {\n         stringArgs = new String[argArray.length];\n         int i = 0;\n         for (final Object obj : argArray) {\n-            stringArgs[i] = obj.toString();\n+            final String string = obj.toString();\n+            stringArgs[i] = string;\n+            out.writeUTF(string);\n             ++i;\n         }\n     }\n",
        "project": "logging-log4j2",
        "linesAdd": 3,
        "jira_id": "964",
        "nb_skipped": 3,
        "commit": "16ad8763",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1156,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.appender.XmlCompleteFileAppenderTest",
            "org.apache.logging.log4j.core.appender.XmlFileAppenderTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java\nindex 763f42ab7..3b34957c5 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java\n@@ -19,12 +19,15 @@\n import java.util.HashSet;\n import java.util.Set;\n \n+import javax.xml.stream.XMLStreamException;\n+\n import org.apache.logging.log4j.core.impl.Log4jLogEvent;\n import org.apache.logging.log4j.core.jackson.JsonConstants;\n import org.apache.logging.log4j.core.jackson.Log4jJsonObjectMapper;\n import org.apache.logging.log4j.core.jackson.Log4jXmlObjectMapper;\n import org.apache.logging.log4j.core.jackson.Log4jYamlObjectMapper;\n import org.apache.logging.log4j.core.jackson.XmlConstants;\n+import org.codehaus.stax2.XMLStreamWriter2;\n \n import com.fasterxml.jackson.core.PrettyPrinter;\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n@@ -72,6 +75,8 @@ protected PrettyPrinter newPrettyPrinter() {\n \n     static class XML extends JacksonFactory {\n \n+        static final int DEFAULT_INDENT = 1;\n+        \n         @Override\n         protected String getPropertNameForContextMap() {\n             return XmlConstants.ELT_CONTEXT_MAP;\n@@ -100,7 +105,7 @@ protected ObjectMapper newObjectMapper() {\n \n         @Override\n         protected PrettyPrinter newPrettyPrinter() {\n-            return new DefaultXmlPrettyPrinter();\n+            return new Log4jXmlPrettyPrinter(DEFAULT_INDENT);\n         }\n     }\n \n@@ -137,6 +142,38 @@ protected PrettyPrinter newPrettyPrinter() {\n         }\n     }\n \n+    /**\n+     * When &lt;Event&gt;s are written into a XML file; the \"Event\" object is not the root element, but an element named\n+     * &lt;Events&gt; created using {@link #getHeader()} and {@link #getFooter()} methods.<br/>\n+     * {@link com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter} is used to print the Event object into\n+     * XML; hence it assumes &lt;Event&gt; tag as the root element, so it prints the &lt;Event&gt; tag without any\n+     * indentation. To add an indentation to the &lt;Event&gt; tag; hence an additional indentation for any\n+     * sub-elements, this class is written. As an additional task, to avoid the blank line printed after the ending\n+     * &lt;/Event&gt; tag, {@link #writePrologLinefeed(XMLStreamWriter2)} method is also overridden.\n+     */\n+    static class Log4jXmlPrettyPrinter extends DefaultXmlPrettyPrinter {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        Log4jXmlPrettyPrinter(int nesting) {\n+            _nesting = nesting;\n+        }\n+\n+        @Override\n+        public void writePrologLinefeed(XMLStreamWriter2 sw) throws XMLStreamException {\n+            // nothing\n+        }\n+\n+        /**\n+         * Sets the nesting level to 1 rather than 0, so the \"Event\" tag will get indentation of next level below root.\n+         */\n+        @Override\n+        public DefaultXmlPrettyPrinter createInstance() {\n+            return new Log4jXmlPrettyPrinter(XML.DEFAULT_INDENT);\n+        }\n+\n+    }\n+\n     abstract protected String getPropertNameForContextMap();\n \n     abstract protected String getPropertNameForSource();\n",
        "project": "logging-log4j2",
        "linesAdd": 25,
        "jira_id": "1372",
        "nb_skipped": 3,
        "commit": "ffedf33f",
        "nb_failure": 3,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 745,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.config.plugins.util.ResolverUtilTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/util/ResolverUtil.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/util/ResolverUtil.java\nindex 475ef9cd3..65da5bca3 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/util/ResolverUtil.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/plugins/util/ResolverUtil.java\n@@ -22,6 +22,7 @@\n import java.io.IOException;\n import java.io.UnsupportedEncodingException;\n import java.net.URI;\n+import java.net.URISyntaxException;\n import java.net.URL;\n import java.net.URLDecoder;\n import java.util.Arrays;\n@@ -41,26 +42,29 @@\n import org.osgi.framework.wiring.BundleWiring;\n \n /**\n- * <p>ResolverUtil is used to locate classes that are available in the/a class path and meet\n- * arbitrary conditions. The two most common conditions are that a class implements/extends\n- * another class, or that is it annotated with a specific annotation. However, through the use\n- * of the {@link Test} class it is possible to search using arbitrary conditions.</p>\n+ * <p>\n+ * ResolverUtil is used to locate classes that are available in the/a class path and meet arbitrary conditions. The two\n+ * most common conditions are that a class implements/extends another class, or that is it annotated with a specific\n+ * annotation. However, through the use of the {@link Test} class it is possible to search using arbitrary conditions.\n+ * </p>\n  *\n- * <p>A ClassLoader is used to locate all locations (directories and jar files) in the class\n- * path that contain classes within certain packages, and then to load those classes and\n- * check them. By default the ClassLoader returned by\n- *  {@code Thread.currentThread().getContextClassLoader()} is used, but this can be overridden\n- * by calling {@link #setClassLoader(ClassLoader)} prior to invoking any of the {@code find()}\n- * methods.</p>\n+ * <p>\n+ * A ClassLoader is used to locate all locations (directories and jar files) in the class path that contain classes\n+ * within certain packages, and then to load those classes and check them. By default the ClassLoader returned by\n+ * {@code Thread.currentThread().getContextClassLoader()} is used, but this can be overridden by calling\n+ * {@link #setClassLoader(ClassLoader)} prior to invoking any of the {@code find()} methods.\n+ * </p>\n  *\n- * <p>General searches are initiated by calling the\n- * {@link #find(ResolverUtil.Test, String...)} method and supplying\n- * a package name and a Test instance. This will cause the named package <b>and all sub-packages</b>\n- * to be scanned for classes that meet the test. There are also utility methods for the common\n- * use cases of scanning multiple packages for extensions of particular classes, or classes\n- * annotated with a specific annotation.</p>\n+ * <p>\n+ * General searches are initiated by calling the {@link #find(ResolverUtil.Test, String...)} method and supplying a\n+ * package name and a Test instance. This will cause the named package <b>and all sub-packages</b> to be scanned for\n+ * classes that meet the test. There are also utility methods for the common use cases of scanning multiple packages for\n+ * extensions of particular classes, or classes annotated with a specific annotation.\n+ * </p>\n  *\n- * <p>The standard usage pattern for the ResolverUtil class is as follows:</p>\n+ * <p>\n+ * The standard usage pattern for the ResolverUtil class is as follows:\n+ * </p>\n  *\n  * <pre>\n  * ResolverUtil&lt;ActionBean&gt; resolver = new ResolverUtil&lt;ActionBean&gt;();\n@@ -70,7 +74,8 @@\n  * Collection&lt;ActionBean&gt; beans = resolver.getClasses();\n  * </pre>\n  *\n- * <p>This class was copied and modified from Stripes - http://stripes.mc4j.org/confluence/display/stripes/Home\n+ * <p>\n+ * This class was copied and modified from Stripes - http://stripes.mc4j.org/confluence/display/stripes/Home\n  * </p>\n  */\n public class ResolverUtil {\n@@ -88,14 +93,14 @@\n     private final Set<URI> resourceMatches = new HashSet<URI>();\n \n     /**\n-     * The ClassLoader to use when looking for classes. If null then the ClassLoader returned\n-     * by Thread.currentThread().getContextClassLoader() will be used.\n+     * The ClassLoader to use when looking for classes. If null then the ClassLoader returned by\n+     * Thread.currentThread().getContextClassLoader() will be used.\n      */\n     private ClassLoader classloader;\n \n     /**\n-     * Provides access to the classes discovered so far. If no calls have been made to\n-     * any of the {@code find()} methods, this set will be empty.\n+     * Provides access to the classes discovered so far. If no calls have been made to any of the {@code find()}\n+     * methods, this set will be empty.\n      *\n      * @return the set of classes that have been discovered.\n      */\n@@ -105,16 +110,16 @@\n \n     /**\n      * Returns the matching resources.\n+     * \n      * @return A Set of URIs that match the criteria.\n      */\n     public Set<URI> getResources() {\n         return resourceMatches;\n     }\n \n-\n     /**\n-     * Returns the classloader that will be used for scanning for classes. If no explicit\n-     * ClassLoader has been set by the calling, the context class loader will be used.\n+     * Returns the classloader that will be used for scanning for classes. If no explicit ClassLoader has been set by\n+     * the calling, the context class loader will be used.\n      *\n      * @return the ClassLoader that will be used to scan for classes\n      */\n@@ -123,19 +128,24 @@ public ClassLoader getClassLoader() {\n     }\n \n     /**\n-     * Sets an explicit ClassLoader that should be used when scanning for classes. If none\n-     * is set then the context classloader will be used.\n+     * Sets an explicit ClassLoader that should be used when scanning for classes. If none is set then the context\n+     * classloader will be used.\n      *\n-     * @param classloader a ClassLoader to use when scanning for classes\n+     * @param classloader\n+     *        a ClassLoader to use when scanning for classes\n      */\n-    public void setClassLoader(final ClassLoader classloader) { this.classloader = classloader; }\n+    public void setClassLoader(final ClassLoader classloader) {\n+        this.classloader = classloader;\n+    }\n \n     /**\n-     * Attempts to discover classes that pass the test. Accumulated\n-     * classes can be accessed by calling {@link #getClasses()}.\n+     * Attempts to discover classes that pass the test. Accumulated classes can be accessed by calling\n+     * {@link #getClasses()}.\n      *\n-     * @param test the test to determine matching classes\n-     * @param packageNames one or more package names to scan (including subpackages) for classes\n+     * @param test\n+     *        the test to determine matching classes\n+     * @param packageNames\n+     *        one or more package names to scan (including subpackages) for classes\n      */\n     public void find(final Test test, final String... packageNames) {\n         if (packageNames == null) {\n@@ -148,14 +158,14 @@ public void find(final Test test, final String... packageNames) {\n     }\n \n     /**\n-     * Scans for classes starting at the package provided and descending into subpackages.\n-     * Each class is offered up to the Test as it is discovered, and if the Test returns\n-     * true the class is retained.  Accumulated classes can be fetched by calling\n-     * {@link #getClasses()}.\n+     * Scans for classes starting at the package provided and descending into subpackages. Each class is offered up to\n+     * the Test as it is discovered, and if the Test returns true the class is retained. Accumulated classes can be\n+     * fetched by calling {@link #getClasses()}.\n      *\n-     * @param test an instance of {@link Test} that will be used to filter classes\n-     * @param packageName the name of the package from which to start scanning for\n-     *        classes, e.g. {@code net.sourceforge.stripes}\n+     * @param test\n+     *        an instance of {@link Test} that will be used to filter classes\n+     * @param packageName\n+     *        the name of the package from which to start scanning for classes, e.g. {@code net.sourceforge.stripes}\n      */\n     public void findInPackage(final Test test, String packageName) {\n         packageName = packageName.replace('.', '/');\n@@ -198,11 +208,13 @@ public void findInPackage(final Test test, String packageName) {\n                 }\n             } catch (final IOException ioe) {\n                 LOGGER.warn(\"could not read entries\", ioe);\n+            } catch (URISyntaxException e) {\n+                LOGGER.warn(\"could not read entries\", e);\n             }\n         }\n     }\n \n-    String extractPath(final URL url) throws UnsupportedEncodingException {\n+    String extractPath(final URL url) throws UnsupportedEncodingException, URISyntaxException {\n         String urlPath = url.getPath(); // same as getFile but without the Query portion\n         // System.out.println(url.getProtocol() + \"->\" + urlPath);\n \n@@ -226,9 +238,10 @@ String extractPath(final URL url) throws UnsupportedEncodingException {\n         if (neverDecode.contains(protocol)) {\n             return urlPath;\n         }\n-        if (new File(urlPath).exists()) {\n+        final String cleanPath = new URI(urlPath).getPath();\n+        if (new File(cleanPath).exists()) {\n             // if URL-encoded file exists, don't decode it\n-            return urlPath;\n+            return cleanPath;\n         }\n         urlPath = URLDecoder.decode(urlPath, Constants.UTF_8.name());\n         return urlPath;\n@@ -237,8 +250,8 @@ String extractPath(final URL url) throws UnsupportedEncodingException {\n     private void loadImplementationsInBundle(final Test test, final String packageName) {\n         // Do not remove the cast on the next line as removing it will cause a compile error on Java 7.\n         @SuppressWarnings(\"RedundantCast\")\n-        final BundleWiring wiring = (BundleWiring) FrameworkUtil.getBundle(\n-                ResolverUtil.class).adapt(BundleWiring.class);\n+        final BundleWiring wiring = (BundleWiring) FrameworkUtil.getBundle(ResolverUtil.class)\n+                .adapt(BundleWiring.class);\n         @SuppressWarnings(\"unchecked\")\n         final Collection<String> list = (Collection<String>) wiring.listResources(packageName, \"*.class\",\n                 BundleWiring.LISTRESOURCES_RECURSE);\n@@ -247,18 +260,20 @@ private void loadImplementationsInBundle(final Test test, final String packageNa\n         }\n     }\n \n-\n     /**\n-     * Finds matches in a physical directory on a filesystem.  Examines all\n-     * files within a directory - if the File object is not a directory, and ends with <i>.class</i>\n-     * the file is loaded and tested to see if it is acceptable according to the Test.  Operates\n-     * recursively to find classes within a folder structure matching the package structure.\n+     * Finds matches in a physical directory on a filesystem. Examines all files within a directory - if the File object\n+     * is not a directory, and ends with <i>.class</i> the file is loaded and tested to see if it is acceptable\n+     * according to the Test. Operates recursively to find classes within a folder structure matching the package\n+     * structure.\n      *\n-     * @param test a Test used to filter the classes that are discovered\n-     * @param parent the package name up to this directory in the package hierarchy.  E.g. if\n-     *        /classes is in the classpath and we wish to examine files in /classes/org/apache then\n-     *        the values of <i>parent</i> would be <i>org/apache</i>\n-     * @param location a File object representing a directory\n+     * @param test\n+     *        a Test used to filter the classes that are discovered\n+     * @param parent\n+     *        the package name up to this directory in the package hierarchy. E.g. if /classes is in the classpath and\n+     *        we wish to examine files in /classes/org/apache then the values of <i>parent</i> would be\n+     *        <i>org/apache</i>\n+     * @param location\n+     *        a File object representing a directory\n      */\n     private void loadImplementationsInDirectory(final Test test, final String parent, final File location) {\n         final File[] files = location.listFiles();\n@@ -285,13 +300,15 @@ private boolean isTestApplicable(final Test test, final String path) {\n     }\n \n     /**\n-     * Finds matching classes within a jar files that contains a folder structure\n-     * matching the package structure.  If the File is not a JarFile or does not exist a warning\n-     * will be logged, but no error will be raised.\n+     * Finds matching classes within a jar files that contains a folder structure matching the package structure. If the\n+     * File is not a JarFile or does not exist a warning will be logged, but no error will be raised.\n      *\n-     * @param test a Test used to filter the classes that are discovered\n-     * @param parent the parent package under which classes must be in order to be considered\n-     * @param jarFile the jar file to be examined for classes\n+     * @param test\n+     *        a Test used to filter the classes that are discovered\n+     * @param parent\n+     *        the parent package under which classes must be in order to be considered\n+     * @param jarFile\n+     *        the jar file to be examined for classes\n      */\n     private void loadImplementationsInJar(final Test test, final String parent, final File jarFile) {\n         @SuppressWarnings(\"resource\")\n@@ -325,13 +342,15 @@ private void close(final JarInputStream jarStream, final Object source) {\n     }\n \n     /**\n-     * Finds matching classes within a jar files that contains a folder structure\n-     * matching the package structure.  If the File is not a JarFile or does not exist a warning\n-     * will be logged, but no error will be raised.\n+     * Finds matching classes within a jar files that contains a folder structure matching the package structure. If the\n+     * File is not a JarFile or does not exist a warning will be logged, but no error will be raised.\n      *\n-     * @param test a Test used to filter the classes that are discovered\n-     * @param parent the parent package under which classes must be in order to be considered\n-     * @param stream The jar InputStream\n+     * @param test\n+     *        a Test used to filter the classes that are discovered\n+     * @param parent\n+     *        the parent package under which classes must be in order to be considered\n+     * @param stream\n+     *        The jar InputStream\n      */\n     private void loadImplementationsInJar(final Test test, final String parent, final String path,\n             final JarInputStream stream) {\n@@ -346,17 +365,19 @@ private void loadImplementationsInJar(final Test test, final String parent, fina\n                 }\n             }\n         } catch (final IOException ioe) {\n-            LOGGER.error(\"Could not search jar file '\" + path + \"' for classes matching criteria: \" +\n-                test + \" due to an IOException\", ioe);\n+            LOGGER.error(\"Could not search jar file '\" + path + \"' for classes matching criteria: \" + test\n+                    + \" due to an IOException\", ioe);\n         }\n     }\n \n     /**\n-     * Add the class designated by the fully qualified class name provided to the set of\n-     * resolved classes if and only if it is approved by the Test supplied.\n+     * Add the class designated by the fully qualified class name provided to the set of resolved classes if and only if\n+     * it is approved by the Test supplied.\n      *\n-     * @param test the test used to determine if the class matches\n-     * @param fqn the fully qualified name of a class\n+     * @param test\n+     *        the test used to determine if the class matches\n+     * @param fqn\n+     *        the fully qualified name of a class\n      */\n     protected void addIfMatching(final Test test, final String fqn) {\n         try {\n@@ -387,21 +408,25 @@ protected void addIfMatching(final Test test, final String fqn) {\n     }\n \n     /**\n-     * A simple interface that specifies how to test classes to determine if they\n-     * are to be included in the results produced by the ResolverUtil.\n+     * A simple interface that specifies how to test classes to determine if they are to be included in the results\n+     * produced by the ResolverUtil.\n      */\n     public interface Test {\n         /**\n-         * Will be called repeatedly with candidate classes. Must return True if a class\n-         * is to be included in the results, false otherwise.\n-         * @param type The Class to match against.\n+         * Will be called repeatedly with candidate classes. Must return True if a class is to be included in the\n+         * results, false otherwise.\n+         * \n+         * @param type\n+         *        The Class to match against.\n          * @return true if the Class matches.\n          */\n         boolean matches(Class<?> type);\n \n         /**\n          * Test for a resource.\n-         * @param resource The URI to the resource.\n+         * \n+         * @param resource\n+         *        The URI to the resource.\n          * @return true if the resource matches.\n          */\n         boolean matches(URI resource);\n",
        "project": "logging-log4j2",
        "linesAdd": 14,
        "jira_id": "1008",
        "nb_skipped": 2,
        "commit": "0c20bfd8",
        "nb_failure": 1,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 14,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.LoggerTest"
        ],
        "patch": "diff --git a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jLogger.java b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jLogger.java\nindex 5d376294b..e5b2e1fd5 100644\n--- a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jLogger.java\n+++ b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jLogger.java\n@@ -29,6 +29,7 @@\n import org.apache.logging.log4j.spi.ExtendedLogger;\n import org.slf4j.Marker;\n import org.slf4j.MarkerFactory;\n+import org.slf4j.impl.StaticMarkerBinder;\n import org.slf4j.spi.LocationAwareLogger;\n \n /**\n@@ -375,7 +376,14 @@ public void log(final Marker marker, final String fqcn, final int level, final S\n     }\n \n     private static org.apache.logging.log4j.Marker getMarker(final Marker marker) {\n-        return marker != null ? ((org.apache.logging.slf4j.Log4jMarker) marker).getLog4jMarker() : null;\n+        if (marker == null) {\n+            return null;\n+        } else if (marker instanceof Log4jMarker) {\n+            return ((Log4jMarker) marker).getLog4jMarker();\n+        } else {\n+            final Log4jMarkerFactory factory = (Log4jMarkerFactory) StaticMarkerBinder.SINGLETON.getMarkerFactory();\n+            return ((Log4jMarker) factory.getMarker(marker)).getLog4jMarker();\n+        }\n     }\n \n     @Override\ndiff --git a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarkerFactory.java b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarkerFactory.java\nindex 4efd4d173..4183f2cd9 100644\n--- a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarkerFactory.java\n+++ b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarkerFactory.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.logging.slf4j;\n \n+import java.util.Iterator;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n \n@@ -24,14 +25,14 @@\n import org.slf4j.Marker;\n \n /**\n- *\n+ * Log4j/SLF4J bridge to create SLF4J Markers based on name or based on existing SLF4J Markers.\n  */\n public class Log4jMarkerFactory implements IMarkerFactory {\n \n     private final ConcurrentMap<String, Marker> markerMap = new ConcurrentHashMap<String, Marker>();\n \n     /**\n-     * Return a Log4j Marker that is compatible with SLF4J.\n+     * Returns a Log4j Marker that is compatible with SLF4J.\n      * @param name The name of the Marker.\n      * @return A Marker.\n      */\n@@ -45,11 +46,48 @@ public Marker getMarker(final String name) {\n             return marker;\n         }\n         final org.apache.logging.log4j.Marker log4jMarker = MarkerManager.getMarker(name);\n-        marker = new Log4jMarker(log4jMarker);\n+        return addMarkerIfAbsent(name, log4jMarker);\n+    }\n+\n+    private Marker addMarkerIfAbsent(final String name, final org.apache.logging.log4j.Marker log4jMarker) {\n+        final Marker marker = new Log4jMarker(log4jMarker);\n         final Marker existing = markerMap.putIfAbsent(name, marker);\n         return existing == null ? marker : existing;\n     }\n \n+    /**\n+     * Returns a Log4j Marker converted from an existing custom SLF4J Marker.\n+     * @param marker The SLF4J Marker to convert.\n+     * @return A converted Log4j/SLF4J Marker.\n+     * @since 2.1\n+     */\n+    public Marker getMarker(final Marker marker) {\n+        if (marker == null) {\n+            throw new IllegalArgumentException(\"Marker must not be null\");\n+        }\n+        Marker m = markerMap.get(marker.getName());\n+        if (m != null) {\n+            return m;\n+        }\n+        return addMarkerIfAbsent(marker.getName(), convertMarker(marker));\n+    }\n+\n+    private static org.apache.logging.log4j.Marker convertMarker(final Marker original) {\n+        if (original == null) {\n+            throw new IllegalArgumentException(\"Marker must not be null\");\n+        }\n+        final org.apache.logging.log4j.Marker marker = MarkerManager.getMarker(original.getName());\n+        if (original.hasReferences()) {\n+            final Iterator it = original.iterator();\n+            while (it.hasNext()) {\n+                final Marker next = (Marker) it.next();\n+                // kind of hope nobody uses cycles in their Markers. I mean, why would you do that?\n+                marker.addParents(convertMarker(next));\n+            }\n+        }\n+        return marker;\n+    }\n+\n     /**\n      * Returns true if the Marker exists.\n      * @param name The Marker name.\n",
        "project": "logging-log4j2",
        "linesAdd": 41,
        "jira_id": "793",
        "nb_skipped": 0,
        "commit": "73400bfb",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 658,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.async.AsyncLoggersWithAsyncAppenderTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/AsyncAppender.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/AsyncAppender.java\nindex 8178fe26f..e47075780 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/AsyncAppender.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/AsyncAppender.java\n@@ -27,6 +27,7 @@\n import org.apache.logging.log4j.core.Appender;\n import org.apache.logging.log4j.core.Filter;\n import org.apache.logging.log4j.core.LogEvent;\n+import org.apache.logging.log4j.core.async.RingBufferLogEvent;\n import org.apache.logging.log4j.core.config.AppenderControl;\n import org.apache.logging.log4j.core.config.AppenderRef;\n import org.apache.logging.log4j.core.config.Configuration;\n@@ -127,12 +128,15 @@ public void stop() {\n      * @param logEvent The LogEvent.\n      */\n     @Override\n-    public void append(final LogEvent logEvent) {\n+    public void append(LogEvent logEvent) {\n         if (!isStarted()) {\n             throw new IllegalStateException(\"AsyncAppender \" + getName() + \" is not active\");\n         }\n         if (!(logEvent instanceof Log4jLogEvent)) {\n-            return; // only know how to Serialize Log4jLogEvents\n+            if (!(logEvent instanceof RingBufferLogEvent)) {\n+                return; // only know how to Serialize Log4jLogEvents and RingBufferLogEvents\n+            }\n+            logEvent = ((RingBufferLogEvent) logEvent).createMemento();\n         }\n         Log4jLogEvent coreEvent = (Log4jLogEvent) logEvent;\n         boolean appendSuccessful = false;\n",
        "project": "logging-log4j2",
        "linesAdd": 6,
        "jira_id": "668",
        "nb_skipped": 2,
        "commit": "60f64cc1",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 47,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.message.StructuredDataMessageTest"
        ],
        "patch": "diff --git a/api/src/main/java/org/apache/logging/log4j/message/StructuredDataMessage.java b/api/src/main/java/org/apache/logging/log4j/message/StructuredDataMessage.java\nindex d3dee6de7..b4e640172 100644\n--- a/api/src/main/java/org/apache/logging/log4j/message/StructuredDataMessage.java\n+++ b/api/src/main/java/org/apache/logging/log4j/message/StructuredDataMessage.java\n@@ -188,8 +188,8 @@ protected void setMessageFormat(String msg) {\n \n     @Override\n     protected void validate(String key, String value) {\n-        if (value.length() > MAX_LENGTH) {\n-            throw new IllegalArgumentException(\"Structured data values are limited to 32 characters. key: \" + key +\n+        if (key.length() > MAX_LENGTH) {\n+            throw new IllegalArgumentException(\"Structured data keys are limited to 32 characters. key: \" + key +\n                 \" value: \" + value);\n         }\n     }\n",
        "project": "logging-log4j2",
        "linesAdd": 2,
        "jira_id": "114",
        "nb_skipped": 0,
        "commit": "afcf92eb",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 745,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.impl.ThrowableProxyTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\nindex 2d0941f27..1d3af2a06 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java\n@@ -342,7 +342,8 @@ public String getExtendedStackTraceAsString(final List<String> ignorePackages) {\n             sb.append(\": \").append(msg);\n         }\n         sb.append(EOL);\n-        this.formatElements(sb, 0, this.throwable.getStackTrace(), this.extendedStackTrace, ignorePackages);\n+        StackTraceElement[] causedTrace = this.throwable != null ? this.throwable.getStackTrace() : null;\n+        this.formatElements(sb, 0, causedTrace, this.extendedStackTrace, ignorePackages);\n         this.formatCause(sb, this.causeProxy, ignorePackages);\n         return sb.toString();\n     }\n",
        "project": "logging-log4j2",
        "linesAdd": 2,
        "jira_id": "914",
        "nb_skipped": 2,
        "commit": "f8a42197",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 45,
        "nb_error": 21,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.EventLoggerTest",
            "org.apache.logging.log4j.LoggerTest"
        ],
        "patch": "diff --git a/api/src/main/java/org/apache/logging/log4j/LogManager.java b/api/src/main/java/org/apache/logging/log4j/LogManager.java\nindex 8f050ee44..a6452cb55 100644\n--- a/api/src/main/java/org/apache/logging/log4j/LogManager.java\n+++ b/api/src/main/java/org/apache/logging/log4j/LogManager.java\n@@ -39,7 +39,7 @@\n      */\n     public static final String ROOT_LOGGER_NAME = \"\";\n \n-    private static final String LOGGER_RESOURCE = \"META-INF/log4j-provider.xml\";\n+    private static final String LOGGER_RESOURCE = \"META-INF/log4j-provider.properties\";\n     private static final String LOGGER_CONTEXT_FACTORY = \"LoggerContextFactory\";\n     private static final String API_VERSION = \"Log4jAPIVersion\";\n     private static final String FACTORY_PRIORITY = \"FactoryPriority\";\n@@ -95,7 +95,7 @@ protected LogManager() {\n                     Properties props = new Properties();\n                     URL url = enumResources.nextElement();\n                     try {\n-                        props.loadFromXML(url.openStream());\n+                        props.load(url.openStream());\n                     } catch (IOException ioe) {\n                         logger.error(\"Unable to read \" + url.toString(), ioe);\n                     }\n",
        "project": "logging-log4j2",
        "linesAdd": 2,
        "jira_id": "104",
        "nb_skipped": 0,
        "commit": "3b12e13d",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 493,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.layout.RFC5424LayoutTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/RFC5424Layout.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/RFC5424Layout.java\nindex e7aff72a1..e26fa4d1a 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/RFC5424Layout.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/RFC5424Layout.java\n@@ -324,7 +324,8 @@ private void appendMessageId(final StringBuilder buffer, final Message message)\n \n     private void appendMessage(final StringBuilder buffer, final LogEvent event) {\n         final Message message = event.getMessage();\n-        final String text = message.getFormat();\n+        // This layout formats StructuredDataMessages instead of delegating to the Message itself.\n+        final String text = (message instanceof StructuredDataMessage) ? message.getFormat() : message.getFormattedMessage();\n \n         if (text != null && text.length() > 0) {\n             buffer.append(\" \").append(escapeNewlines(text, escapeNewLine));\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "430",
        "nb_skipped": 8,
        "commit": "238ce8aa",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 77,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.jul.BracketInNotInterpolatedMessageTest"
        ],
        "patch": "diff --git a/log4j-jul/src/main/java/org/apache/logging/log4j/jul/ApiLogger.java b/log4j-jul/src/main/java/org/apache/logging/log4j/jul/ApiLogger.java\nindex adac9be60..92b2dffe1 100644\n--- a/log4j-jul/src/main/java/org/apache/logging/log4j/jul/ApiLogger.java\n+++ b/log4j-jul/src/main/java/org/apache/logging/log4j/jul/ApiLogger.java\n@@ -23,6 +23,7 @@\n import java.util.logging.Logger;\n \n import org.apache.logging.log4j.message.Message;\n+import org.apache.logging.log4j.message.MessageFactory;\n import org.apache.logging.log4j.spi.ExtendedLogger;\n \n /**\n@@ -56,7 +57,11 @@ public void log(final LogRecord record) {\n             return;\n         }\n         final org.apache.logging.log4j.Level level = LevelTranslator.toLevel(record.getLevel());\n-        final Message message = logger.getMessageFactory().newMessage(record.getMessage(), record.getParameters());\n+        final Object[] parameters = record.getParameters();\n+        final MessageFactory messageFactory = logger.getMessageFactory();\n+        final Message message = parameters == null ?\n+            messageFactory.newMessage(record.getMessage()) /* LOG4J2-1251: not formatted case */ :\n+            messageFactory.newMessage(record.getMessage(), parameters);\n         final Throwable thrown = record.getThrown();\n         logger.logIfEnabled(FQCN, level, null, message, thrown);\n     }\n@@ -94,6 +99,7 @@ protected void doSetLevel(final Level newLevel) throws SecurityException {\n \n     /**\n      * Unsupported operation.\n+     *\n      * @throws UnsupportedOperationException always\n      */\n     @Override\n",
        "project": "logging-log4j2",
        "linesAdd": 6,
        "jira_id": "1251",
        "nb_skipped": 0,
        "commit": "424068f7",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 565,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.async.AsyncLoggerConfigUseAfterShutdownTest",
            "org.apache.logging.log4j.core.async.AsyncLoggerUseAfterShutdownTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java\nindex b99608c20..c8329732d 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java\n@@ -231,9 +231,15 @@ public void logMessage(final String fqcn, final Level level, final Marker marker\n             threadlocalInfo.set(info);\n         }\n         \n+        Disruptor<RingBufferLogEvent> temp = disruptor;\n+        if (temp == null) { // LOG4J2-639\n+            LOGGER.fatal(\"Ignoring log event after log4j was shut down\");\n+            return;\n+        }\n+\n         // LOG4J2-471: prevent deadlock when RingBuffer is full and object\n         // being logged calls Logger.log() from its toString() method\n-        if (info.isAppenderThread && disruptor.getRingBuffer().remainingCapacity() == 0) {\n+        if (info.isAppenderThread && temp.getRingBuffer().remainingCapacity() == 0) {\n             // bypass RingBuffer and invoke Appender directly\n             config.loggerConfig.log(getName(), fqcn, marker, level, message, thrown);\n             return;\n@@ -266,7 +272,15 @@ public void logMessage(final String fqcn, final Level level, final Marker marker\n                 // CachedClock: 10% faster than system clock, smaller gaps\n                 clock.currentTimeMillis());\n \n+        // LOG4J2-639: catch NPE if disruptor field was set to null after our check above\n+        try {\n+            // Note: do NOT use the temp variable above!\n+            // That could result in adding a log event to the disruptor after it was shut down,\n+            // which could cause the publishEvent method to hang and never return.\n             disruptor.publishEvent(info.translator);\n+        } catch (NullPointerException npe) {\n+            LOGGER.fatal(\"Ignoring log event after log4j was shut down.\");\n+        }\n     }\n \n     private static StackTraceElement location(final String fqcnOfLogger) {\ndiff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfigHelper.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfigHelper.java\nindex 9d2f4f06f..2e8814c06 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfigHelper.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerConfigHelper.java\n@@ -316,16 +316,29 @@ public void run() {\n      *          calling thread needs to process the event itself\n      */\n     public boolean callAppendersFromAnotherThread(final LogEvent event) {\n+        Disruptor<Log4jEventWrapper> temp = disruptor;\n+        if (temp == null) { // LOG4J2-639\n+            LOGGER.fatal(\"Ignoring log event after log4j was shut down\");\n+            return true;\n+        }\n \n         // LOG4J2-471: prevent deadlock when RingBuffer is full and object\n         // being logged calls Logger.log() from its toString() method\n         if (isAppenderThread.get() == Boolean.TRUE //\n-                && disruptor.getRingBuffer().remainingCapacity() == 0) {\n+                && temp.getRingBuffer().remainingCapacity() == 0) {\n \n             // bypass RingBuffer and invoke Appender directly\n             return false;\n         }\n+        // LOG4J2-639: catch NPE if disruptor field was set to null after our check above\n+        try {\n+            // Note: do NOT use the temp variable above!\n+            // That could result in adding a log event to the disruptor after it was shut down,\n+            // which could cause the publishEvent method to hang and never return.\n             disruptor.getRingBuffer().publishEvent(translator, event, asyncLoggerConfig);\n+        } catch (NullPointerException npe) {\n+            LOGGER.fatal(\"Ignoring log event after log4j was shut down.\");\n+        }\n         return true;\n     }\n \n",
        "project": "logging-log4j2",
        "linesAdd": 21,
        "jira_id": "639",
        "nb_skipped": 2,
        "commit": "a5a1f1a2",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1181,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.config.properties.RollingFilePropertiesTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationBuilder.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationBuilder.java\nindex 51bdccadf..2c70234c2 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationBuilder.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/properties/PropertiesConfigurationBuilder.java\n@@ -120,26 +120,58 @@ public PropertiesConfiguration build() {\n             }\n         }\n \n-        final Map<String, Properties> filters = PropertiesUtil.partitionOnCommonPrefixes(\n-            PropertiesUtil.extractSubset(rootProperties, \"filter\"));\n+        String filterProp = rootProperties.getProperty(\"filters\");\n+        if (filterProp != null) {\n+            String[] filterNames = filterProp.split(\",\");\n+            for (String filterName : filterNames) {\n+                String name = filterName.trim();\n+                builder.add(createFilter(name, PropertiesUtil.extractSubset(rootProperties, \"filter.\" + name)));\n+            }\n+        } else {\n+\n+            final Map<String, Properties> filters = PropertiesUtil\n+                    .partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties, \"filter\"));\n             for (final Map.Entry<String, Properties> entry : filters.entrySet()) {\n                 builder.add(createFilter(entry.getKey().trim(), entry.getValue()));\n             }\n+        }\n \n-        final Map<String, Properties> appenders = PropertiesUtil.partitionOnCommonPrefixes(\n-            PropertiesUtil.extractSubset(rootProperties, \"appender\"));\n+        String appenderProp = rootProperties.getProperty(\"appenders\");\n+        if (appenderProp != null) {\n+            String[] appenderNames = appenderProp.split(\",\");\n+            for (String appenderName : appenderNames) {\n+                String name = appenderName.trim();\n+                builder.add(createAppender(appenderName.trim(),\n+                        PropertiesUtil.extractSubset(rootProperties, \"appender.\" + name)));\n+            }\n+        } else {\n+            final Map<String, Properties> appenders = PropertiesUtil\n+                    .partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties, \"appender\"));\n             for (final Map.Entry<String, Properties> entry : appenders.entrySet()) {\n                 builder.add(createAppender(entry.getKey().trim(), entry.getValue()));\n             }\n+        }\n \n-        final Map<String, Properties> loggers = PropertiesUtil.partitionOnCommonPrefixes(\n-            PropertiesUtil.extractSubset(rootProperties, \"logger\"));\n+        String loggerProp = rootProperties.getProperty(\"loggers\");\n+        if (loggerProp != null) {\n+            String[] loggerNames = loggerProp.split(\",\");\n+            for (String loggerName : loggerNames) {\n+                String name = loggerName.trim();\n+                if (!name.equals(LoggerConfig.ROOT)) {\n+                    builder.add(createLogger(name, PropertiesUtil.extractSubset(rootProperties, \"logger.\" +\n+                            name)));\n+                }\n+            }\n+        } else {\n+            final Map<String, Properties> loggers = PropertiesUtil\n+                    .partitionOnCommonPrefixes(PropertiesUtil.extractSubset(rootProperties, \"logger\"));\n             for (final Map.Entry<String, Properties> entry : loggers.entrySet()) {\n                 final String name = entry.getKey().trim();\n                 if (!name.equals(LoggerConfig.ROOT)) {\n                     builder.add(createLogger(name, entry.getValue()));\n                 }\n             }\n+        }\n \n         final Properties props = PropertiesUtil.extractSubset(rootProperties, \"rootLogger\");\n         if (props.size() > 0) {\n",
        "project": "logging-log4j2",
        "linesAdd": 38,
        "jira_id": "1402",
        "nb_skipped": 3,
        "commit": "7792679c",
        "nb_failure": 0,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 20,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.MarkerTest"
        ],
        "patch": "diff --git a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\nindex d57cf1907..aee8dcfcd 100644\n--- a/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\n+++ b/log4j-slf4j-impl/src/main/java/org/apache/logging/slf4j/Log4jMarker.java\n@@ -50,6 +50,9 @@ public Log4jMarker(final org.apache.logging.log4j.Marker marker) {\n \r\n     @Override\r\n     public void add(final Marker marker) {\r\n+\t\tif (marker == null) {\r\n+\t\t\tthrow new IllegalArgumentException();\r\n+\t\t}\r\n         final Marker m = factory.getMarker(marker.getName());\r\n         this.marker.addParents(((Log4jMarker)m).getLog4jMarker());\r\n     }\r\n",
        "project": "logging-log4j2",
        "linesAdd": 3,
        "jira_id": "1062",
        "nb_skipped": 0,
        "commit": "4cf831b6",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 515,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.jmx.ServerTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\nindex 9c66b6315..e7af98305 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jmx/Server.java\n@@ -74,14 +74,18 @@ public static String escape(final String name) {\n         for (int i = 0; i < name.length(); i++) {\n             final char c = name.charAt(i);\n             switch (c) {\n-            case ',':\n-            case '=':\n-            case ':':\n             case '\\\\':\n             case '*':\n             case '?':\n-                sb.append('\\\\');\n-                needsQuotes = true;\n+            case '\\\"':\n+                sb.append('\\\\'); // quote, star, question & backslash must be escaped\n+                needsQuotes = true; // ... and can only appear in quoted value\n+                break;\n+            case ',':\n+            case '=':\n+            case ':':\n+                needsQuotes = true; // no need to escape these, but value must be quoted\n+                break;\n             }\n             sb.append(c);\n         }\n",
        "project": "logging-log4j2",
        "linesAdd": 9,
        "jira_id": "492",
        "nb_skipped": 1,
        "commit": "a759d8ae",
        "nb_failure": 4,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 417,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.config.TestConfigurator"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationFactory.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationFactory.java\nindex 7873c79ee..849019675 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationFactory.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationFactory.java\n@@ -88,6 +88,18 @@\n      */\n     protected static final String DEFAULT_PREFIX = \"log4j2\";\n \n+    /**\n+     * The name of the classloader URI scheme.\n+     */\n+    private static final String CLASS_LOADER_SCHEME = \"classloader\";\n+    private static final int CLASS_LOADER_SCHEME_LENGTH = CLASS_LOADER_SCHEME.length() + 1;\n+\n+    /**\n+     * The name of the classpath URI scheme, synonymous with the classloader URI scheme.\n+     */\n+    private static final String CLASS_PATH_SCHEME = \"classpath\";\n+    private static final int CLASS_PATH_SCHEME_LENGTH = CLASS_PATH_SCHEME.length() + 1;\n+\n     private static volatile List<ConfigurationFactory> factories = null;\n \n     private static ConfigurationFactory configFactory = new Factory();\n@@ -221,9 +233,19 @@ protected ConfigurationSource getInputFromURI(final URI configLocation) {\n             }\n         }\n         final String scheme = configLocation.getScheme();\n-        if (scheme == null || scheme.equals(\"classloader\")) {\n+        final boolean isClassLoaderScheme = scheme != null && scheme.equals(CLASS_LOADER_SCHEME);\n+        final boolean isClassPathScheme = scheme != null && !isClassLoaderScheme && scheme.equals(CLASS_PATH_SCHEME);\n+        if (scheme == null || isClassLoaderScheme || isClassPathScheme) {\n             final ClassLoader loader = this.getClass().getClassLoader();\n-            final ConfigurationSource source = getInputFromResource(configLocation.getPath(), loader);\n+            String path;\n+            if (isClassLoaderScheme) {\n+                path = configLocation.toString().substring(CLASS_LOADER_SCHEME_LENGTH);\n+            } else if (isClassPathScheme) {\n+                path = configLocation.toString().substring(CLASS_PATH_SCHEME_LENGTH);\n+            } else {\n+                path = configLocation.getPath();\n+            }\n+            final ConfigurationSource source = getInputFromResource(path, loader);\n             if (source != null) {\n                 return source;\n             }\n@@ -365,7 +387,7 @@ public Configuration getConfiguration(final String name, final URI configLocatio\n                     final String[] types = factory.getSupportedTypes();\n                     if (types != null) {\n                         for (final String type : types) {\n-                            if (type.equals(\"*\") || configLocation.getPath().endsWith(type)) {\n+                            if (type.equals(\"*\") || configLocation.toString().endsWith(type)) {\n                                 final Configuration config = factory.getConfiguration(name, configLocation);\n                                 if (config != null) {\n                                     return config;\n",
        "project": "logging-log4j2",
        "linesAdd": 19,
        "jira_id": "293",
        "nb_skipped": 5,
        "commit": "25cb587a",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 7,
        "nb_test": 197,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.message.ObjectMessageTest",
            "org.apache.logging.log4j.message.StringFormattedMessageTest",
            "org.apache.logging.log4j.message.MessageFormatMessageTest",
            "org.apache.logging.log4j.message.LocalizedMessageTest",
            "org.apache.logging.log4j.message.FormattedMessageTest"
        ],
        "patch": "diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/FormattedMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/FormattedMessage.java\nindex 1c540ddbc..3ca4b8287 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/FormattedMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/FormattedMessage.java\n@@ -46,12 +46,11 @@ public FormattedMessage(final String messagePattern, final Object[] arguments, f\n         this.messagePattern = messagePattern;\n         this.argArray = arguments;\n         this.throwable = throwable;\n+        getFormattedMessage(); // LOG4J2-763 take snapshot of parameters at message construction time\n     }\n \n     public FormattedMessage(final String messagePattern, final Object[] arguments) {\n-        this.messagePattern = messagePattern;\n-        this.argArray = arguments;\n-        this.throwable = null;\n+        this(messagePattern, arguments, null);\n     }\n \n     /**\n@@ -60,9 +59,7 @@ public FormattedMessage(final String messagePattern, final Object[] arguments) {\n      * @param arg The parameter.\n      */\n     public FormattedMessage(final String messagePattern, final Object arg) {\n-        this.messagePattern = messagePattern;\n-        this.argArray = new Object[] {arg};\n-        this.throwable = null;\n+        this(messagePattern, new Object[] {arg}, null);\n     }\n \n     /**\ndiff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/LocalizedMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/LocalizedMessage.java\nindex c6839b801..2a2246b8e 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/LocalizedMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/LocalizedMessage.java\n@@ -78,6 +78,7 @@ public LocalizedMessage(final String baseName, final Locale locale, final String\n         this.baseName = baseName;\n         this.resourceBundle = null;\n         this.locale = locale;\n+        getFormattedMessage(); // LOG4J2-763 take snapshot of parameters at message construction time\n     }\n \n     public LocalizedMessage(final ResourceBundle bundle, final Locale locale, final String key,\n@@ -88,6 +89,7 @@ public LocalizedMessage(final ResourceBundle bundle, final Locale locale, final\n         this.baseName = null;\n         this.resourceBundle = bundle;\n         this.locale = locale;\n+        getFormattedMessage(); // LOG4J2-763 take snapshot of parameters at message construction time\n     }\n \n     public LocalizedMessage(final Locale locale, final String key, final Object[] arguments) {\ndiff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/MapMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/MapMessage.java\nindex db6826acd..4cbef351d 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/MapMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/MapMessage.java\n@@ -26,6 +26,11 @@\n \n /**\n  * Represents a Message that consists of a Map.\n+ * <p>\n+ * Thread-safety note: the contents of this message can be modified after construction.\n+ * When using asynchronous loggers and appenders it is not recommended to modify this message after the message is\n+ * logged, because it is undefined whether the logged message string will contain the old values or the modified\n+ * values.\n  */\n public class MapMessage implements MultiformatMessage {\n     /**\ndiff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/MessageFormatMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/MessageFormatMessage.java\nindex 0493b0fde..f7283245c 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/MessageFormatMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/MessageFormatMessage.java\n@@ -49,6 +49,7 @@ public MessageFormatMessage(final String messagePattern, final Object... argumen\n         if (arguments != null && arguments.length > 0 && arguments[arguments.length - 1] instanceof Throwable) {\n             this.throwable = (Throwable) arguments[arguments.length - 1];\n         }\n+        getFormattedMessage(); // LOG4J2-763 take snapshot of parameters at message construction time\n     }\n \n     /**\ndiff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/ObjectMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/ObjectMessage.java\nindex 27f288e72..dcccf46c1 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/ObjectMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/ObjectMessage.java\n@@ -29,6 +29,7 @@\n     private static final long serialVersionUID = -5903272448334166185L;\n \n     private transient Object obj;\n+    private final String objectString;\n \n     /**\n      * Create the ObjectMessage.\n@@ -39,6 +40,9 @@ public ObjectMessage(Object obj) {\n             obj = \"null\";\n         }\n         this.obj = obj;\n+        \n+        // LOG4J2-763: take snapshot of parameters at message construction time\n+        objectString = String.valueOf(obj);\n     }\n \n     /**\n@@ -47,7 +51,7 @@ public ObjectMessage(Object obj) {\n      */\n     @Override\n     public String getFormattedMessage() {\n-        return obj.toString();\n+        return objectString;\n     }\n \n     /**\n@@ -56,7 +60,7 @@ public String getFormattedMessage() {\n      */\n     @Override\n     public String getFormat() {\n-        return obj.toString();\n+        return objectString;\n     }\n \n     /**\n@@ -89,7 +93,7 @@ public int hashCode() {\n \n     @Override\n     public String toString() {\n-        return \"ObjectMessage[obj=\" + obj.toString() + ']';\n+        return \"ObjectMessage[obj=\" + objectString + ']';\n     }\n \n     private void writeObject(final ObjectOutputStream out) throws IOException {\ndiff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/StringFormattedMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/StringFormattedMessage.java\nindex f6007e4ce..91df3705f 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/StringFormattedMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/StringFormattedMessage.java\n@@ -48,6 +48,7 @@ public StringFormattedMessage(final String messagePattern, final Object... argum\n         if (arguments != null && arguments.length > 0 && arguments[arguments.length - 1] instanceof Throwable) {\n             this.throwable = (Throwable) arguments[arguments.length - 1];\n         }\n+        getFormattedMessage(); // LOG4J2-763 take snapshot of parameters at message construction time\n     }\n \n     /**\ndiff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/StructuredDataMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/StructuredDataMessage.java\nindex 246e11bd7..f6300ee84 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/StructuredDataMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/StructuredDataMessage.java\n@@ -22,6 +22,11 @@\n \n /**\n  * Represents a Message that conforms to an RFC 5424 StructuredData element along with the syslog message.\n+ * <p>\n+ * Thread-safety note: the contents of this message can be modified after construction.\n+ * When using asynchronous loggers and appenders it is not recommended to modify this message after the message is\n+ * logged, because it is undefined whether the logged message string will contain the old values or the modified\n+ * values.\n  *\n  * @see <a href=\"https://tools.ietf.org/html/rfc5424\">RFC 5424</a>\n  */\n",
        "project": "logging-log4j2",
        "linesAdd": 13,
        "jira_id": "763",
        "nb_skipped": 2,
        "commit": "97203de8",
        "nb_failure": 5,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 516,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.LoggerDateTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\nindex 986d2b921..b203fb328 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java\n@@ -243,22 +243,28 @@ public void addComponent(final String name, final Object obj) {\n     protected void doConfigure() {\n         boolean setRoot = false;\n         boolean setLoggers = false;\n-        for (final Node child : rootNode.getChildren()) {\n-            createConfiguration(child, null);\n-            if (child.getObject() == null) {\n-                continue;\n+        if (rootNode.hasChildren() && rootNode.getChildren().get(0).getName().equalsIgnoreCase(\"Properties\")) {\n+            Node first = rootNode.getChildren().get(0);\n+            createConfiguration(first, null);\n+            if (first.getObject() != null) {\n+                subst.setVariableResolver((StrLookup) first.getObject());\n+            }\n+        } else {\n+            final Map<String, String> map = (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);\n+            final StrLookup lookup = map == null ? null : new MapLookup(map);\n+            subst.setVariableResolver(new Interpolator(lookup));\n         }\n+\n+        for (final Node child : rootNode.getChildren()) {\n             if (child.getName().equalsIgnoreCase(\"Properties\")) {\n                 if (tempLookup == subst.getVariableResolver()) {\n-                    subst.setVariableResolver((StrLookup) child.getObject());\n-                } else {\n                     LOGGER.error(\"Properties declaration must be the first element in the configuration\");\n                 }\n                 continue;\n-            } else if (tempLookup == subst.getVariableResolver()) {\n-                final Map<String, String> map = (Map<String, String>) componentMap.get(CONTEXT_PROPERTIES);\n-                final StrLookup lookup = map == null ? null : new MapLookup(map);\n-                subst.setVariableResolver(new Interpolator(lookup));\n+            }\n+            createConfiguration(child, null);\n+            if (child.getObject() == null) {\n+                continue;\n             }\n             if (child.getName().equalsIgnoreCase(\"Appenders\")) {\n                 appenders = (ConcurrentMap<String, Appender>) child.getObject();\n",
        "project": "logging-log4j2",
        "linesAdd": 16,
        "jira_id": "398",
        "nb_skipped": 1,
        "commit": "2c966ad9",
        "nb_failure": 1,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 87,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.lookup.InterpolatorTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java b/core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\nindex 0819211d9..13cf5bb78 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java\n@@ -107,7 +107,7 @@ public String lookup(LogEvent event, String var) {\n             if (value != null) {\n                 return value;\n             }\n-            var = var.substring(prefixPos);\n+            var = var.substring(prefixPos + 1);\n         }\n         if (defaultLookup != null) {\n             return event == null ? defaultLookup.lookup(var) : defaultLookup.lookup(event, var);\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "94",
        "nb_skipped": 0,
        "commit": "d8af1c93",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 13,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.slf4j.SerializeTest"
        ],
        "patch": "diff --git a/log4j-slf4j-impl/src/main/java/org/slf4j/impl/SLF4JLogger.java b/log4j-slf4j-impl/src/main/java/org/slf4j/impl/SLF4JLogger.java\nindex eaac80ea6..767941e8f 100644\n--- a/log4j-slf4j-impl/src/main/java/org/slf4j/impl/SLF4JLogger.java\n+++ b/log4j-slf4j-impl/src/main/java/org/slf4j/impl/SLF4JLogger.java\n@@ -17,6 +17,7 @@\n package org.slf4j.impl;\n \n import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.message.Message;\n import org.apache.logging.log4j.message.ParameterizedMessage;\n import org.apache.logging.log4j.message.SimpleMessage;\n@@ -27,17 +28,23 @@\n import org.slf4j.helpers.EventDataConverter;\n import org.slf4j.spi.LocationAwareLogger;\n \n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n /**\n  *\n  */\n-public class SLF4JLogger implements LocationAwareLogger {\n+public class SLF4JLogger implements LocationAwareLogger, Serializable {\n \n+    private static final long serialVersionUID = 7869000638091304316L;\n     private static final String FQCN = SLF4JLogger.class.getName();\n     private static final Marker EVENT_MARKER = MarkerFactory.getMarker(\"EVENT\");\n     private final boolean eventLogger;\n-    private final AbstractLoggerWrapper logger;\n+    private transient AbstractLoggerWrapper logger;\n     private final String name;\n-    private final EventDataConverter converter;\n+    private transient EventDataConverter converter;\n \n     public SLF4JLogger(final AbstractLogger logger, final String name) {\n         this.logger = new AbstractLoggerWrapper(logger, name, null);\n@@ -502,6 +509,27 @@ public String getName() {\n         return name;\n     }\n \n+    /**\n+     * Always treat de-serialization as a full-blown constructor, by\n+     * validating the final state of the de-serialized object.\n+     */\n+    private void readObject(ObjectInputStream aInputStream) throws ClassNotFoundException, IOException {\n+        //always perform the default de-serialization first\n+        aInputStream.defaultReadObject();\n+        logger = new AbstractLoggerWrapper((AbstractLogger) LogManager.getLogger(name), name, null);\n+        converter = createConverter();\n+    }\n+\n+    /**\n+     * This is the default implementation of writeObject.\n+     * Customise if necessary.\n+     */\n+    private void writeObject(ObjectOutputStream aOutputStream\n+    ) throws IOException {\n+        //perform the default serialization for all non-transient, non-static fields\n+        aOutputStream.defaultWriteObject();\n+    }\n+\n     private EventDataConverter createConverter() {\n         try {\n             Class.forName(\"org.slf4j.ext.EventData\");\n",
        "project": "logging-log4j2",
        "linesAdd": 21,
        "jira_id": "410",
        "nb_skipped": 0,
        "commit": "8f0c4871",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 335,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.layout.XMLLayoutTest"
        ],
        "patch": "diff --git a/core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java b/core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java\nindex ddd45488a..aa40961f5 100644\n--- a/core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java\n+++ b/core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java\n@@ -239,7 +239,7 @@ public String toSerializable(final LogEvent event) {\n      * @return The content type.\n      */\n     public String getContentType() {\n-        return \"text/xml\";\n+        return \"text/xml; charset=\" + this.getCharset();\n     }\n \n     List<String> getThrowableString(final Throwable throwable) {\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "260",
        "nb_skipped": 3,
        "commit": "9d817953",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 920,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.layout.SerializableLayoutTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/AbstractStringLayout.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/AbstractStringLayout.java\nindex c928d621a..255c73b11 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/AbstractStringLayout.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/AbstractStringLayout.java\n@@ -16,6 +16,9 @@\n  */\n package org.apache.logging.log4j.core.layout;\n \n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n import java.io.UnsupportedEncodingException;\n import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n@@ -46,8 +49,8 @@\n     /**\n      * The charset for the formatted message.\n      */\n-    // TODO: Charset is not serializable. Implement read/writeObject() ?\n-    private final Charset charset;\n+    // LOG4J2-1099: charset cannot be final due to serialization needs, so we serialize as charset name instead\n+    private transient Charset charset;\n     private final String charsetName;\n     private final boolean useCustomEncoding;\n \n@@ -97,6 +100,17 @@ private static boolean isPreJava8() {\n         return null;\n     }\n \n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeUTF(charset.name());\n+    }\n+\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        final String charsetName = in.readUTF();\n+        charset = Charset.forName(charsetName);\n+    }\n+\n     /**\n      * Returns a {@code StringBuilder} that this Layout implementation can use to write the formatted log event to.\n      * \n",
        "project": "logging-log4j2",
        "linesAdd": 15,
        "jira_id": "1099",
        "nb_skipped": 3,
        "commit": "3f41ff48",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 419,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.web.Log4jServletContainerInitializerTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\nindex 6add448a8..50b082066 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/web/Log4jServletContainerInitializer.java\n@@ -23,15 +23,18 @@\n import javax.servlet.ServletContainerInitializer;\n import javax.servlet.ServletContext;\n import javax.servlet.ServletException;\n+import javax.servlet.UnavailableException;\n \n /**\n  * In a Servlet 3.0 or newer environment, this initializer is responsible for starting up Log4j logging before anything\n- * else happens in application initialization.\n+ * else happens in application initialization. For consistency across all containers, if the effective Servlet major\n+ * version of the application is less than 3.0, this initializer does nothing.\n  */\n public class Log4jServletContainerInitializer implements ServletContainerInitializer {\n \n     @Override\n     public void onStartup(final Set<Class<?>> classes, final ServletContext servletContext) throws ServletException {\n+        if (servletContext.getMajorVersion() > 2) {\n             servletContext.log(\"Log4jServletContainerInitializer starting up Log4j in Servlet 3.0+ environment.\");\n \n             final Log4jWebInitializer initializer = Log4jWebInitializerImpl.getLog4jWebInitializer(servletContext);\n@@ -40,7 +43,13 @@ public void onStartup(final Set<Class<?>> classes, final ServletContext servletC\n \n             servletContext.addListener(new Log4jServletContextListener());\n \n-        final FilterRegistration.Dynamic filter = servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\n+            final FilterRegistration.Dynamic filter =\n+                    servletContext.addFilter(\"log4jServletFilter\", new Log4jServletFilter());\n+            if (filter == null) {\n+                throw new UnavailableException(\"In a Servlet 3.0+ application, you must not define a \" +\n+                        \"log4jServletFilter in web.xml. Log4j 2 defines this for you automatically.\");\n+            }\n             filter.addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, \"/*\");\n         }\n     }\n+}\n",
        "project": "logging-log4j2",
        "linesAdd": 9,
        "jira_id": "359",
        "nb_skipped": 5,
        "commit": "1df1db27",
        "nb_failure": 8,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 434,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.message.ReusableParameterizedMessageTest"
        ],
        "patch": "diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/ReusableParameterizedMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/ReusableParameterizedMessage.java\nindex abfd620da..1f4e8b95d 100644\n--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/ReusableParameterizedMessage.java\n+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/ReusableParameterizedMessage.java\n@@ -121,8 +121,10 @@ private static int count(final String messagePattern, final int[] indices) {\n     }\n \n     private void initThrowable(final Object[] params, final int argCount, final int usedParams) {\n-        if (usedParams < argCount && this.throwable == null && params[argCount - 1] instanceof Throwable) {\n+        if (usedParams < argCount && params[argCount - 1] instanceof Throwable) {\n             this.throwable = (Throwable) params[argCount - 1];\n+        } else {\n+            this.throwable = null;\n         }\n     }\n \n",
        "project": "logging-log4j2",
        "linesAdd": 3,
        "jira_id": "1406",
        "nb_skipped": 1,
        "commit": "a523dcd5",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 475,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.layout.XMLLayoutTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java\nindex 59a511ab6..d0e4d4861 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java\n@@ -21,6 +21,7 @@\n import java.util.List;\n import java.util.Map;\n \n+import org.apache.logging.log4j.Marker;\n import org.apache.logging.log4j.core.LogEvent;\n import org.apache.logging.log4j.core.config.plugins.Plugin;\n import org.apache.logging.log4j.core.config.plugins.PluginAttribute;\n@@ -195,6 +196,28 @@ public String toSerializable(final LogEvent event) {\n             buf.append(this.eol);\n         }\n \n+        if (event.getMarker() != null) {\n+            final Marker marker = event.getMarker();\n+            buf.append(this.indent2);\n+            buf.append('<');\n+            if (!complete) {\n+                buf.append(this.namespacePrefix);\n+            }\n+            buf.append(\"Marker\");\n+            final Marker parent = marker.getParent();\n+            if (parent != null) {\n+                buf.append(\" parent=\\\"\").append(Transform.escapeHtmlTags(parent.getName())).append(\"\\\"\");\n+            }\n+            buf.append('>');\n+            buf.append(Transform.escapeHtmlTags(marker.getName()));\n+            buf.append(\"</\");\n+            if (!complete) {\n+                buf.append(this.namespacePrefix);\n+            }\n+            buf.append(\"Marker>\");\n+            buf.append(this.eol);\n+        }\n+\n         final Throwable throwable = event.getThrown();\n         if (throwable != null) {\n             final List<String> s = Throwables.toStringList(throwable);\n",
        "project": "logging-log4j2",
        "linesAdd": 23,
        "jira_id": "447",
        "nb_skipped": 8,
        "commit": "0343e9c7",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 673,
        "nb_error": 1,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.logging.log4j.core.config.XIncludeTest"
        ],
        "patch": "diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/xml/XmlConfiguration.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/xml/XmlConfiguration.java\nindex eadcbbccc..ca72c098f 100644\n--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/xml/XmlConfiguration.java\n+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/xml/XmlConfiguration.java\n@@ -131,6 +131,7 @@ public XmlConfiguration(final ConfigurationSource configSource) {\n                 configStream.close();\n             }\n             final InputSource source = new InputSource(new ByteArrayInputStream(buffer));\n+            source.setSystemId(configSource.getLocation());\n             final Document document = newDocumentBuilder().parse(source);\n             rootElement = document.getDocumentElement();\n             final Map<String, String> attrs = processAttributes(rootNode, rootElement);\n",
        "project": "logging-log4j2",
        "linesAdd": 1,
        "jira_id": "742",
        "nb_skipped": 2,
        "commit": "4b77622b",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 1,
        "nb_test": 55,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.extensions.markup.html.repeater.tree.table.NodeBorderTest"
        ],
        "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/tree/table/NodeBorder.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/tree/table/NodeBorder.java\nindex 089a367d60..db1ca42496 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/tree/table/NodeBorder.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/tree/table/NodeBorder.java\n@@ -83,6 +83,10 @@ public void afterRender(Component component)\n \n \t\tfor (int i = 0; i < branches.length; i++)\n \t\t{\n+\t\t\tif (i > 0)\n+\t\t\t{\n+\t\t\t\tresponse.write(\"</div>\");\n+\t\t\t}\n \t\t\tresponse.write(\"</div>\");\n \t\t}\n \t}\n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "5447",
        "nb_skipped": 0,
        "commit": "2abc18f1",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1466,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.validation.validator.UrlValidatorTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java b/wicket-core/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\nindex a259c51175..b7eee1510a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\n@@ -115,7 +115,7 @@\n \tprivate static final int PARSE_AUTHORITY_PORT = 4;\n \tprivate static final int PARSE_AUTHORITY_EXTRA = 5; // Should always be empty.\n \n-\tprivate static final String PATH_PATTERN = \"^(/[-\\\\w:@&?=+,.!/~*'%$_;]*)?$\";\n+\tprivate static final String PATH_PATTERN = \"^(/[-\\\\w:@&?=+,.!/~*'%$_;\\\\(\\\\)]*)?$\";\n \n \tprivate static final String QUERY_PATTERN = \"^(.*)$\";\n \n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "5112",
        "nb_skipped": 3,
        "commit": "ed780cc7",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 46,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.HttpHeaderCollectionTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/HttpHeaderCollection.java b/wicket-request/src/main/java/org/apache/wicket/request/HttpHeaderCollection.java\nindex 3e97a1ec99..8e0cb55e35 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/HttpHeaderCollection.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/HttpHeaderCollection.java\n@@ -99,7 +99,7 @@ public void setHeader(String name, String value)\n \tpublic void addHeader(String name, String value)\n \t{\n \t\t// be lenient and strip leading / trailing blanks\n-\t\tvalue = Args.notEmpty(value, \"value\").trim();\n+\t\tvalue = Args.notNull(value, \"value\").trim();\n \n \t\tinternalAdd(name, value);\n \t}\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "3845",
        "nb_skipped": 0,
        "commit": "afc7034d",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1502,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.resource.PackageResourceReferenceTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\nindex cc7273173d..710eef26dc 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\n@@ -207,7 +207,14 @@ protected String getMinifiedName()\n \t\tif (idxOfExtension > -1)\n \t\t{\n \t\t\tString extension = name.substring(idxOfExtension);\n-\t\t\tminifiedName = name.substring(0, name.length() - extension.length() + 1) + \"min\" + extension;\n+            final String baseName = name.substring(0, name.length() - extension.length() + 1);\n+            if (!\".min\".equals(extension) && !baseName.endsWith(\".min.\"))\n+            {\n+                minifiedName = baseName + \"min\" + extension;\n+            } else\n+            {\n+                minifiedName = name;\n+            }\n \t\t} else\n \t\t{\n \t\t\tminifiedName = name + \".min\";\n",
        "project": "wicket",
        "linesAdd": 8,
        "jira_id": "5251",
        "nb_skipped": 3,
        "commit": "3d2393c7",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1328,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.handler.PageProviderTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\nindex 50402f65ee..6068e352ac 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\n@@ -296,7 +296,10 @@ private IRequestablePage getStoredPage(final int pageId)\n \t\tIRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);\n \t\tif (storedPageInstance != null)\n \t\t{\n-\t\t\tif (pageClass == null || pageClass.equals(storedPageInstance.getClass()))\n+\t\t\tif (\n+\t\t\t\t(pageClass == null || pageClass.equals(storedPageInstance.getClass())) &&\n+\t\t\t\t(isPageParametersEmpty(pageParameters) || arePageParametersSame(storedPageInstance))\n+\t\t\t)\n \t\t\t{\n \t\t\t\tpageInstance = storedPageInstance;\n \t\t\t\tpageInstanceIsFresh = false;\n@@ -413,4 +416,23 @@ public final boolean isPageInstanceFresh()\n \t\t}\n \t\treturn pageInstanceIsFresh;\n \t}\n+\n+\t/**\n+\t * A helper method that compares the requested PageParameters with the ones in the stored\n+\t * page instance. {@code null} and empty PageParameters are considered equal.\n+\t *\n+\t * @param storedPageInstance\n+\t *      the page instance with the original page parameters\n+\t * @return {@code true} if the indexed and named parameters are equal, {@code false} - otherwise\n+\t */\n+\tprivate boolean arePageParametersSame(IRequestablePage storedPageInstance) {\n+\t\tPageParameters currentCopy = new PageParameters(pageParameters);\n+\t\tPageParameters storedCopy = new PageParameters(storedPageInstance.getPageParameters());\n+\t\treturn currentCopy.equals(storedCopy);\n+\t}\n+\n+\tprivate boolean isPageParametersEmpty(PageParameters parameters)\n+\t{\n+\t\treturn parameters == null || parameters.isEmpty();\n+\t}\n }\n",
        "project": "wicket",
        "linesAdd": 15,
        "jira_id": "4441",
        "nb_skipped": 8,
        "commit": "54c86ebb",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 162,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.parse.metapattern.parsers.VariableAssignmentParserTest"
        ],
        "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/parse/metapattern/parsers/VariableAssignmentParser.java b/wicket-util/src/main/java/org/apache/wicket/util/parse/metapattern/parsers/VariableAssignmentParser.java\nindex dc49c1745e..ee4f443117 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/parse/metapattern/parsers/VariableAssignmentParser.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/parse/metapattern/parsers/VariableAssignmentParser.java\n@@ -29,11 +29,11 @@\n  */\n public final class VariableAssignmentParser extends MetaPatternParser\n {\n-\t/** The optional namespace like \"namespace:*\" */\n+\t/** The optional namespace like \"namespace:*[:*]\" */\n \tprivate static final MetaPattern namespace = new OptionalMetaPattern(new MetaPattern[] {\n-\t\t\tMetaPattern.VARIABLE_NAME, MetaPattern.COLON });\n+\t\t\tMetaPattern.VARIABLE_NAME, MetaPattern.COLON, new OptionalMetaPattern(new MetaPattern[] {MetaPattern.VARIABLE_NAME, MetaPattern.COLON })});\n \n-\t/** The key (lvalue) like \"name\" or \"namespace:name\" */\n+\t/** The key (lvalue) like \"name\" or \"namespace:name\" or \"namespace:name:subname\" */\n \tprivate final Group key = new Group(new MetaPattern(namespace, MetaPattern.XML_ATTRIBUTE_NAME));\n \n \t/** The rvalue of the assignment */\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "4679",
        "nb_skipped": 0,
        "commit": "f3ec1503",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1690,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ajax.form.OnChangeAjaxBehaviorTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/form/OnChangeAjaxBehavior.java b/wicket-core/src/main/java/org/apache/wicket/ajax/form/OnChangeAjaxBehavior.java\nindex f363cd88fa..27c229c36a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/form/OnChangeAjaxBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/form/OnChangeAjaxBehavior.java\n@@ -47,7 +47,8 @@\n \t * for text input form component depending on the browser.\n \t * 'change' is used as a fallback for all other form component types.\n \t */\n-\tpublic static final String EVENT_INPUTCHANGE = \"inputchange\";\n+\tpublic static final String EVENT_NAME = \"inputchange change\";\n+\n \tpublic static final String EVENT_CHANGE = \"change\";\n \n \t/**\n@@ -55,7 +56,7 @@\n \t */\n \tpublic OnChangeAjaxBehavior()\n \t{\n-\t\tsuper(EVENT_INPUTCHANGE + \" \" + EVENT_CHANGE);\n+\t\tsuper(EVENT_NAME);\n \t}\n \n \t@Override\n@@ -65,13 +66,9 @@ protected void updateAjaxAttributes(AjaxRequestAttributes attributes)\n \n \t\tComponent component = getComponent();\n \n-\t\t//textfiels and textareas will trigger this behavior with event 'inputchange'\n-\t\t//while all the other components will use 'change'\n-\t\tif (component instanceof TextField || component instanceof TextArea) \n-\t\t{\n-\t\t\tattributes.setEventNames(EVENT_INPUTCHANGE);\n-\t\t} \n-\t\telse \n+\t\t// textfiels and textareas will trigger this behavior with either 'inputchange' or 'change' events\n+\t\t// all the other components will use just 'change'\n+\t\tif (!(component instanceof TextField || component instanceof TextArea))\n \t\t{\n \t\t\tattributes.setEventNames(EVENT_CHANGE);\n \t\t}\n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "5711",
        "nb_skipped": 1,
        "commit": "5837817c",
        "nb_failure": 1,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1323,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ComponentTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex fb56254ff5..342f10742e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -2985,15 +2985,11 @@ public Component setDefaultModel(final IModel<?> model)\n \t\t// Change model\n \t\tif (wrappedModel != model)\n \t\t{\n-\t\t\tif (wrappedModel != null)\n-\t\t\t{\n-\t\t\t\taddStateChange();\n-\t\t\t}\n-\n+\t\t\tmodelChanging();\n \t\t\tsetModelImpl(wrap(model));\n+\t\t\tmodelChanged();\n \t\t}\n \n-\t\tmodelChanged();\n \t\treturn this;\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "4483",
        "nb_skipped": 8,
        "commit": "53442bb4",
        "nb_failure": 1,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1147,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.MarkupVariationTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 956df8804b..94bef50709 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -36,6 +36,7 @@\n import org.apache.wicket.feedback.IFeedback;\n import org.apache.wicket.markup.ComponentTag;\n import org.apache.wicket.markup.IMarkupFragment;\n+import org.apache.wicket.markup.MarkupCache;\n import org.apache.wicket.markup.MarkupElement;\n import org.apache.wicket.markup.MarkupException;\n import org.apache.wicket.markup.MarkupNotFoundException;\n@@ -1170,6 +1171,8 @@ public final void detach()\n \n \t\trequestFlags = 0;\n \n+\t\tinternalDetach();\n+\n \t\t// notify any detach listener\n \t\tIDetachListener detachListener = getApplication().getFrameworkSettings()\n \t\t\t.getDetachListener();\n@@ -1179,6 +1182,15 @@ public final void detach()\n \t\t}\n \t}\n \n+\t/**\n+\t * Removes the cached markup at the end of the request. For the next request it will be get\n+\t * either from the parent's markup or from {@link MarkupCache}.\n+\t */\n+\tprivate void internalDetach()\n+\t{\n+\t\tmarkup = null;\n+\t}\n+\n \t/**\n \t * Detaches all models\n \t */\n@@ -3065,7 +3077,7 @@ public final Component setOutputMarkupPlaceholderTag(final boolean outputTag)\n \t\t\t{\n \t\t\t\tsetFlag(FLAG_PLACEHOLDER, false);\n \t\t\t\t// I think it's better to not setOutputMarkupId to false...\n-\t\t\t\t// user can do it if we want\n+\t\t\t\t// user can do it if she want\n \t\t\t}\n \t\t}\n \t\treturn this;\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/InlineEnclosure.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/InlineEnclosure.java\nindex 614ccb6beb..9caac6d5ec 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/InlineEnclosure.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/InlineEnclosure.java\n@@ -17,6 +17,8 @@\n package org.apache.wicket.markup.html.internal;\r\n \r\n import org.apache.wicket.markup.ComponentTag;\r\n+import org.apache.wicket.markup.IMarkupFragment;\r\n+import org.apache.wicket.markup.Markup;\r\n import org.apache.wicket.markup.parser.filter.InlineEnclosureHandler;\r\n import org.slf4j.Logger;\r\n import org.slf4j.LoggerFactory;\r\n@@ -42,6 +44,8 @@\n \r\n \tprivate static final Logger log = LoggerFactory.getLogger(InlineEnclosure.class);\r\n \r\n+\tprivate String enclosureMarkupAsString;\r\n+\r\n \t/**\r\n \t * Construct.\r\n \t * \r\n@@ -53,8 +57,9 @@ public InlineEnclosure(final String id, final String childId)\n \t{\r\n \t\tsuper(id, childId);\r\n \r\n+\t\tenclosureMarkupAsString = null;\r\n+\r\n \t\t// ensure that the Enclosure is ready for ajax updates\r\n-\t\tsetOutputMarkupId(true);\r\n \t\tsetOutputMarkupPlaceholderTag(true);\r\n \t\tsetMarkupId(getId());\r\n \t}\r\n@@ -79,4 +84,32 @@ public boolean updateVisibility()\n \t\tsetVisible(visible);\r\n \t\treturn visible;\r\n \t}\r\n+\r\n+\t/**\r\n+\t * {@link InlineEnclosure}s keep their own cache of their markup because Component#markup is\r\n+\t * detached and later during Ajax request it is hard to re-lookup {@link InlineEnclosure}'s\r\n+\t * markup from its parent.\r\n+\t * \r\n+\t * @see org.apache.wicket.Component#getMarkup()\r\n+\t */\r\n+\t@Override\r\n+\tpublic IMarkupFragment getMarkup()\r\n+\t{\r\n+\t\tIMarkupFragment enclosureMarkup = null;\r\n+\t\tif (enclosureMarkupAsString == null)\r\n+\t\t{\r\n+\t\t\tIMarkupFragment markup = super.getMarkup();\r\n+\t\t\tif (markup != null && markup != Markup.NO_MARKUP)\r\n+\t\t\t{\r\n+\t\t\t\tenclosureMarkup = markup;\r\n+\t\t\t\tenclosureMarkupAsString = markup.toString(true);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\telse\r\n+\t\t{\r\n+\t\t\tenclosureMarkup = Markup.of(enclosureMarkupAsString);\r\n+\t\t}\r\n+\r\n+\t\treturn enclosureMarkup;\r\n+\t}\r\n }\r\n",
        "project": "wicket",
        "linesAdd": 35,
        "jira_id": "3931",
        "nb_skipped": 2,
        "commit": "8fbdc68f",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 1637,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.mapper.PackageMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\nindex e9ad89cf0a..e38d956d4d 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n@@ -204,7 +204,25 @@ public AbstractBookmarkableMapper(String mountPath, IPageParametersEncoder pageP\n \t * @see IRequestMapper#getCompatibilityScore(Request)\n \t */\n \t@Override\n-\tpublic abstract int getCompatibilityScore(Request request);\n+\tpublic int getCompatibilityScore(Request request)\n+\t{\n+\t\tif (urlStartsWith(request.getUrl(), mountSegments))\n+\t\t{\n+\t\t\t/* see WICKET-5056 - alter score with pathSegment type */\n+\t\t\tint countOptional = 0;\n+\t\t\tint fixedSegments = 0;\n+\t\t\tfor (MountPathSegment pathSegment : pathSegments)\n+\t\t\t{\n+\t\t\t\tfixedSegments += pathSegment.getFixedPartSize();\n+\t\t\t\tcountOptional += pathSegment.getOptionalParameters();\n+\t\t\t}\n+\t\t\treturn mountSegments.length - countOptional + fixedSegments;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\treturn 0;\n+\t\t}\n+\t}\n \n \t/**\n \t * Creates a {@code IRequestHandler} that processes a bookmarkable request.\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\nindex da6c4c46fd..fdf1dc26da 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\n@@ -267,30 +267,6 @@ protected boolean pageMustHaveBeenCreatedBookmarkable()\n \t\treturn false;\n \t}\n \n-\t/**\n-\t * @see AbstractBookmarkableMapper#getCompatibilityScore(org.apache.wicket.request.Request)\n-\t */\n-\t@Override\n-\tpublic int getCompatibilityScore(Request request)\n-\t{\n-\t\tif (urlStartsWith(request.getUrl(), mountSegments))\n-\t\t{\n-\t\t\t/* see WICKET-5056 - alter score with pathSegment type */\n-\t\t\tint countOptional = 0;\n-\t\t\tint fixedSegments = 0;\n-\t\t\tfor (MountPathSegment pathSegment : pathSegments)\n-\t\t\t{\n-\t\t\t\tfixedSegments += pathSegment.getFixedPartSize();\n-\t\t\t\tcountOptional += pathSegment.getOptionalParameters();\n-\t\t\t}\n-\t\t\treturn mountSegments.length - countOptional + fixedSegments;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treturn 0;\n-\t\t}\n-\t}\n-\n \t/**\n \t * @see AbstractBookmarkableMapper#checkPageClass(java.lang.Class)\n \t */\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\nindex 2037356c10..ff8b81a74e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n@@ -221,17 +221,4 @@ protected boolean pageMustHaveBeenCreatedBookmarkable()\n \t{\n \t\treturn false;\n \t}\n-\n-\t@Override\n-\tpublic int getCompatibilityScore(Request request)\n-\t{\n-\t\tif (urlStartsWith(request.getUrl(), mountSegments))\n-\t\t{\n-\t\t    return mountSegments.length;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t    return 0;\n-\t\t}\n-\t}\n }\n",
        "project": "wicket",
        "linesAdd": 18,
        "jira_id": "5565",
        "nb_skipped": 2,
        "commit": "204849bc",
        "nb_failure": 1,
        "linesRem": 34,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1449,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.mapper.AbstractBookmarkableMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\nindex 86c64a6d46..56e27d4994 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n@@ -24,6 +24,8 @@\n import org.apache.wicket.core.request.handler.PageAndComponentProvider;\n import org.apache.wicket.core.request.handler.PageProvider;\n import org.apache.wicket.core.request.handler.RenderPageRequestHandler;\n+import org.apache.wicket.protocol.http.PageExpiredException;\n+import org.apache.wicket.protocol.http.WebApplication;\n import org.apache.wicket.request.IRequestHandler;\n import org.apache.wicket.request.IRequestHandlerDelegate;\n import org.apache.wicket.request.IRequestMapper;\n@@ -208,8 +210,17 @@ protected IRequestHandler processHybrid(PageInfo pageInfo,\n \t\tPageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters,\n \t\t\trenderCount);\n \t\tprovider.setPageSource(getContext());\n+\t\tif (provider.isNewPageInstance() &&\n+\t\t\t!WebApplication.get().getPageSettings().getRecreateMountedPagesAfterExpiry())\n+\t\t{\n+\t\t\tthrow new PageExpiredException(String.format(\"Bookmarkable page id '%d' has expired.\",\n+\t\t\t\tpageInfo.getPageId()));\n+\t\t}\n+\t\telse\n+\t\t{\n \t\t\treturn new RenderPageRequestHandler(provider);\n \t\t}\n+\t}\n \n \t/**\n \t * Creates a {@code IRequestHandler} that processes a listener request.\n",
        "project": "wicket",
        "linesAdd": 11,
        "jira_id": "4932",
        "nb_skipped": 5,
        "commit": "f20b2d70",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1525,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.link.MountedPageLinkTest",
            "org.apache.wicket.markup.html.internal.EnclosureTest",
            "org.apache.wicket.ajax.AjaxRequestHandlerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 0c56063d15..b78f8bfb95 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -3334,7 +3334,8 @@ public final CharSequence urlFor(final Behavior behaviour,\n \t\tPage page = getPage();\n \t\tPageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);\n \t\tIRequestHandler handler;\n-\t\tif (page.isBookmarkable())\n+\t\tif (getApplication().getPageSettings().getRecreateMountedPagesAfterExpiry() &&\n+\t\t\t((page.isBookmarkable() && page.wasCreatedBookmarkable()) || page.isPageStateless()))\n \t\t{\n \t\t\thandler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);\n \t\t}\n@@ -3377,7 +3378,8 @@ public final CharSequence urlFor(final RequestListenerInterface listener,\n \t\tPage page = getPage();\n \t\tPageAndComponentProvider provider = new PageAndComponentProvider(page, this, parameters);\n \t\tIRequestHandler handler;\n-\t\tif (page.isBookmarkable())\n+\t\tif (getApplication().getPageSettings().getRecreateMountedPagesAfterExpiry() &&\n+\t\t\t((page.isBookmarkable() && page.wasCreatedBookmarkable()) || page.isPageStateless()))\n \t\t{\n \t\t\thandler = new BookmarkableListenerInterfaceRequestHandler(provider, listener);\n \t\t}\n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "4997",
        "nb_skipped": 2,
        "commit": "ee02c883",
        "nb_failure": 5,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1304,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.resource.loader.ValidatorStringResourceLoaderTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/resource/loader/ValidatorStringResourceLoader.java b/wicket-core/src/main/java/org/apache/wicket/resource/loader/ValidatorStringResourceLoader.java\nindex f3f03a26f7..ad7a610423 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/resource/loader/ValidatorStringResourceLoader.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/resource/loader/ValidatorStringResourceLoader.java\n@@ -21,6 +21,7 @@\n import org.apache.wicket.Component;\r\n import org.apache.wicket.markup.html.form.FormComponent;\r\n import org.apache.wicket.validation.IValidator;\r\n+import org.apache.wicket.validation.ValidatorAdapter;\r\n import org.slf4j.Logger;\r\n import org.slf4j.LoggerFactory;\r\n \r\n@@ -81,7 +82,8 @@ public String loadStringResource(final Component component, final String key,\n \t\tFormComponent<?> fc = (FormComponent<?>)component;\r\n \t\tfor (IValidator<?> validator : fc.getValidators())\r\n \t\t{\r\n-\t\t\tString resource = loadStringResource(validator.getClass(), key, locale, style,\r\n+\t\t\tClass<?> scope = getScope(validator);\r\n+\t\t\tString resource = loadStringResource(scope, key, locale, style,\r\n \t\t\t\tvariation);\r\n \t\t\tif (resource != null)\r\n \t\t\t{\r\n@@ -92,4 +94,18 @@ public String loadStringResource(final Component component, final String key,\n \t\t// not found\r\n \t\treturn null;\r\n \t}\r\n+\r\n+\tprivate Class<? extends IValidator> getScope(IValidator<?> validator)\r\n+\t{\r\n+\t\tClass<? extends IValidator> scope;\r\n+\t\tif (validator instanceof ValidatorAdapter)\r\n+\t\t{\r\n+\t\t\tscope = ((ValidatorAdapter) validator).getValidator().getClass();\r\n+\t\t}\r\n+\t\telse\r\n+\t\t{\r\n+\t\t\tscope = validator.getClass();\r\n+\t\t}\r\n+\t\treturn scope;\r\n+\t}\r\n }\r\n",
        "project": "wicket",
        "linesAdd": 17,
        "jira_id": "4379",
        "nb_skipped": 5,
        "commit": "7a162f77",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1705,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.queueing.transparentresolvers.DequeueingTransparentWebMarkupContainerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex 0a3cab4e84..3eef517b1c 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -2096,7 +2096,7 @@ public void dequeue(DequeueContext dequeue)\n \t\t\t{\n \t\t\t\t// could not dequeue, or does not contain children\n \t\n-\t\t\t\tif (tag.isOpen())\n+\t\t\t\tif (tag.isOpen() && !tag.hasNoCloseTag())\n \t\t\t\t{\n \t\t\t\t\tdequeue.skipToCloseTag();\n \t\t\t\t}\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "5728",
        "nb_skipped": 1,
        "commit": "3cc3fe95",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 99,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.UrlTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 11f6b47bc0..e950f6f90a 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -1219,18 +1219,22 @@ public Url canonical()\n \t\t\t// drop '.' from path\n \t\t\tif (\".\".equals(segment))\n \t\t\t{\n-\t\t\t\tcontinue;\n+\t\t\t\t// skip\n+\t\t\t}\n+\t\t\telse if (\"..\".equals(segment) && url.segments.isEmpty() == false)\n+\t\t\t{\n+\t\t\t\turl.segments.remove(url.segments.size() - 1);\n \t\t\t}\n-\n \t\t\t// skip segment if following segment is a '..'\n-\t\t\tif ((i + 1) < segments.size() && \"..\".equals(segments.get(i + 1)))\n+\t\t\telse if ((i + 1) < segments.size() && \"..\".equals(segments.get(i + 1)))\n \t\t\t{\n \t\t\t\ti++;\n-\t\t\t\tcontinue;\n \t\t\t}\n-\n+\t\t\telse\n+\t\t\t{\n \t\t\t\turl.segments.add(segment);\n \t\t\t}\n+\t\t}\n \t\treturn url;\n \t}\n }\n",
        "project": "wicket",
        "linesAdd": 8,
        "jira_id": "5345",
        "nb_skipped": 0,
        "commit": "3fc7234e",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1411,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.basic.SimplePageTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HtmlHeaderContainer.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HtmlHeaderContainer.java\nindex dc5d080cbe..42e63b68cd 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HtmlHeaderContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HtmlHeaderContainer.java\n@@ -30,12 +30,10 @@\n import org.apache.wicket.markup.WicketTag;\n import org.apache.wicket.markup.head.IHeaderResponse;\n import org.apache.wicket.markup.head.PageHeaderItem;\n-import org.apache.wicket.markup.head.StringHeaderItem;\n import org.apache.wicket.markup.head.internal.HeaderResponse;\n import org.apache.wicket.markup.html.TransparentWebMarkupContainer;\n import org.apache.wicket.markup.renderStrategy.AbstractHeaderRenderStrategy;\n import org.apache.wicket.request.Response;\n-import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.response.StringResponse;\n \n \n@@ -227,7 +225,7 @@ public void renderHeaderTagBody(HeaderStreamState headerStreamState)\n \t\t\tCharSequence bodyOutput = getCleanResponse(bodyResponse);\n \t\t\tif (bodyOutput.length() > 0)\n \t\t\t{\n-\t\t\t\tgetHeaderResponse().render(StringHeaderItem.forString(bodyOutput));\n+\t\t\t\tgetHeaderResponse().render(new PageHeaderItem(bodyOutput));\n \t\t\t}\n \t\t}\n \t\tfinally\n@@ -354,32 +352,6 @@ public IHeaderResponse getHeaderResponse()\n \t\treturn headerResponse;\n \t}\n \n-\t/**\n-\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT.\n-\t * \n-\t * Temporarily replaces the response with a StringResponse to capture the header output for this\n-\t * part of the stream and pass it to {@link IHeaderResponse}.\n-\t * \n-\t * @see org.apache.wicket.MarkupContainer#renderNext(org.apache.wicket.markup.MarkupStream)\n-\t */\n-\t@Override\n-\tprotected final boolean renderNext(MarkupStream markupStream)\n-\t{\n-\t\tStringResponse markupHeaderResponse = new StringResponse();\n-\t\tResponse oldResponse = getResponse();\n-\t\tRequestCycle.get().setResponse(markupHeaderResponse);\n-\t\ttry\n-\t\t{\n-\t\t\tboolean ret = super.renderNext(markupStream);\n-\t\t\tgetHeaderResponse().render(new PageHeaderItem(markupHeaderResponse.getBuffer()));\n-\t\t\treturn ret;\n-\t\t}\n-\t\tfinally\n-\t\t{\n-\t\t\tRequestCycle.get().setResponse(oldResponse);\n-\t\t}\n-\t}\n-\n \t@Override\n \tpublic IMarkupFragment getMarkup()\n \t{\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "4766",
        "nb_skipped": 5,
        "commit": "cda34428",
        "nb_failure": 1,
        "linesRem": 21,
        "singleLine": false
    },
    {
        "files": 5,
        "nb_test": 763,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.target.coding.IndexParamWithStatelessIFrameTest",
            "org.apache.wicket.request.target.coding.MixedParamUrlCodingStrategyTest",
            "org.apache.wicket.request.target.coding.StatelessStatefullUrlCodingStrategyTest",
            "org.apache.wicket.markup.html.link.IndexedParamUrlCodingTest",
            "org.apache.wicket.stateless.StatelessComponentTest",
            "org.apache.wicket.util.parse.metapattern.parsers.IndexedParamTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/request/target/coding/AbstractRequestTargetUrlCodingStrategy.java b/wicket/src/main/java/org/apache/wicket/request/target/coding/AbstractRequestTargetUrlCodingStrategy.java\nindex b1d26e9be0..5631502eee 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/target/coding/AbstractRequestTargetUrlCodingStrategy.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/target/coding/AbstractRequestTargetUrlCodingStrategy.java\n@@ -99,9 +99,11 @@ protected void appendParameters(AppendingStringBuffer url, Map<?,?> parameters)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tappendValue(url, ((Entry<?, ?>)entry1).getKey().toString(), value1);\n \t\t\t\t\t\t}\n-\t\t\t\t\t} else\n+\t\t\t\t\t}\n+\t\t\t\t\telse\n \t\t\t\t\t{\n-\t\t\t\t\t\tappendValue(url, ((Entry<?, ?>) entry1).getKey().toString(), value.toString());\n+\t\t\t\t\t\tappendValue(url, ((Entry<?, ?>)entry1).getKey().toString(),\n+\t\t\t\t\t\t\tvalue.toString());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n@@ -117,7 +119,7 @@ private void appendValue(AppendingStringBuffer url, String key, String value)\n \t\t\t{\n \t\t\t\turl.append(\"/\");\n \t\t\t}\n-\t\t\turl.append(key).append(\"/\").append(escapedValue).append(\"/\");\n+\t\t\turl.append(key).append(\"/\").append(escapedValue);\n \t\t}\n \t}\n \ndiff --git a/wicket/src/main/java/org/apache/wicket/request/target/coding/IndexedHybridUrlCodingStrategy.java b/wicket/src/main/java/org/apache/wicket/request/target/coding/IndexedHybridUrlCodingStrategy.java\nindex 4a46b34c7c..2f3ae49056 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/target/coding/IndexedHybridUrlCodingStrategy.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/target/coding/IndexedHybridUrlCodingStrategy.java\n@@ -45,6 +45,7 @@ public IndexedHybridUrlCodingStrategy(String mountPath, Class pageClass)\n \t\tsuper(mountPath, pageClass);\r\n \t}\r\n \r\n+\t@Override\r\n \tprotected void appendParameters(AppendingStringBuffer url, Map parameters)\r\n \t{\r\n \t\tint i = 0;\r\n@@ -55,7 +56,7 @@ protected void appendParameters(AppendingStringBuffer url, Map parameters)\n \t\t\t{\r\n \t\t\t\turl.append(\"/\");\r\n \t\t\t}\r\n-\t\t\turl.append(urlEncodePathComponent(value)).append(\"/\");\r\n+\t\t\turl.append(urlEncodePathComponent(value));\r\n \t\t\ti++;\r\n \t\t}\r\n \r\n@@ -68,8 +69,8 @@ protected void appendParameters(AppendingStringBuffer url, Map parameters)\n \t\t\t{\r\n \t\t\t\turl.append(\"/\");\r\n \t\t\t}\r\n-\t\t\turl.append(WebRequestCodingStrategy.PAGEMAP).append(\"/\").append(urlEncodePathComponent(pageMap))\r\n-\t\t\t\t\t.append(\"/\");\r\n+\t\t\turl.append(WebRequestCodingStrategy.PAGEMAP).append(\"/\").append(\r\n+\t\t\t\turlEncodePathComponent(pageMap));\r\n \t\t}\r\n \r\n \t\tif (i != parameters.size())\r\n@@ -80,6 +81,7 @@ protected void appendParameters(AppendingStringBuffer url, Map parameters)\n \t\t}\r\n \t}\r\n \r\n+\t@Override\r\n \tprotected ValueMap decodeParameters(String urlFragment, Map urlParameters)\r\n \t{\r\n \t\tPageParameters params = new PageParameters();\r\n@@ -102,8 +104,8 @@ protected ValueMap decodeParameters(String urlFragment, Map urlParameters)\n \t\t\tif (WebRequestCodingStrategy.PAGEMAP.equals(parts[i]))\r\n \t\t\t{\r\n \t\t\t\ti++;\r\n-\t\t\t\tparams.put(WebRequestCodingStrategy.PAGEMAP, WebRequestCodingStrategy\r\n-\t\t\t\t\t\t.decodePageMapName(urlDecodePathComponent(parts[i])));\r\n+\t\t\t\tparams.put(WebRequestCodingStrategy.PAGEMAP,\r\n+\t\t\t\t\tWebRequestCodingStrategy.decodePageMapName(urlDecodePathComponent(parts[i])));\r\n \t\t\t}\r\n \t\t\telse\r\n \t\t\t{\r\ndiff --git a/wicket/src/main/java/org/apache/wicket/request/target/coding/IndexedParamUrlCodingStrategy.java b/wicket/src/main/java/org/apache/wicket/request/target/coding/IndexedParamUrlCodingStrategy.java\nindex 5c97510a8b..d6c5c1bc3a 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/target/coding/IndexedParamUrlCodingStrategy.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/target/coding/IndexedParamUrlCodingStrategy.java\n@@ -90,7 +90,7 @@ protected void appendParameters(AppendingStringBuffer url, Map parameters)\n \t\t\t{\n \t\t\t\turl.append(\"/\");\n \t\t\t}\n-\t\t\turl.append(urlEncodePathComponent(value)).append(\"/\");\n+\t\t\turl.append(urlEncodePathComponent(value));\n \t\t\ti++;\n \t\t}\n \n@@ -104,7 +104,7 @@ protected void appendParameters(AppendingStringBuffer url, Map parameters)\n \t\t\t\turl.append(\"/\");\n \t\t\t}\n \t\t\turl.append(WebRequestCodingStrategy.PAGEMAP).append(\"/\").append(\n-\t\t\t\turlEncodePathComponent(pageMap)).append(\"/\");\n+\t\t\t\turlEncodePathComponent(pageMap));\n \t\t}\n \n \t\tString intface = (String)parameters.get(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);\n@@ -116,7 +116,7 @@ protected void appendParameters(AppendingStringBuffer url, Map parameters)\n \t\t\t\turl.append(\"/\");\n \t\t\t}\n \t\t\turl.append(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME).append(\"/\").append(\n-\t\t\t\turlEncodePathComponent(intface)).append(\"/\");\n+\t\t\t\turlEncodePathComponent(intface));\n \t\t}\n \t\tif (i != parameters.size())\n \t\t{\ndiff --git a/wicket/src/main/java/org/apache/wicket/request/target/coding/MixedParamUrlCodingStrategy.java b/wicket/src/main/java/org/apache/wicket/request/target/coding/MixedParamUrlCodingStrategy.java\nindex 97881969ea..388a0df2b5 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/target/coding/MixedParamUrlCodingStrategy.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/target/coding/MixedParamUrlCodingStrategy.java\n@@ -129,7 +129,11 @@ protected void appendParameters(AppendingStringBuffer url, Map parameters)\n \t\t\t\t{\r\n \t\t\t\t\tvalue = \"\";\r\n \t\t\t\t}\r\n-\t\t\t\turl.append(urlEncodePathComponent(value)).append(\"/\");\r\n+\t\t\t\tif (!url.endsWith(\"/\"))\r\n+\t\t\t\t{\r\n+\t\t\t\t\turl.append(\"/\");\r\n+\t\t\t\t}\r\n+\t\t\t\turl.append(urlEncodePathComponent(value));\r\n \t\t\t\tparameterNamesToAdd.remove(parameterName);\r\n \t\t\t}\r\n \t\t}\r\ndiff --git a/wicket/src/main/java/org/apache/wicket/request/target/coding/PackageRequestTargetUrlCodingStrategy.java b/wicket/src/main/java/org/apache/wicket/request/target/coding/PackageRequestTargetUrlCodingStrategy.java\nindex 9519fe8337..1808f3a253 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/target/coding/PackageRequestTargetUrlCodingStrategy.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/target/coding/PackageRequestTargetUrlCodingStrategy.java\n@@ -39,8 +39,7 @@\n  */\n public class PackageRequestTargetUrlCodingStrategy extends AbstractRequestTargetUrlCodingStrategy\n {\n-\tprivate static final Logger log = LoggerFactory\n-\t\t\t.getLogger(PackageRequestTargetUrlCodingStrategy.class);\n+\tprivate static final Logger log = LoggerFactory.getLogger(PackageRequestTargetUrlCodingStrategy.class);\n \n \t/** package for this mount. */\n \tprivate final PackageName packageName;\n@@ -110,8 +109,7 @@ public IRequestTarget decode(RequestParameters requestParameters)\n \t\t// do some extra work for checking whether this is a normal request to a\n \t\t// bookmarkable page, or a request to a stateless page (in which case a\n \t\t// wicket:interface parameter should be available\n-\t\tfinal String interfaceParameter = (String)parameters\n-\t\t\t\t.remove(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);\n+\t\tfinal String interfaceParameter = (String)parameters.remove(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);\n \n \t\tif (interfaceParameter != null)\n \t\t{\n@@ -139,13 +137,13 @@ public final CharSequence encode(IRequestTarget requestTarget)\n \t\tAppendingStringBuffer url = new AppendingStringBuffer(40);\n \t\turl.append(getMountPath());\n \t\tIBookmarkablePageRequestTarget target = (IBookmarkablePageRequestTarget)requestTarget;\n-\t\turl.append(\"/\").append(Classes.simpleName(target.getPageClass())).append(\"/\");\n+\t\turl.append(\"/\").append(Classes.simpleName(target.getPageClass()));\n \n \t\tPageParameters pageParameters = target.getPageParameters();\n \t\tif (target.getPageMapName() != null)\n \t\t{\n-\t\t\tpageParameters.put(WebRequestCodingStrategy.PAGEMAP, WebRequestCodingStrategy\n-\t\t\t\t\t.encodePageMapName(target.getPageMapName()));\n+\t\t\tpageParameters.put(WebRequestCodingStrategy.PAGEMAP,\n+\t\t\t\tWebRequestCodingStrategy.encodePageMapName(target.getPageMapName()));\n \t\t}\n \n \t\tappendParameters(url, pageParameters);\n@@ -171,6 +169,7 @@ public boolean matches(IRequestTarget requestTarget)\n \t/**\n \t * @see java.lang.Object#toString()\n \t */\n+\t@Override\n \tpublic String toString()\n \t{\n \t\treturn \"PackageEncoder[package=\" + packageName + \"]\";\n",
        "project": "wicket",
        "linesAdd": 26,
        "jira_id": "2065",
        "nb_skipped": 0,
        "commit": "9da430fb",
        "nb_failure": 16,
        "linesRem": 19,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 9,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.extensions.yui.calendar.DatePickerTest"
        ],
        "patch": "diff --git a/wicket-datetime/src/main/java/org/apache/wicket/datetime/markup/html/form/DateTextField.java b/wicket-datetime/src/main/java/org/apache/wicket/datetime/markup/html/form/DateTextField.java\nindex 718e7a3bb2..ba144cfe88 100644\n--- a/wicket-datetime/src/main/java/org/apache/wicket/datetime/markup/html/form/DateTextField.java\n+++ b/wicket-datetime/src/main/java/org/apache/wicket/datetime/markup/html/form/DateTextField.java\n@@ -132,7 +132,7 @@ public static DateTextField forDateStyle(String id, String dateStyle)\n \t */\n \tpublic static DateTextField forShortStyle(String id)\n \t{\n-\t\treturn forShortStyle(id, null);\n+\t\treturn forShortStyle(id, null, true);\n \t}\n \n \t/**\n@@ -144,9 +144,10 @@ public static DateTextField forShortStyle(String id)\n \t *            The model\n \t * @return DateTextField\n \t */\n-\tpublic static DateTextField forShortStyle(String id, IModel<Date> model)\n+\tpublic static DateTextField forShortStyle(String id, IModel<Date> model,\n+\t\tboolean applyTimeZoneDifference)\n \t{\n-\t\treturn new DateTextField(id, model, new StyleDateConverter(true));\n+\t\treturn new DateTextField(id, model, new StyleDateConverter(applyTimeZoneDifference));\n \t}\n \n \t/**\ndiff --git a/wicket-datetime/src/main/java/org/apache/wicket/extensions/yui/calendar/DateTimeField.java b/wicket-datetime/src/main/java/org/apache/wicket/extensions/yui/calendar/DateTimeField.java\nindex ebb04e458f..25f0d5c33d 100644\n--- a/wicket-datetime/src/main/java/org/apache/wicket/extensions/yui/calendar/DateTimeField.java\n+++ b/wicket-datetime/src/main/java/org/apache/wicket/extensions/yui/calendar/DateTimeField.java\n@@ -377,7 +377,7 @@ protected void convertInput()\n \t */\n \tprotected DateTextField newDateTextField(String id, PropertyModel<Date> dateFieldModel)\n \t{\n-\t\treturn DateTextField.forShortStyle(id, dateFieldModel);\n+\t\treturn DateTextField.forShortStyle(id, dateFieldModel, false);\n \t}\n \n \t/**\n",
        "project": "wicket",
        "linesAdd": 5,
        "jira_id": "3510",
        "nb_skipped": 0,
        "commit": "292a2582",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1325,
        "nb_error": 1,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.wicket.markup.parser.filter.HtmlHandlerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHandler.java\nindex b45ed7c42f..440e5bc33a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHandler.java\n@@ -78,6 +78,7 @@ public void postProcess(final Markup markup)\n \t\t\tif (!requiresCloseTag(top.getName()))\n \t\t\t{\n \t\t\t\tstack.pop();\n+\t\t\t\ttop.setHasNoCloseTag(true);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "4494",
        "nb_skipped": 8,
        "commit": "35843c19",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": true,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 1174,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.form.upload.FileUploadTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/upload/FileUpload.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/upload/FileUpload.java\nindex 3f895d300b..6bc50c4973 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/upload/FileUpload.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/upload/FileUpload.java\n@@ -27,6 +27,7 @@\n import org.apache.wicket.IClusterable;\n import org.apache.wicket.Session;\n import org.apache.wicket.WicketRuntimeException;\n+import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.util.file.Files;\n import org.apache.wicket.util.io.IOUtils;\n import org.apache.wicket.util.lang.Args;\n@@ -247,8 +248,10 @@ public void writeTo(final File file) throws IOException\n \t */\n \tpublic final File writeToTempFile() throws IOException\n \t{\n-\t\tFile temp = File.createTempFile(Session.get().getId(),\n-\t\t\tFiles.cleanupFilename(item.getFieldName()));\n+\t\tSession.get();\n+\t\tString sessionId = Session.exists() ? Session.get().getId() : \"\";\n+\t\tString tempFileName = sessionId + \"_\" + RequestCycle.get().getStartTime();\n+\t\tFile temp = File.createTempFile(tempFileName, Files.cleanupFilename(item.getFieldName()));\n \t\twriteTo(temp);\n \t\treturn temp;\n \t}\n",
        "project": "wicket",
        "linesAdd": 5,
        "jira_id": "3715",
        "nb_skipped": 0,
        "commit": "557de7bc",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 15,
        "nb_error": 6,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.spring.injection.annot.AnnotProxyFieldValueFactoryTest",
            "org.apache.wicket.spring.SpringBeanLocatorTest"
        ],
        "patch": "diff --git a/wicket-spring/src/main/java/org/apache/wicket/spring/SpringBeanLocator.java b/wicket-spring/src/main/java/org/apache/wicket/spring/SpringBeanLocator.java\nindex 35d3be3505..dfa21818f2 100644\n--- a/wicket-spring/src/main/java/org/apache/wicket/spring/SpringBeanLocator.java\n+++ b/wicket-spring/src/main/java/org/apache/wicket/spring/SpringBeanLocator.java\n@@ -26,9 +26,11 @@\n import org.apache.wicket.util.lang.Objects;\n import org.apache.wicket.util.lang.WicketObjects;\n import org.apache.wicket.util.string.Strings;\n+import org.springframework.beans.factory.BeanFactory;\n import org.springframework.beans.factory.BeanFactoryUtils;\n import org.springframework.beans.factory.NoSuchBeanDefinitionException;\n import org.springframework.beans.factory.config.BeanDefinition;\n+import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n import org.springframework.beans.factory.support.AbstractBeanDefinition;\n import org.springframework.context.ApplicationContext;\n import org.springframework.context.support.AbstractApplicationContext;\n@@ -120,14 +122,17 @@ private final String getBeanNameOfClass(final ApplicationContext ctx, final Clas\n \t\twhile (it.hasNext())\n \t\t{\n \t\t\tfinal String possibility = it.next();\n-\t\t\tBeanDefinition beanDef = ((AbstractApplicationContext)ctx).getBeanFactory()\n-\t\t\t\t\t.getBeanDefinition(possibility);\n+\t\t\tif (ctx instanceof AbstractApplicationContext)\n+\t\t\t{\n+\t\t\t\tBeanDefinition beanDef = getBeanDefinition(((AbstractApplicationContext)ctx)\n+\t\t\t\t\t\t.getBeanFactory(), possibility);\n \t\t\t\tif (BeanFactoryUtils.isFactoryDereference(possibility) ||\n \t\t\t\t\t\tpossibility.startsWith(\"scopedTarget.\") || !beanDef.isAutowireCandidate())\n \t\t\t\t{\n \t\t\t\t\tit.remove();\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n \n \t\tif (names.isEmpty())\n \t\t{\n@@ -137,18 +142,23 @@ else if (names.size() > 1)\n \t\t{\n \t\t\tif (ctx instanceof AbstractApplicationContext)\n \t\t\t{\n+\t\t\t\tList<String> primaries = new ArrayList<String>();\n \t\t\t\tfor (String name : names)\n \t\t\t\t{\n-\t\t\t\t\tBeanDefinition beanDef = ((AbstractApplicationContext)ctx).getBeanFactory()\n-\t\t\t\t\t\t\t.getBeanDefinition(name);\n+\t\t\t\t\tBeanDefinition beanDef = getBeanDefinition(((AbstractApplicationContext)ctx)\n+\t\t\t\t\t\t\t.getBeanFactory(), name);\n \t\t\t\t\tif (beanDef instanceof AbstractBeanDefinition)\n \t\t\t\t\t{\n \t\t\t\t\t\tif (((AbstractBeanDefinition)beanDef).isPrimary())\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\treturn name;\n+\t\t\t\t\t\t\tprimaries.add(name);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tif (primaries.size() == 1)\n+\t\t\t\t{\n+\t\t\t\t\treturn primaries.get(0);\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tStringBuilder msg = new StringBuilder();\n@@ -166,6 +176,28 @@ else if (names.size() > 1)\n \t\t}\n \t}\n \n+\tprivate BeanDefinition getBeanDefinition(ConfigurableListableBeanFactory beanFactory,\n+\t\t\tString name)\n+\t{\n+\t\tif (beanFactory.containsBeanDefinition(name))\n+\t\t{\n+\t\t\treturn beanFactory.getBeanDefinition(name);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tBeanFactory parent = beanFactory.getParentBeanFactory();\n+\t\t\tif (parent != null && parent instanceof ConfigurableListableBeanFactory)\n+\t\t\t{\n+\t\t\t\treturn getBeanDefinition(beanFactory, name);\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\n \t/**\n \t * @return returns whether the bean (the locator is supposed to istantiate) is a singleton or\n \t *         not\ndiff --git a/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java b/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\nindex 5cf9d0e445..6b3629582c 100644\n--- a/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\n+++ b/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\n@@ -29,8 +29,10 @@\n import org.apache.wicket.spring.SpringBeanLocator;\n import org.apache.wicket.util.lang.Generics;\n import org.apache.wicket.util.string.Strings;\n+import org.springframework.beans.factory.BeanFactory;\n import org.springframework.beans.factory.BeanFactoryUtils;\n import org.springframework.beans.factory.config.BeanDefinition;\n+import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\n import org.springframework.beans.factory.support.AbstractBeanDefinition;\n import org.springframework.context.ApplicationContext;\n import org.springframework.context.support.AbstractApplicationContext;\n@@ -187,14 +189,17 @@ private final String getBeanNameOfClass(ApplicationContext ctx, Class< ? > clazz\n \t\twhile (it.hasNext())\n \t\t{\n \t\t\tfinal String possibility = it.next();\n-\t\t\tBeanDefinition beanDef = ((AbstractApplicationContext)ctx).getBeanFactory()\n-\t\t\t\t\t.getBeanDefinition(possibility);\n+\t\t\tif (ctx instanceof AbstractApplicationContext)\n+\t\t\t{\n+\t\t\t\tBeanDefinition beanDef = getBeanDefinition(((AbstractApplicationContext)ctx)\n+\t\t\t\t\t\t.getBeanFactory(), possibility);\n \t\t\t\tif (BeanFactoryUtils.isFactoryDereference(possibility) ||\n \t\t\t\t\t\tpossibility.startsWith(\"scopedTarget.\") || !beanDef.isAutowireCandidate())\n \t\t\t\t{\n \t\t\t\t\tit.remove();\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n \n \t\tif (names.isEmpty())\n \t\t{\n@@ -204,17 +209,22 @@ else if (names.size() > 1)\n \t\t{\n \t\t\tif (ctx instanceof AbstractApplicationContext)\n \t\t\t{\n+\t\t\t\tList<String> primaries = new ArrayList<String>();\n \t\t\t\tfor (String name : names)\n \t\t\t\t{\n-\t\t\t\t\tBeanDefinition beanDef = ((AbstractApplicationContext)ctx).getBeanFactory()\n-\t\t\t\t\t\t\t.getBeanDefinition(name);\n+\t\t\t\t\tBeanDefinition beanDef = getBeanDefinition(((AbstractApplicationContext)ctx)\n+\t\t\t\t\t\t\t.getBeanFactory(), name);\n \t\t\t\t\tif (beanDef instanceof AbstractBeanDefinition)\n \t\t\t\t\t{\n \t\t\t\t\t\tif (((AbstractBeanDefinition)beanDef).isPrimary())\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\treturn name;\n+\t\t\t\t\t\t\tprimaries.add(name);\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tif (primaries.size() == 1)\n+\t\t\t\t{\n+\t\t\t\t\treturn primaries.get(0);\n \t\t\t\t}\n \t\t\t}\n \t\t\tStringBuilder msg = new StringBuilder();\n@@ -232,6 +242,28 @@ else if (names.size() > 1)\n \t\t}\n \t}\n \n+\tprivate BeanDefinition getBeanDefinition(ConfigurableListableBeanFactory beanFactory,\n+\t\t\tString name)\n+\t{\n+\t\tif (beanFactory.containsBeanDefinition(name))\n+\t\t{\n+\t\t\treturn beanFactory.getBeanDefinition(name);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tBeanFactory parent = beanFactory.getParentBeanFactory();\n+\t\t\tif (parent != null && parent instanceof ConfigurableListableBeanFactory)\n+\t\t\t{\n+\t\t\t\treturn getBeanDefinition(beanFactory, name);\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\n \t/**\n \t * @see org.apache.wicket.injection.IFieldValueFactory#supportsField(java.lang.reflect.Field)\n \t */\n",
        "project": "wicket",
        "linesAdd": 74,
        "jira_id": "2900",
        "nb_skipped": 0,
        "commit": "0e70ce39",
        "nb_failure": 0,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1641,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.http.servlet.ServletWebResponseTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\nindex e665aaf1db..e7e32d17a2 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\n@@ -173,29 +173,39 @@ public String encodeURL(CharSequence url)\n \t{\n \t\tArgs.notNull(url, \"url\");\n \n+\t\tUrlRenderer urlRenderer = RequestCycle.get().getUrlRenderer();\n+\n+\t\tUrl originalUrl = Url.parse(url);\n+\n \t\t/*\n \t\t  WICKET-4645 - always pass absolute url to the web container for encoding\n \t\t  because when REDIRECT_TO_BUFFER is in use Wicket may render PageB when\n \t\t  PageA is actually the requested one and the web container cannot resolve\n \t\t  the base url properly\n \t\t */\n-\t\tUrlRenderer urlRenderer = RequestCycle.get().getUrlRenderer();\n-\t\tUrl relativeUrl = Url.parse(url);\n-\t\tString fullUrl = urlRenderer.renderFullUrl(relativeUrl);\n+\t\tString fullUrl = urlRenderer.renderFullUrl(originalUrl);\n \t\tString encodedFullUrl = httpServletResponse.encodeURL(fullUrl);\n-\t\tfinal String encodedRelativeUrl;\n+\n+\t\tfinal String encodedUrl;\n+\t\tif (originalUrl.isFull())\n+\t\t{\n+\t\t\tencodedUrl = encodedFullUrl;\n+\t\t}\n+\t\telse\n+\t\t{\n \t\t\tif (fullUrl.equals(encodedFullUrl))\n \t\t\t{\n-\t\t\t// no encoding happened so just reuse the relative url\n-\t\t\tencodedRelativeUrl = url.toString();\n+\t\t\t\t// no encoding happened so just reuse the original url\n+\t\t\t\tencodedUrl = url.toString();\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\t// get the relative url with the jsessionid encoded in it\n \t\t\t\tUrl _encoded = Url.parse(encodedFullUrl);\n-\t\t\tencodedRelativeUrl = urlRenderer.renderRelativeUrl(_encoded);\n+\t\t\t\tencodedUrl = urlRenderer.renderRelativeUrl(_encoded);\n \t\t\t}\n-\t\treturn encodedRelativeUrl;\n+\t\t}\n+\t\treturn encodedUrl;\n \t}\n \n \t@Override\n@@ -203,29 +213,38 @@ public String encodeRedirectURL(CharSequence url)\n \t{\n \t\tArgs.notNull(url, \"url\");\n \n+\t\tUrlRenderer urlRenderer = RequestCycle.get().getUrlRenderer();\n+\n+\t\tUrl originalUrl = Url.parse(url);\n+\n \t\t/*\n-\t\t  WICKET-4854 - always pass absolute url to the web container for encoding\n-\t\t  because when REDIRECT_TO_BUFFER is in use Wicket may render PageB when\n-\t\t  PageA is actually the requested one and the web container cannot resolve\n-\t\t  the base url properly\n+\t\t * WICKET-4645 - always pass absolute url to the web container for encoding because when\n+\t\t * REDIRECT_TO_BUFFER is in use Wicket may render PageB when PageA is actually the requested\n+\t\t * one and the web container cannot resolve the base url properly\n \t\t */\n-\t\tUrlRenderer urlRenderer = new UrlRenderer(webRequest);\n-\t\tUrl relativeUrl = Url.parse(url);\n-\t\tString fullUrl = urlRenderer.renderFullUrl(relativeUrl);\n+\t\tString fullUrl = urlRenderer.renderFullUrl(originalUrl);\n \t\tString encodedFullUrl = httpServletResponse.encodeRedirectURL(fullUrl);\n-\t\tfinal String encodedRelativeUrl;\n+\n+\t\tfinal String encodedUrl;\n+\t\tif (originalUrl.isFull())\n+\t\t{\n+\t\t\tencodedUrl = encodedFullUrl;\n+\t\t}\n+\t\telse\n+\t\t{\n \t\t\tif (fullUrl.equals(encodedFullUrl))\n \t\t\t{\n-\t\t\t// no encoding happened so just reuse the relative url\n-\t\t\tencodedRelativeUrl = url.toString();\n+\t\t\t\t// no encoding happened so just reuse the original url\n+\t\t\t\tencodedUrl = url.toString();\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\t// get the relative url with the jsessionid encoded in it\n \t\t\t\tUrl _encoded = Url.parse(encodedFullUrl);\n-\t\t\tencodedRelativeUrl = urlRenderer.renderRelativeUrl(_encoded);\n+\t\t\t\tencodedUrl = urlRenderer.renderRelativeUrl(_encoded);\n+\t\t\t}\n \t\t}\n-\t\treturn encodedRelativeUrl;\n+\t\treturn encodedUrl;\n \t}\n \n \t@Override\n",
        "project": "wicket",
        "linesAdd": 34,
        "jira_id": "5582",
        "nb_skipped": 2,
        "commit": "1fb66533",
        "nb_failure": 2,
        "linesRem": 18,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1045,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.tree.TreeTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/tree/AbstractTree.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/tree/AbstractTree.java\nindex ed9843ad9c..2547853127 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/tree/AbstractTree.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/tree/AbstractTree.java\n@@ -832,13 +832,17 @@ public final void treeNodesInserted(TreeModelEvent e)\n \t\t\t{\n \t\t\t\twasLeaf = eventChildren.contains(getChildAt(parentNode, i));\n \t\t\t}\n-\n-\t\t\tif (wasLeaf)\n+\t\t\t// if parent was a leaf, testing if wasn't an not presented root\n+\t\t\tif (wasLeaf && !(parentItem.getParentItem() == null && isRootLess()))\n \t\t\t{\n-\t\t\t\t// parentNode now has children for the first time, so we need to invalidate\n+\t\t\t\t// parentNode now has children for the first time, so we may need to invalidate\n \t\t\t\t// grandparent so that parentNode's junctionLink gets rebuilt with a plus/minus link\n \t\t\t\tObject grandparentNode = getParentNode(parentNode);\n+\t\t\t\t// not invalidating if the grandparent is a not presented root\n+\t\t\t\tif (!(getParentNode(grandparentNode) == null && isRootLess()))\n+\t\t\t\t{\n \t\t\t\t\tinvalidateNodeWithChildren(grandparentNode);\n+\t\t\t\t}\n \t\t\t\tgetTreeState().expandNode(parentNode);\n \t\t\t}\n \t\t\telse\n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "3309",
        "nb_skipped": 0,
        "commit": "debca73b",
        "nb_failure": 2,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1679,
        "nb_error": 22,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.handler.render.WebPageRendererTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WebApplication.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WebApplication.java\nindex 52d41cad74..0ff49bc479 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WebApplication.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WebApplication.java\n@@ -876,10 +876,12 @@ public boolean hasBufferedResponse(String sessionId, Url url)\n \t}\n \n \t/**\n+\t * Retrieves a stored buffered response for a given sessionId and url.\n \t *\n-\t * @param sessionId\n \t * @param url\n-\t * @return buffered response\n+\t *          The url used as a key\n+\t * @return the stored buffered response. {@code null} if there is no stored response for the given url\n+\t * @see org.apache.wicket.settings.IRequestCycleSettings.RenderStrategy#REDIRECT_TO_BUFFER\n \t */\n \tpublic BufferedWebResponse getAndRemoveBufferedResponse(String sessionId, Url url)\n \t{\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\nindex aee01040c8..00a8ea2906 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n@@ -87,11 +87,6 @@ protected void storeBufferedResponse(Url url, BufferedWebResponse response)\n \t\tWebApplication.get().storeBufferedResponse(getSessionId(), url, response);\n \t}\n \t\n-\tprotected BufferedWebResponse getAndRemoveBufferedResponse(Url url)\n-\t{\n-\t\treturn WebApplication.get().getAndRemoveBufferedResponse(getSessionId(), url);\n-\t}\n-\n \t/**\n \t * Renders page to a {@link BufferedWebResponse}. All URLs in page will be rendered relative to\n \t * <code>targetUrl</code>\n@@ -195,17 +190,7 @@ public void respond(RequestCycle requestCycle)\n \t\t// 3 rendering strategies and two kind of requests (ajax and normal)\n \t\t//\n \n-\t\t// try to get an already rendered buffered response for current URL\n-\t\tBufferedWebResponse bufferedResponse = getAndRemoveBufferedResponse(currentUrl);\n-\n-\t\tif (bufferedResponse != null)\n-\t\t{\n-\t\t\tlogger\n-\t\t\t\t.warn(\"The Buffered response should be handled by BufferedResponseRequestHandler\");\n-\t\t\t// if there is saved response for this URL render it\n-\t\t\tbufferedResponse.writeTo((WebResponse)requestCycle.getResponse());\n-\t\t}\n-\t\telse if (shouldRenderPageAndWriteResponse(requestCycle, currentUrl, targetUrl))\n+\t\tif (shouldRenderPageAndWriteResponse(requestCycle, currentUrl, targetUrl))\n \t\t{\n \t\t\tBufferedWebResponse response = renderPage(currentUrl, requestCycle);\n \t\t\tif (response != null)\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "5689",
        "nb_skipped": 1,
        "commit": "2ac29d30",
        "nb_failure": 0,
        "linesRem": 14,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1046,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.form.TextFieldTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/AbstractTextComponent.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/AbstractTextComponent.java\nindex 845187ca08..b9a424485f 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/AbstractTextComponent.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/AbstractTextComponent.java\n@@ -21,7 +21,6 @@\n import org.apache.wicket.Component;\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.model.IObjectClassAwareModel;\n-import org.apache.wicket.util.convert.ConversionException;\n import org.apache.wicket.util.string.Strings;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -109,6 +108,8 @@ public boolean isInputNullable()\n \t}\n \n \t/**\n+\t * Convert the input respecting the flag convertEmptyInputStringToNull. Subclasses that override\n+\t * this method should test this flag also.\n \t * \n \t * @see org.apache.wicket.markup.html.form.FormComponent#convertInput()\n \t */\n@@ -118,8 +119,17 @@ protected void convertInput()\n \t\t// Stateless forms don't have to be rendered first, convertInput could be called before\n \t\t// onBeforeRender calling resolve type here again to check if the type is correctly set.\n \t\tresolveType();\n+\t\tString[] value = getInputAsArray();\n+\t\tString tmp = value != null && value.length > 0 ? value[0] : null;\n+\t\tif (getConvertEmptyInputStringToNull() && Strings.isEmpty(tmp))\n+\t\t{\n+\t\t\tsetConvertedInput(null);\n+\t\t}\n+\t\telse\n+\t\t{\n \t\t\tsuper.convertInput();\n \t\t}\n+\t}\n \n \t/**\n \t * If the type is not set try to guess it if the model supports it.\n@@ -140,13 +150,8 @@ private void resolveType()\n \t{\n \t\tif (!getFlag(TYPE_RESOLVED) && getType() == null)\n \t\t{\n-\t\t\t// Set the type, but only if it's not a String (see WICKET-606).\n-\t\t\t// Otherwise, getConvertEmptyInputStringToNull() won't work.\n \t\t\tClass<?> type = getModelType(getDefaultModel());\n-\t\t\tif (!String.class.equals(type))\n-\t\t\t{\n \t\t\tsetType(type);\n-\t\t\t}\n \t\t\tsetFlag(TYPE_RESOLVED, true);\n \t\t}\n \t}\n@@ -186,18 +191,4 @@ private void resolveType()\n \t\tsetFlag(FLAG_CONVERT_EMPTY_INPUT_STRING_TO_NULL, flag);\n \t\treturn this;\n \t}\n-\n-\t/**\n-\t * @see org.apache.wicket.markup.html.form.FormComponent#convertValue(String[])\n-\t */\n-\t@Override\n-\tprotected T convertValue(String[] value) throws ConversionException\n-\t{\n-\t\tString tmp = value != null && value.length > 0 ? value[0] : null;\n-\t\tif (getConvertEmptyInputStringToNull() && Strings.isEmpty(tmp))\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n-\t\treturn super.convertValue(value);\n-\t}\n }\n",
        "project": "wicket",
        "linesAdd": 9,
        "jira_id": "3304",
        "nb_skipped": 0,
        "commit": "7e7ab76c",
        "nb_failure": 1,
        "linesRem": 15,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 8,
        "nb_error": 0,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.wicket.request.UrlEncoderTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/UrlEncoder.java b/wicket-request/src/main/java/org/apache/wicket/request/UrlEncoder.java\nindex 3bfc78af7a..aadac5ef2e 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/UrlEncoder.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/UrlEncoder.java\n@@ -174,7 +174,6 @@ protected UrlEncoder(final Type type, final char stopChar)\n \t\tdontNeedEncoding.set('!');\r\n \t\tdontNeedEncoding.set('$');\r\n \t\t// \"&\" needs to be encoded for query stings\r\n-\t\tdontNeedEncoding.set('\\'');\r\n \t\t// \"(\" and \")\" probably don't need encoding, but we'll be conservative\r\n \t\tdontNeedEncoding.set('*');\r\n \t\t// \"+\" needs to be encoded for query strings (since it means =\r\n",
        "project": "wicket",
        "linesAdd": 0,
        "jira_id": "3721",
        "nb_skipped": 0,
        "commit": "1858bc18",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": true,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 1063,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.cycle.RequestCycleListenerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java b/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\nindex 81923b6f16..4c933706da 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\n@@ -199,6 +199,8 @@ public boolean processRequest()\n \t\ttry\n \t\t{\n \t\t\tset(this);\n+\t\t\tlisteners.onBeginRequest(this);\n+\t\t\tonBeginRequest();\n \t\t\tIRequestHandler handler = resolveRequestHandler();\n \t\t\tif (handler != null)\n \t\t\t{\n@@ -242,8 +244,6 @@ public boolean processRequestAndDetach()\n \t\tboolean result;\n \t\ttry\n \t\t{\n-\t\t\tlisteners.onBeginRequest(this);\n-\t\t\tonBeginRequest();\n \t\t\tresult = processRequest();\n \t\t}\n \t\tfinally\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "3428",
        "nb_skipped": 0,
        "commit": "ffc0cae9",
        "nb_failure": 2,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1260,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.http.mock.MockHttpServletResponseTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletResponse.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletResponse.java\nindex eb8262ac10..01581ef201 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletResponse.java\n@@ -27,6 +27,7 @@\n import java.util.Collections;\n import java.util.Date;\n import java.util.GregorianCalendar;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Locale;\n import java.util.Set;\n@@ -102,7 +103,18 @@ public MockHttpServletResponse(MockHttpServletRequest servletRequest)\n \tpublic void addCookie(final Cookie cookie)\n \t{\n \t\t// remove any potential duplicates\n-\t\tcookies.remove(cookie);\n+\t\t// see http://www.ietf.org/rfc/rfc2109.txt, p.4.3.3\n+\t\tIterator<Cookie> iterator = cookies.iterator();\n+\t\twhile (iterator.hasNext())\n+\t\t{\n+\t\t\tCookie old = iterator.next();\n+\t\t\tif (cookie.getName().equals(old.getName()) &&\n+\t\t\t\t((cookie.getPath() == null && old.getPath() == null) || (cookie.getPath().equals(old.getPath()))) &&\n+\t\t\t\t((cookie.getDomain() == null && old.getDomain() == null) || (cookie.getDomain().equals(old.getDomain()))))\n+\t\t\t{\n+\t\t\t\titerator.remove();\n+\t\t\t}\n+\t\t}\n \t\tcookies.add(cookie);\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 12,
        "jira_id": "4292",
        "nb_skipped": 3,
        "commit": "9cb617ae",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1688,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.panel.FencedFeedbackPanelTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/feedback/FencedFeedbackPanel.java b/wicket-core/src/main/java/org/apache/wicket/feedback/FencedFeedbackPanel.java\nindex f7df59ec21..42e134405f 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/feedback/FencedFeedbackPanel.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/feedback/FencedFeedbackPanel.java\n@@ -29,13 +29,13 @@\n  * the nesting of these panels to work correctly without displaying the same feedback message twice.\n  * A constructor that does not takes a fencing component creates a catch-all panel that shows\n  * messages that do not come from inside any fence or from the {@link Session}.\n- * \n+ * <p/>\n  * <h2>IN DEPTH EXPLANATION</h2>\n  * <p>\n  * It is often very useful to have feedback panels that show feedback that comes from inside a\n  * certain container only. For example given a page with the following structure:\n  * </p>\n- * \n+ * <p/>\n  * <pre>\n  * Page\n  *   Form1\n@@ -112,10 +112,9 @@ public FencedFeedbackPanel(String id, Component fence)\n \t/**\n \t * Creates a catch-all instance with a filter.\n \t *\n-\t * @see #FencedFeedbackPanel(String)\n-\t * \n \t * @param id\n \t * @param filter\n+\t * @see #FencedFeedbackPanel(String)\n \t */\n \tpublic FencedFeedbackPanel(String id, IFeedbackMessageFilter filter)\n \t{\n@@ -125,23 +124,27 @@ public FencedFeedbackPanel(String id, IFeedbackMessageFilter filter)\n \t/**\n \t * Creates a fenced feedback panel with a filter.\n \t *\n-\t * @see #FencedFeedbackPanel(String, Component)\n-\t * \n \t * @param id\n \t * @param fence\n \t * @param filter\n+\t * @see #FencedFeedbackPanel(String, Component)\n \t */\n \tpublic FencedFeedbackPanel(String id, Component fence, IFeedbackMessageFilter filter)\n \t{\n \t\tsuper(id, filter);\n \t\tthis.fence = fence;\n \t\tif (fence != null)\n+\t\t{\n+\t\t\tincrementFenceCount();\n+\t\t}\n+\t}\n+\n+\tprivate void incrementFenceCount()\n \t{\n \t\tInteger count = fence.getMetaData(FENCE_KEY);\n \t\tcount = count == null ? 1 : count + 1;\n \t\tfence.setMetaData(FENCE_KEY, count);\n \t}\n-\t}\n \n \t@Override\n \tprotected void onRemove()\n@@ -151,11 +154,16 @@ protected void onRemove()\n \t\t{\n \t\t\t// decrement the fence count\n \n+\t\t\tdecrementFenceCount();\n+\t\t}\n+\t}\n+\n+\tprivate void decrementFenceCount()\n+\t{\n \t\tInteger count = fence.getMetaData(FENCE_KEY);\n \t\tcount = (count == null || count == 1) ? null : count - 1;\n \t\tfence.setMetaData(FENCE_KEY, count);\n \t}\n-\t}\n \n \t@Override\n \tprotected FeedbackMessagesModel newFeedbackMessagesModel()\n@@ -177,7 +185,7 @@ protected FeedbackMessagesModel newFeedbackMessagesModel()\n \t\t\t\t\t\t@Override\n \t\t\t\t\t\tprotected boolean shouldRecurseInto(Component component)\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\treturn component.getMetaData(FENCE_KEY) == null;\n+\t\t\t\t\t\t\treturn !componentIsMarkedAsFence(component);\n \t\t\t\t\t\t}\n \t\t\t\t\t}.collect(filter);\n \t\t\t\t}\n@@ -191,12 +199,29 @@ protected boolean shouldRecurseInto(Component component)\n \t\t\t\t\t\tprotected boolean shouldRecurseInto(Component component)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\t// only recurse into components that are not fences\n-\n-\t\t\t\t\t\t\treturn component.getMetaData(FENCE_KEY) == null;\n+\t\t\t\t\t\t\treturn !componentIsMarkedAsFence(component);\n \t\t\t\t\t\t}\n \t\t\t\t\t}.setIncludeSession(false).collect(filter);\n \t\t\t\t}\n \t\t\t}\n \t\t};\n \t}\n+\n+\tprivate boolean componentIsMarkedAsFence(Component component)\n+\t{\n+\t\treturn component.getMetaData(FENCE_KEY) != null;\n+\t}\n+\n+\t@Override\n+\tprotected void onReAdd()\n+\t{\n+\t\tif (this.fence != null)\n+\t\t{\n+\t\t\t// The fence mark is removed when the feedback panel is removed from the hierarchy.\n+\t\t\t// see onRemove().\n+\t\t\t// when the panel is re-added, we recreate the fence mark.\n+\t\t\tincrementFenceCount();\n+\t\t}\n+\t\tsuper.onReAdd();\n+\t}\n }\n",
        "project": "wicket",
        "linesAdd": 29,
        "jira_id": "5265",
        "nb_skipped": 1,
        "commit": "0eb596df",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1791,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.RestartResponseAtInterceptPageExceptionTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/WebPage.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/WebPage.java\nindex 903d7c414e..5c7d6bb8d8 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/WebPage.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/WebPage.java\n@@ -26,11 +26,9 @@\n import org.apache.wicket.markup.renderStrategy.AbstractHeaderRenderStrategy;\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.protocol.http.WebApplication;\n-import org.apache.wicket.request.IRequestHandler;\n import org.apache.wicket.request.Request;\n import org.apache.wicket.request.Response;\n import org.apache.wicket.request.cycle.RequestCycle;\n-import org.apache.wicket.core.request.handler.IPageRequestHandler;\n import org.apache.wicket.request.http.WebRequest;\n import org.apache.wicket.request.http.WebResponse;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n@@ -216,8 +214,11 @@ protected void onAfterRender()\n \t\t// only in development mode validate the headers\n \t\tif (getApplication().usesDevelopmentConfig())\n \t\t{\n+\t\t\t// check headers only when page was completely rendered\n+\t\t\tif (wasRendered(this)) {\n \t\t\t\tvalidateHeaders();\n \t\t\t}\n+\t\t}\n \n \t\tsuper.onAfterRender();\n \t}\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "1718",
        "nb_skipped": 1,
        "commit": "bb7f9cf5",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 935,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.parser.MergedMarkupTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/MergedMarkup.java b/wicket/src/main/java/org/apache/wicket/markup/MergedMarkup.java\nindex 1e686c2525..c1194fffa1 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/MergedMarkup.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/MergedMarkup.java\n@@ -63,6 +63,12 @@ public MergedMarkup(final Markup markup, final Markup baseMarkup, int extendInde\n \n \t\tgetMarkupResourceStream().setBaseMarkup(baseMarkup);\n \n+\t\t// Copy settings from derived markup\n+\t\tMarkupResourceStream baseResourceStream = baseMarkup.getMarkupResourceStream();\n+\t\tgetMarkupResourceStream().setXmlDeclaration(baseResourceStream.getXmlDeclaration());\n+\t\tgetMarkupResourceStream().setEncoding(baseResourceStream.getEncoding());\n+\t\tgetMarkupResourceStream().setWicketNamespace(baseResourceStream.getWicketNamespace());\n+\n \t\tif (log.isDebugEnabled())\n \t\t{\n \t\t\tString derivedResource = Strings.afterLast(markup.getMarkupResourceStream()\n",
        "project": "wicket",
        "linesAdd": 5,
        "jira_id": "2569",
        "nb_skipped": 0,
        "commit": "9ced53a5",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1194,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.wicket4066.Wicket4066Test"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java b/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\nindex 1a3187887f..98668ade0e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\n@@ -165,7 +165,7 @@ static boolean continueToOriginalDestination()\n \t{\n \t\tpublic int getCompatibilityScore(Request request)\n \t\t{\n-\t\t\treturn 0;\n+\t\t\treturn matchedData(request) != null ? Integer.MAX_VALUE : 0;\n \t\t}\n \n \t\tpublic Url mapHandler(IRequestHandler requestHandler)\n@@ -175,10 +175,8 @@ public Url mapHandler(IRequestHandler requestHandler)\n \n \t\tpublic IRequestHandler mapRequest(Request request)\n \t\t{\n-\t\t\tInterceptData data = InterceptData.get();\n+\t\t\tInterceptData data = matchedData(request);\n \t\t\tif (data != null)\n-\t\t\t{\n-\t\t\t\tif (data.originalUrl.equals(request.getOriginalUrl()))\n \t\t\t{\n \t\t\t\tif (data.postParameters.isEmpty() == false &&\n \t\t\t\t\trequest.getPostParameters() instanceof IWritableRequestParameters)\n@@ -192,6 +190,15 @@ public IRequestHandler mapRequest(Request request)\n \t\t\t\t}\n \t\t\t\tInterceptData.clear();\n \t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\t\t\n+\t\tprivate InterceptData matchedData(Request request)\n+\t\t{\n+\t\t\tInterceptData data = InterceptData.get();\n+\t\t\tif(data != null && data.originalUrl.equals(request.getOriginalUrl()))\n+\t\t\t{\n+\t\t\t\treturn data;\n \t\t\t}\n \t\t\treturn null;\n \t\t}\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/SystemMapper.java b/wicket-core/src/main/java/org/apache/wicket/SystemMapper.java\nindex e0eea63735..7412737dcd 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/SystemMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/SystemMapper.java\n@@ -46,12 +46,12 @@\n \tpublic SystemMapper(final Application application)\r\n \t{\r\n \t\tthis.application = application;\r\n-\t\tadd(RestartResponseAtInterceptPageException.MAPPER);\r\n \t\tadd(new PageInstanceMapper());\r\n \t\tadd(new BookmarkableMapper());\r\n \t\tadd(new HomePageMapper(new HomePageProvider<Page>(application)));\r\n \t\tadd(new ResourceReferenceMapper(new PageParametersEncoder(),\r\n \t\t\tnew ParentFolderPlaceholderProvider(application), getResourceCachingStrategy()));\r\n+\t\tadd(RestartResponseAtInterceptPageException.MAPPER);\r\n \t\tadd(new BufferedResponseMapper());\r\n \t}\r\n \r\n",
        "project": "wicket",
        "linesAdd": 12,
        "jira_id": "4066",
        "nb_skipped": 2,
        "commit": "4d3d1f85",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 4,
        "nb_test": 1332,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.internal.InlineEnclosureTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Application.java b/wicket-core/src/main/java/org/apache/wicket/Application.java\nindex 6cd4445911..98078ea2ce 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Application.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Application.java\n@@ -685,11 +685,11 @@ protected void internalInit()\n \t\tpageSettings.addComponentResolver(new HtmlHeaderResolver());\n \t\tpageSettings.addComponentResolver(new WicketLinkTagHandler());\n \t\tpageSettings.addComponentResolver(new WicketMessageResolver());\n-\t\tpageSettings.addComponentResolver(new WicketMessageTagHandler());\n \t\tpageSettings.addComponentResolver(new FragmentResolver());\n \t\tpageSettings.addComponentResolver(new RelativePathPrefixHandler());\n \t\tpageSettings.addComponentResolver(new EnclosureHandler());\n \t\tpageSettings.addComponentResolver(new InlineEnclosureHandler());\n+\t\tpageSettings.addComponentResolver(new WicketMessageTagHandler());\n \t\tpageSettings.addComponentResolver(new WicketContainerResolver());\n \n \t\t// Install button image resource factory\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/MarkupParser.java b/wicket-core/src/main/java/org/apache/wicket/markup/MarkupParser.java\nindex d84383f03c..47203147f8 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/MarkupParser.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/MarkupParser.java\n@@ -150,6 +150,7 @@ protected MarkupFilterList initializeMarkupFilters(final Markup markup)\n \t\tfilters.add(new WicketLinkTagHandler());\n \t\tfilters.add(new AutoLabelTagHandler());\n \t\tfilters.add(new WicketNamespaceHandler(markupResourceStream));\n+\t\tfilters.add(new WicketMessageTagHandler(markupResourceStream));\n \n \t\t// Provided the wicket component requesting the markup is known ...\n \t\tif ((markupResourceStream != null) && (markupResourceStream.getResource() != null))\n@@ -157,8 +158,6 @@ protected MarkupFilterList initializeMarkupFilters(final Markup markup)\n \t\t\tfinal ContainerInfo containerInfo = markupResourceStream.getContainerInfo();\n \t\t\tif (containerInfo != null)\n \t\t\t{\n-\t\t\t\tfilters.add(new WicketMessageTagHandler(markupResourceStream));\n-\n \t\t\t\t// Pages require additional handlers\n \t\t\t\tif (Page.class.isAssignableFrom(containerInfo.getContainerClass()))\n \t\t\t\t{\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\nindex ab7e609003..06a193aaa6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\n@@ -43,7 +43,6 @@\n  * enclosure is identified by the 'child' attribute value which must be equal to the relative child\r\n  * id path.\r\n  * \r\n- * @see EnclosureResolver\r\n  * @see InlineEnclosure\r\n  * \r\n  * @author Joonas Hamalainen\r\n@@ -96,7 +95,7 @@ protected MarkupElement onComponentTag(final ComponentTag tag) throws ParseExcep\n \t\t\t\t\t\t\ttag.toString(), tag.getPos());\r\n \t\t\t\t}\r\n \r\n-\t\t\t\t// if it doesn't have a wicket-id already, than assign one now.\r\n+\t\t\t\t// if it doesn't have a wicket-id already, then assign one now.\r\n \t\t\t\tif (Strings.isEmpty(tag.getId()))\r\n \t\t\t\t{\r\n \t\t\t\t\tif (Strings.isEmpty(htmlId))\r\n@@ -129,7 +128,7 @@ protected MarkupElement onComponentTag(final ComponentTag tag) throws ParseExcep\n \t\t// Are we within an enclosure?\r\n \t\telse if ((enclosures != null) && (enclosures.size() > 0))\r\n \t\t{\r\n-\t\t\t// In case the enclosure tag did not provide a child component id, than assign the\r\n+\t\t\t// In case the enclosure tag did not provide a child component id, then assign the\r\n \t\t\t// first ComponentTag's id found as the controlling child to the enclosure.\r\n \t\t\tif (tag.isOpen() && (tag.getId() != null) && !(tag instanceof WicketTag) &&\r\n \t\t\t\t!tag.isAutoComponentTag())\r\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/WicketMessageTagHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/WicketMessageTagHandler.java\nindex acda0a6b9e..504412848e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/WicketMessageTagHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/WicketMessageTagHandler.java\n@@ -83,7 +83,7 @@ protected final MarkupElement onComponentTag(ComponentTag tag) throws ParseExcep\n \t\tfinal String wicketMessageAttribute = tag.getAttributes().getString(\n \t\t\tgetWicketMessageAttrName());\n \n-\t\tif ((wicketMessageAttribute != null) && (wicketMessageAttribute.trim().length() > 0))\n+\t\tif (Strings.isEmpty(wicketMessageAttribute) == false)\n \t\t{\n \t\t\t// check if this tag is raw markup\n \t\t\tif (tag.getId() == null)\n@@ -165,7 +165,7 @@ public Component resolve(MarkupContainer container, MarkupStream markupStream, C\n \t\t// localize any raw markup that has wicket:message attrs\n \t\tif ((tag != null) && (tag.getId().startsWith(WICKET_MESSAGE_CONTAINER_ID)))\n \t\t{\n-\t\t\tComponent wc = null;\n+\t\t\tComponent wc;\n \t\t\tint autoIndex = container.getPage().getAutoIndex();\n \t\t\tString id = WICKET_MESSAGE_CONTAINER_ID + autoIndex;\n \n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "4520",
        "nb_skipped": 8,
        "commit": "b91154ea",
        "nb_failure": 2,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1133,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.MarkupContainerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 33c515d576..13b32cb054 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -941,6 +941,11 @@ public final void afterRender()\n \t\ttry\n \t\t{\n \t\t\tsetFlag(FLAG_AFTER_RENDERING, true);\n+\n+\t\t\t// always detach children because components can be attached\n+\t\t\t// independently of their parents\n+\t\t\tonAfterRenderChildren();\n+\n \t\t\tonAfterRender();\n \t\t\tgetApplication().getComponentOnAfterRenderListeners().onAfterRender(this);\n \t\t\tif (getFlag(FLAG_AFTER_RENDERING))\n@@ -950,9 +955,6 @@ public final void afterRender()\n \t\t\t\t\tgetClass().getName() +\n \t\t\t\t\t\" has not called super.onAfterRender() in the override of onAfterRender() method\");\n \t\t\t}\n-\t\t\t// always detach children because components can be attached\n-\t\t\t// independently of their parents\n-\t\t\tonAfterRenderChildren();\n \t\t}\n \t\tfinally\n \t\t{\n@@ -2852,10 +2854,7 @@ final void setMarkupId(Component comp)\n \t */\n \tpublic Component setMarkupId(String markupId)\n \t{\n-\t\tif (markupId != null && Strings.isEmpty(markupId))\n-\t\t{\n-\t\t\tthrow new IllegalArgumentException(\"Markup id cannot be an empty string\");\n-\t\t}\n+\t\tArgs.notEmpty(markupId, \"markupId\");\n \n \t\t// TODO check if an automatic id has already been generated or getmarkupid() called\n \t\t// previously and throw an illegalstateexception because something else might be depending\n@@ -4112,6 +4111,10 @@ void internalMarkRendering(boolean setRenderingFlag)\n \t\t\tsetFlag(FLAG_PREPARED_FOR_RENDER, false);\n \t\t\tsetFlag(FLAG_RENDERING, true);\n \t\t}\n+\t\telse\n+\t\t{\n+\t\t\tsetFlag(FLAG_RENDERING, false);\n+\t\t}\n \t}\n \n \t/**\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex 37986ff17a..056d48365d 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -1835,13 +1835,11 @@ public void component(Component component, IVisit<Void> visit)\n \t@Override\n \tprotected void onAfterRenderChildren()\n \t{\n-\t\t// Loop through child components\n \t\tfor (Component child : this)\n \t\t{\n-\t\t\t// Call end request on the child\n-\t\t\tchild.afterRender();\n+\t\t\t// set RENDERING_FLAG to false for auto-component's children (like Enclosure)\n+\t\t\tchild.markRendering(false);\n \t\t}\n-\n \t\tsuper.onAfterRenderChildren();\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 9,
        "jira_id": "4012",
        "nb_skipped": 2,
        "commit": "d35d2d85",
        "nb_failure": 1,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 70,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.UrlTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex bbaf6eafb1..d387a13c2b 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -297,10 +297,13 @@ public static Url parse(String url, Charset charset)\n \t\t{\n \t\t\tString queryArray[] = Strings.split(queryString, '&');\n \t\t\tfor (String s : queryArray)\n+\t\t\t{\n+\t\t\t\tif (Strings.isEmpty(s) == false)\n \t\t\t\t{\n \t\t\t\t\tresult.parameters.add(parseQueryParameter(s, charset));\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n \n \t\treturn result;\n \t}\n@@ -315,23 +318,14 @@ private static QueryParameter parseQueryParameter(final String qp, final Charset\n \t{\n \t\tif (qp.indexOf('=') == -1)\n \t\t{\n+\t\t\t// name => empty value\n \t\t\treturn new QueryParameter(decodeParameter(qp, charset), \"\");\n \t\t}\n+\n \t\tString parts[] = Strings.split(qp, '=');\n-\t\tif (parts.length == 0)\n-\t\t{\n-\t\t\treturn new QueryParameter(\"\", \"\");\n-\t\t}\n-\t\telse if (parts.length == 1)\n-\t\t{\n-\t\t\treturn new QueryParameter(\"\", decodeParameter(parts[0], charset));\n-\t\t}\n-\t\telse\n-\t\t{\n \t\treturn new QueryParameter(decodeParameter(parts[0], charset), decodeParameter(parts[1],\n \t\t\tcharset));\n \t}\n-\t}\n \n \t/**\n \t * get default port number for protocol\ndiff --git a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/INamedParameters.java b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/INamedParameters.java\nindex e84ed21258..bcf16be283 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/INamedParameters.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/INamedParameters.java\n@@ -49,9 +49,8 @@\n \t\t */\r\n \t\tpublic NamedPair(final String key, final String value)\r\n \t\t{\r\n-\t\t\tArgs.notEmpty(key, \"key\");\r\n-\t\t\tthis.key = key;\r\n-\t\t\tthis.value = value;\r\n+\t\t\tthis.key = Args.notNull(key, \"key\");;\r\n+\t\t\tthis.value = Args.notNull(value, \"value\");\r\n \t\t}\r\n \r\n \t\t/**\r\n",
        "project": "wicket",
        "linesAdd": 6,
        "jira_id": "4398",
        "nb_skipped": 0,
        "commit": "f88721fd",
        "nb_failure": 1,
        "linesRem": 14,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 1197,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.TransparentWebMarkupContainerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex bd62e4726d..77dd7e1240 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -40,6 +40,7 @@\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.model.IWrapModel;\n import org.apache.wicket.settings.IDebugSettings;\n+import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.lang.Generics;\n import org.apache.wicket.util.string.ComponentStrings;\n import org.apache.wicket.util.string.Strings;\n@@ -129,10 +130,7 @@ public final MarkupContainer add(final Component... childs)\n \t{\n \t\tfor (Component child : childs)\n \t\t{\n-\t\t\tif (child == null)\n-\t\t\t{\n-\t\t\t\tthrow new IllegalArgumentException(\"argument child may not be null\");\n-\t\t\t}\n+\t\t\tArgs.notNull(child, \"child\");\n \n \t\t\tMarkupContainer parent = getParent();\n \t\t\twhile (parent != null)\n@@ -899,10 +900,7 @@ public String toString(final boolean detailed)\n \tprivate final void addedComponent(final Component child)\n \t{\n \t\t// Check for degenerate case\n-\t\tif (child == this)\n-\t\t{\n-\t\t\tthrow new IllegalArgumentException(\"Component can't be added to itself\");\n-\t\t}\n+\t\tArgs.notNull(child, \"child\");\n \n \t\tMarkupContainer parent = child.getParent();\n \t\tif (parent != null)\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/Markup.java b/wicket-core/src/main/java/org/apache/wicket/markup/Markup.java\nindex 6bc5bd8398..2d27638392 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/Markup.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/Markup.java\n@@ -25,7 +25,6 @@\n import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.resource.ResourceStreamNotFoundException;\n import org.apache.wicket.util.string.AppendingStringBuffer;\n-import org.apache.wicket.util.string.Strings;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -187,10 +186,7 @@ final public void makeImmutable()\n \n \tpublic final IMarkupFragment find(final String id)\n \t{\n-\t\tif (Strings.isEmpty(id))\n-\t\t{\n-\t\t\tthrow new IllegalArgumentException(\"Parameter 'id' must not be null or empty\");\n-\t\t}\n+\t\tArgs.notEmpty(id, \"id\");\n \n \t\tMarkupStream stream = new MarkupStream(this);\n \t\tstream.setCurrentIndex(0);\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\nindex e183553f84..9a4a1d3585 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n@@ -23,6 +23,7 @@\n import org.apache.wicket.markup.MarkupStream;\n import org.apache.wicket.markup.html.internal.HtmlHeaderContainer;\n import org.apache.wicket.markup.html.list.AbstractItem;\n+import org.apache.wicket.markup.resolver.IComponentResolver;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -95,6 +96,24 @@ public IMarkupFragment getMarkup(final MarkupContainer container, final Componen\n \t\t\treturn markup;\n \t\t}\n \n+\t\t// If the child has not been directly added to the container, but via a\n+\t\t// TransparentWebMarkupContainer, than we are in trouble. In general Wicket iterates over\n+\t\t// the markup elements and searches for associated components, not the other way around.\n+\t\t// Because of TransparentWebMarkupContainer (or more generally resolvers), there is no\n+\t\t// \"synchronous\" search possible.\n+\t\tfor (Component ch : container)\n+\t\t{\n+\t\t\tif ((ch != child) && (ch instanceof MarkupContainer) &&\n+\t\t\t\t(ch instanceof IComponentResolver))\n+\t\t\t{\n+\t\t\t\tmarkup = ((MarkupContainer)ch).getMarkup(child);\n+\t\t\t\tif (markup != null)\n+\t\t\t\t{\n+\t\t\t\t\treturn markup;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n \t\t// This is to make migration for Items from 1.4 to 1.5 more easy\n \t\tif (Character.isDigit(child.getId().charAt(0)))\n \t\t{\n",
        "project": "wicket",
        "linesAdd": 18,
        "jira_id": "3719",
        "nb_skipped": 1,
        "commit": "5ad32df9",
        "nb_failure": 0,
        "linesRem": 13,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 408,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "wicket.util.collections.MicroMapTest"
        ],
        "patch": "diff --git a/jdk-1.4/wicket/src/main/java/wicket/util/collections/MicroMap.java b/jdk-1.4/wicket/src/main/java/wicket/util/collections/MicroMap.java\nindex c708f98faa..1253baa895 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/util/collections/MicroMap.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/util/collections/MicroMap.java\n@@ -22,6 +22,7 @@\n import java.util.Collection;\n import java.util.Iterator;\n import java.util.Map;\n+import java.util.NoSuchElementException;\n import java.util.Set;\n \n /**\n@@ -211,6 +212,10 @@ public boolean hasNext()\n \n \t\t\t\t\tpublic Object next()\n \t\t\t\t\t{\n+\t\t\t\t\t\tif (!hasNext())\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tthrow new NoSuchElementException();\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tindex++;\n \n \t\t\t\t\t\treturn key;\n@@ -241,6 +246,9 @@ public Collection values()\n \t\t{\n \t\t\tpublic Object get(final int index)\n \t\t\t{\n+\t\t\t\tif (index > size() - 1) {\n+\t\t\t\t\tthrow new IndexOutOfBoundsException();\n+\t\t\t\t}\n \t\t\t\treturn value;\n \t\t\t}\n \n@@ -269,6 +277,10 @@ public boolean hasNext()\n \n \t\t\t\t\tpublic Object next()\n \t\t\t\t\t{\n+\t\t\t\t\t\tif (!hasNext())\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tthrow new NoSuchElementException();\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tindex++;\n \n \t\t\t\t\t\treturn new Map.Entry()\n",
        "project": "wicket",
        "linesAdd": 12,
        "jira_id": "428",
        "nb_skipped": 0,
        "commit": "d906576c",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1469,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.http.WicketFilterTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\nindex eb73ee7986..be577f3338 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\n@@ -96,8 +96,8 @@\n \tprivate boolean isServlet = false;\n \n \t/**\n-\t * default constructor, usually invoked through the servlet \n-\t * container by the web.xml configuration\n+\t * default constructor, usually invoked through the servlet container by the web.xml\n+\t * configuration\n \t */\n \tpublic WicketFilter()\n \t{\n@@ -106,8 +106,8 @@ public WicketFilter()\n \t/**\n \t * constructor supporting programmatic setup of the filter\n \t * <p/>\n-\t *  this can be useful for programmatically creating and appending the \n-\t *  wicket filter to the servlet context using servlet 3 features.\n+\t * this can be useful for programmatically creating and appending the wicket filter to the\n+\t * servlet context using servlet 3 features.\n \t * \n \t * @param application\n \t *            web application\n@@ -174,7 +174,7 @@ boolean processRequest(ServletRequest request, final ServletResponse response,\n \t\t\t\treturn false;\n \t\t\t}\n \n-\t\t\tif (\"OPTIONS\".equals(httpServletRequest.getMethod()))\n+\t\t\tif (\"OPTIONS\".equalsIgnoreCase(httpServletRequest.getMethod()))\n \t\t\t{\n \t\t\t\t// handle the OPTIONS request outside of normal request processing.\n \t\t\t\t// wicket pages normally only support GET and POST methods, but resources and\n@@ -198,7 +198,8 @@ boolean processRequest(ServletRequest request, final ServletResponse response,\n \t\t\t\t\thttpServletResponse);\n \n \t\t\t\tRequestCycle requestCycle = application.createRequestCycle(webRequest, webResponse);\n-\t\t\t\tres = processRequestCycle(requestCycle, webResponse, httpServletRequest, httpServletResponse, chain);\n+\t\t\t\tres = processRequestCycle(requestCycle, webResponse, httpServletRequest,\n+\t\t\t\t\thttpServletResponse, chain);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n@@ -250,7 +251,8 @@ boolean processRequest(ServletRequest request, final ServletResponse response,\n \t */\n \tprotected boolean processRequestCycle(RequestCycle requestCycle, WebResponse webResponse,\n \t\tHttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse,\n-\t\tfinal FilterChain chain) throws IOException, ServletException {\n+\t\tfinal FilterChain chain) throws IOException, ServletException\n+\t{\n \t\t// Assume we are able to handle the request\n \t\tboolean res = true;\n \n@@ -518,6 +520,7 @@ protected String getFilterPath(final HttpServletRequest request)\n \n \t/**\n \t * Provide a standard getter for filterPath.\n+\t * \n \t * @return The configured filterPath.\n \t */\n \tprotected String getFilterPath()\n@@ -651,7 +654,8 @@ public final void setFilterPath(String filterPath)\n \t\tif (this.filterPath != null)\n \t\t{\n \t\t\tthrow new IllegalStateException(\n-\t\t\t\t\"Filter path is write-once. You can not change it. Current value='\" + filterPath + '\\'');\n+\t\t\t\t\"Filter path is write-once. You can not change it. Current value='\" + filterPath +\n+\t\t\t\t\t'\\'');\n \t\t}\n \t\tif (filterPath != null)\n \t\t{\n",
        "project": "wicket",
        "linesAdd": 7,
        "jira_id": "5138",
        "nb_skipped": 3,
        "commit": "e8dab4a0",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1426,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.http.servlet.ServletWebRequestTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebRequest.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebRequest.java\nindex 02ffe67337..8e41aef4a8 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebRequest.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebRequest.java\n@@ -30,6 +30,7 @@\n import javax.servlet.ServletRequest;\n import javax.servlet.http.Cookie;\n import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n \n import org.apache.wicket.protocol.http.RequestUtils;\n import org.apache.wicket.request.IRequestParameters;\n@@ -37,9 +38,9 @@\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.UrlUtils;\n import org.apache.wicket.request.http.WebRequest;\n+import org.apache.wicket.request.http.flow.AbortWithHttpErrorCodeException;\n import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.lang.Bytes;\n-import org.apache.wicket.util.lang.Checks;\n import org.apache.wicket.util.string.PrependingStringBuffer;\n import org.apache.wicket.util.string.StringValue;\n import org.apache.wicket.util.string.Strings;\n@@ -168,7 +169,11 @@ else if (!isAjax())\n \t\t\t\tbase = getRequestParameters().getParameterValue(PARAM_AJAX_BASE_URL).toString(null);\n \t\t\t}\n \n-\t\t\tChecks.notNull(base, \"Current ajax request is missing the base url header or parameter\");\n+\t\t\tif (base == null)\n+\t\t\t{\n+\t\t\t\tthrow new AbortWithHttpErrorCodeException(HttpServletResponse.SC_BAD_REQUEST,\n+\t\t\t\t\t\"Current ajax request is missing the base url header or parameter\");\n+\t\t\t}\n \n \t\t\treturn setParameters(Url.parse(base, getCharset()));\n \t\t}\n",
        "project": "wicket",
        "linesAdd": 7,
        "jira_id": "4841",
        "nb_skipped": 5,
        "commit": "ce172da8",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 362,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "wicket.protocol.http.request.WebRequestCodingStrategyTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/wicket/protocol/http/request/WebRequestCodingStrategy.java b/wicket/src/main/java/wicket/protocol/http/request/WebRequestCodingStrategy.java\nindex 7d452664c8..93d5d9696e 100644\n--- a/wicket/src/main/java/wicket/protocol/http/request/WebRequestCodingStrategy.java\n+++ b/wicket/src/main/java/wicket/protocol/http/request/WebRequestCodingStrategy.java\n@@ -563,7 +563,25 @@ protected CharSequence encode(RequestCycle requestCycle,\n \n \n \t\t\t// Add <page-map-name>:<bookmarkable-page-class>\n-\t\t\turl.append(pageMapName + Component.PATH_SEPARATOR + pageClass.getName());\n+\t\t\tString pageClassName = pageClass.getName();\n+\t\t\t/*\n+\t\t\t * Encode the url so it is correct even for class names containing\n+\t\t\t * non ASCII characters, like \u00e4, \u00e6, \u00f8, \u00e5 etc.\n+\t\t\t * \n+\t\t\t * The reason for this is that when redirecting to these\n+\t\t\t * bookmarkable pages, we need to have the url encoded correctly\n+\t\t\t * because we can't rely on the browser to interpret the unencoded\n+\t\t\t * url correctly.\n+\t\t\t */\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tpageClassName = URLEncoder.encode(pageClassName, \"UTF-8\");\n+\t\t\t}\n+\t\t\tcatch (UnsupportedEncodingException e)\n+\t\t\t{\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t\turl.append(pageMapName + Component.PATH_SEPARATOR + pageClassName);\n \t\t}\n \n \t\t// Get page parameters\n",
        "project": "wicket",
        "linesAdd": 10,
        "jira_id": "16",
        "nb_skipped": 0,
        "commit": "6c5083b4",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1379,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.response.PreserveCookieForTheNextHandlerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\nindex b92f3e378a..a0dbfeb8c1 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n@@ -20,7 +20,6 @@\n import org.apache.wicket.protocol.http.WebApplication;\n import org.apache.wicket.request.IRequestHandler;\n import org.apache.wicket.request.Request;\n-import org.apache.wicket.request.Response;\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.core.request.handler.RenderPageRequestHandler;\n@@ -91,10 +90,10 @@ protected BufferedWebResponse renderPage(Url targetUrl, RequestCycle requestCycl\n \t\tIRequestHandler scheduled = requestCycle.getRequestHandlerScheduledAfterCurrent();\n \n \t\t// keep the original response\n-\t\tfinal Response originalResponse = requestCycle.getResponse();\n+\t\tfinal WebResponse originalResponse = (WebResponse) requestCycle.getResponse();\n \n \t\t// buffered web response for page\n-\t\tBufferedWebResponse response = new BufferedWebResponse((WebResponse)originalResponse);\n+\t\tBufferedWebResponse response = new BufferedWebResponse(originalResponse);\n \n \t\t// keep the original base URL\n \t\tUrl originalBaseUrl = requestCycle.getUrlRenderer().setBaseUrl(targetUrl);\n@@ -106,9 +105,12 @@ protected BufferedWebResponse renderPage(Url targetUrl, RequestCycle requestCycl\n \n \t\t\tif (scheduled == null && requestCycle.getRequestHandlerScheduledAfterCurrent() != null)\n \t\t\t{\n-\t\t\t\t// This is a special case. During page render another request handler got scheduled.\n-\t\t\t\t// The handler\n-\t\t\t\t// will want to overwrite the response, so we need to let it\n+\t\t\t\t// This is a special case.\n+\t\t\t\t// During page render another request handler got scheduled and will want to overwrite\n+\t\t\t\t// the response, so we need to let it.\n+\t\t\t\t// Just preserve the meta data headers\n+\t\t\t\toriginalResponse.reset(); // clear the initial actions because they are already copied into the new response's actions\n+\t\t\t\tresponse.writeMetaData(originalResponse);\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\telse\n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "4358",
        "nb_skipped": 5,
        "commit": "02ebc8ae",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 17,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.extensions.yui.calendar.DatePickerTest"
        ],
        "patch": "diff --git a/wicket-datetime/src/main/java/org/apache/wicket/extensions/yui/calendar/DateTimeField.java b/wicket-datetime/src/main/java/org/apache/wicket/extensions/yui/calendar/DateTimeField.java\nindex 2534f48afa..13b9cb867b 100644\n--- a/wicket-datetime/src/main/java/org/apache/wicket/extensions/yui/calendar/DateTimeField.java\n+++ b/wicket-datetime/src/main/java/org/apache/wicket/extensions/yui/calendar/DateTimeField.java\n@@ -435,19 +435,15 @@ protected void onBeforeRender()\n \t\t}\n \t\telse\n \t\t{\n-\t\t\tMutableDateTime mDate;\n+\t\t\tMutableDateTime mDate = new MutableDateTime(modelObject);\n \t\t\t// convert date to the client's time zone if we have that info\n \t\t\tTimeZone zone = getClientTimeZone();\n \t\t\tif (zone != null)\n \t\t\t{\n-\t\t\t\tmDate = new MutableDateTime(modelObject, DateTimeZone.forTimeZone(zone));\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\tmDate = new MutableDateTime(modelObject);\n+\t\t\t\tmDate.setZone(DateTimeZone.forTimeZone(zone));\n \t\t\t}\n \n-\t\t\tdate = mDate.toDate();\n+\t\t\tdate = mDate.toDateTime().toLocalDate().toDate();\n \n \t\t\tif (use12HourFormat)\n \t\t\t{\n",
        "project": "wicket",
        "linesAdd": 3,
        "jira_id": "5204",
        "nb_skipped": 0,
        "commit": "9e6efa61",
        "nb_failure": 1,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 972,
        "nb_error": 0,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.wicket.BehaviorRequestTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/RequestListenerInterface.java b/wicket/src/main/java/org/apache/wicket/RequestListenerInterface.java\nindex 06d4dcfbe7..26282cce98 100644\n--- a/wicket/src/main/java/org/apache/wicket/RequestListenerInterface.java\n+++ b/wicket/src/main/java/org/apache/wicket/RequestListenerInterface.java\n@@ -255,6 +255,7 @@ public final void invoke(final IRequestableComponent component, final IBehavior\n \t\t{\n \t\t\tlog.warn(\"behavior not enabled; ignore call. Behavior {} at component {}\", behavior,\n \t\t\t\tcomponent);\n+\t\t\treturn;\n \t\t}\n \n \t\ttry\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "3098",
        "nb_skipped": 0,
        "commit": "1b7afefc",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 2,
        "nb_test": 1460,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ajax.DomReadyOrderTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractAjaxResponse.java b/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractAjaxResponse.java\nindex 80624bfbdb..1e3cd1a21e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractAjaxResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractAjaxResponse.java\n@@ -25,7 +25,6 @@\n import java.util.Map;\n \n import org.apache.wicket.Component;\n-import org.apache.wicket.MarkupContainer;\n import org.apache.wicket.Page;\n import org.apache.wicket.markup.head.HeaderItem;\n import org.apache.wicket.markup.head.IHeaderResponse;\n@@ -34,6 +33,8 @@\n import org.apache.wicket.markup.head.internal.HeaderResponse;\n import org.apache.wicket.markup.html.internal.HtmlHeaderContainer;\n import org.apache.wicket.markup.parser.filter.HtmlHeaderSectionHandler;\n+import org.apache.wicket.markup.renderStrategy.AbstractHeaderRenderStrategy;\n+import org.apache.wicket.markup.renderStrategy.IHeaderRenderStrategy;\n import org.apache.wicket.markup.repeater.AbstractRepeater;\n import org.apache.wicket.request.IRequestCycle;\n import org.apache.wicket.request.Response;\n@@ -44,8 +45,6 @@\n import org.apache.wicket.util.lang.Generics;\n import org.apache.wicket.util.string.AppendingStringBuffer;\n import org.apache.wicket.util.string.Strings;\n-import org.apache.wicket.util.visit.IVisit;\n-import org.apache.wicket.util.visit.IVisitor;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -460,28 +459,9 @@ protected void writeHeaderContribution(final Response response, final Component\n \t\ttry {\n \t\t\tencodingHeaderResponse.reset();\n \n-\t\t\t// render the head of component and all it's children\n+\t\t\tIHeaderRenderStrategy strategy = AbstractHeaderRenderStrategy.get();\n \n-\t\t\tcomponent.renderHead(header);\n-\n-\t\t\tif (component instanceof MarkupContainer)\n-\t\t\t{\n-\t\t\t\t((MarkupContainer)component).visitChildren(new IVisitor<Component, Void>()\n-\t\t\t\t{\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void component(final Component component, final IVisit<Void> visit)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tif (component.isVisibleInHierarchy())\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tcomponent.renderHead(header);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tvisit.dontGoDeeper();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t}\n+\t\t\tstrategy.renderHeader(header, null, component);\n \t\t} finally {\n \t\t\t// revert to old response\n \t\t\trequestCycle.setResponse(oldResponse);\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java b/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\nindex 8998cb5c74..0cee432bfe 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\n@@ -82,16 +82,8 @@ public void renderHead(final Component component, final IHeaderResponse response\n \t\t{\n \t\t\tCharSequence js = getCallbackScript(component);\n \n-\t\t\tAjaxRequestTarget target = component.getRequestCycle().find(AjaxRequestTarget.class);\n-\t\t\tif (target == null)\n-\t\t\t{\n \t\t\tresponse.render(OnDomReadyHeaderItem.forScript(js.toString()));\n \t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\ttarget.appendJavaScript(js);\n-\t\t\t}\n-\t\t}\n \t}\n \n \t@Override\n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "5082",
        "nb_skipped": 3,
        "commit": "217fbb3b",
        "nb_failure": 2,
        "linesRem": 31,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 183,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.collections.IntHashMapTest"
        ],
        "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/collections/IntHashMap.java b/wicket-util/src/main/java/org/apache/wicket/util/collections/IntHashMap.java\nindex 7b377fc9c9..7a8d180929 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/collections/IntHashMap.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/collections/IntHashMap.java\n@@ -1145,6 +1145,8 @@ private void writeObject(final java.io.ObjectOutputStream s) throws IOException\n \tprivate void readObject(final java.io.ObjectInputStream s) throws IOException,\n \t\tClassNotFoundException\n \t{\n+\t\tmodCount = new AtomicInteger(0);\n+\n \t\t// Read in the threshold, loadfactor, and any hidden stuff\n \t\ts.defaultReadObject();\n \n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "5751",
        "nb_skipped": 2,
        "commit": "bcea89fc",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1184,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.mapper.MountedMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/MountedMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/MountedMapper.java\nindex 1c5d039906..04fe4e828c 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/MountedMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/MountedMapper.java\n@@ -19,10 +19,15 @@\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.apache.wicket.RequestListenerInterface;\n+import org.apache.wicket.request.IRequestHandler;\n import org.apache.wicket.request.Request;\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.component.IRequestablePage;\n+import org.apache.wicket.request.handler.ListenerInterfaceRequestHandler;\n+import org.apache.wicket.request.mapper.info.ComponentInfo;\n import org.apache.wicket.request.mapper.info.PageComponentInfo;\n+import org.apache.wicket.request.mapper.info.PageInfo;\n import org.apache.wicket.request.mapper.parameter.IPageParametersEncoder;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n import org.apache.wicket.request.mapper.parameter.PageParametersEncoder;\n@@ -354,6 +359,41 @@ protected PageParameters newPageParameters()\n \t\treturn new PageParameters();\n \t}\n \n+\t@Override\n+\tpublic Url mapHandler(IRequestHandler requestHandler)\n+\t{\n+\t\tUrl url = super.mapHandler(requestHandler);\n+\n+\t\tif (url == null && requestHandler instanceof ListenerInterfaceRequestHandler)\n+\t\t{\n+\t\t\tListenerInterfaceRequestHandler handler = (ListenerInterfaceRequestHandler)requestHandler;\n+\t\t\tIRequestablePage page = handler.getPage();\n+\t\t\tClass<? extends IRequestablePage> pageClass = page.getClass();\n+\t\t\tif (checkPageClass(pageClass))\n+\t\t\t{\n+\t\t\t\tString componentPath = handler.getComponentPath();\n+\t\t\t\tRequestListenerInterface listenerInterface = handler.getListenerInterface();\n+\n+\t\t\t\tInteger renderCount = null;\n+\t\t\t\tif (listenerInterface.isIncludeRenderCount())\n+\t\t\t\t{\n+\t\t\t\t\trenderCount = page.getRenderCount();\n+\t\t\t\t}\n+\n+\t\t\t\tPageInfo pageInfo = new PageInfo(page.getPageId());\n+\t\t\t\tComponentInfo componentInfo = new ComponentInfo(renderCount,\n+\t\t\t\t\trequestListenerInterfaceToString(listenerInterface), componentPath,\n+\t\t\t\t\thandler.getBehaviorIndex());\n+\t\t\t\tPageComponentInfo pageComponentInfo = new PageComponentInfo(pageInfo, componentInfo);\n+\t\t\t\tUrlInfo urlInfo = new UrlInfo(pageComponentInfo, page.getClass(),\n+\t\t\t\t\thandler.getPageParameters());\n+\t\t\t\turl = buildUrl(urlInfo);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn url;\n+\t}\n+\n \t/**\n \t * @see org.apache.wicket.request.mapper.AbstractBookmarkableMapper#buildUrl(org.apache.wicket.request.mapper.AbstractBookmarkableMapper.UrlInfo)\n \t */\n",
        "project": "wicket",
        "linesAdd": 40,
        "jira_id": "4014",
        "nb_skipped": 2,
        "commit": "e60bac5f",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1659,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.tester.WicketTesterLazyIsPageStatelessRedirectToBufferTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 9a72a11b84..c1d1826fe9 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -4544,6 +4544,7 @@ public Component add(final Behavior... behaviors)\n \t@Override\n \tpublic boolean canCallListenerInterfaceAfterExpiry()\n \t{\n-\t\treturn getApplication().getPageSettings().getCallListenerInterfaceAfterExpiry();\n+        \treturn getApplication().getPageSettings()\n+        \t\t.getCallListenerInterfaceAfterExpiry() || isStateless();\n \t}\n }\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "5578",
        "nb_skipped": 2,
        "commit": "5cdc1c8d",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1023,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.MarkupParserTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/AbstractMarkupParser.java b/wicket/src/main/java/org/apache/wicket/markup/AbstractMarkupParser.java\nindex de976e797e..51c46e60e9 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/AbstractMarkupParser.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/AbstractMarkupParser.java\n@@ -30,7 +30,6 @@\n import org.apache.wicket.settings.IMarkupSettings;\n import org.apache.wicket.util.resource.ResourceStreamNotFoundException;\n import org.apache.wicket.util.resource.StringResourceStream;\n-import org.apache.wicket.util.string.AppendingStringBuffer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -404,9 +403,9 @@ private String removeComment(String rawMarkup)\n \t\tint pos1 = rawMarkup.indexOf(\"<!--\");\n \t\twhile (pos1 != -1)\n \t\t{\n-\t\t\tfinal int pos2 = rawMarkup.indexOf(\"-->\", pos1 + 4);\n+\t\t\tint pos2 = rawMarkup.indexOf(\"-->\", pos1 + 4);\n \n-\t\t\tfinal AppendingStringBuffer buf = new AppendingStringBuffer(rawMarkup.length());\n+\t\t\tfinal StringBuilder buf = new StringBuilder(rawMarkup.length());\n \t\t\tif (pos2 != -1)\n \t\t\t{\n \t\t\t\tfinal String comment = rawMarkup.substring(pos1 + 4, pos2);\n@@ -424,8 +423,12 @@ private String removeComment(String rawMarkup)\n \t\t\t\t\t}\n \t\t\t\t\trawMarkup = buf.toString();\n \t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\tpos1 = pos2;\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tpos1 = rawMarkup.length() <= pos1 + 2 ? -1 : rawMarkup.indexOf(\"<!--\", pos1 + 4);\n+\t\t\tpos1 = rawMarkup.indexOf(\"<!--\", pos1);\n \t\t}\n \t\treturn rawMarkup;\n \t}\n",
        "project": "wicket",
        "linesAdd": 7,
        "jira_id": "3222",
        "nb_skipped": 0,
        "commit": "5729ed90",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1497,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.session.BindSessionOnRedirectTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\nindex e25142cfdd..c3899ec82f 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n@@ -16,9 +16,14 @@\n  */\n package org.apache.wicket.request.handler.render;\n \n+import java.util.List;\n+\n import org.apache.wicket.Application;\n+import org.apache.wicket.Session;\n import org.apache.wicket.core.request.handler.RenderPageRequestHandler;\n import org.apache.wicket.core.request.handler.RenderPageRequestHandler.RedirectPolicy;\n+import org.apache.wicket.feedback.FeedbackCollector;\n+import org.apache.wicket.feedback.FeedbackMessage;\n import org.apache.wicket.protocol.http.BufferedWebResponse;\n import org.apache.wicket.protocol.http.WebApplication;\n import org.apache.wicket.request.IRequestHandler;\n@@ -145,11 +150,28 @@ protected BufferedWebResponse renderPage(Url targetUrl, RequestCycle requestCycl\n \t */\n \tprotected void redirectTo(Url url, RequestCycle requestCycle)\n \t{\n+\t\tbindSessionIfNeeded();\n+\n \t\tWebResponse response = (WebResponse)requestCycle.getResponse();\n \t\tString relativeUrl = requestCycle.getUrlRenderer().renderUrl(url);\n \t\tresponse.sendRedirect(relativeUrl);\n \t}\n \n+\t/**\n+\t * Bind the session if there are feedback messages pending.\n+\t * https://issues.apache.org/jira/browse/WICKET-5165\n+\t */\n+\tprivate void bindSessionIfNeeded()\n+\t{\n+\t\t// check for session feedback messages only\n+\t\tFeedbackCollector collector = new FeedbackCollector();\n+\t\tList<FeedbackMessage> feedbackMessages = collector.collect();\n+\t\tif (feedbackMessages.size() > 0)\n+\t\t{\n+\t\t\tSession.get().bind();\n+\t\t}\n+\t}\n+\n \t/*\n \t * TODO: simplify the code below. See WICKET-3347\n \t */\n",
        "project": "wicket",
        "linesAdd": 17,
        "jira_id": "5165",
        "nb_skipped": 3,
        "commit": "0d4d1df7",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 798,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.form.ValidatorPropertiesTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\nindex 32edb5c9c2..5673f2396e 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\n@@ -159,11 +159,12 @@ public String getMessage(String key)\n \t\t\tString prefix = formComponent.getValidatorKeyPrefix();\n \t\t\tString message = null;\n \n-\t\t\t// first try the full form of key [prefix].[form-component-id].[key]\n-\t\t\tString resource = prefix(prefix, getId() + \".\" + key);\n+\t\t\t// first try the full form of key [form-component-id].[key]\n+\t\t\tString resource = getId() + \".\" + prefix(prefix, key);\n \t\t\tmessage = getString(localizer, resource, formComponent);\n \n-\t\t\t// if not found, try a more general form (without prefix) [form-component-id].[key]\n+\t\t\t// if not found, try a more general form (without prefix)\n+\t\t\t// [form-component-id].[prefix].[key]\n \t\t\tif (Strings.isEmpty(message) && Strings.isEmpty(prefix))\n \t\t\t{\n \t\t\t\tresource = getId() + \".\" + key;\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "2350",
        "nb_skipped": 0,
        "commit": "cd281092",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1235,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.handler.render.WebPageRendererTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java b/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\nindex 022f95aabb..73a3463dc3 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\n@@ -601,7 +601,7 @@ public void setResponsePage(Class<? extends IRequestablePage> pageClass)\n \t{\n \t\tIPageProvider provider = new PageProvider(pageClass, null);\n \t\tscheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(provider,\n-\t\t\tRenderPageRequestHandler.RedirectPolicy.AUTO_REDIRECT));\n+\t\t\tRenderPageRequestHandler.RedirectPolicy.ALWAYS_REDIRECT));\n \t}\n \n \n@@ -616,7 +616,7 @@ public void setResponsePage(Class<? extends IRequestablePage> pageClass,\n \t{\n \t\tIPageProvider provider = new PageProvider(pageClass, parameters);\n \t\tscheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(provider,\n-\t\t\tRenderPageRequestHandler.RedirectPolicy.AUTO_REDIRECT));\n+\t\t\tRenderPageRequestHandler.RedirectPolicy.ALWAYS_REDIRECT));\n \t}\n \n \t/**\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\nindex 7d8540592c..3c84f2c979 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n@@ -164,7 +164,7 @@ public void respond(RequestCycle requestCycle)\n \t\t\tbufferedResponse.writeTo((WebResponse)requestCycle.getResponse());\n \t\t}\n \t\telse if (getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT ||\n-\t\t\t(isOnePassRender() && isAjax == false) //\n+\t\t\t(isOnePassRender() && isAjax == false && getRedirectPolicy() != RedirectPolicy.ALWAYS_REDIRECT) //\n \t\t\t||\n \t\t\t(!isAjax //\n \t\t\t\t&&\n",
        "project": "wicket",
        "linesAdd": 3,
        "jira_id": "4173",
        "nb_skipped": 2,
        "commit": "84bbbf68",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 32,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.extensions.markup.html.basic.DefaultLinkParserTest"
        ],
        "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/DefaultLinkParser.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/DefaultLinkParser.java\nindex 54705e4852..515bba93ec 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/DefaultLinkParser.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/DefaultLinkParser.java\n@@ -29,7 +29,7 @@\n public class DefaultLinkParser extends LinkParser\n {\n \t/** Email address pattern */\n-\tprivate static final String emailPattern = \"[\\\\w\\\\.-\\\\\\\\+]+@[\\\\w\\\\.-]+\";\n+\tprivate static final String emailPattern = \"[\\\\w\\\\.\\\\-\\\\\\\\+]+@[\\\\w\\\\.\\\\-]+\";\n \n \t/** URL pattern */\n \tprivate static final String urlPattern = \"([a-zA-Z]+://[\\\\w\\\\.\\\\-\\\\:\\\\/~]+)[\\\\w\\\\.:\\\\-/?&=%]*\";\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "4477",
        "nb_skipped": 0,
        "commit": "2624d2db",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1064,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.model.InheritedModelTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex f94cf41533..7a3df6abe9 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -2956,6 +2956,12 @@ void setModelImpl(IModel<?> model)\n \t\t\tif (model != null)\n \t\t\t{\n \t\t\t\tdata_set(0, model);\n+\t\t\t\t// WICKET-3413 reset 'inherited model' flag if model changed\n+\t\t\t\t// and a new one is not IComponentInheritedModel\n+\t\t\t\tif (getFlag(FLAG_INHERITABLE_MODEL) && !(model instanceof IComponentInheritedModel))\n+\t\t\t\t{\n+\t\t\t\t\tsetFlag(FLAG_INHERITABLE_MODEL, false);\n+\t\t\t\t}\n \t\t\t}\n \t\t\telse\n \t\t\t{\n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "3413",
        "nb_skipped": 0,
        "commit": "499a9c6b",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1608,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.handler.render.WebPageRendererTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\nindex 8c99c13832..1b98beda73 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n@@ -342,7 +342,7 @@ protected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url curre\n \t\t\t|| ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl\n \t\t\t\t.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(),\n \t\t\t\tisPageStateless()))) || (targetUrl.equals(currentUrl) && isRedirectToRender())\n-\t\t\t|| shouldPreserveClientUrl(cycle);\n+\t\t\t|| (shouldPreserveClientUrl(cycle) && notForcedRedirect(getRedirectPolicy()));\n \t}\n \n \tprivate static boolean notNewAndNotStatelessPage(boolean newPageInstance, boolean pageStateless)\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "5486",
        "nb_skipped": 2,
        "commit": "a79ed51e",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 47,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.extensions.markup.html.form.palette.PaletteTest"
        ],
        "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/form/palette/component/AbstractOptions.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/form/palette/component/AbstractOptions.java\nindex 73d6e82cb7..f5d3fc0e60 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/form/palette/component/AbstractOptions.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/form/palette/component/AbstractOptions.java\n@@ -199,4 +199,13 @@ protected void avoidAjaxSerialization()\n \tpublic void updateModel()\n \t{\n \t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tprotected String getModelValue()\n+\t{\n+\t\treturn null;\n+\t}\n }\n",
        "project": "wicket",
        "linesAdd": 6,
        "jira_id": "5086",
        "nb_skipped": 0,
        "commit": "ba516f02",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 18,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.extensions.markup.html.repeater.data.table.DataTableTest"
        ],
        "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/DataTable.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/DataTable.java\nindex caa2f9ea69..f2e4618b5c 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/DataTable.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/DataTable.java\n@@ -204,7 +204,15 @@ protected String getCssClass()\n \t */\n \tprotected WebMarkupContainer newBodyContainer(final String id)\n \t{\n-\t\treturn new WebMarkupContainer(id);\n+\t\treturn new WebMarkupContainer(id)\n+\t\t{\n+\t\t\t@Override\n+\t\t\tprotected void onConfigure()\n+\t\t\t{\n+\t\t\t\tsuper.onConfigure();\n+\t\t\t\tsetVisible(getRowCount() > 0);\n+\t\t\t}\n+\t\t};\n \t}\n \n \t/**\n",
        "project": "wicket",
        "linesAdd": 9,
        "jira_id": "4153",
        "nb_skipped": 0,
        "commit": "2737d7c7",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 1039,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.response.filter.ResponseFilterTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java b/wicket/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\nindex 84ff3f0..c1ff4a5 100644\n--- a/wicket/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\n+++ b/wicket/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\n@@ -51,6 +51,8 @@ import org.apache.wicket.request.http.WebRequest;\n import org.apache.wicket.request.http.WebResponse;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n import org.apache.wicket.request.resource.ResourceReference;\n+import org.apache.wicket.response.StringResponse;\n+import org.apache.wicket.response.filter.IResponseFilter;\n import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.string.AppendingStringBuffer;\n import org.apache.wicket.util.string.Strings;\n@@ -603,43 +605,18 @@ public class AjaxRequestTarget implements IPageRequestHandler\n \t\t\t// Make sure it is not cached by a client\n \t\t\tresponse.disableCaching();\n \n-\t\t\tresponse.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\n-\t\t\tresponse.write(encoding);\n-\t\t\tresponse.write(\"\\\"?>\");\n-\t\t\tresponse.write(\"<ajax-response>\");\n-\n-\t\t\t// invoke onbeforerespond event on listeners\n-\t\t\tfireOnBeforeRespondListeners();\n-\n-\t\t\t// normal behavior\n-\t\t\tIterator<CharSequence> it = prependJavaScripts.iterator();\n-\t\t\twhile (it.hasNext())\n-\t\t\t{\n-\t\t\t\tCharSequence js = it.next();\n-\t\t\t\trespondInvocation(response, js);\n-\t\t\t}\n-\n-\t\t\t// process added components\n-\t\t\trespondComponents(response);\n-\n-\t\t\tfireOnAfterRespondListeners(response);\n-\n-\t\t\t// execute the dom ready javascripts as first javascripts\n-\t\t\t// after component replacement\n-\t\t\tit = domReadyJavaScripts.iterator();\n-\t\t\twhile (it.hasNext())\n+\t\t\ttry\n \t\t\t{\n-\t\t\t\tCharSequence js = it.next();\n-\t\t\t\trespondInvocation(response, js);\n+\t\t\t\tfinal StringResponse bodyResponse = new StringResponse();\n+\t\t\t\tcontructResponseBody(bodyResponse, encoding);\n+\t\t\t\tinvokeResponseFilters(bodyResponse);\n+\t\t\t\tresponse.write(bodyResponse.getBuffer());\n \t\t\t}\n-\t\t\tit = appendJavaScripts.iterator();\n-\t\t\twhile (it.hasNext())\n+\t\t\tfinally\n \t\t\t{\n-\t\t\t\tCharSequence js = it.next();\n-\t\t\t\trespondInvocation(response, js);\n+\t\t\t\t// restore the original response\n+\t\t\t\tRequestCycle.get().setResponse(response);\n \t\t\t}\n-\n-\t\t\tresponse.write(\"</ajax-response>\");\n \t\t}\n \t\tfinally\n \t\t{\n@@ -648,6 +625,80 @@ public class AjaxRequestTarget implements IPageRequestHandler\n \t}\n \n \t/**\n+\t * Collects the response body (without the headers) so that it can be pre-processed before\n+\t * written down to the original response.\n+\t * \n+\t * @param bodyResponse\n+\t *            the buffering response\n+\t * @param encoding\n+\t *            the encoding that should be used to encode the body\n+\t */\n+\tprivate void contructResponseBody(final Response bodyResponse, final String encoding)\n+\t{\n+\t\tbodyResponse.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\n+\t\tbodyResponse.write(encoding);\n+\t\tbodyResponse.write(\"\\\"?>\");\n+\t\tbodyResponse.write(\"<ajax-response>\");\n+\n+\t\t// invoke onbeforerespond event on listeners\n+\t\tfireOnBeforeRespondListeners();\n+\n+\t\t// normal behavior\n+\t\tIterator<CharSequence> it = prependJavaScripts.iterator();\n+\t\twhile (it.hasNext())\n+\t\t{\n+\t\t\tCharSequence js = it.next();\n+\t\t\trespondInvocation(bodyResponse, js);\n+\t\t}\n+\n+\t\t// process added components\n+\t\trespondComponents(bodyResponse);\n+\n+\t\tfireOnAfterRespondListeners(bodyResponse);\n+\n+\t\t// execute the dom ready javascripts as first javascripts\n+\t\t// after component replacement\n+\t\tit = domReadyJavaScripts.iterator();\n+\t\twhile (it.hasNext())\n+\t\t{\n+\t\t\tCharSequence js = it.next();\n+\t\t\trespondInvocation(bodyResponse, js);\n+\t\t}\n+\t\tit = appendJavaScripts.iterator();\n+\t\twhile (it.hasNext())\n+\t\t{\n+\t\t\tCharSequence js = it.next();\n+\t\t\trespondInvocation(bodyResponse, js);\n+\t\t}\n+\n+\t\tbodyResponse.write(\"</ajax-response>\");\n+\t}\n+\n+\t/**\n+\t * Runs the configured {@link IResponseFilter}s over the constructed Ajax response\n+\t * \n+\t * @param contentResponse\n+\t *            the Ajax {@link Response} body\n+\t */\n+\tprivate void invokeResponseFilters(final StringResponse contentResponse)\n+\t{\n+\t\tAppendingStringBuffer responseBuffer = new AppendingStringBuffer(\n+\t\t\tcontentResponse.getBuffer());\n+\n+\t\tList<IResponseFilter> responseFilters = Application.get()\n+\t\t\t.getRequestCycleSettings()\n+\t\t\t.getResponseFilters();\n+\n+\t\tif (responseFilters != null)\n+\t\t{\n+\t\t\tfor (IResponseFilter filter : responseFilters)\n+\t\t\t{\n+\t\t\t\tfilter.filter(responseBuffer);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n \t * \n \t */\n \tprivate void fireOnBeforeRespondListeners()\n@@ -667,7 +718,7 @@ public class AjaxRequestTarget implements IPageRequestHandler\n \t * \n \t * @param response\n \t */\n-\tprivate void fireOnAfterRespondListeners(final WebResponse response)\n+\tprivate void fireOnAfterRespondListeners(final Response response)\n \t{\n \t\t// invoke onafterresponse event on listeners\n \t\tif (listeners != null)\n@@ -697,7 +748,7 @@ public class AjaxRequestTarget implements IPageRequestHandler\n \t * \n \t * @param response\n \t */\n-\tprivate void respondComponents(WebResponse response)\n+\tprivate void respondComponents(Response response)\n \t{\n \t\t// TODO: We might need to call prepareRender on all components upfront\n \ndiff --git a/wicket/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java b/wicket/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\nindex 113e442..1c9debe 100644\n--- a/wicket/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\n+++ b/wicket/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\n@@ -24,10 +24,13 @@ import java.util.List;\n \n import javax.servlet.http.Cookie;\n \n+import org.apache.wicket.Application;\n import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.request.Response;\n import org.apache.wicket.request.http.WebResponse;\n+import org.apache.wicket.response.filter.IResponseFilter;\n import org.apache.wicket.util.lang.Args;\n+import org.apache.wicket.util.string.AppendingStringBuffer;\n \n /**\n  * Subclass of {@link WebResponse} that buffers the actions and performs those on another response.\n@@ -117,6 +120,20 @@ public class BufferedWebResponse extends WebResponse implements IMetaDataBufferi\n \t\t@Override\n \t\tprotected void invoke(WebResponse response)\n \t\t{\n+\n+\t\t\tAppendingStringBuffer responseBuffer = new AppendingStringBuffer(builder);\n+\n+\t\t\tList<IResponseFilter> responseFilters = Application.get()\n+\t\t\t\t.getRequestCycleSettings()\n+\t\t\t\t.getResponseFilters();\n+\n+\t\t\tif (responseFilters != null)\n+\t\t\t{\n+\t\t\t\tfor (IResponseFilter filter : responseFilters)\n+\t\t\t\t{\n+\t\t\t\t\tfilter.filter(responseBuffer);\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tresponse.write(builder);\n \t\t}\n \t};\n@@ -534,4 +551,5 @@ public class BufferedWebResponse extends WebResponse implements IMetaDataBufferi\n \t{\n \t\treturn charSequenceAction.builder.toString();\n \t}\n+\n }\ndiff --git a/wicket/src/main/java/org/apache/wicket/response/filter/IResponseFilter.java b/wicket/src/main/java/org/apache/wicket/response/filter/IResponseFilter.java\nindex e2f76cc..c106782 100644\n--- a/wicket/src/main/java/org/apache/wicket/response/filter/IResponseFilter.java\n+++ b/wicket/src/main/java/org/apache/wicket/response/filter/IResponseFilter.java\n@@ -21,7 +21,7 @@ import org.apache.wicket.util.string.AppendingStringBuffer;\n /**\n  * A response filter can be added to the\n  * {@link org.apache.wicket.settings.IRequestCycleSettings#addResponseFilter(IResponseFilter)}\n- * object The will be called from the Buffered Response objects right before they would send it to\n+ * object. This will be called from the Buffered Response objects right before they would send it to\n  * the real responses. You have to use the\n  * {@link org.apache.wicket.settings.IRequestCycleSettings#setBufferResponse(boolean)}(to true which\n  * is the default) for this filtering to work.\n",
        "project": "wicket",
        "linesAdd": 83,
        "jira_id": "3280",
        "nb_skipped": 0,
        "commit": "295e73bd",
        "nb_failure": 2,
        "linesRem": 30,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 810,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.internal.EnclosureTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java b/wicket/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\nindex 11d40a26e9..b90c80edec 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\n@@ -180,22 +180,36 @@ protected void onComponentTagBody(final MarkupStream markupStream, ComponentTag\n \t\t}\n \t}\n \n+\t/**\n+\t * \n+\t * @param container\n+\t * @param markupStream\n+\t * @param enclosureOpenTag\n+\t */\n \tprivate void applyEnclosureVisibilityToChildren(final MarkupContainer container,\n-\t\tfinal MarkupStream markupStream, ComponentTag enclosureOpenTag)\n+\t\tfinal MarkupStream markupStream, final ComponentTag enclosureOpenTag)\n \t{\n \t\tDirectChildTagIterator it = new DirectChildTagIterator(markupStream, enclosureOpenTag);\n \t\twhile (it.hasNext())\n \t\t{\n \t\t\tfinal ComponentTag tag = it.next();\n+\t\t\tif (tag.isAutoComponentTag() == false)\n+\t\t\t{\n \t\t\t\tfinal Component child = container.get(tag.getId());\n+\n \t\t\t\t// record original visiblity allowed value, will restore later\n \t\t\t\tchanges.put(child, child.isVisibilityAllowed());\n \t\t\t\tchild.setVisibilityAllowed(isVisible());\n \t\t\t}\n+\t\t}\n \t\tit.rewind();\n \t}\n \n-\tprivate void checkChildComponent(Component controller)\n+\t/**\n+\t * \n+\t * @param controller\n+\t */\n+\tprivate void checkChildComponent(final Component controller)\n \t{\n \t\tif (controller == null)\n \t\t{\n@@ -209,6 +223,12 @@ else if (controller == this)\n \t\t}\n \t}\n \n+\t/**\n+\t * \n+\t * @param container\n+\t * @param markupStream\n+\t * @param enclosureOpenTag\n+\t */\n \tprivate void ensureAllChildrenPresent(final MarkupContainer container,\n \t\tfinal MarkupStream markupStream, ComponentTag enclosureOpenTag)\n \t{\n@@ -217,6 +237,8 @@ private void ensureAllChildrenPresent(final MarkupContainer container,\n \t\t{\n \t\t\tfinal ComponentTag tag = it.next();\n \n+\t\t\tif (tag.isAutoComponentTag() == false)\n+\t\t\t{\n \t\t\t\tComponent child = container.get(tag.getId());\n \t\t\t\tif (child == null)\n \t\t\t\t{\n@@ -224,7 +246,8 @@ private void ensureAllChildrenPresent(final MarkupContainer container,\n \t\t\t\t\t// resolvers\n \t\t\t\t\tfinal int tagIndex = it.getCurrentIndex();\n \n-\t\t\t\t// because the resolvers can auto-add and therefore immediately render the component\n+\t\t\t\t\t// because the resolvers can auto-add and therefore immediately render the\n+\t\t\t\t\t// component\n \t\t\t\t\t// we have to buffer the output since we do not yet know the visibility of the\n \t\t\t\t\t// enclosure\n \t\t\t\t\tCharSequence buffer = new ResponseBufferZone(getRequestCycle(), markupStream)\n@@ -242,7 +265,8 @@ protected void executeInsideBufferedZone()\n \n \t\t\t\t\tif (buffer.length() > 0)\n \t\t\t\t\t{\n-\t\t\t\t\t// we have already rendered this child component, insert a stub component that\n+\t\t\t\t\t\t// we have already rendered this child component, insert a stub component\n+\t\t\t\t\t\t// that\n \t\t\t\t\t\t// will dump the markup during the normal render process if the enclosure is\n \t\t\t\t\t\t// visible\n \t\t\t\t\t\tfinal Component stub = new AutoMarkupLabel(child.getId(), buffer);\n@@ -250,10 +274,13 @@ protected void executeInsideBufferedZone()\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n \t\tit.rewind();\n \t}\n \n-\n+\t/**\n+\t * @see org.apache.wicket.Component#onDetach()\n+\t */\n \t@Override\n \tprotected void onDetach()\n \t{\n@@ -261,6 +288,9 @@ protected void onDetach()\n \t\tsuper.onDetach();\n \t}\n \n+\t/**\n+\t * \n+\t */\n \tprivate void restoreOriginalChildVisibility()\n \t{\n \t\tif (changes != null)\n",
        "project": "wicket",
        "linesAdd": 9,
        "jira_id": "2506",
        "nb_skipped": 0,
        "commit": "0f8a2990",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 23,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.extensions.markup.html.form.select.SelectTest"
        ],
        "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/form/select/Select.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/form/select/Select.java\nindex 56fec8d865..8284d59e85 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/form/select/Select.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/form/select/Select.java\n@@ -214,7 +214,7 @@ public void updateModel()\n \t * Checks if the specified option is selected based on raw input\n \t * \n \t * @param option\n-\t * @return true} iff the option is selected\n+\t * @return {@code true} if the option is selected, {@code false} otherwise\n \t */\n \tboolean isSelected(final SelectOption<?> option)\n \t{\n@@ -223,12 +223,13 @@ boolean isSelected(final SelectOption<?> option)\n \t\t// if the raw input is specified use that, otherwise use model\n \t\tif (hasRawInput())\n \t\t{\n-\t\t\tString[] paths = getInputAsArray();\n-\t\t\tif ((paths != null) && (paths.length > 0))\n+\t\t\tString[] values = getInputAsArray();\n+\t\t\tif (values != null && values.length > 0)\n \t\t\t{\n-\t\t\t\tfor (String path : paths)\n+\t\t\t\tfor (int i = 0; i < values.length; i++)\n \t\t\t\t{\n-\t\t\t\t\tif (path.equals(option.getPath()))\n+\t\t\t\t\tString value = values[i];\n+\t\t\t\t\tif (value.equals(option.getValue()))\n \t\t\t\t\t{\n \t\t\t\t\t\treturn true;\n \t\t\t\t\t}\n",
        "project": "wicket",
        "linesAdd": 5,
        "jira_id": "4276",
        "nb_skipped": 0,
        "commit": "32c76c4a",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 106,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.UrlTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 9d5b401df9..be49640499 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -290,7 +290,11 @@ public static Url parse(CharSequence _url, Charset charset, boolean isFullHint)\n \t\t\t}\n \n \t\t\tfinal int credentialsAt = hostAndPort.lastIndexOf('@') + 1;\n-\t\t\tfinal int portAt = hostAndPort.substring(credentialsAt).lastIndexOf(':');\n+\t\t\t//square brackets are used for ip6 URLs\n+\t\t\tfinal int closeSqrBracketAt = hostAndPort.lastIndexOf(']') + 1;\n+\t\t\tfinal int portAt = hostAndPort.substring(credentialsAt)\n+\t\t\t\t\t\t\t\t\t\t  .substring(closeSqrBracketAt)\n+\t\t\t\t\t\t\t\t\t      .lastIndexOf(':');\n \n \t\t\tif (portAt == -1)\n \t\t\t{\n@@ -299,8 +303,10 @@ public static Url parse(CharSequence _url, Charset charset, boolean isFullHint)\n \t\t\t}\n \t\t\telse\n \t\t\t{\n-\t\t\t\tresult.host = hostAndPort.substring(0, portAt + credentialsAt);\n-\t\t\t\tresult.port = Integer.parseInt(hostAndPort.substring(portAt + credentialsAt + 1));\n+\t\t\t\tfinal int portOffset = portAt + credentialsAt + closeSqrBracketAt;\n+\t\t\t\t\n+\t\t\t\tresult.host = hostAndPort.substring(0, portOffset);\n+\t\t\t\tresult.port = Integer.parseInt(hostAndPort.substring(portOffset + 1));\n \t\t\t}\n \n \t\t\tif (relativeAt < 0)\n",
        "project": "wicket",
        "linesAdd": 8,
        "jira_id": "5809",
        "nb_skipped": 0,
        "commit": "b1f4e6a3",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1038,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.mapper.BasicResourceReferenceMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractResourceReferenceMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractResourceReferenceMapper.java\nindex b0b40ecbac..ce4896c5d6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractResourceReferenceMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractResourceReferenceMapper.java\n@@ -47,14 +47,22 @@ protected static String encodeResourceReferenceAttributes(\n \t\t\t{\n \t\t\t\tres.append(attributes.getLocale().toString());\n \t\t\t}\n-\t\t\tif (!Strings.isEmpty(attributes.getStyle()))\n+\t\t\tboolean styleEmpty = Strings.isEmpty(attributes.getStyle());\n+\t\t\tif (!styleEmpty)\n \t\t\t{\n-\t\t\t\tres.append(\"-\");\n+\t\t\t\tres.append('-');\n \t\t\t\tres.append(attributes.getStyle());\n \t\t\t}\n \t\t\tif (!Strings.isEmpty(attributes.getVariation()))\n \t\t\t{\n-\t\t\t\tres.append(\"-\");\n+\t\t\t\tif (styleEmpty)\n+\t\t\t\t{\n+\t\t\t\t\tres.append(\"--\");\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\tres.append('-');\n+\t\t\t\t}\n \t\t\t\tres.append(attributes.getVariation());\n \t\t\t}\n \t\t\treturn res.toString();\n",
        "project": "wicket",
        "linesAdd": 11,
        "jira_id": "3297",
        "nb_skipped": 0,
        "commit": "71499e17",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1636,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.dontstoreunrendered.DontStoreNotRenderedPageOnePassRenderTest",
            "org.apache.wicket.dontstoreunrendered.DontStoreNotRenderedPageRedirectToRenderTest",
            "org.apache.wicket.dontstoreunrendered.DontStoreNotRenderedPageRedirectToBufferTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex c7d38f1028..3ac6f5984d 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -680,6 +680,9 @@ public Component(final String id)\n \tpublic Component(final String id, final IModel<?> model)\n \t{\n \t\tsetId(id);\n+\n+\t\tinit();\n+\n \t\tgetApplication().getComponentInstantiationListeners().onInstantiation(this);\n \n \t\tfinal DebugSettings debugSettings = getApplication().getDebugSettings();\n@@ -695,6 +698,15 @@ public Component(final String id, final IModel<?> model)\n \t\t}\n \t}\n \n+\t/**\n+\t * Let subclasses initialize this instance, before constructors are executed. <br>\n+\t * This method is intentionally <b>not</b> declared protected, to limit overriding to classes in\n+\t * this package.\n+\t */\n+\tvoid init()\n+\t{\n+\t}\n+\n \t/**\n \t * Get the Markup associated with the Component. If not subclassed, the parent container is\n \t * asked to return the markup of this child component.\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/Page.java b/wicket-core/src/main/java/org/apache/wicket/Page.java\nindex ea1dad2326..0935942545 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Page.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Page.java\n@@ -177,7 +177,6 @@ private Page(final PageParameters parameters, IModel<?> model)\n \t\t{\n \t\t\tpageParameters = parameters;\n \t\t}\n-\t\tinit();\n \t}\n \n \t/**\n@@ -703,7 +702,8 @@ private boolean hasInvisibleTransparentChild(final MarkupContainer root, final C\n \t/**\n \t * Initializes Page by adding it to the Session and initializing it.\n \t */\n-\tprivate void init()\n+\t@Override\n+\tvoid init()\n \t{\n \t\tif (isBookmarkable() == false)\n \t\t{\n",
        "project": "wicket",
        "linesAdd": 9,
        "jira_id": "5546",
        "nb_skipped": 2,
        "commit": "f1af9e03",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 764,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.border.ComponentBorderTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/Page.java b/wicket/src/main/java/org/apache/wicket/Page.java\nindex eaf188d430..b6f0290810 100644\n--- a/wicket/src/main/java/org/apache/wicket/Page.java\n+++ b/wicket/src/main/java/org/apache/wicket/Page.java\n@@ -33,6 +33,7 @@\n import org.apache.wicket.markup.MarkupException;\n import org.apache.wicket.markup.MarkupStream;\n import org.apache.wicket.markup.html.WebPage;\n+import org.apache.wicket.markup.html.border.Border;\n import org.apache.wicket.markup.html.form.Form;\n import org.apache.wicket.markup.resolver.IComponentResolver;\n import org.apache.wicket.model.IModel;\n@@ -1133,6 +1134,29 @@ public Object component(final Component component)\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\n+\t\t\t\t\t// Check if this component is a child of a border whose body is invisible and if\n+\t\t\t\t\t// so ignore it\n+\t\t\t\t\tBorder border = component.findParent(Border.class);\n+\t\t\t\t\tif (border != null && !border.getBodyContainer().isVisibleInHierarchy())\n+\t\t\t\t\t{\n+\n+\t\t\t\t\t\t// Suppose:\n+\t\t\t\t\t\t//\t\t\t\t\t\t  \n+\t\t\t\t\t\t// <div wicket:id=\"border\"><div wicket:id=\"label\"></div> suppose\n+\t\t\t\t\t\t// border->label and border's body is hidden.\n+\t\t\t\t\t\t//\t\t\t\t\t\t  \n+\t\t\t\t\t\t// The label is added to border not to its hidden body so as far as wicket\n+\t\t\t\t\t\t// is concerned label is visible in hierarchy, but when rendering label wont\n+\t\t\t\t\t\t// be rendered because in the markup it is inside the border's hidden body.\n+\t\t\t\t\t\t// Thus component use check will fail even though it shouldnt - make sure it\n+\t\t\t\t\t\t// doesnt.\n+\t\t\t\t\t\t//\t\t\t\t\t\t \n+\n+\t\t\t\t\t\t// TODO it would be more accurate to determine that this component is inside\n+\t\t\t\t\t\t// the border parent's markup not the border's itself\n+\t\t\t\t\t\titerator.remove();\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\t// if still > 0\n \t\t\t\tif (unrenderedComponents.size() > 0)\n",
        "project": "wicket",
        "linesAdd": 9,
        "jira_id": "2079",
        "nb_skipped": 0,
        "commit": "ceac38b1",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1494,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.mapper.MountedMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\nindex ae742d63f1..12f8985e43 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\n@@ -495,7 +495,15 @@ public int getCompatibilityScore(Request request)\n \t{\n \t\tif (urlStartsWith(request.getUrl(), mountSegments))\n \t\t{\n-\t\t\treturn mountSegments.length;\n+\t\t\t/* see WICKET-5056 - alter score with pathSegment type */\n+\t\t\tint countOptional = 0;\n+\t\t\tint fixedSegments = 0;\n+\t\t\tfor (MountPathSegment pathSegment : pathSegments)\n+\t\t\t{\n+\t\t\t\tfixedSegments += pathSegment.getFixedPartSize();\n+\t\t\t\tcountOptional += pathSegment.getOptionalParameters();\n+\t\t\t}\n+\t\t\treturn mountSegments.length - countOptional + fixedSegments;\n \t\t}\n \t\telse\n \t\t{\n",
        "project": "wicket",
        "linesAdd": 8,
        "jira_id": "5056",
        "nb_skipped": 4,
        "commit": "56169634",
        "nb_failure": 3,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1140,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.AttributeModifierTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/behavior/AttributeAppender.java b/wicket-core/src/main/java/org/apache/wicket/behavior/AttributeAppender.java\nindex 13b7fe9871..5db452618e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/behavior/AttributeAppender.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/behavior/AttributeAppender.java\n@@ -152,9 +152,9 @@ protected String newValue(String currentValue, String appendValue)\n \t{\n \t\t// Short circuit when one of the values is empty: return the other value.\n \t\tif (Strings.isEmpty(currentValue))\n-\t\t\treturn appendValue != null ? appendValue : \"\";\n+\t\t\treturn appendValue != null ? appendValue : null;\n \t\telse if (Strings.isEmpty(appendValue))\n-\t\t\treturn currentValue != null ? currentValue : \"\";\n+\t\t\treturn currentValue != null ? currentValue : null;\n \n \t\tStringBuilder sb = new StringBuilder(currentValue);\n \t\tsb.append((getSeparator() == null ? \"\" : getSeparator()));\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "3884",
        "nb_skipped": 2,
        "commit": "b772ff87",
        "nb_failure": 5,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1566,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.handler.render.WebPageRendererTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\nindex 4b95e32893..8c99c13832 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n@@ -332,10 +332,16 @@ protected boolean shouldRedirectToTargetUrl(RequestCycle cycle, Url currentUrl,\n \tprotected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url currentUrl,\n \t\tUrl targetUrl)\n \t{\n+\t\t// WICKET-5484 never render and write for Ajax requests\n+\t\tif (isAjax(cycle))\n+\t\t{\n+\t\t\treturn false;\n+\t\t}\n+\n \t\treturn neverRedirect(getRedirectPolicy())\n-\t\t\t|| (!isAjax(cycle) && ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl\n+\t\t\t|| ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl\n \t\t\t\t.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(),\n-\t\t\t\tisPageStateless())))) || (targetUrl.equals(currentUrl) && isRedirectToRender())\n+\t\t\t\tisPageStateless()))) || (targetUrl.equals(currentUrl) && isRedirectToRender())\n \t\t\t|| shouldPreserveClientUrl(cycle);\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 7,
        "jira_id": "5484",
        "nb_skipped": 2,
        "commit": "ecdfc124",
        "nb_failure": 2,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1275,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.resource.ByteArrayResourceTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/ByteArrayResource.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/ByteArrayResource.java\nindex d11cab8809..544f7ad460 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/ByteArrayResource.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/ByteArrayResource.java\n@@ -21,6 +21,8 @@\n import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.util.time.Time;\n \n+import javax.servlet.http.HttpServletResponse;\n+\n /**\n  * An {@link IResource} for byte arrays. The byte array can be static - passed to the constructor,\n  * or dynamic - by overriding\n@@ -119,8 +121,10 @@ protected ResourceResponse newResourceResponse(final Attributes attributes)\n \t\tfinal byte[] data = getData(attributes);\n \t\tif (data == null)\n \t\t{\n-\t\t\tthrow new WicketRuntimeException(\"ByteArrayResource's data cannot be 'null'.\");\n+\t\t\tresponse.setError(HttpServletResponse.SC_NOT_FOUND);\n \t\t}\n+\t\telse\n+\t\t{\n \t\t\tresponse.setContentLength(data.length);\n \n \t\t\tif (response.dataNeedsToBeWritten(attributes))\n@@ -146,6 +150,7 @@ public void writeData(final Attributes attributes)\n \n \t\t\t\tconfigureResponse(response, attributes);\n \t\t\t}\n+\t\t}\n \n \t\treturn response;\n \t}\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/DynamicImageResource.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/DynamicImageResource.java\nindex 472ff4579b..9e023d0bd7 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/DynamicImageResource.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/DynamicImageResource.java\n@@ -167,9 +167,10 @@ public void writeData(final Attributes attributes)\n \t\t\t\t\t\tattributes.getResponse().write(imageData);\n \t\t\t\t\t}\n \t\t\t\t});\n-\t\t\t}\n+\n \t\t\t\tconfigureResponse(response, attributes);\n \t\t\t}\n+\t\t}\n \n \t\treturn response;\n \t}\n",
        "project": "wicket",
        "linesAdd": 8,
        "jira_id": "4301",
        "nb_skipped": 4,
        "commit": "50b52742",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1203,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.mapper.PackageMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/PackageMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/PackageMapper.java\nindex 563afd042f..f6082e375c 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/PackageMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/PackageMapper.java\n@@ -16,11 +16,11 @@\n  */\n package org.apache.wicket.request.mapper;\n \n+import org.apache.wicket.protocol.http.WebApplication;\n import org.apache.wicket.request.Request;\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.component.IRequestablePage;\n import org.apache.wicket.request.mapper.info.PageComponentInfo;\n-import org.apache.wicket.request.mapper.mount.MountMapper;\n import org.apache.wicket.request.mapper.parameter.IPageParametersEncoder;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n import org.apache.wicket.request.mapper.parameter.PageParametersEncoder;\n@@ -30,10 +30,14 @@\n /**\n  * A request mapper that mounts all bookmarkable pages in a given package.\n  * <p>\n- * To mount this mapper onto a path use the {@link MountMapper}, ex:\n+ * To mount this mapper onto a path use the {@link WebApplication#mountPackage(String, Class)}, ex:\n  * \n  * <pre>\n- * new MountMapper(&quot;/my/path&quot;, new packageMapper(PackageName.forClass(MyPage.class)));\n+ * MyApp#init() {\n+ * \n+ *   super.init();\n+ *   mountPackage(&quot;/my/path&quot;, MyPage.class);\n+ * }\n  * </pre>\n  * \n  * will result in urls like {@code /my/path/MyPage}\n@@ -96,10 +100,19 @@ public PackageMapper(final PackageName packageName,\n \tprotected Url buildUrl(UrlInfo info)\n \t{\n \t\tClass<? extends IRequestablePage> pageClass = info.getPageClass();\n-\t\tif (PackageName.forClass(pageClass).equals(packageName))\n+\t\tPackageName pageClassPackageName = PackageName.forClass(pageClass);\n+\t\tif (pageClassPackageName.equals(packageName))\n \t\t{\n \t\t\tUrl url = new Url();\n-\t\t\turl.getSegments().add(pageClass.getSimpleName());\n+\n+\t\t\tString fullyQualifiedClassName = pageClass.getName();\n+\t\t\tString packageRelativeClassName = fullyQualifiedClassName;\n+\t\t\tint packageNameLength = packageName.getName().length();\n+\t\t\tif (packageNameLength > 0)\n+\t\t\t{\n+\t\t\t\tpackageRelativeClassName = fullyQualifiedClassName.substring(packageNameLength + 1);\n+\t\t\t}\n+\t\t\turl.getSegments().add(packageRelativeClassName);\n \t\t\tencodePageComponentInfo(url, info.getPageComponentInfo());\n \t\t\treturn encodePageParameters(url, info.getPageParameters(), pageParametersEncoder);\n \t\t}\n",
        "project": "wicket",
        "linesAdd": 12,
        "jira_id": "3838",
        "nb_skipped": 2,
        "commit": "97514205",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 180,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.resource.ResourceUtilsTest"
        ],
        "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/resource/ResourceUtils.java b/wicket-util/src/main/java/org/apache/wicket/util/resource/ResourceUtils.java\nindex e7ec95a2fe..3216707247 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/resource/ResourceUtils.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/resource/ResourceUtils.java\n@@ -33,10 +33,10 @@\n {\r\n \tprivate static final Pattern LOCALE_PATTERN = Pattern.compile(\"_([a-z]{2})(_([A-Z]{2})(_([^_]+))?)?$\");\r\n \r\n-\tprivate final static Set<String> isoCountries = new ConcurrentHashSet<String>(\r\n+\tprivate final static Set<String> isoCountries = new ConcurrentHashSet<>(\r\n \t\tArrays.asList(Locale.getISOCountries()));\r\n \r\n-\tprivate final static Set<String> isoLanguages = new ConcurrentHashSet<String>(\r\n+\tprivate final static Set<String> isoLanguages = new ConcurrentHashSet<>(\r\n \t\tArrays.asList(Locale.getISOLanguages()));\r\n \r\n \t/**\r\n@@ -56,7 +56,7 @@ private ResourceUtils()\n \tpublic static PathLocale getLocaleFromFilename(String path)\r\n \t{\r\n \t\tString extension = \"\";\r\n-\t\tint pos = path.indexOf('.');\r\n+\t\tint pos = path.lastIndexOf('.');\r\n \t\tif (pos != -1)\r\n \t\t{\r\n \t\t\textension = path.substring(pos);\r\n@@ -104,7 +104,7 @@ public static PathLocale getLocaleFromFilename(String path)\n \t\t\t}\r\n \t\t} // else skip the whole thing... probably user specific underscores used\r\n \r\n-\t\treturn new PathLocale(path, null);\r\n+\t\treturn new PathLocale(path + extension, null);\r\n \t}\r\n \r\n \t/**\r\n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "5706",
        "nb_skipped": 2,
        "commit": "0f8a6d75",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1176,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.http.request.UserAgentTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/request/UserAgent.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/request/UserAgent.java\nindex 4c663d3225..b6c028ad2c 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/request/UserAgent.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/request/UserAgent.java\n@@ -96,16 +96,20 @@ public boolean matches(String userAgent)\n \n \t\tfor (List<String> detectionGroup : detectionStrings)\n \t\t{\n+\t\t\tboolean groupPassed = true;\n \t\t\tfor (String detectionString : detectionGroup)\n \t\t\t{\n \t\t\t\tif (!userAgent.contains(detectionString))\n \t\t\t\t{\n-\t\t\t\t\treturn false;\n+\t\t\t\t\tgroupPassed = false;\n+\t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n-\n+\t\t\tif (groupPassed)\n+\t\t\t{\n \t\t\t\treturn true;\n \t\t\t}\n+\t\t}\n \n \t\treturn false;\n \t}\n",
        "project": "wicket",
        "linesAdd": 6,
        "jira_id": "3713",
        "nb_skipped": 0,
        "commit": "e1168a57",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1200,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.transformer.AbstractTransformerBehaviorTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/AbstractTransformerBehavior.java b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/AbstractTransformerBehavior.java\nindex be0490b983..f752e10ebc 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/AbstractTransformerBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/AbstractTransformerBehavior.java\n@@ -20,12 +20,13 @@\n import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.behavior.Behavior;\n import org.apache.wicket.protocol.http.BufferedWebResponse;\n+import org.apache.wicket.request.Response;\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.request.http.WebResponse;\n \n /**\n- * A IBehavior which can be added to any component. It allows to post-process (transform) the markup\n- * generated by the component.\n+ * A {@link Behavior} which can be added to any component. It allows to post-process (transform) the\n+ * markup generated by the component.\n  * \n  * @see org.apache.wicket.markup.transformer.AbstractOutputTransformerContainer\n  * \n@@ -35,20 +36,17 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n-\tprivate WebResponse webResponse;\n-\n \t/**\n-\t * Construct.\n+\t * The request cycle's response before the transformation.\n \t */\n-\tpublic AbstractTransformerBehavior()\n-\t{\n-\t}\n+\tprivate Response originalResponse;\n \n \t/**\n \t * Create a new response object which is used to store the markup generated by the child\n \t * objects.\n \t * \n \t * @param originalResponse\n+\t *            the original web response or {@code null} if it isn't a {@link WebResponse}\n \t * \n \t * @return Response object. Must not be null\n \t */\n@@ -65,17 +63,14 @@ public void beforeRender(Component component)\n \t\tfinal RequestCycle requestCycle = RequestCycle.get();\n \n \t\t// Temporarily replace the web response with a String response\n-\t\twebResponse = (WebResponse)requestCycle.getResponse();\n+\t\toriginalResponse = requestCycle.getResponse();\n \n-\t\t// Create a new response object\n-\t\tfinal BufferedWebResponse response = newResponse(webResponse);\n-\t\tif (response == null)\n-\t\t{\n-\t\t\tthrow new IllegalStateException(\"newResponse() must not return null\");\n-\t\t}\n+\t\tWebResponse origResponse = (WebResponse)((originalResponse instanceof WebResponse)\n+\t\t\t? originalResponse : null);\n+\t\tBufferedWebResponse tempResponse = newResponse(origResponse);\n \n-\t\t// and make it the current one\n-\t\trequestCycle.setResponse(response);\n+\t\t// temporarily set StringResponse to collect the transformed output\n+\t\trequestCycle.setResponse(tempResponse);\n \t}\n \n \t@Override\n@@ -85,28 +80,28 @@ public void afterRender(final Component component)\n \n \t\ttry\n \t\t{\n-\t\t\tBufferedWebResponse response = (BufferedWebResponse)requestCycle.getResponse();\n+\t\t\tBufferedWebResponse tempResponse = (BufferedWebResponse)requestCycle.getResponse();\n \n \t\t\t// Transform the data\n-\t\t\tCharSequence output = transform(component, response.getText());\n-\t\t\tresponse.setText(output);\n-\t\t\tresponse.writeTo(webResponse);\n+\t\t\tCharSequence output = transform(component, tempResponse.getText());\n+\t\t\toriginalResponse.write(output);\n \t\t}\n \t\tcatch (Exception ex)\n \t\t{\n-\t\t\tthrow new WicketRuntimeException(\"Error while transforming the output: \" + this, ex);\n+\t\t\tthrow new WicketRuntimeException(\"Error while transforming the output of component: \" +\n+\t\t\t\tcomponent, ex);\n \t\t}\n \t\tfinally\n \t\t{\n \t\t\t// Restore the original response object\n-\t\t\trequestCycle.setResponse(webResponse);\n+\t\t\trequestCycle.setResponse(originalResponse);\n \t\t}\n \t}\n \n \t@Override\n \tpublic void detach(Component component)\n \t{\n-\t\twebResponse = null;\n+\t\toriginalResponse = null;\n \t\tsuper.detach(component);\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 14,
        "jira_id": "4105",
        "nb_skipped": 2,
        "commit": "64656c98",
        "nb_failure": 0,
        "linesRem": 19,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1078,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.resource.locator.CachingResourceStreamLocatorTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/util/resource/locator/CachingResourceStreamLocator.java b/wicket-core/src/main/java/org/apache/wicket/util/resource/locator/CachingResourceStreamLocator.java\nindex 08f5b26c67..dba49765d0 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/util/resource/locator/CachingResourceStreamLocator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/util/resource/locator/CachingResourceStreamLocator.java\n@@ -22,6 +22,7 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n \n+import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.request.resource.ResourceReference.Key;\n import org.apache.wicket.util.file.File;\n import org.apache.wicket.util.lang.Args;\n@@ -49,7 +50,7 @@\n \t */\n \tprivate static interface IResourceStreamReference\n \t{\n-\t\tString getReference();\n+\t\tIResourceStream getReference();\n \t}\n \n \t/**\n@@ -61,7 +62,7 @@\n \t{\n \t\tprivate final static NullResourceStreamReference INSTANCE = new NullResourceStreamReference();\n \n-\t\tpublic String getReference()\n+\t\tpublic IResourceStream getReference()\n \t\t{\n \t\t\treturn null;\n \t\t}\n@@ -79,9 +80,9 @@ private FileResourceStreamReference(final String fileName)\n \t\t\tthis.fileName = fileName;\n \t\t}\n \n-\t\tpublic String getReference()\n+\t\tpublic FileResourceStream getReference()\n \t\t{\n-\t\t\treturn fileName;\n+\t\t\treturn new FileResourceStream(new File(fileName));\n \t\t}\n \t}\n \n@@ -97,9 +98,18 @@ private UrlResourceStreamReference(final String url)\n \t\t\tthis.url = url;\n \t\t}\n \n-\t\tpublic String getReference()\n+\t\tpublic UrlResourceStream getReference()\n \t\t{\n-\t\t\treturn url;\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\treturn new UrlResourceStream(new URL(url));\n+\t\t\t}\n+\t\t\tcatch (MalformedURLException e)\n+\t\t\t{\n+\t\t\t\t// should not ever happen. The cached url is created by previously existing URL\n+\t\t\t\t// instance\n+\t\t\t\tthrow new WicketRuntimeException(e);\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -133,16 +143,21 @@ public CachingResourceStreamLocator(final IResourceStreamLocator resourceStreamL\n \tpublic IResourceStream locate(Class<?> clazz, String path)\n \t{\n \t\tKey key = new Key(clazz.getName(), path, null, null, null);\n-\t\tIResourceStream resourceStream = getCopyFromCache(key);\n+\t\tIResourceStreamReference resourceStreamReference = cache.get(key);\n \n-\t\tif (resourceStream == null)\n+\t\tfinal IResourceStream result;\n+\t\tif (resourceStreamReference == null)\n \t\t{\n-\t\t\tresourceStream = delegate.locate(clazz, path);\n+\t\t\tresult = delegate.locate(clazz, path);\n \n-\t\t\tupdateCache(key, resourceStream);\n+\t\t\tupdateCache(key, result);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tresult = resourceStreamReference.getReference();\n \t\t}\n \n-\t\treturn resourceStream;\n+\t\treturn result;\n \t}\n \n \tprivate void updateCache(Key key, IResourceStream stream)\n@@ -165,60 +180,25 @@ else if (stream instanceof UrlResourceStream)\n \t\t}\n \t}\n \n-\t/**\n-\t * Make a copy before returning an item from the cache as resource streams are not thread-safe.\n-\t * \n-\t * @param key\n-\t *            the cache key\n-\t * @return the cached File or Url resource stream\n-\t */\n-\tprivate IResourceStream getCopyFromCache(Key key)\n-\t{\n-\t\tfinal IResourceStreamReference orig = cache.get(key);\n-\t\tif (NullResourceStreamReference.INSTANCE == orig)\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\tif (orig instanceof UrlResourceStreamReference)\n-\t\t{\n-\t\t\tUrlResourceStreamReference resourceStreamReference = (UrlResourceStreamReference)orig;\n-\t\t\tString url = resourceStreamReference.getReference();\n-\t\t\ttry\n-\t\t\t{\n-\t\t\t\treturn new UrlResourceStream(new URL(url));\n-\t\t\t}\n-\t\t\tcatch (MalformedURLException e)\n-\t\t\t{\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (orig instanceof FileResourceStreamReference)\n-\t\t{\n-\t\t\tFileResourceStreamReference resourceStreamReference = (FileResourceStreamReference)orig;\n-\t\t\tString absolutePath = resourceStreamReference.getReference();\n-\t\t\treturn new FileResourceStream(new File(absolutePath));\n-\t\t}\n-\n-\t\treturn null;\n-\t}\n-\n \tpublic IResourceStream locate(Class<?> scope, String path, String style, String variation,\n \t\tLocale locale, String extension, boolean strict)\n \t{\n \t\tKey key = new Key(scope.getName(), path, locale, style, variation);\n-\t\tIResourceStream resourceStream = getCopyFromCache(key);\n+\t\tIResourceStreamReference resourceStreamReference = cache.get(key);\n \n-\t\tif (resourceStream == null)\n+\t\tfinal IResourceStream result;\n+\t\tif (resourceStreamReference == null)\n \t\t{\n-\t\t\tresourceStream = delegate.locate(scope, path, style, variation, locale, extension,\n-\t\t\t\tstrict);\n+\t\t\tresult = delegate.locate(scope, path, style, variation, locale, extension, strict);\n \n-\t\t\tupdateCache(key, resourceStream);\n+\t\t\tupdateCache(key, result);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tresult = resourceStreamReference.getReference();\n \t\t}\n \n-\t\treturn resourceStream;\n+\t\treturn result;\n \t}\n \n \tpublic ResourceNameIterator newResourceNameIterator(String path, Locale locale, String style,\n",
        "project": "wicket",
        "linesAdd": 34,
        "jira_id": "3511",
        "nb_skipped": 0,
        "commit": "4a875f46",
        "nb_failure": 1,
        "linesRem": 49,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 92,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.UrlTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 12ca5f0b4d..9ca2c0d8b4 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -674,7 +674,7 @@ else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false)\n \t\t\t\tresult.append(port);\n \t\t\t}\n \n-\t\t\tif (path.contains(\"..\"))\n+\t\t\tif (segments.contains(\"..\"))\n \t\t\t{\n \t\t\t\tthrow new IllegalStateException(\"Cannot render this url in \" +\n \t\t\t\t\tStringMode.FULL.name() + \" mode because it has a `..` segment: \" + toString());\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "5114",
        "nb_skipped": 0,
        "commit": "518c933b",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1742,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.form.CollectionFormComponentTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\nindex 88c53506d6..c0f4f1083c 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\n@@ -1613,6 +1613,9 @@ public final void updateAutoLabels(AjaxRequestTarget target)\n \tpublic static <S> void updateCollectionModel(FormComponent<Collection<S>> formComponent)\n \t{\n \t\tCollection<S> convertedInput = formComponent.getConvertedInput();\n+\t\tif (convertedInput == null) {\n+\t\t\tconvertedInput = Collections.emptyList();\n+\t\t}\n \n \t\tCollection<S> collection = formComponent.getModelObject();\n \t\tif (collection == null)\n@@ -1629,10 +1632,7 @@ public final void updateAutoLabels(AjaxRequestTarget target)\n \t\t\ttry\n \t\t\t{\n \t\t\t\tcollection.clear();\n-\t\t\t\tif (convertedInput != null)\n-\t\t\t\t{\n \t\t\t\tcollection.addAll(convertedInput);\n-\t\t\t\t}\n \t\t\t\tmodified = true;\n \t\t\t}\n \t\t\tcatch (UnsupportedOperationException unmodifiable)\n",
        "project": "wicket",
        "linesAdd": 3,
        "jira_id": "5881",
        "nb_skipped": 1,
        "commit": "8c83c5c5",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1195,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.form.FormComponentTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\nindex 52612b2..1f2d23e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\n@@ -1405,9 +1405,17 @@ public abstract class FormComponent<T> extends LabeledWebMarkupContainer\n \t\t{\n \t\t\tfor (Behavior behavior : getBehaviors())\n \t\t\t{\n-\t\t\t\tif (behavior instanceof IValidator)\n+\t\t\t\tvalidator = null;\n+\t\t\t\tif (behavior instanceof ValidatorAdapter)\n+\t\t\t\t{\n+\t\t\t\t\tvalidator = ((ValidatorAdapter<T>)behavior).getValidator();\n+\t\t\t\t}\n+\t\t\t\telse if (behavior instanceof IValidator)\n \t\t\t\t{\n \t\t\t\t\tvalidator = (IValidator<T>)behavior;\n+\t\t\t\t}\n+\t\t\t\tif (validator != null)\n+\t\t\t\t{\n \t\t\t\t\tif (isNull == false || validator instanceof INullAcceptingValidator<?>)\n \t\t\t\t\t{\n \t\t\t\t\t\tvalidator.validate(validatable);\n",
        "project": "wicket",
        "linesAdd": 9,
        "jira_id": "3767",
        "nb_skipped": 1,
        "commit": "84c3baac",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 1003,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.header.testing3.HeaderTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/Component.java b/wicket/src/main/java/org/apache/wicket/Component.java\nindex aeba67441d..1660a1382b 100644\n--- a/wicket/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket/src/main/java/org/apache/wicket/Component.java\n@@ -64,6 +64,7 @@\n import org.apache.wicket.settings.IDebugSettings;\n import org.apache.wicket.util.IHierarchical;\n import org.apache.wicket.util.convert.IConverter;\n+import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.lang.Classes;\n import org.apache.wicket.util.lang.WicketObjects;\n import org.apache.wicket.util.string.ComponentStrings;\n@@ -2774,6 +2773,21 @@ public final void setMarkupIdImpl(Object markupId)\n \t\tsetOutputMarkupId(true);\n \t}\n \n+\t/**\n+\t * Copy markupId\n+\t * \n+\t * @param comp\n+\t */\n+\tfinal void setMarkupId(Component comp)\n+\t{\n+\t\tArgs.notNull(comp, \"comp\");\n+\n+\t\tgeneratedMarkupId = comp.generatedMarkupId;\n+\t\tsetMetaData(MARKUP_ID_KEY, comp.getMetaData(MARKUP_ID_KEY));\n+\t\tsetOutputMarkupId(comp.getOutputMarkupId());\n+\t\treturn;\n+\t}\n+\n \t/**\n \t * Sets this component's markup id to a user defined value. It is up to the user to ensure this\n \t * value is unique.\ndiff --git a/wicket/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket/src/main/java/org/apache/wicket/MarkupContainer.java\nindex 07536ee720..cff90560fc 100644\n--- a/wicket/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -804,7 +804,7 @@ public final MarkupContainer replace(final Component child)\n \t\t\taddedComponent(child);\n \n \t\t\t// The generated markup id remains the same\n-\t\t\tchild.setMarkupIdImpl(replaced.getMarkupIdImpl());\n+\t\t\tchild.setMarkupId(replaced);\n \t\t}\n \n \t\treturn this;\ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/html/panel/Panel.java b/wicket/src/main/java/org/apache/wicket/markup/html/panel/Panel.java\nindex 8fa10e28a1..3245a542b2 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/panel/Panel.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/panel/Panel.java\n@@ -106,6 +106,13 @@ protected void onComponentTag(final ComponentTag tag)\n \t\t\t// <span wicket:id=\"myPanel\">...</span>\n \t\t\ttag.setType(XmlTag.OPEN);\n \t\t}\n+\n+// IMarkupFragment markup = getMarkup(null);\n+// ComponentTag panelTag = (ComponentTag)markup.get(0);\n+// for (String key : panelTag.getAttributes().keySet())\n+// {\n+// tag.append(key, panelTag.getAttribute(key), \", \");\n+// }\n \t\tsuper.onComponentTag(tag);\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 13,
        "jira_id": "3197",
        "nb_skipped": 0,
        "commit": "be70e608",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 726,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.tester.WicketTesterTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/protocol/http/MockWebApplication.java b/wicket/src/main/java/org/apache/wicket/protocol/http/MockWebApplication.java\nindex aaf95f6520..3ad878fc48 100644\n--- a/wicket/src/main/java/org/apache/wicket/protocol/http/MockWebApplication.java\n+++ b/wicket/src/main/java/org/apache/wicket/protocol/http/MockWebApplication.java\n@@ -16,16 +16,18 @@\n  */\n package org.apache.wicket.protocol.http;\n \n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n import java.io.File;\n import java.util.Enumeration;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Map;\n-\n-import javax.servlet.FilterConfig;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.http.HttpServletResponse;\n+import java.util.Set;\n \n import org.apache.wicket.Application;\n import org.apache.wicket.Component;\n@@ -121,6 +123,7 @@\n \tprivate final ServletContext context;\n \n \tprivate final WicketFilter filter;\n+\tprivate Set<Cookie> cookiesOfThisSession = new HashSet<Cookie>();\n \n \t/**\n \t * Create the mock http tester that can be used for testing.\n@@ -195,7 +198,15 @@ public String getFilterName()\n \t\tservletSession = new MockHttpSession(context);\n \t\tservletSession.setTemporary(initializeHttpSessionAsTemporary());\n \t\tservletRequest = new MockHttpServletRequest(this.application, servletSession, context);\n-\t\tservletResponse = new MockHttpServletResponse(servletRequest);\n+\t\tservletResponse = new MockHttpServletResponse(servletRequest)\n+\t\t{\n+\t\t\t@Override\n+\t\t\tpublic void addCookie(Cookie cookie)\n+\t\t\t{\n+\t\t\t\tsuper.addCookie(cookie);\n+\t\t\t\tcookiesOfThisSession.add(cookie);\n+\t\t\t}\n+\t\t};\n \n \t\t// Construct request and response using factories\n \t\twicketRequest = this.application.newWebRequest(servletRequest);\n@@ -620,6 +631,7 @@ public WebRequestCycle setupRequestAndResponse(boolean isAjax)\n \t{\n \t\tservletRequest.initialize();\n \t\tservletResponse.initialize();\n+\t\tservletRequest.addCookies(cookiesOfThisSession);\n \t\tservletRequest.setParameters(parametersForNextRequest);\n \t\tif (isAjax)\n \t\t{\n",
        "project": "wicket",
        "linesAdd": 18,
        "jira_id": "1886",
        "nb_skipped": 0,
        "commit": "5226978a",
        "nb_failure": 0,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 4,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.bean.validation.PropertyValidatorRequiredTest"
        ],
        "patch": "diff --git a/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/PropertyValidator.java b/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/PropertyValidator.java\nindex 032a818e5a..e8e6376d4d 100644\n--- a/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/PropertyValidator.java\n+++ b/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/PropertyValidator.java\n@@ -1,6 +1,10 @@\n package org.apache.wicket.bean.validation;\n \n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Set;\n \n import javax.validation.ConstraintViolation;\n@@ -62,8 +66,8 @@\n \tprivate final IModel<Class<?>[]> groups_;\n \n \t/**\n-\t * A flag that indicates whether {@linkplain #setComponentRequiredFlag()}\n-\t * has been called for this behavior.\n+\t * A flag that indicates whether {@linkplain #setComponentRequiredFlag()} has been called for\n+\t * this behavior.\n \t */\n \tprivate boolean requiredFlagSet;\n \n@@ -132,8 +136,10 @@ public void bind(Component component)\n \t\t\t\t\" can only be added to FormComponents\");\n \t\t}\n \n-\t\t// TODO add a validation key that appends the type so we can have different messages for\n-\t\t// @Size on String vs Collection - done but need to add a key for each superclass/interface\n+\t\t// TODO add a validation key that appends the type so we can have\n+\t\t// different messages for\n+\t\t// @Size on String vs Collection - done but need to add a key for each\n+\t\t// superclass/interface\n \n \t\tthis.component = (FormComponent<T>)component;\n \t}\n@@ -144,10 +150,15 @@ public void onConfigure(Component component)\n \t\tsuper.onConfigure(component);\n \t\tif (requiredFlagSet == false)\n \t\t{\n-\t\t\t// \"Required\" flag is calculated upon component's model property, so we must ensure,\n-\t\t\t// that model object is accessible (i.e. component is already added in a page).\n+\t\t\t// \"Required\" flag is calculated upon component's model property, so\n+\t\t\t// we must ensure,\n+\t\t\t// that model object is accessible (i.e. component is already added\n+\t\t\t// in a page).\n \t\t\trequiredFlagSet = true;\n-\t\t\tsetComponentRequiredFlag();\n+\t\t\tif (isRequired())\n+\t\t\t{\n+\t\t\t\tthis.component.setRequired(true);\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -161,28 +172,58 @@ public void detach(Component component)\n \t\t}\n \t}\n \n-\t/**\n-\t * Marks the form component required if necessary\n-\t */\n-\tprivate void setComponentRequiredFlag()\n+\tprivate List<NotNull> findNotNullConstraints()\n \t{\n \t\tBeanValidationContext config = BeanValidationConfiguration.get();\n \t\tValidator validator = config.getValidator();\n \t\tProperty property = getProperty();\n \n-\t\t// if the property has a NotNull constraint mark the form component required\n+\t\tList<NotNull> constraints = new ArrayList<NotNull>();\n \n \t\tIterator<ConstraintDescriptor<?>> it = new ConstraintIterator(validator, property);\n+\n \t\twhile (it.hasNext())\n \t\t{\n \t\t\tConstraintDescriptor<?> desc = it.next();\n \t\t\tif (desc.getAnnotation().annotationType().equals(NotNull.class))\n \t\t\t{\n-\t\t\t\tcomponent.setRequired(true);\n-\t\t\t\tbreak;\n+\t\t\t\tconstraints.add((NotNull)desc.getAnnotation());\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn constraints;\n+\t}\n+\n+\tboolean isRequired()\n+\t{\n+\t\tList<NotNull> constraints = findNotNullConstraints();\n+\n+\t\tif (constraints.isEmpty())\n+\t\t{\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tHashSet<Class<?>> validatorGroups = new HashSet<Class<?>>();\n+\t\tvalidatorGroups.addAll(Arrays.asList(getGroups()));\n+\n+\t\tfor (NotNull constraint : constraints)\n+\t\t{\n+\t\t\tif (constraint.groups().length == 0 && validatorGroups.isEmpty())\n+\t\t\t{\n+\t\t\t\treturn true;\n \t\t\t}\n+\n+\t\t\tfor (Class<?> constraintGroup : constraint.groups())\n+\t\t\t{\n+\t\t\t\tif (validatorGroups.contains(constraintGroup))\n+\t\t\t\t{\n+\t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n \n \t@Override\n \t@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n@@ -194,7 +235,8 @@ public void onComponentTag(Component component, ComponentTag tag)\n \t\tValidator validator = config.getValidator();\n \t\tProperty property = getProperty();\n \n-\t\t// find any tag modifiers that apply to the constraints of the property being validated\n+\t\t// find any tag modifiers that apply to the constraints of the property\n+\t\t// being validated\n \t\t// and allow them to modify the component tag\n \n \t\tIterator<ConstraintDescriptor<?>> it = new ConstraintIterator(validator, property,\ndiff --git a/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/SessionLocaleInterpolator.java b/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/SessionLocaleInterpolator.java\nindex 00aa5068f8..f8927e2229 100644\n--- a/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/SessionLocaleInterpolator.java\n+++ b/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/SessionLocaleInterpolator.java\n@@ -28,7 +28,8 @@ public SessionLocaleInterpolator(MessageInterpolator delegate)\n \t\tthis.delegate = delegate;\n \t}\n \n-\tpublic String interpolate(final String messageTemplate, final MessageInterpolator.Context context)\n+\tpublic String interpolate(final String messageTemplate,\n+\t\tfinal MessageInterpolator.Context context)\n \t{\n \t\tfinal Locale locale = getLocale();\n \t\tif (locale != null)\n@@ -41,7 +42,8 @@ public String interpolate(final String messageTemplate, final MessageInterpolato\n \t\t}\n \t}\n \n-\tpublic String interpolate(final String message, final MessageInterpolator.Context context, final Locale locale)\n+\tpublic String interpolate(final String message, final MessageInterpolator.Context context,\n+\t\tfinal Locale locale)\n \t{\n \t\treturn delegate.interpolate(message, context, locale);\n \t}\ndiff --git a/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/SizeTagModifier.java b/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/SizeTagModifier.java\nindex 41249742e3..1795dc4be1 100644\n--- a/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/SizeTagModifier.java\n+++ b/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/SizeTagModifier.java\n@@ -6,8 +6,8 @@\n import org.apache.wicket.markup.html.form.FormComponent;\n \n /**\n- * A tag modifier that adds the {@code maxlength} attribute to the {@code input} tag with the max value\n- * from the {@link Size} constraint annotation.\n+ * A tag modifier that adds the {@code maxlength} attribute to the {@code input} tag with the max\n+ * value from the {@link Size} constraint annotation.\n  * \n  * @author igor\n  * \n",
        "project": "wicket",
        "linesAdd": 49,
        "jira_id": "5418",
        "nb_skipped": 0,
        "commit": "e350f19e",
        "nb_failure": 1,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 154,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.visit.ClassVisitFilterTest"
        ],
        "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/visit/ClassVisitFilter.java b/wicket-util/src/main/java/org/apache/wicket/util/visit/ClassVisitFilter.java\nindex c94e069831..0a7d0b1a5d 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/visit/ClassVisitFilter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/visit/ClassVisitFilter.java\n@@ -45,6 +45,6 @@ public boolean visitChildren(final Object object)\n \t/** {@inheritDoc} */\r\n \tpublic boolean visitObject(final Object object)\r\n \t{\r\n-\t\treturn clazz.isAssignableFrom(object.getClass());\r\n+\t\treturn clazz == null || clazz.isAssignableFrom(object.getClass());\r\n \t}\r\n }\r\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "4519",
        "nb_skipped": 0,
        "commit": "e62ded51",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 4,
        "nb_test": 1206,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.resource.ByteArrayResourceTest",
            "org.apache.wicket.markup.html.PackageResourceTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockServletContext.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockServletContext.java\nindex 42a8996a18..392e921cd2 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockServletContext.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockServletContext.java\n@@ -107,7 +107,7 @@ public MockServletContext(final Application application, final String path)\n \t\tmimeTypes.put(\"htm\", \"text/html\");\n \t\tmimeTypes.put(\"css\", \"text/css\");\n \t\tmimeTypes.put(\"xml\", \"text/xml\");\n-\t\tmimeTypes.put(\"js\", \"text/plain\");\n+\t\tmimeTypes.put(\"js\", \"text/javascript\");\n \t\tmimeTypes.put(\"gif\", \"image/gif\");\n \t\tmimeTypes.put(\"jpg\", \"image/jpeg\");\n \t\tmimeTypes.put(\"png\", \"image/png\");\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/ByteArrayResource.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/ByteArrayResource.java\nindex d156c11563..d11cab8809 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/ByteArrayResource.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/ByteArrayResource.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.wicket.request.resource;\n \n+import java.net.URLConnection;\n+\n import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.util.time.Time;\n \n@@ -95,6 +97,22 @@ protected ResourceResponse newResourceResponse(final Attributes attributes)\n \t{\n \t\tfinal ResourceResponse response = new ResourceResponse();\n \n+\t\tString contentType = this.contentType;\n+\n+\t\tif (contentType == null)\n+\t\t{\n+\t\t\tif (filename != null)\n+\t\t\t{\n+\t\t\t\tcontentType = URLConnection.getFileNameMap().getContentTypeFor(filename);\n+\t\t\t}\n+\n+\t\t\tif (contentType == null)\n+\t\t\t{\n+\t\t\t\tcontentType = \"application/octet-stream\";\n+\t\t\t}\n+\t\t}\n+\n+\n \t\tresponse.setContentType(contentType);\n \t\tresponse.setLastModified(lastModified);\n \ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResource.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResource.java\nindex 449c344663..a4ce0fe962 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResource.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResource.java\n@@ -252,11 +252,15 @@ protected ResourceResponse newResourceResponse(Attributes attributes)\n \t\t\t\treturn sendResourceError(resourceResponse, HttpServletResponse.SC_NOT_FOUND,\n \t\t\t\t\t\"Unable to find resource\");\n \n-\t\t\tString contentType = resourceStream.getContentType();\n-\t\t\tif (contentType == null && Application.exists())\n+\t\t\tfinal String contentType;\n+\t\t\tif (Application.exists())\n \t\t\t{\n \t\t\t\tcontentType = Application.get().getMimeType(path);\n \t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tcontentType = resourceStream.getContentType();\n+\t\t\t}\n \t\t\t// set Content-Type (may be null)\n \t\t\tresourceResponse.setContentType(contentType);\n \ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/ResourceStreamResource.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/ResourceStreamResource.java\nindex e9d25f0563..e83257aecc 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/ResourceStreamResource.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/ResourceStreamResource.java\n@@ -123,11 +123,15 @@ protected ResourceResponse newResourceResponse(Attributes attributes)\n \t\t\t}\n \t\t\tdata.setFileName(fileName);\n \n-\t\t\tString contentType = stream.getContentType();\n-\t\t\tif (contentType == null && fileName != null && Application.exists())\n+\t\t\tfinal String contentType;\n+\t\t\tif (fileName != null && Application.exists())\n \t\t\t{\n \t\t\t\tcontentType = Application.get().getMimeType(fileName);\n \t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tcontentType = stream.getContentType();\n+\t\t\t}\n \t\t\tdata.setContentType(contentType);\n \t\t\tdata.setTextEncoding(textEncoding);\n \n",
        "project": "wicket",
        "linesAdd": 31,
        "jira_id": "4119",
        "nb_skipped": 2,
        "commit": "bb7a6995",
        "nb_failure": 2,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1442,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.http.HeaderBufferingWebResponseTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/HeaderBufferingWebResponse.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/HeaderBufferingWebResponse.java\nindex 0ac0c2a5a5..8771dcaf5b 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/HeaderBufferingWebResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/HeaderBufferingWebResponse.java\n@@ -24,20 +24,24 @@\n import org.apache.wicket.util.time.Time;\n \n /**\n- * Response that keeps headers in buffers but writes the content directly to the response.\n+ * Response that keeps headers in buffers until the first content is written.\n  * \n  * This is necessary to get {@link #reset()} working without removing the JSESSIONID cookie. When\n  * {@link HttpServletResponse#reset()} is called it removes all cookies, including the JSESSIONID\n- * cookie.\n+ * cookie - see <a href=\"https://issues.apache.org/bugzilla/show_bug.cgi?id=26183\">Bug 26183</a>.\n  * \n- * Calling {@link #reset()} on this response only clears the buffered headers. If there is any\n- * content written to response it throws {@link IllegalStateException}.\n+ * Calling {@link #reset()} on this response clears the buffered meta data, if there is already any\n+ * content written it throws {@link IllegalStateException}.\n  * \n  * @author Matej Knopp\n  */\n class HeaderBufferingWebResponse extends WebResponse implements IMetaDataBufferingWebResponse\n {\n \tprivate final WebResponse originalResponse;\n+\n+\t/**\n+\t * Buffer of meta data.\n+\t */\n \tprivate final BufferedWebResponse bufferedResponse;\n \n \tpublic HeaderBufferingWebResponse(WebResponse originalResponse)\n@@ -46,113 +51,107 @@ public HeaderBufferingWebResponse(WebResponse originalResponse)\n \t\tbufferedResponse = new BufferedWebResponse(originalResponse);\n \t}\n \n-\tprivate boolean bufferedWritten = false;\n+\tprivate boolean buffering = true;\n \n-\tprivate void writeBuffered()\n+\tprivate void stopBuffering()\n \t{\n-\t\tif (!bufferedWritten)\n+\t\tif (buffering)\n \t\t{\n \t\t\tbufferedResponse.writeTo(originalResponse);\n-\t\t\tbufferedWritten = true;\n+\t\t\tbuffering = false;\n \t\t}\n \t}\n \n-\tprivate void checkHeader()\n+\t/**\n+\t * The response used for meta data.\n+\t * \n+\t * @return buffered response if nothing was written yet, the original response otherwise\n+\t */\n+\tprivate WebResponse getMetaResponse()\n+\t{\n+\t\tif (buffering)\n \t\t{\n-\t\tif (bufferedWritten)\n+\t\t\treturn bufferedResponse;\n+\t\t}\n+\t\telse\n \t\t{\n-\t\t\tthrow new IllegalStateException(\"Header was already written to response!\");\n+\t\t\treturn originalResponse;\n \t\t}\n \t}\n \n \t@Override\n \tpublic void addCookie(Cookie cookie)\n \t{\n-\t\tcheckHeader();\n-\t\tbufferedResponse.addCookie(cookie);\n+\t\tgetMetaResponse().addCookie(cookie);\n \t}\n \n \t@Override\n \tpublic void clearCookie(Cookie cookie)\n \t{\n-\t\tcheckHeader();\n-\t\tbufferedResponse.clearCookie(cookie);\n+\t\tgetMetaResponse().clearCookie(cookie);\n \t}\n \n-\tprivate boolean flushed = false;\n-\n \t@Override\n \tpublic void flush()\n \t{\n-\t\tif (!bufferedWritten)\n-\t\t{\n-\t\t\tbufferedResponse.writeTo(originalResponse);\n-\t\t\tbufferedResponse.reset();\n-\t\t}\n+\t\tstopBuffering();\n+\n \t\toriginalResponse.flush();\n-\t\tflushed = true;\n \t}\n \n \t@Override\n \tpublic boolean isRedirect()\n \t{\n-\t\treturn bufferedResponse.isRedirect();\n+\t\treturn getMetaResponse().isRedirect();\n \t}\n \n \t@Override\n \tpublic void sendError(int sc, String msg)\n \t{\n-\t\tcheckHeader();\n-\t\tbufferedResponse.sendError(sc, msg);\n+\t\tgetMetaResponse().sendError(sc, msg);\n \t}\n \n \t@Override\n \tpublic void sendRedirect(String url)\n \t{\n-\t\tcheckHeader();\n-\t\tbufferedResponse.sendRedirect(url);\n+\t\tgetMetaResponse().sendRedirect(url);\n \t}\n \n \t@Override\n \tpublic void setContentLength(long length)\n \t{\n-\t\tcheckHeader();\n-\t\tbufferedResponse.setContentLength(length);\n+\t\tgetMetaResponse().setContentLength(length);\n \t}\n \n \t@Override\n \tpublic void setContentType(String mimeType)\n \t{\n-\t\tcheckHeader();\n-\t\tbufferedResponse.setContentType(mimeType);\n+\t\tgetMetaResponse().setContentType(mimeType);\n \t}\n \n \t@Override\n \tpublic void setDateHeader(String name, Time date)\n \t{\n \t\tArgs.notNull(date, \"date\");\n-\t\tcheckHeader();\n-\t\tbufferedResponse.setDateHeader(name, date);\n+\t\tgetMetaResponse().setDateHeader(name, date);\n \t}\n \n \t@Override\n \tpublic void setHeader(String name, String value)\n \t{\n-\t\tcheckHeader();\n-\t\tbufferedResponse.setHeader(name, value);\n+\t\tgetMetaResponse().setHeader(name, value);\n \t}\n \n \t@Override\n \tpublic void addHeader(String name, String value)\n \t{\n-\t\tcheckHeader();\n-\t\tbufferedResponse.addHeader(name, value);\n+\t\tgetMetaResponse().addHeader(name, value);\n \t}\n \n \t@Override\n \tpublic void setStatus(int sc)\n \t{\n-\t\tbufferedResponse.setStatus(sc);\n+\t\tgetMetaResponse().setStatus(sc);\n \t}\n \n \t@Override\n@@ -170,14 +169,16 @@ public String encodeRedirectURL(CharSequence url)\n \t@Override\n \tpublic void write(CharSequence sequence)\n \t{\n-\t\twriteBuffered();\n+\t\tstopBuffering();\n+\n \t\toriginalResponse.write(sequence);\n \t}\n \n \t@Override\n \tpublic void write(byte[] array)\n \t{\n-\t\twriteBuffered();\n+\t\tstopBuffering();\n+\n \t\toriginalResponse.write(array);\n \t}\n \n@@ -185,19 +186,24 @@ public void write(byte[] array)\n \t@Override\n \tpublic void write(byte[] array, int offset, int length)\n \t{\n-\t\twriteBuffered();\n+\t\tstopBuffering();\n+\n \t\toriginalResponse.write(array, offset, length);\n \t}\n \n \t@Override\n \tpublic void reset()\n \t{\n-\t\tif (flushed)\n+\t\tif (buffering)\n \t\t{\n-\t\t\tthrow new IllegalStateException(\"Response has already been flushed!\");\n-\t\t}\n+\t\t\t// still buffering so just reset the buffer of meta data\n \t\t\tbufferedResponse.reset();\n-\t\tbufferedWritten = false;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\t// the original response is never reset (see class javadoc)\n+\t\t\tthrow new IllegalStateException(\"Response is no longer buffering!\");\n+\t\t}\n \t}\n \n \t@Override\n",
        "project": "wicket",
        "linesAdd": 37,
        "jira_id": "4927",
        "nb_skipped": 5,
        "commit": "8c827e33",
        "nb_failure": 1,
        "linesRem": 42,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1719,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.http.AbstractRequestLoggerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/AbstractRequestLogger.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/AbstractRequestLogger.java\nindex d6a3287af0..34964d33e2 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/AbstractRequestLogger.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/AbstractRequestLogger.java\n@@ -160,20 +160,17 @@ public int getPeakSessions()\n \t */\n \tprivate void copyRequestsInOrder(RequestData[] copy)\n \t{\n+\t\tint destPos = 0;\n+\t\t\n \t\tif (hasBufferRolledOver())\n \t\t{\n-\t\t\t// first copy the oldest requests stored behind the cursor into the copy\n-\t\t\tint oldestPos = indexInWindow + 1;\n-\t\t\tif (oldestPos < requestWindow.length)\n-\t\t\t\tarraycopy(requestWindow, oldestPos, copy, 0, requestWindow.length - oldestPos);\n+\t\t\tdestPos = requestWindow.length - indexInWindow;\n \t\t\t\n-\t\t\t// then append the newer requests stored from index 0 til the cursor position.\n-\t\t\tarraycopy(requestWindow, 0, copy, requestWindow.length - oldestPos, indexInWindow);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tarraycopy(requestWindow, 0, copy, 0, indexInWindow);\n+\t\t\t// first copy the oldest requests stored behind the cursor into the copy\n+\t\t\tarraycopy(requestWindow, indexInWindow, copy, 0, destPos);\n \t\t}\n+\t\t\n+\t\tarraycopy(requestWindow, 0, copy, destPos, indexInWindow);\n \t}\n \n \t/**\n",
        "project": "wicket",
        "linesAdd": 6,
        "jira_id": "5784",
        "nb_skipped": 1,
        "commit": "b6259e5f",
        "nb_failure": 0,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1274,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.RestartResponseAtInterceptPageExceptionInAjaxTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java b/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\nindex 69fe186959..6c425c0661 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\n@@ -19,6 +19,7 @@\n import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.HashMap;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n \n@@ -27,11 +28,13 @@\n import org.apache.wicket.request.IWritableRequestParameters;\n import org.apache.wicket.request.Request;\n import org.apache.wicket.request.Url;\n+import org.apache.wicket.request.Url.QueryParameter;\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.request.flow.ResetResponseException;\n import org.apache.wicket.request.handler.PageProvider;\n import org.apache.wicket.request.handler.RenderPageRequestHandler;\n import org.apache.wicket.request.handler.RenderPageRequestHandler.RedirectPolicy;\n+import org.apache.wicket.request.http.WebRequest;\n import org.apache.wicket.request.http.handler.RedirectRequestHandler;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n import org.apache.wicket.util.string.StringValue;\n@@ -110,9 +113,27 @@ public static void set()\n \t\t\tInterceptData data = new InterceptData();\n \t\t\tRequest request = RequestCycle.get().getRequest();\n \t\t\tdata.originalUrl = request.getOriginalUrl();\n+\t\t\tIterator<QueryParameter> itor = data.originalUrl.getQueryParameters().iterator();\n+\t\t\twhile (itor.hasNext())\n+\t\t\t{\n+\t\t\t\tQueryParameter parameter = itor.next();\n+\t\t\t\tString parameterName = parameter.getName();\n+\t\t\t\tif (WebRequest.PARAM_AJAX.equals(parameterName) ||\n+\t\t\t\t\tWebRequest.PARAM_AJAX_BASE_URL.equals(parameterName) ||\n+\t\t\t\t\tWebRequest.PARAM_AJAX_REQUEST_ANTI_CACHE.equals(parameterName))\n+\t\t\t\t{\n+\t\t\t\t\titor.remove();\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tdata.postParameters = new HashMap<String, List<StringValue>>();\n \t\t\tfor (String s : request.getPostParameters().getParameterNames())\n \t\t\t{\n+\t\t\t\tif (WebRequest.PARAM_AJAX.equals(s) || WebRequest.PARAM_AJAX_BASE_URL.equals(s) ||\n+\t\t\t\t\tWebRequest.PARAM_AJAX_REQUEST_ANTI_CACHE.equals(s))\n+\t\t\t\t{\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n \t\t\t\tdata.postParameters.put(s, new ArrayList<StringValue>(request.getPostParameters()\n \t\t\t\t\t.getParameterValues(s)));\n \t\t\t}\n",
        "project": "wicket",
        "linesAdd": 21,
        "jira_id": "4251",
        "nb_skipped": 4,
        "commit": "53bcb78d",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1473,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.mapper.BookmarkableMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\nindex b1418bf730..1fd71d630a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.wicket.core.request.mapper;\n \n+import java.util.List;\n+\n import org.apache.wicket.Application;\n import org.apache.wicket.core.request.handler.PageProvider;\n import org.apache.wicket.core.request.handler.RenderPageRequestHandler;\n@@ -93,14 +95,26 @@ protected Url buildUrl(UrlInfo info)\n \t@Override\n \tprotected UrlInfo parseRequest(Request request)\n \t{\n-\t\tUrl url = request.getUrl();\n-\t\tif (matches(url))\n+\t\tif (matches(request))\n \t\t{\n+\t\t\tUrl url = request.getUrl();\n+\n \t\t\t// try to extract page and component information from URL\n \t\t\tPageComponentInfo info = getPageComponentInfo(url);\n \n+\t\t\tList<String> segments = url.getSegments();\n+\n \t\t\t// load the page class\n-\t\t\tString className = url.getSegments().get(2);\n+\t\t\tString className;\n+\t\t\tif (segments.size() >= 3)\n+\t\t\t{\n+\t\t\t\tclassName = segments.get(2);\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tclassName = segments.get(1);\n+\t\t\t}\n+\n \t\t\tClass<? extends IRequestablePage> pageClass = getPageClass(className);\n \n \t\t\tif (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass))\n@@ -111,13 +125,13 @@ protected UrlInfo parseRequest(Request request)\n \n \t\t\t\t\tif (application.getSecuritySettings().getEnforceMounts())\n \t\t\t\t\t{\n-\t\t\t\t\t\t// we make an excepion if the homepage itself was mounted, see WICKET-1898\n+\t\t\t\t\t\t// we make an exception if the homepage itself was mounted, see WICKET-1898\n \t\t\t\t\t\tif (!pageClass.equals(application.getHomePage()))\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\t// WICKET-5094 only enforce mount if page is mounted\n \t\t\t\t\t\t\tUrl reverseUrl = application.getRootRequestMapper().mapHandler(\n \t\t\t\t\t\t\t\tnew RenderPageRequestHandler(new PageProvider(pageClass)));\n-\t\t\t\t\t\t\tif (!matches(reverseUrl))\n+\t\t\t\t\t\t\tif (!matches(request.cloneWithUrl(reverseUrl)))\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n@@ -151,17 +165,37 @@ protected boolean pageMustHaveBeenCreatedBookmarkable()\n \tpublic int getCompatibilityScore(Request request)\n \t{\n \t\tint score = 0;\n-\t\tUrl url = request.getUrl();\n-\t\tif (matches(url))\n+\t\tif (matches(request))\n \t\t{\n \t\t\tscore = Integer.MAX_VALUE;\n \t\t}\n \t\treturn score;\n \t}\n \n-\tprivate boolean matches(final Url url)\n+\tprivate boolean matches(final Request request)\n+\t{\n+\t\tboolean matches = false;\n+\t\tUrl url = request.getUrl();\n+\t\tUrl baseUrl = request.getClientUrl();\n+\t\tString namespace = getContext().getNamespace();\n+\t\tString bookmarkableIdentifier = getContext().getBookmarkableIdentifier();\n+\t\tString pageIdentifier = getContext().getPageIdentifier();\n+\n+\t\tif (url.getSegments().size() >= 3 && urlStartsWith(url, namespace, bookmarkableIdentifier))\n+\t\t{\n+\t\t\tmatches = true;\n+\t\t}\n+\t\t// baseUrl = 'wicket/bookmarkable/com.example.SomePage[?...]', requestUrl = 'bookmarkable/com.example.SomePage'\n+\t\telse if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace, bookmarkableIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier))\n+\t\t{\n+\t\t\tmatches = true;\n+\t\t}\n+\t\t// baseUrl = 'wicket/page[?...]', requestUrl = 'bookmarkable/com.example.SomePage'\n+\t\telse if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier))\n \t\t{\n-\t\treturn (url.getSegments().size() >= 3 && urlStartsWith(url, getContext().getNamespace(),\n-\t\t\tgetContext().getBookmarkableIdentifier()));\n+\t\t\tmatches = true;\n+\t\t}\n+\n+\t\treturn matches;\n \t}\n }\n",
        "project": "wicket",
        "linesAdd": 41,
        "jira_id": "5071",
        "nb_skipped": 4,
        "commit": "6e794ad0",
        "nb_failure": 2,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1119,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.cycle.RequestCycleListenerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java b/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\nindex d4a45d2ea1..f1208b6ac6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycle.java\n@@ -668,6 +668,9 @@ public void scheduleRequestHandlerAfterCurrent(IRequestHandler handler)\n \t{\n \t\t// just delegating the call to {@link IRequestHandlerExecutor} and invoking listeners\n \t\trequestHandlerExecutor.schedule(handler);\n+\n+\t\t// only forward calls to the listeners when handler is null\n+\t\tif (handler != null)\n \t\t\tlisteners.onRequestHandlerScheduled(handler);\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "3646",
        "nb_skipped": 0,
        "commit": "12124902",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 1859,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.queueing.transparentresolvers.DequeueingTransparentWebMarkupContainerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\nindex 49d55c341f..882a3bae34 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\n@@ -16,12 +16,17 @@\n  */\n package org.apache.wicket.markup.html.internal;\n \n+import java.util.Iterator;\n+\n import org.apache.wicket.Component;\n+import org.apache.wicket.DequeueContext;\n import org.apache.wicket.MarkupContainer;\n import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.markup.ComponentTag;\n+import org.apache.wicket.markup.IMarkupFragment;\n import org.apache.wicket.markup.MarkupException;\n import org.apache.wicket.markup.MarkupStream;\n+import org.apache.wicket.markup.html.TransparentWebMarkupContainer;\n import org.apache.wicket.markup.html.WebMarkupContainer;\n import org.apache.wicket.markup.html.basic.EnclosureContainer;\n import org.apache.wicket.markup.parser.filter.EnclosureHandler;\n@@ -125,7 +130,7 @@ protected final Component getChild()\n \t\tif (childComponent == null)\n \t\t{\n \t\t\t// try to find child when queued\n-\t\t\tchildComponent = get(childId);\n+\t\t\tchildComponent = resolveChild(this);\n \t\t}\n \t\tif (childComponent == null)\n \t\t{\n@@ -135,6 +140,33 @@ protected final Component getChild()\n \t\treturn childComponent;\n \t}\n \t\n+\t/**\n+\t * Searches for the controlling child component looking also \n+\t * through transparent components.\n+\t * \n+\t * @param container\n+\t * \t\t\tthe current container\n+\t * @return the controlling child component, null if no one is found \n+\t */\n+\tprivate Component resolveChild(MarkupContainer container)\n+\t{\n+\t\tComponent childController = container.get(childId);\n+\t\t\n+\t\tIterator<Component> children = container.iterator();\n+\t\t\n+\t\twhile (children.hasNext() && childController == null)\n+\t\t{\n+\t\t\tComponent transparentChild = children.next();\n+\t\t\t\n+\t\t\tif(transparentChild instanceof TransparentWebMarkupContainer)\n+\t\t\t{\n+\t\t\t\tchildController = resolveChild((MarkupContainer)transparentChild);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn childController;\n+\t}\n+\n \t@Override\n \tpublic boolean isVisible()\n \t{\n@@ -274,4 +306,16 @@ else if (controller == this)\n \t\t\t\t\"Programming error: childComponent == enclose component; endless loop\");\n \t\t}\n \t}\n+\t\n+\t@Override\n+\tpublic DequeueContext newDequeueContext()\n+\t{\n+\t\tIMarkupFragment markup = getMarkupSourcingStrategy().getMarkup(this, null);\n+\t\tif (markup == null)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new DequeueContext(markup, this, true);\n+\t}\n }\n",
        "project": "wicket",
        "linesAdd": 37,
        "jira_id": "5964",
        "nb_skipped": 1,
        "commit": "86066852",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1301,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.mapper.UrlInfoTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractBookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractBookmarkableMapper.java\nindex d66f32ed1c..ad48cf1350 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractBookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractBookmarkableMapper.java\n@@ -98,6 +98,11 @@ private PageParameters cleanPageParameters(final PageParameters originalParamete\n \t\t\t\tcleanParameters.remove(WebRequest.PARAM_AJAX);\n \t\t\t\tcleanParameters.remove(WebRequest.PARAM_AJAX_BASE_URL);\n \t\t\t\tcleanParameters.remove(WebRequest.PARAM_AJAX_REQUEST_ANTI_CACHE);\n+\n+\t\t\t\tif (cleanParameters.isEmpty())\n+\t\t\t\t{\n+\t\t\t\t\tcleanParameters = null;\n+\t\t\t\t}\n \t\t\t}\n \t\t\treturn cleanParameters;\n \t\t}\n",
        "project": "wicket",
        "linesAdd": 5,
        "jira_id": "4384",
        "nb_skipped": 4,
        "commit": "614e3b50",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 17,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.extensions.wizard.WizardModelTest"
        ],
        "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/wizard/Wizard.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/wizard/Wizard.java\nindex b6ebad429b..3bad8db6ae 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/wizard/Wizard.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/wizard/Wizard.java\n@@ -16,8 +16,6 @@\n  */\n package org.apache.wicket.extensions.wizard;\n \n-import java.util.Iterator;\n-\n import org.apache.wicket.Component;\n import org.apache.wicket.feedback.ContainerFeedbackMessageFilter;\n import org.apache.wicket.markup.html.IHeaderResponse;\n@@ -276,15 +274,6 @@ protected void init(final IWizardModel wizardModel)\n \n \t\twizardModel.addListener(this);\n \n-\t\tIterator<IWizardStep> stepsIterator = wizardModel.stepIterator();\n-\t\tif (stepsIterator != null)\n-\t\t{\n-\t\t\twhile (stepsIterator.hasNext())\n-\t\t\t{\n-\t\t\t\t(stepsIterator.next()).init(wizardModel);\n-\t\t\t}\n-\t\t}\n-\n \t\t// reset model to prepare for action\n \t\twizardModel.reset();\n \t}\ndiff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/wizard/WizardModel.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/wizard/WizardModel.java\nindex c66d352831..69c973f50a 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/wizard/WizardModel.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/wizard/WizardModel.java\n@@ -217,6 +217,12 @@ public void reset()\n \t{\n \t\thistory.clear();\n \t\tactiveStep = null;\n+\t\t\n+\t\tfor (IWizardStep step : steps)\n+\t\t{\n+\t\t\tstep.init(this);\n+\t\t}\n+\n \t\tsetActiveStep(findNextVisibleStep());\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 6,
        "jira_id": "4121",
        "nb_skipped": 0,
        "commit": "8967eb2b",
        "nb_failure": 1,
        "linesRem": 11,
        "singleLine": false
    },
    {
        "files": 0,
        "nb_test": 1244,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.http.servlet.ServletWebRequestTest"
        ],
        "patch": "",
        "project": "wicket",
        "linesAdd": 0,
        "jira_id": "4138",
        "nb_skipped": 3,
        "commit": "7c89598a",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 188,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.resource.ResourceUtilsTest"
        ],
        "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/resource/ResourceUtils.java b/wicket-util/src/main/java/org/apache/wicket/util/resource/ResourceUtils.java\nindex edcd96c264..ac1d02553f 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/resource/ResourceUtils.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/resource/ResourceUtils.java\n@@ -34,7 +34,8 @@\n \t/** The default postfix for minified names (ex: /css/mystyle.min.css) **/\r\n \tpublic static final String MIN_POSTFIX_DEFAULT = \"min\";\r\n \t/** Regular expression patter to extract the locale from the filename (ex: de_DE) **/\r\n-\tprivate static final Pattern LOCALE_PATTERN = Pattern.compile(\"_([a-z]{2})(_([A-Z]{2})(_([^_]+))?)?$\");\r\n+\tprivate static final Pattern LOCALE_MIN_PATTERN = Pattern\r\n+\t\t.compile(\"_([a-z]{2})(_([A-Z]{2})(_([^_\\\\.]+))?)?(\\\\.min)?$\");\r\n \t/** Stores standard ISO country codes from {@code java.util.Locale} **/\r\n \tprivate final static Set<String> isoCountries = new HashSet<>(\r\n \t\tArrays.asList(Locale.getISOCountries()));\r\n@@ -77,7 +78,12 @@ public static String getMinifiedName(String name, String minPostfix)\n \t}\r\n \t\r\n \t/**\r\n-\t * Extract the locale from the filename\r\n+\t * Extract the locale from the filename taking into account possible minimized resource name.\r\n+\t * \r\n+\t * E.g. {@code file_us_EN.min.js} will correctly determine a locale of {@code us_EN} by\r\n+\t * stripping the {@code .min} from the filename, the filename returned will be\r\n+\t * {@code file.min.js}, if you want the {@code .min} to be removed as well, use\r\n+\t * {@link #getLocaleFromMinifiedFilename(String)} instead.\r\n \t * \r\n \t * @param path\r\n \t *            The file path\r\n@@ -86,7 +92,8 @@ public static String getMinifiedName(String name, String minPostfix)\n \tpublic static PathLocale getLocaleFromFilename(String path)\r\n \t{\r\n \t\tString extension = \"\";\r\n-\t\tint pos = path.lastIndexOf('.');\r\n+\r\n+\t\tfinal int pos = path.lastIndexOf('.');\r\n \t\tif (pos != -1)\r\n \t\t{\r\n \t\t\textension = path.substring(pos);\r\n@@ -94,12 +101,13 @@ public static PathLocale getLocaleFromFilename(String path)\n \t\t}\r\n \r\n \t\tString filename = Strings.lastPathComponent(path, '/');\r\n-\t\tMatcher matcher = LOCALE_PATTERN.matcher(filename);\r\n+\t\tMatcher matcher = LOCALE_MIN_PATTERN.matcher(filename);\r\n \t\tif (matcher.find())\r\n \t\t{\r\n \t\t\tString language = matcher.group(1);\r\n \t\t\tString country = matcher.group(3);\r\n \t\t\tString variant = matcher.group(5);\r\n+\t\t\tString min = matcher.group(6);\r\n \r\n \t\t\t// did we find a language?\r\n \t\t\tif (language != null)\r\n@@ -124,8 +132,9 @@ public static PathLocale getLocaleFromFilename(String path)\n \r\n \t\t\tif (language != null)\r\n \t\t\t{\r\n-\t\t\t\tpos = path.length() - filename.length() + matcher.start();\r\n-\t\t\t\tString basePath = path.substring(0, pos) + extension;\r\n+\t\t\t\tint languagePos = path.length() - filename.length() + matcher.start();\r\n+\t\t\t\tString basePath = path.substring(0, languagePos) + (min == null ? \"\" : min) +\r\n+\t\t\t\t\textension;\r\n \r\n \t\t\t\tLocale locale = new Locale(language, country != null ? country : \"\",\r\n \t\t\t\t\tvariant != null ? variant : \"\");\r\n",
        "project": "wicket",
        "linesAdd": 9,
        "jira_id": "5966",
        "nb_skipped": 2,
        "commit": "d547fcd4",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1279,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.resource.aggregator.ResourceAggregatorRenderTest",
            "org.apache.wicket.markup.html.header.response.HeaderResponseTest",
            "org.apache.wicket.markup.html.header.HeaderScopingTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/renderStrategy/ChildFirstHeaderRenderStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/renderStrategy/ChildFirstHeaderRenderStrategy.java\nindex cf4d8da568..89381829ef 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/renderStrategy/ChildFirstHeaderRenderStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/renderStrategy/ChildFirstHeaderRenderStrategy.java\n@@ -79,9 +79,12 @@ protected void renderChildHeaders(final HtmlHeaderContainer headerContainer,\n \t\t\t{\n \t\t\t\t@Override\n \t\t\t\tpublic void component(final Component component, final IVisit<Void> visit)\n+\t\t\t\t{\n+\t\t\t\t\tif (component != rootComponent)\n \t\t\t\t\t{\n \t\t\t\t\t\tcomponent.renderHead(headerContainer);\n \t\t\t\t\t}\n+\t\t\t\t}\n \n \t\t\t\t@Override\n \t\t\t\tpublic boolean preCheck(Component component)\n",
        "project": "wicket",
        "linesAdd": 3,
        "jira_id": "4000",
        "nb_skipped": 4,
        "commit": "38e928c1",
        "nb_failure": 4,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1343,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.form.LocalizedErrorMessageTest",
            "org.apache.wicket.validation.ValidatorBehaviorTest",
            "org.apache.wicket.util.tester.FormTesterTest",
            "org.apache.wicket.markup.html.form.ValidatorPropertiesTest",
            "org.apache.wicket.markup.html.form.validation.innerfeedback.InnerFeedbackTest",
            "org.apache.wicket.resource.loader.ValidatorStringResourceLoaderTest",
            "org.apache.wicket.util.tester.WicketTesterTest",
            "org.apache.wicket.util.tester.apps_4.FormTesterTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/ValidationErrorFeedback.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/ValidationErrorFeedback.java\nindex f6e1ce7ce6..48b8d0b698 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/ValidationErrorFeedback.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/ValidationErrorFeedback.java\n@@ -78,8 +78,6 @@ public Serializable getMessage()\n \t@Override\n \tpublic String toString()\n \t{\n-\t\treturn \"ValidationErrorFeedback{\" +\n-\t\t\t\t\"message=\" + message +\n-\t\t\t\t'}';\n+\t\treturn message != null ? message.toString() : \"\";\n \t}\n }\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "4548",
        "nb_skipped": 8,
        "commit": "9a6a06be",
        "nb_failure": 10,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1324,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.http.servlet.ServletWebResponseTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\nindex 27b52b1e23..2296e34588 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\n@@ -227,6 +227,14 @@ public void sendRedirect(String url)\n \t\t\t}\n \t\t\telse\n \t\t\t{\n+\t\t\t\tif (url.startsWith(\"./\"))\n+\t\t\t\t{\n+\t\t\t\t\t/*\n+\t\t\t\t\t * WICKET-4260 Tomcat does not canonalize urls, which leads to problems with IE\n+\t\t\t\t\t * when url is relative and starts with a dot\n+\t\t\t\t\t */\n+\t\t\t\t\turl = url.substring(2);\n+\t\t\t\t}\n \t\t\t\thttpServletResponse.sendRedirect(url);\n \t\t\t}\n \t\t}\n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "4260",
        "nb_skipped": 8,
        "commit": "925cae5c",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 4,
        "nb_test": 66,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.mapper.parameter.PageParametersEncoderTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParametersEncoder.java b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParametersEncoder.java\nindex 2312995d25..5687a71478 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParametersEncoder.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParametersEncoder.java\n@@ -16,9 +16,13 @@\n  */\n package org.apache.wicket.request.mapper.parameter;\n \n+import java.util.List;\n+\n+import org.apache.wicket.request.IRequestParameters;\n import org.apache.wicket.request.Request;\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.Url.QueryParameter;\n+import org.apache.wicket.util.string.StringValue;\n \n /**\n  * Simple encoder with direct indexed/named parameters mapping.\n@@ -48,9 +52,14 @@ public PageParameters decodePageParameters(final Request request)\n \t\t\t++i;\n \t\t}\n \t\t\n-\t\tfor (QueryParameter p : request.getUrl().getQueryParameters())\n+\t\tIRequestParameters requestParameters = request.getRequestParameters();\n+\t\tfor (String paramName : requestParameters.getParameterNames())\n+\t\t{\n+\t\t\tList<StringValue> parameterValues = requestParameters.getParameterValues(paramName);\n+\t\t\tfor (StringValue paramValue : parameterValues)\n \t\t\t{\n-\t\t\tparameters.add(p.getName(), p.getValue());\n+\t\t\t\tparameters.add(paramName, paramValue);\n+\t\t\t}\n \t\t}\n \n \t\treturn parameters.isEmpty() ? null : parameters;\ndiff --git a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/UrlPathPageParametersEncoder.java b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/UrlPathPageParametersEncoder.java\nindex db3ea51fc6..f31f5c1f7a 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/UrlPathPageParametersEncoder.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/UrlPathPageParametersEncoder.java\n@@ -25,9 +25,12 @@\n \r\n \r\n /**\r\n+ * <p>\r\n  * Encodes page parameters into Url path fragments instead of the query string like the default\r\n  * {@link PageParametersEncoder}. The parameters are encoded in the following format:\r\n  * {@code /param1Name/param1Value/param2Name/param2Value}.\r\n+ * </p>\r\n+ * <strong>Note</strong>: Because of the nature of the encoder it doesn't support POST request parameters.\r\n  * <p>\r\n  * This used to be the default way of encoding page parameters in 1.4.x applications. Newer 1.5.x+\r\n  * applications use the query string, by default. This class facilitates backwards compatibility and\r\ndiff --git a/wicket-request/src/main/java/org/apache/wicket/request/parameter/CombinedRequestParametersAdapter.java b/wicket-request/src/main/java/org/apache/wicket/request/parameter/CombinedRequestParametersAdapter.java\nindex e895f3b5c3..b5792cc043 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/parameter/CombinedRequestParametersAdapter.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/parameter/CombinedRequestParametersAdapter.java\n@@ -19,10 +19,12 @@\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashSet;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n \n import org.apache.wicket.request.IRequestParameters;\n+import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.string.StringValue;\n \n /**\n@@ -41,11 +43,7 @@\n \t */\n \tpublic CombinedRequestParametersAdapter(final IRequestParameters... parameters)\n \t{\n-\t\tif (parameters == null)\n-\t\t{\n-\t\t\tthrow new IllegalStateException(\"Argument 'parameters' may not be null\");\n-\t\t}\n-\t\tthis.parameters = parameters;\n+\t\tthis.parameters = Args.notNull(parameters, \"parameters\");\n \t}\n \n \t/**\n@@ -53,7 +51,7 @@ public CombinedRequestParametersAdapter(final IRequestParameters... parameters)\n \t */\n \tpublic Set<String> getParameterNames()\n \t{\n-\t\tSet<String> result = new HashSet<String>();\n+\t\tSet<String> result = new LinkedHashSet<String>();\n \t\tfor (IRequestParameters p : parameters)\n \t\t{\n \t\t\tresult.addAll(p.getParameterNames());\ndiff --git a/wicket-request/src/main/java/org/apache/wicket/request/parameter/UrlRequestParametersAdapter.java b/wicket-request/src/main/java/org/apache/wicket/request/parameter/UrlRequestParametersAdapter.java\nindex d65d1d630f..bbdd1da794 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/parameter/UrlRequestParametersAdapter.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/parameter/UrlRequestParametersAdapter.java\n@@ -18,7 +18,7 @@\n \n import java.util.ArrayList;\n import java.util.Collections;\n-import java.util.HashSet;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n \n@@ -55,7 +55,7 @@ public UrlRequestParametersAdapter(final Url url)\n \t */\n \tpublic Set<String> getParameterNames()\n \t{\n-\t\tSet<String> result = new HashSet<String>();\n+\t\tSet<String> result = new LinkedHashSet<String>();\n \t\tfor (QueryParameter parameter : url.getQueryParameters())\n \t\t{\n \t\t\tresult.add(parameter.getName());\n",
        "project": "wicket",
        "linesAdd": 17,
        "jira_id": "4338",
        "nb_skipped": 0,
        "commit": "9decad35",
        "nb_failure": 1,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1187,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.handler.render.WebPageRendererTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\nindex 37b718b724..c3a01669c3 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n@@ -163,7 +163,8 @@ public void respond(RequestCycle requestCycle)\n \t\t\t// if there is saved response for this URL render it\n \t\t\tbufferedResponse.writeTo((WebResponse)requestCycle.getResponse());\n \t\t}\n-\t\telse if (getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT || isOnePassRender() //\n+\t\telse if (getRedirectPolicy() == RedirectPolicy.NEVER_REDIRECT ||\n+\t\t\t(isOnePassRender() && isAjax == false) //\n \t\t\t||\n \t\t\t(!isAjax //\n \t\t\t\t&&\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "3617",
        "nb_skipped": 1,
        "commit": "7ae109a6",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1283,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.link.MountedPageLinkTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/MountedMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/MountedMapper.java\nindex 3137b6c8d7..f5271c5136 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/MountedMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/MountedMapper.java\n@@ -385,7 +385,7 @@ public Url mapHandler(IRequestHandler requestHandler)\n \t\t\t\t\thandler.getBehaviorIndex());\n \t\t\t\tPageComponentInfo pageComponentInfo = new PageComponentInfo(pageInfo, componentInfo);\n \t\t\t\tUrlInfo urlInfo = new UrlInfo(pageComponentInfo, page.getClass(),\n-\t\t\t\t\thandler.getPageParameters());\n+\t\t\t\t\tpage.getPageParameters());\n \t\t\t\turl = buildUrl(urlInfo);\n \t\t\t}\n \t\t}\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "4290",
        "nb_skipped": 4,
        "commit": "e1953357",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 0,
        "nb_test": 2,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.devutils.stateless.StatelessCheckerTest"
        ],
        "patch": "",
        "project": "wicket",
        "linesAdd": 0,
        "jira_id": "2334",
        "nb_skipped": 0,
        "commit": "96330447",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1247,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.model.DetachableTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex 17f43d72da..b72702e19d 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -644,7 +644,7 @@ public MarkupContainer removeAll()\n \t\t\t\t\t// Do not call remove() because the state change would than be\n \t\t\t\t\t// recorded twice.\n \t\t\t\t\tchild.internalOnRemove();\n-\t\t\t\t\tchild.detachModel();\n+\t\t\t\t\tchild.detach();\n \t\t\t\t\tchild.setParent(null);\n \t\t\t\t}\n \t\t\t}\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "3872",
        "nb_skipped": 2,
        "commit": "3feb0e3a",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 1184,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.DefaultExceptionMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java b/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\nindex 2f712179fe..8d66d8af11 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\n@@ -121,7 +121,7 @@ else if (IExceptionSettings.SHOW_INTERNAL_ERROR_PAGE.equals(unexpectedExceptionD\n \t\t\telse\n \t\t\t{\n \t\t\t\t// IExceptionSettings.SHOW_NO_EXCEPTION_PAGE\n-\t\t\t\treturn new EmptyRequestHandler();\n+\t\t\t\treturn new ErrorCodeRequestHandler(500);\n \t\t\t}\n \t\t}\n \t}\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "3520",
        "nb_skipped": 1,
        "commit": "d1b62639",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 1196,
        "nb_error": 0,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.form.FormTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\nindex 17fe546fe7..e97e0b193f 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n@@ -797,6 +797,7 @@ public void process(IFormSubmitter submittingComponent)\n \t\t\tif (hasError())\n \t\t\t{\n \t\t\t\tcallOnError(submittingComponent);\n+\t\t\t\treturn;\n \t\t\t}\n \n \t\t\t// Form has no error\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "4070",
        "nb_skipped": 2,
        "commit": "d450acb0",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 2,
        "nb_test": 792,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ajax.form.AjaxFormSubmitTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java b/wicket/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\nindex ca427191d9..7f6afe7683 100644\n--- a/wicket/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\n+++ b/wicket/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\n@@ -108,10 +108,21 @@ protected void onComponentTag(final ComponentTag tag)\n \t\tComponent myComponent = getComponent();\n \t\tif (myComponent.isEnabledInHierarchy())\n \t\t{\n-\t\t\ttag.put(event, getEventHandler());\n+\t\t\ttag.put(event, escapeAttribute(getEventHandler()));\n \t\t}\n \t}\n \t\n+\tprivate CharSequence escapeAttribute(final CharSequence attr)\n+\t{\n+\t\tif(null == attr)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\t\tCharSequence escaped = Strings.escapeMarkup(attr.toString());\n+\t\t// No need to escape the apostrophe; it just clutters the markup\n+\t\treturn Strings.replaceAll(escaped, \"&#039;\", \"'\");\n+\t}\n+\n \t/**\n \t * \n \t * @return event handler\ndiff --git a/wicket/src/main/java/org/apache/wicket/ajax/form/AjaxFormSubmitBehavior.java b/wicket/src/main/java/org/apache/wicket/ajax/form/AjaxFormSubmitBehavior.java\nindex 5ae018a3d6..5a226c0d18 100644\n--- a/wicket/src/main/java/org/apache/wicket/ajax/form/AjaxFormSubmitBehavior.java\n+++ b/wicket/src/main/java/org/apache/wicket/ajax/form/AjaxFormSubmitBehavior.java\n@@ -176,6 +176,6 @@ protected void onEvent(AjaxRequestTarget target)\n \t@Override\n \tprotected CharSequence getPreconditionScript()\n \t{\n-\t\treturn \"return Wicket.$$(this)&amp;&amp;Wicket.$$('\" + getForm().getMarkupId() + \"')\";\n+\t\treturn \"return Wicket.$$(this)&&Wicket.$$('\" + getForm().getMarkupId() + \"')\";\n \t}\n }\n",
        "project": "wicket",
        "linesAdd": 12,
        "jira_id": "2033",
        "nb_skipped": 0,
        "commit": "420ac965",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1196,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.tester.WicketTesterSessionInvalidateTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/mock/MockSessionStore.java b/wicket-core/src/main/java/org/apache/wicket/mock/MockSessionStore.java\nindex 0eb0abe9be..61c1581445 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/mock/MockSessionStore.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/mock/MockSessionStore.java\n@@ -86,12 +86,13 @@ private void cleanup()\n \n \tpublic void invalidate(Request request)\n \t{\n+\t\tString sessId = sessionId;\n+\t\tcleanup();\n \t\tfor (UnboundListener l : unboundListeners)\n \t\t{\n-\t\t\tl.sessionUnbound(sessionId);\n+\t\t\tl.sessionUnbound(sessId);\n \t\t}\n \n-\t\tcleanup();\n \t}\n \n \tpublic Session lookup(Request request)\n",
        "project": "wicket",
        "linesAdd": 3,
        "jira_id": "3769",
        "nb_skipped": 1,
        "commit": "b4e9d426",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1333,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.parser.filter.HtmlHeaderSectionHandlerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\nindex 5d7cd84652..1b2ac8e4b3 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\n@@ -21,6 +21,8 @@\n import org.apache.wicket.markup.ComponentTag;\n import org.apache.wicket.markup.Markup;\n import org.apache.wicket.markup.MarkupElement;\n+import org.apache.wicket.markup.MarkupException;\n+import org.apache.wicket.markup.MarkupStream;\n import org.apache.wicket.markup.parser.AbstractMarkupFilter;\n import org.apache.wicket.markup.parser.XmlTag.TagType;\n \n@@ -46,6 +48,9 @@\n \t/** True if <head> has been found already */\n \tprivate boolean foundHead = false;\n \n+\t/** True if </head> has been found already */\n+\tprivate boolean foundClosingHead = false;\n+\n \t/** True if all the rest of the markup file can be ignored */\n \tprivate boolean ignoreTheRest = false;\n \n@@ -78,16 +83,21 @@ protected final MarkupElement onComponentTag(ComponentTag tag) throws ParseExcep\n \t\t\tif (tag.getNamespace() == null)\n \t\t\t{\n \t\t\t\t// we found <head>\n-\t\t\t\tif (tag.isClose())\n+\t\t\t\tif (tag.isOpen())\n \t\t\t\t{\n \t\t\t\t\tfoundHead = true;\n-\t\t\t\t}\n-\t\t\t\telse if (tag.getId() == null)\n+\n+\t\t\t\t\tif (tag.getId() == null)\n \t\t\t\t\t{\n \t\t\t\t\t\ttag.setId(HEADER_ID);\n \t\t\t\t\t\ttag.setAutoComponentTag(true);\n \t\t\t\t\t\ttag.setModified(true);\n \t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\telse if (tag.isClose())\n+\t\t\t\t{\n+\t\t\t\t\tfoundClosingHead = true;\n+\t\t\t\t}\n \n \t\t\t\treturn tag;\n \t\t\t}\n@@ -95,10 +105,18 @@ else if (tag.getId() == null)\n \t\t\t{\n \t\t\t\t// we found <wicket:head>\n \t\t\t\tfoundHead = true;\n+\t\t\t\tfoundClosingHead = true;\n \t\t\t}\n \t\t}\n \t\telse if (BODY.equalsIgnoreCase(tag.getName()) && (tag.getNamespace() == null))\n \t\t{\n+\t\t\t// WICKET-4511: We found <body> inside <head> tag. Markup is not valid!\n+\t\t\tif (foundHead && !foundClosingHead)\n+\t\t\t{\n+\t\t\t\tthrow new MarkupException(new MarkupStream(markup),\n+\t\t\t\t\t\"Invalid page markup. Tag <BODY> found inside <HEAD>\");\n+\t\t\t}\n+\n \t\t\t// We found <body>\n \t\t\tif (foundHead == false)\n \t\t\t{\n",
        "project": "wicket",
        "linesAdd": 19,
        "jira_id": "4511",
        "nb_skipped": 8,
        "commit": "4ee5ad1f",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 789,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.http.request.CryptedUrlWebRequestCodingStrategyTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/protocol/http/MockHttpServletRequest.java b/wicket/src/main/java/org/apache/wicket/protocol/http/MockHttpServletRequest.java\nindex 7b240c6692..b9981567c0 100644\n--- a/wicket/src/main/java/org/apache/wicket/protocol/http/MockHttpServletRequest.java\n+++ b/wicket/src/main/java/org/apache/wicket/protocol/http/MockHttpServletRequest.java\n@@ -1255,6 +1255,16 @@ else if (component instanceof IOnChangeListener)\n \t\t\t\t\t.get(clazz);\n \n \t\t\t\tString auto = component.getRequestCycle().urlFor(component, rli).toString();\n+\n+\t\t\t\t// check for crypted strategy\n+\t\t\t\tif (auto.startsWith(\"?x=\"))\n+\t\t\t\t{\n+\t\t\t\t\tauto = auto.substring(3);\n+\t\t\t\t\tparameters.put(\"x\", auto);\n+\t\t\t\t\tparameters.remove(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n \t\t\t\t\tint idx = auto.indexOf(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME);\n \t\t\t\t\tif (idx >= 0)\n \t\t\t\t\t{\n@@ -1263,22 +1273,14 @@ else if (component instanceof IOnChangeListener)\n \t\t\t\t\t}\n \t\t\t\t\telse\n \t\t\t\t\t{\n-\t\t\t\t\t// additional check for crypted strategy\n-\t\t\t\t\tidx = auto.indexOf(\"x=6*\");\n-\t\t\t\t\tif (idx >= 0)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tauto = auto.substring(idx + 4);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n \t\t\t\t\t\tidx = auto.indexOf(\"&\");\n \t\t\t\t\t\tif (idx >= 0)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tauto = auto.substring(0, idx);\n \t\t\t\t\t\t}\n-\n+\t\t\t\t\t}\n \t\t\t\t\tparameters.put(WebRequestCodingStrategy.INTERFACE_PARAMETER_NAME, auto);\n-\n+\t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception e)\n \t\t\t{\n",
        "project": "wicket",
        "linesAdd": 11,
        "jira_id": "2281",
        "nb_skipped": 0,
        "commit": "6e0b40bc",
        "nb_failure": 0,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1367,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.page.persistent.disk.PageWindowManagerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/pageStore/PageWindowManager.java b/wicket-core/src/main/java/org/apache/wicket/pageStore/PageWindowManager.java\nindex 0f2faa6fd1..03887bb0dd 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/pageStore/PageWindowManager.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/pageStore/PageWindowManager.java\n@@ -64,6 +64,11 @@\n \t */\n \tprivate IntHashMap<Integer> idToWindowIndex = null;\n \n+\t/**\n+\t * Inversed index of #idToWindowIndex\n+\t */\n+\tprivate IntHashMap<Integer> windowIndexToPageId = null;\n+\n \t/** index of last added page */\n \tprivate int indexPointer = -1;\n \n@@ -84,7 +89,13 @@ private void putWindowIndex(int pageId, int windowIndex)\n \t{\n \t\tif (idToWindowIndex != null && pageId != -1 && windowIndex != -1)\n \t\t{\n+\t\t\tInteger oldPageId = windowIndexToPageId.remove(windowIndex);\n+\t\t\tif (oldPageId != null)\n+\t\t\t{\n+\t\t\t\tidToWindowIndex.remove(oldPageId);\n+\t\t\t}\n \t\t\tidToWindowIndex.put(pageId, windowIndex);\n+\t\t\twindowIndexToPageId.put(windowIndex, pageId);\n \t\t}\n \t}\n \n@@ -94,7 +105,11 @@ private void putWindowIndex(int pageId, int windowIndex)\n \t */\n \tprivate void removeWindowIndex(int pageId)\n \t{\n-\t\tidToWindowIndex.remove(pageId);\n+\t\tInteger windowIndex = idToWindowIndex.remove(pageId);\n+\t\tif (windowIndex != null)\n+\t\t{\n+\t\t\twindowIndexToPageId.remove(windowIndex);\n+\t\t}\n \t}\n \n \t/**\n@@ -104,6 +119,8 @@ private void rebuildIndices()\n \t{\n \t\tidToWindowIndex = null;\n \t\tidToWindowIndex = new IntHashMap<Integer>();\n+\t\twindowIndexToPageId = null;\n+\t\twindowIndexToPageId = new IntHashMap<Integer>();\n \t\tfor (int i = 0; i < windows.size(); ++i)\n \t\t{\n \t\t\tPageWindowInternal window = windows.get(i);\n@@ -195,6 +212,7 @@ else if (window.filePartSize != size)\n \t\t}\n \n \t\tidToWindowIndex = null;\n+\t\twindowIndexToPageId = null;\n \t}\n \n \t/**\n@@ -213,6 +231,7 @@ private void mergeWindowWithNext(int index)\n \n \t\t\twindows.remove(index + 1);\n \t\t\tidToWindowIndex = null; // reset index\n+\t\t\twindowIndexToPageId = null;\n \t\t}\n \t}\n \n@@ -364,7 +383,7 @@ public PageWindow createPageWindow(int pageId, int size)\n \t\t}\n \n \t\t// if we are not going to reuse a page window (because it's not on\n-\t\t// indexPointor position or because we didn't find it), increment the\n+\t\t// indexPointer position or because we didn't find it), increment the\n \t\t// indexPointer\n \t\tif (index == -1 || index != indexPointer)\n \t\t{\n",
        "project": "wicket",
        "linesAdd": 17,
        "jira_id": "4572",
        "nb_skipped": 8,
        "commit": "dfc56674",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 5,
        "nb_test": 763,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.form.CheckGroupTest",
            "org.apache.wicket.markup.html.form.RadioGroupTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/ajax/form/AjaxFormChoiceComponentUpdatingBehavior.java b/wicket/src/main/java/org/apache/wicket/ajax/form/AjaxFormChoiceComponentUpdatingBehavior.java\nindex ce38a7c66d..f8f2e50810 100644\n--- a/wicket/src/main/java/org/apache/wicket/ajax/form/AjaxFormChoiceComponentUpdatingBehavior.java\n+++ b/wicket/src/main/java/org/apache/wicket/ajax/form/AjaxFormChoiceComponentUpdatingBehavior.java\n@@ -33,6 +33,9 @@\n  * <p>\n  * Use the normal {@link AjaxFormChoiceComponentUpdatingBehavior} for the normal single component\n  * fields\n+ * <p>\n+ * In order to be supported by this behavior the group components must output children with markup\n+ * id in format of 'groupId-childId'\n  * \n  * @author jcompagner\n  * \n@@ -67,6 +70,7 @@ public void renderHead(IHeaderResponse response)\n \t\tasb.append(\" for (var i = 0 ; i < inputNodes.length ; i ++) {\\n\");\n \t\tasb.append(\" var inputNode = inputNodes[i];\\n\");\n \t\tasb.append(\" if (!inputNode.type) continue;\\n\");\n+\t\tasb.append(\" if (!(inputNode.id.indexOf(markupId+'-')===0)) continue;\\n\");\n \t\tasb.append(\" var inputType = inputNode.type.toLowerCase();\\n\");\n \t\tasb.append(\" if (inputType == 'checkbox' || inputType == 'radio') {\\n\");\n \t\tasb.append(\" Wicket.Event.add(inputNode, 'click', callbackScript);\\n\");\ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/Check.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/Check.java\nindex 7ebf5c333a..c74b293dc3 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/Check.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/Check.java\n@@ -94,6 +94,7 @@ public Check(String id, IModel<T> model, CheckGroup<T> group)\n \t{\n \t\tsuper(id, model);\n \t\tthis.group = group;\n+\t\tsetOutputMarkupId(true);\n \t}\n \n \n@@ -112,6 +113,32 @@ public final String getValue()\n \t\treturn \"check\" + uuid;\n \t}\n \n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate CheckGroup<T> getGroup()\n+\t{\n+\t\tCheckGroup<T> group = this.group;\n+\t\tif (group == null)\n+\t\t{\n+\t\t\tgroup = findParent(CheckGroup.class);\n+\t\t\tif (group == null)\n+\t\t\t{\n+\t\t\t\tthrow new WicketRuntimeException(\"Check component [\" + getPath() +\n+\t\t\t\t\t\"] cannot find its parent CheckGroup\");\n+\t\t\t}\n+\t\t}\n+\t\treturn group;\n+\t}\n+\n+\t/** {@inheritDoc} */\n+\t@Override\n+\tprotected void onBeforeRender()\n+\t{\n+\t\t// prefix markup id of this radio with its group's id\n+\t\t// this will make it easier to identify all radios that belong to a specific group\n+\t\tsetMarkupId(getGroup().getMarkupId() + \"-\" + getMarkupId());\n+\t\tsuper.onBeforeRender();\n+\t}\n+\n \n \t/**\n \t * @see Component#onComponentTag(ComponentTag)\n@@ -128,16 +155,7 @@ protected void onComponentTag(final ComponentTag tag)\n \t\tcheckComponentTag(tag, \"input\");\n \t\tcheckComponentTagAttribute(tag, \"type\", \"checkbox\");\n \n-\t\tCheckGroup<?> group = this.group;\n-\t\tif (group == null)\n-\t\t{\n-\t\t\tgroup = findParent(CheckGroup.class);\n-\t\t\tif (group == null)\n-\t\t\t{\n-\t\t\t\tthrow new WicketRuntimeException(\"Check component [\" + getPath() +\n-\t\t\t\t\t\"] cannot find its parent CheckGroup\");\n-\t\t\t}\n-\t\t}\n+\t\tCheckGroup<?> group = getGroup();\n \n \t\tfinal String uuid = getValue();\n \ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/CheckBoxMultipleChoice.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/CheckBoxMultipleChoice.java\nindex e52fe46d95..65dab2f7e4 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/CheckBoxMultipleChoice.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/CheckBoxMultipleChoice.java\n@@ -411,7 +411,7 @@ else if (displayValue != null)\n \t\t\t\tbuffer.append(getPrefix());\n \n \t\t\t\tString id = getChoiceRenderer().getIdValue(choice, index);\n-\t\t\t\tfinal String idAttr = getInputName() + \"_\" + id;\n+\t\t\t\tfinal String idAttr = getMarkupId() + \"-\" + getInputName() + \"_\" + id;\n \n \t\t\t\t// Add checkbox element\n \t\t\t\tbuffer.append(\"<input name=\\\"\")\ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/Radio.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/Radio.java\nindex 130c2d970a..0788018cb0 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/Radio.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/Radio.java\n@@ -91,6 +91,7 @@ public Radio(String id, IModel<T> model, RadioGroup<T> group)\n \t{\n \t\tsuper(id, model);\n \t\tthis.group = group;\n+\t\tsetOutputMarkupId(true);\n \t}\n \n \n@@ -109,6 +110,34 @@ public final String getValue()\n \t\treturn \"radio\" + uuid;\n \t}\n \n+\t/** {@inheritDoc} */\n+\t@Override\n+\tprotected void onBeforeRender()\n+\t{\n+\t\t// prefix markup id of this radio with its group's id\n+\t\t// this will make it easier to identify all radios that belong to a specific group\n+\t\tsetMarkupId(getGroup().getMarkupId() + \"-\" + getMarkupId());\n+\t\tsuper.onBeforeRender();\n+\t}\n+\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate RadioGroup<T> getGroup()\n+\t{\n+\t\tRadioGroup<T> group = this.group;\n+\t\tif (group == null)\n+\t\t{\n+\t\t\tgroup = findParent(RadioGroup.class);\n+\t\t\tif (group == null)\n+\t\t\t{\n+\t\t\t\tthrow new WicketRuntimeException(\n+\t\t\t\t\t\"Radio component [\" +\n+\t\t\t\t\t\tgetPath() +\n+\t\t\t\t\t\t\"] cannot find its parent RadioGroup. All Radio components must be a child of or below in the hierarchy of a RadioGroup component.\");\n+\t\t\t}\n+\t\t}\n+\t\treturn group;\n+\t}\n \n \t/**\n \t * @see Component#onComponentTag(ComponentTag)\n@@ -127,19 +156,7 @@ protected void onComponentTag(final ComponentTag tag)\n \n \t\tfinal String value = getValue();\n \n-\t\tRadioGroup<?> group = this.group;\n-\t\tif (group == null)\n-\t\t{\n-\t\t\tgroup = findParent(RadioGroup.class);\n-\t\t\tif (group == null)\n-\t\t\t{\n-\t\t\t\tthrow new WicketRuntimeException(\n-\t\t\t\t\t\"Radio component [\" +\n-\t\t\t\t\t\tgetPath() +\n-\t\t\t\t\t\t\"] cannot find its parent RadioGroup. All Radio components must be a child of or below in the hierarchy of a RadioGroup component.\");\n-\t\t\t}\n-\t\t}\n-\n+\t\tRadioGroup<?> group = getGroup();\n \n \t\t// assign name and value\n \t\ttag.put(\"name\", group.getInputName());\ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/RadioChoice.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/RadioChoice.java\nindex 2b762e2cf3..cf1d86756e 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/RadioChoice.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/RadioChoice.java\n@@ -450,7 +450,7 @@ else if (displayValue != null)\n \t\t\t\tbuffer.append(getPrefix());\n \n \t\t\t\tString id = getChoiceRenderer().getIdValue(choice, index);\n-\t\t\t\tfinal String idAttr = getMarkupId() + \"_\" + id;\n+\t\t\t\tfinal String idAttr = getMarkupId() + \"-\" + id;\n \n \t\t\t\tboolean enabled = isEnabledInHierarchy() && !isDisabled(choice, index, selected);\n \n",
        "project": "wicket",
        "linesAdd": 55,
        "jira_id": "1677",
        "nb_skipped": 0,
        "commit": "01a3dd66",
        "nb_failure": 5,
        "linesRem": 25,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1552,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.handler.ListenerInterfaceRequestHandlerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/ListenerInterfaceRequestHandler.java b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/ListenerInterfaceRequestHandler.java\nindex 84592d70bb..1e24206c3d 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/ListenerInterfaceRequestHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/ListenerInterfaceRequestHandler.java\n@@ -172,9 +172,12 @@ public void respond(final IRequestCycle requestCycle)\n \t\t\tcomponent = null;\n \t\t}\n \n-\t\tif ((component == null && freshPage) ||\n-\t\t\t(component != null && getComponent().getPage() == page))\n+\t\tif ((component == null && !freshPage) || (component != null && component.getPage() != page))\n \t\t{\n+\t\t\tthrow new WicketRuntimeException(\"Component '\" + getComponentPath()\n+\t\t\t\t+ \"' has been removed from page.\");\n+\t\t}\n+\n \t\tif (page instanceof Page)\n \t\t{\n \t\t\t// initialize the page to be able to check whether it is stateless\n@@ -182,7 +185,8 @@ public void respond(final IRequestCycle requestCycle)\n \t\t}\n \t\tfinal boolean isStateless = page.isPageStateless();\n \n-\t\t\tRedirectPolicy policy = isStateless ? RedirectPolicy.NEVER_REDIRECT\n+\t\tRedirectPolicy policy = isStateless\n+\t\t\t? RedirectPolicy.NEVER_REDIRECT\n \t\t\t: RedirectPolicy.AUTO_REDIRECT;\n \t\tfinal IPageProvider pageProvider = new PageProvider(page);\n \n@@ -224,13 +228,6 @@ public void respond(final IRequestCycle requestCycle)\n \t\t}\n \n \t\tinvokeListener();\n-\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tthrow new WicketRuntimeException(\"Component \" + getComponent() +\n-\t\t\t\t\" has been removed from page.\");\n-\t\t}\n \t}\n \n \tprivate void invokeListener()\n",
        "project": "wicket",
        "linesAdd": 7,
        "jira_id": "5466",
        "nb_skipped": 2,
        "commit": "c1c1f794",
        "nb_failure": 1,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 25,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.spring.injection.annot.JavaxInjectAnnotProxyFieldValueFactoryTest"
        ],
        "patch": "diff --git a/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java b/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\nindex 6b7d071164..54d11de842 100644\n--- a/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\n+++ b/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\n@@ -68,6 +68,7 @@\n  * @see LazyInitProxyFactory\n  * @see SpringBean\n  * @see SpringBeanLocator\n+ * @see javax.inject.Inject\n  * \n  * @author Igor Vaynberg (ivaynberg)\n  * @author Istvan Devai\n@@ -123,7 +124,7 @@ public Object getFieldValue(final Field field, final Object fieldOwner)\n \t\t\t{\n \t\t\t\tNamed named = field.getAnnotation(Named.class);\n \t\t\t\tname = named != null ? named.value() : \"\";\n-\t\t\t\trequired = false;\n+\t\t\t\trequired = true;\n \t\t\t}\n \n \t\t\tString beanName = getBeanName(field, name, required);\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "5686",
        "nb_skipped": 0,
        "commit": "8e794fc4",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 1452,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.resource.MinifiedAwareResourceReferenceTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\nindex ea2ddb6817..cc7273173d 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\n@@ -173,7 +173,7 @@ private String getCurrentStyle()\n \tprivate String internalGetMinifiedName()\n \t{\n \t\tString minifiedName = MINIFIED_NAMES_CACHE.get(this);\n-\t\tif (minifiedName != null && minifiedName != NO_MINIFIED_NAME)\n+\t\tif (minifiedName != null)\n \t\t{\n \t\t\treturn minifiedName;\n \t\t}\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "5019",
        "nb_skipped": 5,
        "commit": "917dd2b5",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1461,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.internal.InlineEnclosureTest",
            "org.apache.wicket.markup.html.internal.TogglePageTest",
            "org.apache.wicket.markup.html.internal.AjaxEnclosureTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/InlineEnclosure.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/InlineEnclosure.java\nindex 6ce1edc351..3e4d230dfe 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/InlineEnclosure.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/InlineEnclosure.java\n@@ -19,7 +19,6 @@\n import org.apache.wicket.Page;\r\n import org.apache.wicket.markup.ComponentTag;\r\n import org.apache.wicket.markup.IMarkupFragment;\r\n-import org.apache.wicket.markup.Markup;\r\n import org.apache.wicket.markup.MarkupParser;\r\n import org.apache.wicket.markup.MarkupResourceStream;\r\n import org.apache.wicket.markup.parser.filter.InlineEnclosureHandler;\r\n@@ -47,8 +46,6 @@\n \r\n \tprivate static final Logger log = LoggerFactory.getLogger(InlineEnclosure.class);\r\n \r\n-\tprivate String enclosureMarkupAsString;\r\n-\r\n \t/**\r\n \t * Construct.\r\n \t * \r\n@@ -59,8 +56,6 @@ public InlineEnclosure(final String id, final String childId)\n \t{\r\n \t\tsuper(id, childId);\r\n \r\n-\t\tenclosureMarkupAsString = null;\r\n-\r\n \t\t// ensure that the Enclosure is ready for ajax updates\r\n \t\tsetOutputMarkupPlaceholderTag(true);\r\n \t\tsetMarkupId(getId());\r\n@@ -87,34 +82,6 @@ public boolean updateVisibility()\n \t\treturn visible;\r\n \t}\r\n \r\n-\t/**\r\n-\t * {@link InlineEnclosure}s keep their own cache of their markup because Component#markup is\r\n-\t * detached and later during Ajax request it is hard to re-lookup {@link InlineEnclosure}'s\r\n-\t * markup from its parent.\r\n-\t * \r\n-\t * @see org.apache.wicket.Component#getMarkup()\r\n-\t */\r\n-\t@Override\r\n-\tpublic IMarkupFragment getMarkup()\r\n-\t{\r\n-\t\tIMarkupFragment enclosureMarkup = null;\r\n-\t\tif (enclosureMarkupAsString == null)\r\n-\t\t{\r\n-\t\t\tIMarkupFragment markup = super.getMarkup();\r\n-\t\t\tif (markup != null && markup != Markup.NO_MARKUP)\r\n-\t\t\t{\r\n-\t\t\t\tenclosureMarkup = markup;\r\n-\t\t\t\tenclosureMarkupAsString = markup.toString(true);\r\n-\t\t\t}\r\n-\t\t}\r\n-\t\telse\r\n-\t\t{\r\n-\t\t\tenclosureMarkup = Markup.of(enclosureMarkupAsString, getWicketNamespace());\r\n-\t\t}\r\n-\r\n-\t\treturn enclosureMarkup;\r\n-\t}\r\n-\r\n \t/**\r\n \t * @return the markup namespace for Wicket elements and attributes.\r\n \t */\r\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\nindex 7e9ea8e519..507339b5e6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\n@@ -64,6 +64,12 @@\n \t/** enclosures inside enclosures */\r\n \tprivate Stack<ComponentTag> enclosures;\r\n \r\n+\t/**\r\n+\t * InlinceEnclosures are not removed after render as other auto-components,\r\n+\t * thus they have to have a stable id.\r\n+\t */\r\n+\tprivate int counter;\r\n+\r\n \t/**\r\n \t * Construct.\r\n \t */\r\n@@ -107,7 +113,8 @@ protected MarkupElement onComponentTag(final ComponentTag tag) throws ParseExcep\n \t\t\t\t{\r\n \t\t\t\t\tif (Strings.isEmpty(htmlId))\r\n \t\t\t\t\t{\r\n-\t\t\t\t\t\tString id = getWicketNamespace() + \"_\" + INLINE_ENCLOSURE_ID_PREFIX;\r\n+\t\t\t\t\t\tString id = getWicketNamespace() + \"_\" + INLINE_ENCLOSURE_ID_PREFIX +\r\n+\t\t\t\t\t\t\t(counter++);\r\n \t\t\t\t\t\ttag.setId(id);\r\n \t\t\t\t\t}\r\n \t\t\t\t\telse\r\n@@ -198,10 +205,7 @@ public Component resolve(final MarkupContainer container, final MarkupStream mar\n \t\tif (Strings.isEmpty(inlineEnclosureChildId) == false)\r\n \t\t{\r\n \t\t\tString id = tag.getId();\r\n-\t\t\tif (id.startsWith(getWicketNamespace(markupStream)))\r\n-\t\t\t{\r\n-\t\t\t\tid = id + container.getPage().getAutoIndex();\r\n-\t\t\t}\r\n+\r\n \t\t\t// Yes, we handled the tag\r\n \t\t\treturn new InlineEnclosure(id, inlineEnclosureChildId);\r\n \t\t}\r\n",
        "project": "wicket",
        "linesAdd": 5,
        "jira_id": "5085",
        "nb_skipped": 3,
        "commit": "581c7306",
        "nb_failure": 9,
        "linesRem": 31,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 8,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.bean.validation.PropertyValidatorRequiredTest"
        ],
        "patch": "diff --git a/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/PropertyValidator.java b/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/PropertyValidator.java\nindex e8e6376d4d..a2486c7590 100644\n--- a/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/PropertyValidator.java\n+++ b/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/PropertyValidator.java\n@@ -10,6 +10,7 @@\n import javax.validation.ConstraintViolation;\n import javax.validation.Validator;\n import javax.validation.constraints.NotNull;\n+import javax.validation.groups.Default;\n import javax.validation.metadata.ConstraintDescriptor;\n \n import org.apache.wicket.Component;\n@@ -100,11 +101,10 @@ private Property getProperty()\n \t\t\tif (property_ == null)\n \t\t\t{\n \t\t\t\tthrow new IllegalStateException(\n-\t\t\t\t\t\"Could not resolve Property from component: \" +\n-\t\t\t\t\t\tcomponent +\n-\t\t\t\t\t\t\". Either specify the Property in the constructor or use a model that works in combination with a \" +\n-\t\t\t\t\t\tIPropertyResolver.class.getSimpleName() +\n-\t\t\t\t\t\t\" to resolve the Property automatically\");\n+\t\t\t\t\t\"Could not resolve Property from component: \" + component\n+\t\t\t\t\t\t+ \". Either specify the Property in the constructor or use a model that works in combination with a \"\n+\t\t\t\t\t\t+ IPropertyResolver.class.getSimpleName()\n+\t\t\t\t\t\t+ \" to resolve the Property automatically\");\n \t\t\t}\n \t\t}\n \t\treturn property_;\n@@ -126,14 +126,15 @@ public void bind(Component component)\n \t\tif (this.component != null)\n \t\t{\n \t\t\tthrow new IllegalStateException( //\n-\t\t\t\t\"This validator has already been added to component: \" + this.component +\n-\t\t\t\t\t\". This validator does not support reusing instances, please create a new one\");\n+\t\t\t\t\"This validator has already been added to component: \"\n+\t\t\t\t\t+ this.component\n+\t\t\t\t\t+ \". This validator does not support reusing instances, please create a new one\");\n \t\t}\n \n \t\tif (!(component instanceof FormComponent))\n \t\t{\n-\t\t\tthrow new IllegalStateException(getClass().getSimpleName() +\n-\t\t\t\t\" can only be added to FormComponents\");\n+\t\t\tthrow new IllegalStateException(getClass().getSimpleName()\n+\t\t\t\t+ \" can only be added to FormComponents\");\n \t\t}\n \n \t\t// TODO add a validation key that appends the type so we can have\n@@ -208,7 +209,7 @@ boolean isRequired()\n \n \t\tfor (NotNull constraint : constraints)\n \t\t{\n-\t\t\tif (constraint.groups().length == 0 && validatorGroups.isEmpty())\n+\t\t\tif (canApplyToDefaultGroup(constraint) && validatorGroups.isEmpty())\n \t\t\t{\n \t\t\t\treturn true;\n \t\t\t}\n@@ -225,6 +226,14 @@ boolean isRequired()\n \t\treturn false;\n \t}\n \n+\tprivate boolean canApplyToDefaultGroup(NotNull constraint)\n+\t{\n+\t\tList<Class<?>> groups = Arrays.asList(constraint.groups());\n+\t\t//the constraint can be applied to default group either if its group array is empty\n+\t\t//or if it contains javax.validation.groups.Default\n+\t\treturn groups.size() == 0 || groups.contains(Default.class);\n+\t}\n+\n \t@Override\n \t@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n \tpublic void onComponentTag(Component component, ComponentTag tag)\n",
        "project": "wicket",
        "linesAdd": 17,
        "jira_id": "5656",
        "nb_skipped": 0,
        "commit": "f539c18c",
        "nb_failure": 1,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1328,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.ComponentTagAttributeEscapingTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/TagAttributes.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/TagAttributes.java\nindex 6f9719d185..041b0cdb95 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/TagAttributes.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/TagAttributes.java\n@@ -54,7 +54,7 @@ public TagAttributes(final IValueMap map)\n \tpublic final Object put(String key, Object value)\r\n \t{\r\n \r\n-\t\treturn super.put(key, unescapeHtml(value));\r\n+\t\treturn super.put(key, value);\r\n \t}\r\n \r\n \t@Override\r\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/XmlPullParser.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/XmlPullParser.java\nindex 0ec91c9776..93c57d00f1 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/XmlPullParser.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/XmlPullParser.java\n@@ -31,6 +31,7 @@\n import org.apache.wicket.util.parse.metapattern.parsers.TagNameParser;\n import org.apache.wicket.util.parse.metapattern.parsers.VariableAssignmentParser;\n import org.apache.wicket.util.resource.ResourceStreamNotFoundException;\n+import org.apache.wicket.util.string.Strings;\n \n /**\n  * A fairly shallow markup pull parser which parses a markup string of a given type of markup (for\n@@ -665,6 +666,9 @@ private boolean parseTagText(final XmlTag tag, final String tagText) throws Pars\n \t\t\t\t// Trim trailing whitespace\n \t\t\t\tvalue = value.trim();\n \n+\t\t\t\t// Unescape\n+\t\t\t\tvalue = Strings.unescapeMarkup(value).toString();\n+\n \t\t\t\t// Get key\n \t\t\t\tfinal String key = attributeParser.getKey();\n \n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "4505",
        "nb_skipped": 8,
        "commit": "a4caaa57",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1495,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.mapper.BookmarkableMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\nindex 1fd71d630a..a9fd2123c7 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n@@ -190,6 +190,11 @@ else if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace,\n \t\t{\n \t\t\tmatches = true;\n \t\t}\n+\t\t// baseUrl = 'bookmarkable/com.example.SomePage', requestUrl = 'bookmarkable/com.example.SomePage'\n+\t\telse if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, bookmarkableIdentifier) && url.getSegments().size() == 2 && urlStartsWith(url, bookmarkableIdentifier))\n+\t\t{\n+\t\t\tmatches = true;\n+\t\t}\n \t\t// baseUrl = 'wicket/page[?...]', requestUrl = 'bookmarkable/com.example.SomePage'\n \t\telse if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier))\n \t\t{\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\nindex 3789a9f355..a03464270a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\n@@ -175,17 +175,19 @@ private boolean matches(final Request request)\n \t{\n \t\tboolean matches = false;\n \t\tUrl url = request.getUrl();\n+\t\tUrl baseUrl = request.getClientUrl();\n \t\tString namespace = getContext().getNamespace();\n \t\tString pageIdentifier = getContext().getPageIdentifier();\n+\n \t\tif (urlStartsWith(url, namespace, pageIdentifier))\n \t\t{\n \t\t\tmatches = true;\n \t\t}\n-\t\telse if (urlStartsWith(request.getClientUrl(), namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier))\n+\t\telse if (urlStartsWith(baseUrl, namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier))\n \t\t{\n \t\t\tmatches = true;\n \t\t}\n-\t\telse if (urlStartsWith(request.getClientUrl(), pageIdentifier) && urlStartsWith(url, pageIdentifier))\n+\t\telse if (urlStartsWith(baseUrl, pageIdentifier) && urlStartsWith(url, pageIdentifier))\n \t\t{\n \t\t\tmatches = true;\n \t\t}\n",
        "project": "wicket",
        "linesAdd": 8,
        "jira_id": "5071",
        "nb_skipped": 4,
        "commit": "faaae8d3",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 937,
        "nb_error": 38,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.stateless.TemporarySessionTest",
            "org.apache.wicket.markup.html.form.login.InterceptTest",
            "org.apache.wicket.markup.html.form.DropDownChoiceTest",
            "org.apache.wicket.markup.html.internal.EnclosureTest",
            "org.apache.wicket.util.tester.FormTesterTest",
            "org.apache.wicket.markup.html.link.submitLink.FormPage2Test",
            "org.apache.wicket.markup.html.link.submitLink.FormPageTest",
            "org.apache.wicket.util.tester.apps_3.FormTesterTest",
            "org.apache.wicket.markup.html.form.FormComponentPanelProcessingTest",
            "org.apache.wicket.FormDispatchEventTest",
            "org.apache.wicket.markup.html.form.FormSubmitTest",
            "org.apache.wicket.util.tester.apps_4.FormTesterTest",
            "org.apache.wicket.util.tester.WicketTesterTest",
            "org.apache.wicket.stateless.StatelessFormTest",
            "org.apache.wicket.markup.html.form.upload.FileUploadFieldTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/Form.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/Form.java\nindex a5d3b39c21..806e3a5327 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/Form.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/Form.java\n@@ -376,7 +376,10 @@ public String getQueryString()\n \tprivate Bytes maxSize = null;\n \n \t/** True if the form has enctype of multipart/form-data */\n-\tprivate boolean multiPart = false;\n+\tprivate short multiPart = 0;\n+\n+\tprivate static short MULTIPART_HARD = 0x01;\n+\tprivate static short MULTIPART_HINT = 0x02;\n \n \t/**\n \t * Constructs a form with no validation.\n@@ -1051,7 +1054,14 @@ public void setMaxSize(final Bytes maxSize)\n \t */\n \tpublic void setMultiPart(boolean multiPart)\n \t{\n-\t\tthis.multiPart = multiPart;\n+\t\tif (multiPart)\n+\t\t{\n+\t\t\tthis.multiPart |= MULTIPART_HARD;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tthis.multiPart &= ~MULTIPART_HARD;\n+\t\t}\n \t}\n \n \t/**\n@@ -1399,7 +1409,7 @@ protected boolean getStatelessHint()\n \n \tprivate boolean isMultiPart()\n \t{\n-\t\tif (multiPart)\n+\t\tif (multiPart != 0)\n \t\t{\n \t\t\treturn true;\n \t\t}\n@@ -1411,7 +1421,7 @@ private boolean isMultiPart()\n \n \t\t\t\tpublic Object component(Form<?> form)\n \t\t\t\t{\n-\t\t\t\t\tif (form.multiPart)\n+\t\t\t\t\tif (form.multiPart != 0)\n \t\t\t\t\t{\n \t\t\t\t\t\tanyEmbeddedMultipart[0] = true;\n \t\t\t\t\t\treturn STOP_TRAVERSAL;\n@@ -1788,6 +1798,9 @@ protected void onError()\n \t@Override\n \tprotected void onRender()\n \t{\n+\t\t// clear multipart hint, it will be set if necessary by the visitor\n+\t\tthis.multiPart &= ~MULTIPART_HINT;\n+\n \t\t// Force multi-part on if any child form component is multi-part\n \t\tvisitFormComponents(new FormComponent.AbstractVisitor()\n \t\t{\n@@ -1796,7 +1809,7 @@ public void onFormComponent(FormComponent<?> formComponent)\n \t\t\t{\n \t\t\t\tif (formComponent.isVisible() && formComponent.isMultiPart())\n \t\t\t\t{\n-\t\t\t\t\tsetMultiPart(true);\n+\t\t\t\t\tmultiPart |= MULTIPART_HINT;\n \t\t\t\t}\n \t\t\t}\n \t\t});\ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/upload/MultiFileUploadField.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/upload/MultiFileUploadField.java\nindex ef2b286be9..9b49e7a1db 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/upload/MultiFileUploadField.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/upload/MultiFileUploadField.java\n@@ -193,9 +193,13 @@ protected void onBeforeRender()\n \t\t\tthrow new IllegalStateException(\"Component \" + getClass().getName() + \" must have a \" +\n \t\t\t\tForm.class.getName() + \" component above in the hierarchy\");\n \t\t}\n-\t\tform.setMultiPart(true);\n \t}\n \n+\t@Override\n+\tpublic boolean isMultiPart()\n+\t{\n+\t\treturn true;\n+\t}\n \n \t/**\n \t * @see org.apache.wicket.markup.html.IHeaderContributor#renderHead(org.apache.wicket.markup.html.IHeaderResponse)\ndiff --git a/wicket/src/main/java/org/apache/wicket/protocol/http/servlet/MultipartServletWebRequest.java b/wicket/src/main/java/org/apache/wicket/protocol/http/servlet/MultipartServletWebRequest.java\nindex 6c95e9511d..b4ce08b86d 100644\n--- a/wicket/src/main/java/org/apache/wicket/protocol/http/servlet/MultipartServletWebRequest.java\n+++ b/wicket/src/main/java/org/apache/wicket/protocol/http/servlet/MultipartServletWebRequest.java\n@@ -110,7 +110,8 @@ public MultipartServletWebRequest(HttpServletRequest request, Bytes maxSize,\n \t\tfinal boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n \t\tif (!isMultipart)\n \t\t{\n-\t\t\tthrow new IllegalStateException(\"ServletRequest does not contain multipart content\");\n+\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\"ServletRequest does not contain multipart content. One possible solution is to explicitly call Form.setMultipart(true), Wicket tries its best to auto-detect multipart forms but there are certain situation where it cannot.\");\n \t\t}\n \n \n",
        "project": "wicket",
        "linesAdd": 24,
        "jira_id": "2621",
        "nb_skipped": 0,
        "commit": "c849f986",
        "nb_failure": 0,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1471,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.model.StringResourceModelTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/model/StringResourceModel.java b/wicket-core/src/main/java/org/apache/wicket/model/StringResourceModel.java\nindex 95b37f8121..35ef7bbe7d 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/model/StringResourceModel.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/model/StringResourceModel.java\n@@ -590,13 +590,10 @@ protected final String load()\n \t\treturn getString();\n \t}\n \n-\t/**\n-\t * @see org.apache.wicket.model.IDetachable#detach()\n-\t */\n \t@Override\n-\tprotected final void onDetach()\n+\tpublic final void detach()\n \t{\n-\t\tsuper.onDetach();\n+\t\tsuper.detach();\n \n \t\t// detach any model\n \t\tif (model != null)\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "5176",
        "nb_skipped": 4,
        "commit": "34634266",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 12,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.extensions.markup.html.repeater.data.table.DataTableTest"
        ],
        "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/DataTable.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/DataTable.java\nindex f3146d1f50..d7af5f7281 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/DataTable.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/DataTable.java\n@@ -33,6 +33,8 @@\n import org.apache.wicket.markup.repeater.data.IDataProvider;\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.util.string.Strings;\n+import org.apache.wicket.util.visit.IVisit;\n+import org.apache.wicket.util.visit.IVisitor;\n \n \n /**\n@@ -109,9 +111,9 @@ public void onComponentTag(final Component component, final ComponentTag tag)\n \n \tprivate final List<IColumn<T>> columns;\n \n-\tprivate final RepeatingView topToolbars;\n+\tprivate final ToolbarsContainer topToolbars;\n \n-\tprivate final RepeatingView bottomToolbars;\n+\tprivate final ToolbarsContainer bottomToolbars;\n \n \t/**\n \t * Constructor\n@@ -320,14 +322,14 @@ public int getItemCount()\n \t\treturn datagrid.getItemCount();\n \t}\n \n-\tprivate void addToolbar(final AbstractToolbar toolbar, final RepeatingView container)\n+\tprivate void addToolbar(final AbstractToolbar toolbar, final ToolbarsContainer container)\n \t{\n \t\tif (toolbar == null)\n \t\t{\n \t\t\tthrow new IllegalArgumentException(\"argument [toolbar] cannot be null\");\n \t\t}\n \n-\t\tcontainer.add(toolbar);\n+\t\tcontainer.getRepeatingView().add(toolbar);\n \t}\n \n \t/**\n@@ -392,14 +394,18 @@ protected void onPageChanged()\n \t}\n \n \t/**\n-\t * This class acts as a repeater that will contain the toolbar.\n+\t * This class acts as a repeater that will contain the toolbar. It makes sure that the table row\n+\t * group (e.g. thead) tags are only visible when they contain rows in accordance with the HTML\n+\t * specification.\n \t * \n \t * @author igor.vaynberg\n \t */\n-\tprivate static class ToolbarsContainer extends RepeatingView\n+\tprivate static class ToolbarsContainer extends WebMarkupContainer\n \t{\n \t\tprivate static final long serialVersionUID = 1L;\n \n+\t\tprivate final RepeatingView toolbars;\n+\n \t\t/**\n \t\t * Constructor\n \t\t * \n@@ -408,6 +414,41 @@ protected void onPageChanged()\n \t\tprivate ToolbarsContainer(final String id)\n \t\t{\n \t\t\tsuper(id);\n+\t\t\ttoolbars = new RepeatingView(\"toolbars\");\n+\t\t\tadd(toolbars);\n+\t\t}\n+\n+\t\tpublic RepeatingView getRepeatingView()\n+\t\t{\n+\t\t\treturn toolbars;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isVisible()\n+\t\t{\n+\t\t\tif (!super.isVisible())\n+\t\t\t{\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\ttoolbars.configure();\n+\n+\t\t\tBoolean visible = toolbars.visitChildren(new IVisitor<Component, Boolean>()\n+\t\t\t{\n+\t\t\t\tpublic void component(Component object, IVisit<Boolean> visit)\n+\t\t\t\t{\n+\t\t\t\t\tobject.configure();\n+\t\t\t\t\tif (object.isVisible())\n+\t\t\t\t\t{\n+\t\t\t\t\t\tvisit.stop(Boolean.TRUE);\n+\t\t\t\t\t}\n+\t\t\t\t\telse\n+\t\t\t\t\t{\n+\t\t\t\t\t\tvisit.dontGoDeeper();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\treturn visible == Boolean.TRUE;\n \t\t}\n \t}\n }\n",
        "project": "wicket",
        "linesAdd": 44,
        "jira_id": "3603",
        "nb_skipped": 0,
        "commit": "aa1d177a",
        "nb_failure": 0,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 927,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.validation.validator.CreditCardValidatorTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java b/wicket/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\nindex 96ba9c012a..b84d4611da 100644\n--- a/wicket/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\n+++ b/wicket/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\n@@ -19,27 +19,586 @@\n import org.apache.wicket.validation.IValidatable;\n \n /**\n- * Performs the so-called \"mod 10\" algorithm to check the validity of credit card numbers such as\n- * VISA.\n+ * Checks if a credit card number is valid. The number will be checked for \"American Express\",\n+ * \"China UnionPay\", \"Diners Club Carte Blanche\", \"Diners Club International\",\n+ * \"Diners Club US & Canada\", \"Discover Card\", \"JCB\", \"Laser\", \"Maestro\", \"MasterCard\", \"Solo\",\n+ * \"Switch\", \"Visa\" and \"Visa Electron\". If none of those apply to the credit card number, the\n+ * credit card number is considered invalid.\n+ * \n  * <p>\n- * In addition to this, the credit card number can be further validated by its length and prefix,\n- * but those properties depend upon the credit card type, and such validation is not performed by\n- * this validator.\n+ * Card prefixes and lengths have been taken from <a\n+ * href=\"http://en.wikipedia.org/w/index.php?title=Bank_card_number&oldid=322132931\">Wikipedia</a>.\n  * \n  * @author Johan Compagner\n+ * @author Joachim F. Rohde\n  * @since 1.2.6\n  */\n public class CreditCardValidator extends AbstractValidator<String>\n {\n \tprivate static final long serialVersionUID = 1L;\n \n+\t/** The credit card number, which should be validated. */\n+\tprivate String creditCardNumber = null;\n+\n+\t/** The ID which represents the credit card institute. */\n+\tprivate int cardId = -1;\n+\n+\t/** */\n+\tpublic static final int INVALID = -1;\n+\tpublic static final int AMERICAN_EXPRESS = 0;\n+\tpublic static final int CHINA_UNIONPAY = 1;\n+\tpublic static final int DINERS_CLUB_CARTE_BLANCHE = 2;\n+\tpublic static final int DINERS_CLUB_INTERNATIONAL = 3;\n+\tpublic static final int DINERS_CLUB_US_AND_CANADA = 4;\n+\tpublic static final int DISCOVER_CARD = 5;\n+\tpublic static final int JCB = 6;\n+\tpublic static final int LASER = 7;\n+\tpublic static final int MAESTRO = 8;\n+\tpublic static final int MASTERCARD = 9;\n+\tpublic static final int SOLO = 10;\n+\tpublic static final int SWITCH = 11;\n+\tpublic static final int VISA = 12;\n+\tpublic static final int VISA_ELECTRON = 13;\n+\n+\tprivate static final String[] creditCardNames = { \"American Express\", \"China UnionPay\",\n+\t\t\t\"Diners Club Carte Blanche\", \"Diners Club International\", \"Diners Club US & Canada\",\n+\t\t\t\"Discover Card\", \"JCB\", \"Laser\", \"Maestro\", \"MasterCard\", \"Solo\", \"Switch\", \"Visa\",\n+\t\t\t\"Visa Electron\" };\n+\n \t/**\n \t * @see AbstractValidator#onValidate(IValidatable)\n \t */\n \t@Override\n \tprotected void onValidate(IValidatable<String> validatable)\n \t{\n-\t\tString input = (validatable.getValue());\n+\t\tcreditCardNumber = validatable.getValue();\n+\t\tif (!isLengthAndPrefixCorrect(creditCardNumber))\n+\t\t{\n+\t\t\terror(validatable);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks if the credit card number can be determined as a valid number.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number could be determined as a valid number,\n+\t *         else <code>FALSE</code> is returned\n+\t */\n+\tprivate boolean isLengthAndPrefixCorrect(String creditCardNumber)\n+\t{\n+\t\tif (creditCardNumber != null)\n+\t\t{\n+\t\t\t// strip spaces and dashes\n+\t\t\tcreditCardNumber = creditCardNumber.replaceAll(\"[ -]\", \"\");\n+\t\t}\n+\n+\t\t// the length of the credit card number has to be between 12 and 19.\n+\t\t// else the number is invalid.\n+\t\tif (creditCardNumber != null && creditCardNumber.length() >= 12 &&\n+\t\t\tcreditCardNumber.length() <= 19)\n+\t\t{\n+\t\t\tif (isAmericanExpress(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isChinaUnionPay(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isDinersClubCarteBlanche(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isDinersClubInternational(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isDinersClubUsAndCanada(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isDiscoverCard(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isJCB(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isLaser(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isMaestro(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isMastercard(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isSolo(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isSwitch(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isVisa(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isVisaElectron(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\telse if (isUnknown(creditCardNumber))\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Can be used (subclassed) to extend the test with a credit card not yet known by the\n+\t * validator.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid American Express\n+\t *         number. Else <code>FALSE</code> will be returned\n+\t */\n+\tprotected boolean isUnknown(String creditCardNumber)\n+\t{\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is an American Express. An American Express number has to start with\n+\t * 34 or 37 and has to have a length of 15. The number has to be validated with the Luhn\n+\t * alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid American Express\n+\t *         number. Else <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isAmericanExpress(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 15 &&\n+\t\t\t(creditCardNumber.startsWith(\"34\") || creditCardNumber.startsWith(\"37\")))\n+\t\t{\n+\t\t\tif (isChecksumCorrect(creditCardNumber))\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.AMERICAN_EXPRESS;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a China UnionPay. A China UnionPay number has to start with 622\n+\t * (622126-622925) and has to have a length between 16 and 19. No further validation takes\n+\t * place.<br/>\n+\t * <br/>\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid China UnionPay\n+\t *         number. Else <code>FALSE</code> will be returned.\n+\t */\n+\tprivate boolean isChinaUnionPay(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif ((creditCardNumber.length() >= 16 && creditCardNumber.length() <= 19) &&\n+\t\t\t(creditCardNumber.startsWith(\"622\")))\n+\t\t{\n+\t\t\tint firstDigits = Integer.parseInt(creditCardNumber.substring(0, 5));\n+\t\t\tif (firstDigits >= 622126 && firstDigits <= 622925)\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.CHINA_UNIONPAY;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Diners Club Carte Blanche. A Diners Club Carte Blanche number\n+\t * has to start with a number between 300 and 305 and has to have a length of 14. The number has\n+\t * to be validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Diners Club Carte\n+\t *         Blanche number. Else <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isDinersClubCarteBlanche(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 14 && creditCardNumber.startsWith(\"30\"))\n+\t\t{\n+\t\t\tint firstDigits = Integer.parseInt(creditCardNumber.substring(0, 3));\n+\t\t\tif (firstDigits >= 300 && firstDigits <= 305 && isChecksumCorrect(creditCardNumber))\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.DINERS_CLUB_CARTE_BLANCHE;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Diners Club International. A Diners Club International number\n+\t * has to start with the number 36 and has to have a length of 14. The number has to be\n+\t * validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Diners Club\n+\t *         International number. Else <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isDinersClubInternational(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 14 && creditCardNumber.startsWith(\"36\") &&\n+\t\t\tisChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tcardId = CreditCardValidator.DINERS_CLUB_INTERNATIONAL;\n+\t\t\treturnValue = true;\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Diners Club US & Canada. A Diners Club US & Canada number has\n+\t * to start with the number 54 or 55 and has to have a length of 16. The number has to be\n+\t * validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Diners Club US &\n+\t *         Canada number. Else <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isDinersClubUsAndCanada(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 16 &&\n+\t\t\t(creditCardNumber.startsWith(\"54\") || creditCardNumber.startsWith(\"55\")) &&\n+\t\t\tisChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tcardId = CreditCardValidator.DINERS_CLUB_US_AND_CANADA;\n+\t\t\treturnValue = true;\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Discover Card. A Discover Card number has to start with 6011,\n+\t * 622126-622925, 644-649 or 65 and has to have a length of 16. The number has to be validated\n+\t * with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Discover Card number.\n+\t *         Else <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isDiscoverCard(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 16 && creditCardNumber.startsWith(\"6\") &&\n+\t\t\tisChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tint firstThreeDigits = Integer.parseInt(creditCardNumber.substring(0, 3));\n+\t\t\tint firstSixDigits = Integer.parseInt(creditCardNumber.substring(0, 6));\n+\t\t\tif (creditCardNumber.startsWith(\"6011\") || creditCardNumber.startsWith(\"65\") ||\n+\t\t\t\t(firstThreeDigits >= 644 && firstThreeDigits <= 649) ||\n+\t\t\t\t(firstSixDigits >= 622126 && firstSixDigits <= 622925))\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.DISCOVER_CARD;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a JCB. A JCB number has to start with a number between 3528 and\n+\t * 3589 and has to have a length of 16. The number has to be validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid JCB number. Else\n+\t *         <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isJCB(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 16 && isChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tint firstFourDigits = Integer.parseInt(creditCardNumber.substring(0, 4));\n+\t\t\tif (firstFourDigits >= 3528 && firstFourDigits <= 3589)\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.JCB;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Laser. A Laser number has to start with 6304, 6706, 6771 or\n+\t * 6709 and has to have a length between 16 and 19 digits. The number has to be validated with\n+\t * the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Laser number. Else\n+\t *         <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isLaser(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() >= 16 && creditCardNumber.length() <= 19 &&\n+\t\t\tisChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tif (creditCardNumber.startsWith(\"6304\") || creditCardNumber.startsWith(\"6706\") ||\n+\t\t\t\tcreditCardNumber.startsWith(\"6771\") || creditCardNumber.startsWith(\"6709\"))\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.LASER;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Maestro. A Maestro number has to start with\n+\t * 5018,5020,5038,6304,6759,6761 or 6763 and has to have a length between 12 and 19 digits. The\n+\t * number has to be validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Maestro number. Else\n+\t *         <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isMaestro(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() >= 12 && creditCardNumber.length() <= 19 &&\n+\t\t\tisChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tif (creditCardNumber.startsWith(\"5018\") || creditCardNumber.startsWith(\"5020\") ||\n+\t\t\t\tcreditCardNumber.startsWith(\"5038\") || creditCardNumber.startsWith(\"6304\") ||\n+\t\t\t\tcreditCardNumber.startsWith(\"6759\") || creditCardNumber.startsWith(\"6761\") ||\n+\t\t\t\tcreditCardNumber.startsWith(\"6763\"))\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.MAESTRO;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Solo. A Solo number has to start with 6334 or 6767 and has to\n+\t * have a length of 16, 18 or 19 digits. The number has to be validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Solo number. Else\n+\t *         <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isSolo(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif ((creditCardNumber.length() == 16 || creditCardNumber.length() == 18 || creditCardNumber.length() == 19) &&\n+\t\t\tisChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tif (creditCardNumber.startsWith(\"6334\") || creditCardNumber.startsWith(\"6767\"))\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.SOLO;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Switch. A Switch number has to start with\n+\t * 4903,4905,4911,4936,564182,633110,6333 or 6759 and has to have a length of 16, 18 or 19\n+\t * digits. The number has to be validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Switch number. Else\n+\t *         <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isSwitch(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif ((creditCardNumber.length() == 16 || creditCardNumber.length() == 18 || creditCardNumber.length() == 19) &&\n+\t\t\tisChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tif (creditCardNumber.startsWith(\"4903\") || creditCardNumber.startsWith(\"4905\") ||\n+\t\t\t\tcreditCardNumber.startsWith(\"4911\") || creditCardNumber.startsWith(\"4936\") ||\n+\t\t\t\tcreditCardNumber.startsWith(\"564182\") || creditCardNumber.startsWith(\"633110\") ||\n+\t\t\t\tcreditCardNumber.startsWith(\"6333\") || creditCardNumber.startsWith(\"6759\"))\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.SWITCH;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Visa. A Visa number has to start with a 4 and has to have a\n+\t * length of 13 or 16 digits. The number has to be validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Visa number. Else\n+\t *         <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isVisa(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 13 || creditCardNumber.length() == 16)\n+\t\t{\n+\t\t\tif (creditCardNumber.startsWith(\"4\"))\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.SWITCH;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Visa Electron. A Visa Electron number has to start with\n+\t * 417500,4917,4913,4508 or 4844 and has to have a length of 16 digits. The number has to be\n+\t * validated with the Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Visa Electron number.\n+\t *         Else <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isVisaElectron(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 16 &&\n+\t\t\t(creditCardNumber.startsWith(\"417500\") || creditCardNumber.startsWith(\"4917\") ||\n+\t\t\t\tcreditCardNumber.startsWith(\"4913\") || creditCardNumber.startsWith(\"4508\") || creditCardNumber.startsWith(\"4844\")))\n+\t\t{\n+\t\t\tcardId = CreditCardValidator.VISA_ELECTRON;\n+\t\t\treturnValue = true;\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Check if the credit card is a Mastercard. A Mastercard number has to start with a number\n+\t * between 51 and 55 and has to have a length of 16. The number has to be validated with the\n+\t * Luhn alorithm.\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number as a string\n+\t * @return <code>TRUE</code> if the credit card number seems to be a valid Mastercard number.\n+\t *         Else <code>FALSE</code> will be returned\n+\t */\n+\tprivate boolean isMastercard(String creditCardNumber)\n+\t{\n+\t\tcardId = CreditCardValidator.INVALID;\n+\t\tboolean returnValue = false;\n+\n+\t\tif (creditCardNumber.length() == 16 && isChecksumCorrect(creditCardNumber))\n+\t\t{\n+\t\t\tint firstTwoDigits = Integer.parseInt(creditCardNumber.substring(0, 2));\n+\t\t\tif (firstTwoDigits >= 51 && firstTwoDigits <= 55)\n+\t\t\t{\n+\t\t\t\tcardId = CreditCardValidator.MASTERCARD;\n+\t\t\t\treturnValue = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn returnValue;\n+\t}\n+\n+\t/**\n+\t * Just used for debugging purposes.<br>\n+\t * Due to re-branding (e.g. Switch was re-branded as Maestro in mid 2007) some rules might\n+\t * overlap, but those overlappings are not considered. So it might happen, that a Switch-card is\n+\t * identified as a Maestro. <br>\n+\t * So you shouldn't rely on the name which is returned here.\n+\t * \n+\t * @return the name of the credit card if it could be determined, else an empty string\n+\t */\n+\tprivate String getCardName()\n+\t{\n+\t\treturn (cardId > -1 && cardId < creditCardNames.length ? creditCardNames[cardId] : \"\");\n+\t}\n+\n+\t/**\n+\t * Calculates the checksum of a credit card number using the Luhn algorithm (the so-called\n+\t * \"mod 10\" algorithm).\n+\t * \n+\t * @param creditCardNumber\n+\t *            the credit card number for which the checksum should be calculated\n+\t * @return <code>TRUE</code> if the checksum for the given credit card number is valid, else\n+\t *         return <code>FALSE</code>\n+\t * @see <a href=\"http://en.wikipedia.org/wiki/Luhn_algorithm\">Wikipedie - Luhn algorithm</a>\n+\t */\n+\tprivate boolean isChecksumCorrect(String creditCardNumber)\n+\t{\n+\t\tString input = creditCardNumber;\n \t\tString numberToCheck = input.replaceAll(\"[ -]\", \"\");\n \t\tint nulOffset = '0';\n \t\tint sum = 0;\n@@ -57,9 +616,7 @@ protected void onValidate(IValidatable<String> validatable)\n \t\t\t\tsum += currentDigit;\n \t\t\t}\n \t\t}\n-\t\tif (!((sum % 10) == 0))\n-\t\t{\n-\t\t\terror(validatable);\n-\t\t}\n+\n+\t\treturn (sum % 10) == 0;\n \t}\n }\n",
        "project": "wicket",
        "linesAdd": 378,
        "jira_id": "2552",
        "nb_skipped": 0,
        "commit": "12e1f39b",
        "nb_failure": 0,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 93,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.http.handler.RedirectRequestHandlerTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/http/handler/RedirectRequestHandler.java b/wicket-request/src/main/java/org/apache/wicket/request/http/handler/RedirectRequestHandler.java\nindex e21856f076..13c99fa029 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/http/handler/RedirectRequestHandler.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/http/handler/RedirectRequestHandler.java\n@@ -59,9 +59,10 @@ public RedirectRequestHandler(final String redirectUrl)\n \tpublic RedirectRequestHandler(final String redirectUrl, final int status)\n \t{\n \t\tif ((status != HttpServletResponse.SC_MOVED_PERMANENTLY) &&\n-\t\t\t(status != HttpServletResponse.SC_MOVED_TEMPORARILY))\n+\t\t\t(status != HttpServletResponse.SC_MOVED_TEMPORARILY) &&\n+\t\t\t(status != HttpServletResponse.SC_SEE_OTHER))\n \t\t{\n-\t\t\tthrow new IllegalStateException(\"Status must be either 301 or 302, but was: \" + status);\n+\t\t\tthrow new IllegalStateException(\"Status must be either 301, 302 or 303, but was: \" + status);\n \t\t}\n \t\tthis.redirectUrl = redirectUrl;\n \t\tthis.status = status;\n@@ -93,17 +94,19 @@ public void respond(final IRequestCycle requestCycle)\n \t{\n \t\tfinal String location;\n \n-\t\tif (redirectUrl.startsWith(\"/\"))\n+\t\tfinal String url = getRedirectUrl();\n+\n+\t\tif (url.charAt(0) == '/')\n \t\t{\n \t\t\t// context-absolute url\n-\t\t\tlocation = requestCycle.getUrlRenderer().renderContextRelativeUrl(redirectUrl);\n+\t\t\tlocation = requestCycle.getUrlRenderer().renderContextRelativeUrl(url);\n \t\t}\n \t\telse\n \t\t{\n \t\t\t// if relative url, servlet container will translate to absolute as\n \t\t\t// per the servlet spec\n \t\t\t// if absolute url still do the same\n-\t\t\tlocation = redirectUrl;\n+\t\t\tlocation = url;\n \t\t}\n \n \t\tWebResponse response = (WebResponse)requestCycle.getResponse();\n@@ -114,7 +117,7 @@ public void respond(final IRequestCycle requestCycle)\n \t\t}\n \t\telse\n \t\t{\n-\t\t\tresponse.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);\n+\t\t\tresponse.setStatus(status);\n \t\t\tresponse.setHeader(\"Location\", location);\n \t\t}\n \t}\n",
        "project": "wicket",
        "linesAdd": 9,
        "jira_id": "5131",
        "nb_skipped": 0,
        "commit": "4b7367ef",
        "nb_failure": 0,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1746,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.validation.validator.CreditCardValidatorTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java b/wicket-core/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\nindex 28225c2394..eeff47bda0 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\n@@ -322,7 +322,7 @@ private CreditCard isChinaUnionPay(String creditCardNumber)\n \t\tif ((creditCardNumber.length() >= 16 && creditCardNumber.length() <= 19) &&\n \t\t\t(creditCardNumber.startsWith(\"622\")))\n \t\t{\n-\t\t\tint firstDigits = Integer.parseInt(creditCardNumber.substring(0, 5));\n+\t\t\tint firstDigits = Integer.parseInt(creditCardNumber.substring(0, 6));\n \t\t\tif (firstDigits >= 622126 && firstDigits <= 622925)\n \t\t\t{\n \t\t\t\treturn CreditCard.CHINA_UNIONPAY;\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "5891",
        "nb_skipped": 1,
        "commit": "2d9ebf9a",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1050,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.link.AutolinkTest",
            "org.apache.wicket.markup.html.link.BookmarkableHomePageLinksTest",
            "org.apache.wicket.stateless.StatelessComponentTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/link/Link.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/link/Link.java\nindex f674c75646..bc4b4f1cfc 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/link/Link.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/link/Link.java\n@@ -21,7 +21,6 @@\n import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.markup.ComponentTag;\n import org.apache.wicket.model.IModel;\n-import org.apache.wicket.util.string.Strings;\n \n /**\n  * Implementation of a hyperlink component. A link can be used with an anchor (&lt;a href...)\n@@ -368,7 +367,7 @@ protected void onComponentTag(final ComponentTag tag)\n \t\t\t\ttag.getName().equalsIgnoreCase(\"area\"))\n \t\t\t{\n \t\t\t\t// generate the href attribute\n-\t\t\t\ttag.put(\"href\", Strings.replaceAll(url, \"&\", \"&amp;\"));\n+\t\t\t\ttag.put(\"href\", url);\n \n \t\t\t\t// Add any popup script\n \t\t\t\tif (popupSettings != null)\n@@ -381,7 +380,7 @@ protected void onComponentTag(final ComponentTag tag)\n \t\t\telse if (tag.getName().equalsIgnoreCase(\"script\") ||\n \t\t\t\ttag.getName().equalsIgnoreCase(\"style\"))\n \t\t\t{\n-\t\t\t\ttag.put(\"src\", Strings.replaceAll(url, \"&\", \"&amp;\"));\n+\t\t\t\ttag.put(\"src\", url);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n@@ -401,7 +400,8 @@ else if (tag.getName().equalsIgnoreCase(\"script\") ||\n \t\t\t\t\t\t\"onclick\",\n \t\t\t\t\t\t\"var win = this.ownerDocument.defaultView || this.ownerDocument.parentWindow; \" +\n \t\t\t\t\t\t\t\"if (win == window) { window.location.href='\" +\n-\t\t\t\t\t\t\tStrings.replaceAll(url, \"&\", \"&amp;\") + \"'; } ;return false\");\n+\t\t\t\t\t\t\turl +\n+\t\t\t\t\t\t\t\"'; } ;return false\");\n \t\t\t\t}\n \t\t\t}\n \n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "3333",
        "nb_skipped": 0,
        "commit": "ddf7e8a2",
        "nb_failure": 5,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1474,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.http.servlet.ServletWebRequestTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebRequest.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebRequest.java\nindex 83df540047..24947bbf4e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebRequest.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebRequest.java\n@@ -102,20 +102,7 @@ public ServletWebRequest(HttpServletRequest httpServletRequest, String filterPre\n \n \t\tforwardAttributes = ForwardAttributes.of(httpServletRequest, filterPrefix);\n \n-\t\tif (forwardAttributes != null || errorAttributes != null)\n-\t\t{\n-\t\t\tif (LOG.isDebugEnabled())\n-\t\t\t{\n-\t\t\t\tLOG.debug(\"Setting filterPrefix('{}') to '' because there is either an error or a forward. {}, {}\",\n-\t\t\t\t\t\tnew Object[] {filterPrefix, forwardAttributes, errorAttributes});\n-\t\t\t}\n-\t\t\t// the filter prefix is not needed when the current request is internal\n-\t\t\t// see WICKET-4387\n-\t\t\tthis.filterPrefix = \"\";\n-\t\t} else\n-\t\t{\n \t\tthis.filterPrefix = filterPrefix;\n-\t\t}\n \n \t\tif (url != null)\n \t\t{\n",
        "project": "wicket",
        "linesAdd": 0,
        "jira_id": "5203",
        "nb_skipped": 4,
        "commit": "2293764f",
        "nb_failure": 1,
        "linesRem": 11,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1637,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.mapper.PackageMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\nindex ad15d6d2e1..2037356c10 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n@@ -225,7 +225,13 @@ protected boolean pageMustHaveBeenCreatedBookmarkable()\n \t@Override\n \tpublic int getCompatibilityScore(Request request)\n \t{\n-\t\t// always return 0 here so that the mounts have higher priority\n+\t\tif (urlStartsWith(request.getUrl(), mountSegments))\n+\t\t{\n+\t\t    return mountSegments.length;\n+\t\t}\n+\t\telse\n+\t\t{\n \t\t    return 0;\n \t\t}\n \t}\n+}\n",
        "project": "wicket",
        "linesAdd": 7,
        "jira_id": "5565",
        "nb_skipped": 2,
        "commit": "44f4782a",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1374,
        "nb_error": 0,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.wicket.util.tester.WicketTesterTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletResponse.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletResponse.java\nindex 01581ef201..af090609a4 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletResponse.java\n@@ -604,6 +604,7 @@ private String getURL()\n \tpublic void sendRedirect(String location) throws IOException\n \t{\n \t\tredirectLocation = location;\n+\t\tstatus = HttpServletResponse.SC_FOUND;\n \t}\n \n \t/**\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "4610",
        "nb_skipped": 5,
        "commit": "b19a3d69",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 1,
        "nb_test": 1369,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.link.MountedPageLinkTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\nindex 50402f65ee..a5ae4f2f2b 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\n@@ -265,7 +265,17 @@ private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePag\n \t\t{\n \t\t\tif (pageClass != null)\n \t\t\t{\n-\t\t\t\tpage = getPageSource().newPageInstance(pageClass, pageParameters);\n+\t\t\t\tPageParameters parameters;\n+\t\t\t\tif (pageId != null)\n+\t\t\t\t{\n+\t\t\t\t\t// WICKET-4594 - re-creating an expired page. Ignore the parsed parameters for the callback url\n+\t\t\t\t\tparameters = new PageParameters();\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\tparameters = pageParameters;\n+\t\t\t\t}\n+\t\t\t\tpage = getPageSource().newPageInstance(pageClass, parameters);\n \t\t\t\tfreshCreated = true;\n \t\t\t}\n \t\t}\n",
        "project": "wicket",
        "linesAdd": 10,
        "jira_id": "4594",
        "nb_skipped": 8,
        "commit": "556a2236",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1393,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.validation.validator.RangeValidatorTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/validation/validator/AbstractRangeValidator.java b/wicket-core/src/main/java/org/apache/wicket/validation/validator/AbstractRangeValidator.java\nindex babc170a5b..f6ba851cda 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/validation/validator/AbstractRangeValidator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/validation/validator/AbstractRangeValidator.java\n@@ -109,7 +109,8 @@ public void validate(IValidatable<V> validatable)\n \t\tfinal R max = getMaximum();\r\n \t\tif ((min != null && value.compareTo(min) < 0) || (max != null && value.compareTo(max) > 0))\r\n \t\t{\r\n-\t\t\tValidationError error = new ValidationError(this, getMode().getVariation());\r\n+\t\t\tMode mode = getMode();\r\n+\t\t\tValidationError error = new ValidationError(this, mode.getVariation());\r\n \t\t\tif (min != null)\r\n \t\t\t{\r\n \t\t\t\terror.setVariable(\"minimum\", min);\r\n@@ -118,6 +119,10 @@ public void validate(IValidatable<V> validatable)\n \t\t\t{\r\n \t\t\t\terror.setVariable(\"maximum\", max);\r\n \t\t\t}\r\n+\t\t\tif (mode == Mode.EXACT)\r\n+\t\t\t{\r\n+\t\t\t\terror.setVariable(\"exact\", max);\r\n+\t\t\t}\r\n \t\t\tvalidatable.error(decorate(error, validatable));\r\n \t\t}\r\n \t}\r\n",
        "project": "wicket",
        "linesAdd": 6,
        "jira_id": "4717",
        "nb_skipped": 5,
        "commit": "6a1b2f61",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 935,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.form.EnumChoiceRendererTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/EnumChoiceRenderer.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/EnumChoiceRenderer.java\nindex 3af4e4982e..9181c8ed62 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/EnumChoiceRenderer.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/EnumChoiceRenderer.java\n@@ -94,7 +94,7 @@ public final Object getDisplayValue(T object)\n \t */\r\n \tprotected String resourceKey(T object)\r\n \t{\r\n-\t\treturn object.getClass().getSimpleName() + \".\" + object.name();\r\n+\t\treturn object.getDeclaringClass().getSimpleName() + \".\" + object.name();\r\n \t}\r\n \r\n \t/**\r\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "2609",
        "nb_skipped": 0,
        "commit": "7da4ad17",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 103,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.mapper.CompoundRequestMapperTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/mapper/CompoundRequestMapper.java b/wicket-request/src/main/java/org/apache/wicket/request/mapper/CompoundRequestMapper.java\nindex bbd6277ca6..94635b392a 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/mapper/CompoundRequestMapper.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/mapper/CompoundRequestMapper.java\n@@ -251,7 +251,12 @@ public void unmount(String path)\n \n \t\tfor (IRequestMapper mapper : this)\n \t\t{\n-\t\t\tif (mapper.mapRequest(request) != null)\n+\t\t\tif (mapper instanceof ICompoundRequestMapper)\n+\t\t\t{\n+\t\t\t\tICompoundRequestMapper inner = (ICompoundRequestMapper) mapper;\n+\t\t\t\tinner.unmount(path);\n+\t\t\t}\n+\t\t\telse if (mapper.mapRequest(request) != null)\n \t\t\t{\n \t\t\t\tremove(mapper);\n \t\t\t}\n",
        "project": "wicket",
        "linesAdd": 6,
        "jira_id": "5698",
        "nb_skipped": 0,
        "commit": "f45ce896",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 966,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.string.UrlUtilsTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/util/string/UrlUtils.java b/wicket/src/main/java/org/apache/wicket/util/string/UrlUtils.java\nindex c18852d4b0..6f1e8d7f12 100644\n--- a/wicket/src/main/java/org/apache/wicket/util/string/UrlUtils.java\n+++ b/wicket/src/main/java/org/apache/wicket/util/string/UrlUtils.java\n@@ -39,9 +39,10 @@ private UrlUtils()\n \t * @param url\r\n \t * @return <code>true</code> if url is relative, <code>false</code> otherwise\r\n \t */\r\n-\tpublic static boolean isRelative(String url)\r\n+\tpublic static boolean isRelative(final String url)\r\n \t{\r\n-\t\tif ((url != null) && (url.startsWith(\"/\") == false) && (url.indexOf(\"://\") < 0) &&\r\n+\t\t// the regex means \"doesn't start with 'scheme://'\"\r\n+\t\tif ((url != null) && (url.startsWith(\"/\") == false) && (!url.matches(\"^\\\\w+\\\\:\\\\/\\\\/.*\")) &&\r\n \t\t\t!(url.startsWith(\"#\")))\r\n \t\t{\r\n \t\t\treturn true;\r\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "3076",
        "nb_skipped": 1,
        "commit": "d3dc9a50",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1758,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.model.LoadableDetachableModelTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/model/LoadableDetachableModel.java b/wicket-core/src/main/java/org/apache/wicket/model/LoadableDetachableModel.java\nindex c172678d79..e3a7fc0013 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/model/LoadableDetachableModel.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/model/LoadableDetachableModel.java\n@@ -23,8 +23,8 @@\n \n /**\n  * Model that makes working with detachable models a breeze. LoadableDetachableModel holds a\n- * temporary, transient model object, that is set when {@link #getObject()} is called by\n- * calling abstract method 'load', and that will be reset/ set to null on {@link #detach()}.\n+ * temporary, transient model object, that is set when {@link #getObject()} is called by calling\n+ * abstract method 'load', and that will be reset/ set to null on {@link #detach()}.\n  * \n  * A usage example:\n  * \n@@ -60,8 +60,40 @@\n \t/** Logger. */\n \tprivate static final Logger log = LoggerFactory.getLogger(LoadableDetachableModel.class);\n \n+\tprivate enum AttachingState \n+\t{\n+\t\tDETACHED(false, false),\n+\t\tATTACHING(true, false), \n+\t\tATTACHED(true, true);\n+\n+\t\tprivate boolean attaching;\n+\t\tprivate boolean attached;\n+\n+\t\tprivate AttachingState(boolean attaching, boolean attached)\n+\t\t{\n+\t\t\tthis.attached = attached;\n+\t\t\tthis.attaching = attaching;\n+\t\t}\n+\t\t\n+\t\tpublic boolean isAttached() \n+\t\t{\n+\t\t\treturn attached;\n+\t\t}\n+\n+\t\tpublic boolean isAttaching() \n+\t\t{\n+\t\t\treturn attaching;\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tpublic String toString()\n+\t\t{\n+\t\t\treturn name().toLowerCase();\n+\t\t}\n+\t}\n+\n \t/** keeps track of whether this model is attached or detached */\n-\tprivate transient boolean attached = false;\n+\tprivate transient AttachingState attached = AttachingState.DETACHED;\n \n \t/** temporary, transient object. */\n \tprivate transient T transientModelObject;\n@@ -83,7 +115,7 @@ public LoadableDetachableModel()\n \tpublic LoadableDetachableModel(T object)\n \t{\n \t\tthis.transientModelObject = object;\n-\t\tattached = true;\n+\t\tattached = AttachingState.ATTACHED;\n \t}\n \n \t/**\n@@ -92,7 +124,7 @@ public LoadableDetachableModel(T object)\n \t@Override\n \tpublic void detach()\n \t{\n-\t\tif (attached)\n+\t\tif (attached == AttachingState.ATTACHED)\n \t\t{\n \t\t\ttry\n \t\t\t{\n@@ -100,7 +132,7 @@ public void detach()\n \t\t\t}\n \t\t\tfinally\n \t\t\t{\n-\t\t\t\tattached = false;\n+\t\t\t\tattached = AttachingState.DETACHED;\n \t\t\t\ttransientModelObject = null;\n \n \t\t\t\tlog.debug(\"removed transient object for {}, requestCycle {}\", this,\n@@ -115,8 +147,11 @@ public void detach()\n \t@Override\n \tpublic final T getObject()\n \t{\n-\t\tif (!attached)\n+\t\tif (attached == AttachingState.DETACHED)\n \t\t{\n+\t\t\t// prevent infinite attachment loops\n+\t\t\tattached = AttachingState.ATTACHING;\n+\n \t\t\ttransientModelObject = load();\n \n \t\t\tif (log.isDebugEnabled())\n@@ -125,7 +160,7 @@ public final T getObject()\n \t\t\t\t\t\", requestCycle \" + RequestCycle.get());\n \t\t\t}\n \n-\t\t\tattached = true;\n+\t\t\tattached = AttachingState.ATTACHED;\n \t\t\tonAttach();\n \t\t}\n \t\treturn transientModelObject;\n@@ -138,7 +173,7 @@ public final T getObject()\n \t */\n \tpublic final boolean isAttached()\n \t{\n-\t\treturn attached;\n+\t\treturn attached.isAttached();\n \t}\n \n \t/**\n@@ -148,8 +183,11 @@ public final boolean isAttached()\n \tpublic String toString()\n \t{\n \t\tStringBuilder sb = new StringBuilder(super.toString());\n-\t\tsb.append(\":attached=\").append(attached).append(\":tempModelObject=[\").append(\n-\t\t\tthis.transientModelObject).append(\"]\");\n+\t\tsb.append(\":attached=\")\n+\t\t\t.append(isAttached())\n+\t\t\t.append(\":tempModelObject=[\")\n+\t\t\t.append(this.transientModelObject)\n+\t\t\t.append(\"]\");\n \t\treturn sb.toString();\n \t}\n \n@@ -187,8 +225,7 @@ protected void onDetach()\n \t@Override\n \tpublic void setObject(final T object)\n \t{\n-\t\tattached = true;\n+\t\tattached = AttachingState.ATTACHED;\n \t\ttransientModelObject = object;\n \t}\n-\n }\n",
        "project": "wicket",
        "linesAdd": 47,
        "jira_id": "5916",
        "nb_skipped": 1,
        "commit": "def03add",
        "nb_failure": 0,
        "linesRem": 11,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 10,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.UrlTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 247197e9c3..d9e0cd5905 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -22,6 +22,7 @@\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Locale;\n \n import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.lang.Generics;\n@@ -105,6 +106,7 @@ else if (parts.length == 1)\n \t * Parses the given URL string.\n \t * \n \t * @param url\n+\t *           absolute or relative url with query string\n \t * @return Url object\n \t */\n \tpublic static Url parse(final String url)\n@@ -116,7 +118,7 @@ public static Url parse(final String url)\n \t * Parses the given URL string.\n \t * \n \t * @param url\n-\t *           full absolute or relative url with query string\n+\t *           absolute or relative url with query string\n \t * @param charset\n \t * @return Url object\n \t */\n@@ -154,7 +156,7 @@ public static Url parse(String url, Charset charset)\n \n \t\tif (protocolAt != -1)\n \t\t{\n-\t\t\tresult.protocol = absoluteUrl.substring(0, protocolAt);\n+\t\t\tresult.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\n \t\t\tfinal String afterProto = absoluteUrl.substring(protocolAt + 3);\n \t\t\tfinal String hostAndPort;\n \n@@ -176,7 +179,7 @@ public static Url parse(String url, Charset charset)\n \t\t\tif (portAt == -1)\n \t\t\t{\n \t\t\t\tresult.host = hostAndPort;\n-\t\t\t\tresult.port = null;\n+\t\t\t\tresult.port = getDefaultPortForProtocol(result.protocol);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n@@ -229,6 +232,33 @@ public static Url parse(String url, Charset charset)\n \t\treturn result;\n \t}\n \n+\t/**\n+\t * get default port number for protocol\n+\t * \n+\t * @param protocol\n+\t *           name of protocol\n+\t * @return default port for protocol or <code>null</code> if unknown\n+\t */\n+\tprivate static Integer getDefaultPortForProtocol(String protocol)\n+\t{\n+\t\tif (\"http\".equals(protocol))\n+\t\t{\n+\t\t\treturn 80;\n+\t\t}\n+\t\telse if (\"https\".equals(protocol))\n+\t\t{\n+\t\t\treturn 443;\n+\t\t}\n+\t\telse if (\"ftp\".equals(protocol))\n+\t\t{\n+\t\t\treturn 21;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n \t/**\n \t * Construct.\n \t */\n",
        "project": "wicket",
        "linesAdd": 23,
        "jira_id": "3834",
        "nb_skipped": 0,
        "commit": "747bccb5",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1114,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.PlaceholderTagIdTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 238b278932..6644c24a63 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -23,6 +23,7 @@\n import java.util.Locale;\n import java.util.Stack;\n \n+import org.apache.wicket.ajax.IAjaxRegionMarkupIdProvider;\n import org.apache.wicket.authorization.Action;\n import org.apache.wicket.authorization.AuthorizationException;\n import org.apache.wicket.authorization.IAuthorizationStrategy;\n@@ -2463,7 +2464,7 @@ protected void renderPlaceholderTag(final ComponentTag tag, final Response respo\n \t\t}\n \t\tresponse.write(tag.getName());\n \t\tresponse.write(\" id=\\\"\");\n-\t\tresponse.write(getMarkupId());\n+\t\tresponse.write(getAjaxRegionMarkupId());\n \t\tresponse.write(\"\\\" style=\\\"display:none\\\"></\");\n \t\tif (ns != null)\n \t\t{\n@@ -2473,6 +2474,39 @@ protected void renderPlaceholderTag(final ComponentTag tag, final Response respo\n \t\tresponse.write(\">\");\n \t}\n \n+\n+\t/**\n+\t * Returns the id of the markup region that will be updated via ajax. This can be different to\n+\t * the markup id of the component if a {@link IAjaxRegionMarkupIdProvider} behavior has been\n+\t * added.\n+\t * \n+\t * @return the markup id of the region to be updated via ajax.\n+\t */\n+\tpublic final String getAjaxRegionMarkupId()\n+\t{\n+\t\tString markupId = null;\n+\t\tfor (Behavior behavior : getBehaviors())\n+\t\t{\n+\t\t\tif (behavior instanceof IAjaxRegionMarkupIdProvider)\n+\t\t\t{\n+\t\t\t\tmarkupId = ((IAjaxRegionMarkupIdProvider)behavior).getAjaxRegionMarkupId(this);\n+\t\t\t}\n+\t\t}\n+\t\tif (markupId == null)\n+\t\t{\n+\t\t\tif (this instanceof IAjaxRegionMarkupIdProvider)\n+\t\t\t{\n+\t\t\t\tmarkupId = ((IAjaxRegionMarkupIdProvider)this).getAjaxRegionMarkupId(this);\n+\t\t\t}\n+\t\t}\n+\t\tif (markupId == null)\n+\t\t{\n+\t\t\tmarkupId = getMarkupId();\n+\t\t}\n+\t\treturn markupId;\n+\t}\n+\n+\n \t/**\n \t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT.\n \t * <p>\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java b/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\nindex f6ff1adadb..7b2467e578 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\n@@ -31,7 +31,6 @@\n import org.apache.wicket.Component;\n import org.apache.wicket.MarkupContainer;\n import org.apache.wicket.Page;\n-import org.apache.wicket.behavior.Behavior;\n import org.apache.wicket.event.Broadcast;\n import org.apache.wicket.markup.html.IHeaderResponse;\n import org.apache.wicket.markup.html.internal.HeaderResponse;\n@@ -753,7 +752,7 @@ private void respondComponents(Response response)\n \n \t\t\tif (!containsAncestorFor(component))\n \t\t\t{\n-\t\t\t\trespondComponent(response, getAjaxRegionMarkupId(component), component);\n+\t\t\t\trespondComponent(response, component.getAjaxRegionMarkupId(), component);\n \t\t\t}\n \t\t}\n \n@@ -803,30 +802,6 @@ private void writeHeaderContribution(Response response)\n \t\t}\n \t}\n \n-\tprivate String getAjaxRegionMarkupId(Component component)\n-\t{\n-\t\tString markupId = null;\n-\t\tfor (Behavior behavior : component.getBehaviors())\n-\t\t{\n-\t\t\tif (behavior instanceof IAjaxRegionMarkupIdProvider)\n-\t\t\t{\n-\t\t\t\tmarkupId = ((IAjaxRegionMarkupIdProvider)behavior).getAjaxRegionMarkupId(component);\n-\t\t\t}\n-\t\t}\n-\t\tif (markupId == null)\n-\t\t{\n-\t\t\tif (component instanceof IAjaxRegionMarkupIdProvider)\n-\t\t\t{\n-\t\t\t\tmarkupId = ((IAjaxRegionMarkupIdProvider)component).getAjaxRegionMarkupId(component);\n-\t\t\t}\n-\t\t}\n-\t\tif (markupId == null)\n-\t\t{\n-\t\t\tmarkupId = component.getMarkupId();\n-\t\t}\n-\t\treturn markupId;\n-\t}\n-\n \t/**\n \t * Checks if the target contains an ancestor for the given component\n \t * \n",
        "project": "wicket",
        "linesAdd": 29,
        "jira_id": "3563",
        "nb_skipped": 0,
        "commit": "c62b66c1",
        "nb_failure": 1,
        "linesRem": 27,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1201,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.RestartResponseAtInterceptPageExceptionTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java b/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\nindex 819df8872c..1a3187887f 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/RestartResponseAtInterceptPageException.java\n@@ -52,7 +52,7 @@\n \tpublic RestartResponseAtInterceptPageException(Page interceptPage)\n \t{\n \t\tsuper(new RenderPageRequestHandler(new PageProvider(interceptPage),\n-\t\t\tRedirectPolicy.ALWAYS_REDIRECT));\n+\t\t\tRedirectPolicy.AUTO_REDIRECT));\n \t\tInterceptData.set();\n \t}\n \n@@ -76,7 +76,7 @@ public RestartResponseAtInterceptPageException(Class<? extends Page> interceptPa\n \t\tPageParameters parameters)\n \t{\n \t\tsuper(new RenderPageRequestHandler(new PageProvider(interceptPageClass, parameters),\n-\t\t\tRedirectPolicy.ALWAYS_REDIRECT));\n+\t\t\tRedirectPolicy.AUTO_REDIRECT));\n \t\tInterceptData.set();\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "3836",
        "nb_skipped": 2,
        "commit": "843b76b1",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 141,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.string.AppendingStringBufferTest"
        ],
        "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/string/AppendingStringBuffer.java b/wicket-util/src/main/java/org/apache/wicket/util/string/AppendingStringBuffer.java\nindex a8abb5f8f3..19e69a685b 100755\n--- a/wicket-util/src/main/java/org/apache/wicket/util/string/AppendingStringBuffer.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/string/AppendingStringBuffer.java\n@@ -37,6 +37,7 @@\n \r\n \tprivate static final AppendingStringBuffer NULL = new AppendingStringBuffer(\"null\");\r\n \tprivate static final StringBuilder SB_NULL = new StringBuilder(\"null\");\r\n+\tprivate static final StringBuffer SBF_NULL = new StringBuffer(\"null\");\r\n \r\n \t/**\r\n \t * The value is used for character storage.\r\n@@ -947,7 +948,11 @@ public AppendingStringBuffer insert(final int offset, final Object obj)\n \t\t}\r\n \t\telse if (obj instanceof StringBuffer)\r\n \t\t{\r\n-\t\t\treturn insert(offset, obj);\r\n+\t\t\treturn insert(offset, (StringBuffer)obj);\r\n+\t\t}\r\n+\t\telse if (obj instanceof StringBuilder)\r\n+\t\t{\r\n+\t\t\treturn insert(offset, (StringBuilder)obj);\r\n \t\t}\r\n \t\treturn insert(offset, String.valueOf(obj));\r\n \t}\r\n@@ -1010,9 +1015,9 @@ public AppendingStringBuffer insert(final int offset, String str)\n \t/**\r\n \t * Inserts the string into this string buffer.\r\n \t * <p>\r\n-\t * The characters of the <code>String</code> argument are inserted, in order, into this string\r\n-\t * buffer at the indicated offset, moving up any characters originally above that position and\r\n-\t * increasing the length of this string buffer by the length of the argument. If\r\n+\t * The characters of the <code>StringBuilder</code> argument are inserted, in order, into this\r\n+\t * string buffer at the indicated offset, moving up any characters originally above that\r\n+\t * position and increasing the length of this string buffer by the length of the argument. If\r\n \t * <code>str</code> is <code>null</code>, then the four characters <code>\"null\"</code> are\r\n \t * inserted into this string buffer.\r\n \t * <p>\r\n@@ -1062,6 +1067,61 @@ public AppendingStringBuffer insert(final int offset, StringBuilder str)\n \t\treturn this;\r\n \t}\r\n \r\n+\t/**\r\n+\t * Inserts the string into this string buffer.\r\n+\t * <p>\r\n+\t * The characters of the <code>StringBuffer</code> argument are inserted, in order, into this\r\n+\t * string buffer at the indicated offset, moving up any characters originally above that\r\n+\t * position and increasing the length of this string buffer by the length of the argument. If\r\n+\t * <code>str</code> is <code>null</code>, then the four characters <code>\"null\"</code> are\r\n+\t * inserted into this string buffer.\r\n+\t * <p>\r\n+\t * The character at index <i>k</i> in the new character sequence is equal to:\r\n+\t * <ul>\r\n+\t * <li>the character at index <i>k</i> in the old character sequence, if <i>k</i> is less than\r\n+\t * <code>offset</code>\r\n+\t * <li>the character at index <i>k</i><code>-offset</code> in the argument <code>str</code>, if\r\n+\t * <i>k</i> is not less than <code>offset</code> but is less than\r\n+\t * <code>offset+str.length()</code>\r\n+\t * <li>the character at index <i>k</i><code>-str.length()</code> in the old character sequence,\r\n+\t * if <i>k</i> is not less than <code>offset+str.length()</code>\r\n+\t * </ul>\r\n+\t * <p>\r\n+\t * The offset argument must be greater than or equal to <code>0</code>, and less than or equal\r\n+\t * to the length of this string buffer.\r\n+\t * \r\n+\t * @param offset\r\n+\t *            the offset.\r\n+\t * @param str\r\n+\t *            a string.\r\n+\t * @return a reference to this <code>AppendingStringBuffer</code> object.\r\n+\t * @exception StringIndexOutOfBoundsException\r\n+\t *                if the offset is invalid.\r\n+\t * @see java.lang.StringBuffer#length()\r\n+\t */\r\n+\tpublic AppendingStringBuffer insert(final int offset, StringBuffer str)\r\n+\t{\r\n+\t\tif ((offset < 0) || (offset > count))\r\n+\t\t{\r\n+\t\t\tthrow new StringIndexOutOfBoundsException();\r\n+\t\t}\r\n+\r\n+\t\tif (str == null)\r\n+\t\t{\r\n+\t\t\tstr = SBF_NULL;\r\n+\t\t}\r\n+\t\tint len = str.length();\r\n+\t\tint newcount = count + len;\r\n+\t\tif (newcount > value.length)\r\n+\t\t{\r\n+\t\t\texpandCapacity(newcount);\r\n+\t\t}\r\n+\t\tSystem.arraycopy(value, offset, value, offset + len, count - offset);\r\n+\t\tstr.getChars(0, len, value, offset);\r\n+\t\tcount = newcount;\r\n+\t\treturn this;\r\n+\t}\r\n+\r\n \t/**\r\n \t * Inserts the string representation of the <code>char</code> array argument into this string\r\n \t * buffer.\r\n",
        "project": "wicket",
        "linesAdd": 29,
        "jira_id": "4184",
        "nb_skipped": 0,
        "commit": "a0150366",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1291,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.mapper.CryptoMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/CryptoMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/CryptoMapper.java\nindex 417e9d0886..a53ce246a0 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/CryptoMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/CryptoMapper.java\n@@ -152,7 +152,7 @@ private Url encryptUrl(final Url url)\n \r\n \tprivate Url decryptUrl(final Request request, final Url encryptedUrl)\r\n \t{\r\n-\t\tif (encryptedUrl.getSegments().isEmpty() && encryptedUrl.getQueryParameters().isEmpty())\r\n+\t\tif (encryptedUrl.getSegments().isEmpty())\r\n \t\t{\r\n \t\t\treturn encryptedUrl;\r\n \t\t}\r\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "4345",
        "nb_skipped": 4,
        "commit": "4f08e6f2",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1751,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.TransparentWebMarkupContainerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\nindex 6ba5b616a7..f1749af14a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n@@ -21,6 +21,7 @@\n import org.apache.wicket.markup.ComponentTag;\n import org.apache.wicket.markup.IMarkupFragment;\n import org.apache.wicket.markup.MarkupStream;\n+import org.apache.wicket.markup.resolver.IComponentResolver;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -96,7 +97,10 @@ public IMarkupFragment getMarkup(final MarkupContainer container, final Componen\n \t\t\treturn markup;\n \t\t}\n \t\t\n+\t\tif(!(child instanceof IComponentResolver)) \n+\t\t{\n \t\t\tmarkup = searchMarkupInTransparentResolvers(container, child);\n+\t\t}\n \t\t\n \t\treturn markup;\n \t}\n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "5898",
        "nb_skipped": 1,
        "commit": "b00920f3",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1039,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ajax.form.OnChangeAjaxBehaviorTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/AbstractSingleSelectChoice.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/AbstractSingleSelectChoice.java\nindex b86f32e61b..937acc900a 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/AbstractSingleSelectChoice.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/AbstractSingleSelectChoice.java\n@@ -165,7 +165,8 @@ public String getModelValue()\n \t\t\tint index = getChoices().indexOf(object);\n \t\t\treturn getChoiceRenderer().getIdValue(object, index);\n \t\t}\n-\t\treturn getNoSelectionValue().toString();\n+\t\tObject noSelectionValue = getNoSelectionValue();\n+\t\treturn noSelectionValue != null ? noSelectionValue.toString() : null;\n \t}\n \n \t/**\n@@ -269,6 +270,9 @@ protected T convertChoiceIdToChoice(String id)\n \t@Override\n \tprotected CharSequence getDefaultChoice(final Object selected)\n \t{\n+\n+\t\tfinal Object noSelectionValue = getNoSelectionValue();\n+\n \t\t// Is null a valid selection value?\n \t\tif (isNullValid())\n \t\t{\n@@ -287,19 +291,21 @@ protected CharSequence getDefaultChoice(final Object selected)\n \t\t\tbuffer.append(\"\\n<option\");\n \n \t\t\t// If null is selected, indicate that\n-\t\t\tif (selected == null)\n+\t\t\tif (selected == noSelectionValue)\n \t\t\t{\n \t\t\t\tbuffer.append(\" selected=\\\"selected\\\"\");\n \t\t\t}\n \n \t\t\t// Add body of option tag\n-\t\t\tbuffer.append(\" value=\\\"\\\">\").append(option).append(\"</option>\");\n+\t\t\tbuffer.append(\" value=\\\"\" + noSelectionValue + \"\\\">\")\n+\t\t\t\t.append(option)\n+\t\t\t\t.append(\"</option>\");\n \t\t\treturn buffer;\n \t\t}\n \t\telse\n \t\t{\n \t\t\t// Null is not valid. Is it selected anyway?\n-\t\t\tif ((selected == null) || getNoSelectionValue().equals(selected) ||\n+\t\t\tif ((selected == null) || selected.equals(noSelectionValue) ||\n \t\t\t\tselected.equals(EMPTY_STRING))\n \t\t\t{\n \t\t\t\t// Force the user to pick a non-null value\n@@ -311,7 +317,8 @@ protected CharSequence getDefaultChoice(final Object selected)\n \t\t\t\t\toption = getLocalizer().getString(\"null\", this, CHOOSE_ONE);\n \t\t\t\t}\n \n-\t\t\t\treturn \"\\n<option selected=\\\"selected\\\" value=\\\"\\\">\" + option + \"</option>\";\n+\t\t\t\treturn \"\\n<option selected=\\\"selected\\\" value=\\\"\" + noSelectionValue + \"\\\">\" +\n+\t\t\t\t\toption + \"</option>\";\n \t\t\t}\n \t\t}\n \t\treturn \"\";\n",
        "project": "wicket",
        "linesAdd": 12,
        "jira_id": "3278",
        "nb_skipped": 0,
        "commit": "60d07288",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 14,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.datetime.DateConverterTest"
        ],
        "patch": "diff --git a/wicket-datetime/src/main/java/org/apache/wicket/datetime/StyleDateConverter.java b/wicket-datetime/src/main/java/org/apache/wicket/datetime/StyleDateConverter.java\nindex d68b04aec3..92ade4c2ad 100644\n--- a/wicket-datetime/src/main/java/org/apache/wicket/datetime/StyleDateConverter.java\n+++ b/wicket-datetime/src/main/java/org/apache/wicket/datetime/StyleDateConverter.java\n@@ -16,14 +16,14 @@\n  */\n package org.apache.wicket.datetime;\n \n-import java.util.Locale;\n-\n import org.apache.wicket.datetime.markup.html.form.DateTextField;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n+import java.util.Locale;\n+\n \n /**\n  * Date converter that uses Joda Time and can be configured to take the time zone difference between\n@@ -52,15 +52,13 @@\n \n \t/**\n \t * Construct. The dateStyle 'S-' (which is the same as {@link DateTimeFormat#shortDate()}) will\n-\t * be used for constructing the date format for the current locale.\n-\t * </p>\n-\t * When applyTimeZoneDifference is true, the current time is applied on the parsed date, and the\n-\t * date will be corrected for the time zone difference between the server and the client. For\n+\t * be used for constructing the date format for the current locale. </p> When\n+\t * applyTimeZoneDifference is true, the current time is applied on the parsed date, and the date\n+\t * will be corrected for the time zone difference between the server and the client. For\n \t * instance, if I'm in Seattle and the server I'm working on is in Amsterdam, the server is 9\n \t * hours ahead. So, if I'm inputting say 12/24 at a couple of hours before midnight, at the\n \t * server it is already 12/25. If this boolean is true, it will be transformed to 12/25, while\n-\t * the client sees 12/24.\n-\t * </p>\n+\t * the client sees 12/24. </p>\n \t * \n \t * @param applyTimeZoneDifference\n \t *            whether to apply the difference in time zones between client and server\n@@ -72,15 +70,13 @@ public StyleDateConverter(boolean applyTimeZoneDifference)\n \n \t/**\n \t * Construct. The provided pattern will be used as the base format (but they will be localized\n-\t * for the current locale) and if null, {@link DateTimeFormat#shortDate()} will be used.\n-\t * </p>\n+\t * for the current locale) and if null, {@link DateTimeFormat#shortDate()} will be used. </p>\n \t * When applyTimeZoneDifference is true, the current time is applied on the parsed date, and the\n \t * date will be corrected for the time zone difference between the server and the client. For\n \t * instance, if I'm in Seattle and the server I'm working on is in Amsterdam, the server is 9\n \t * hours ahead. So, if I'm inputting say 12/24 at a couple of hours before midnight, at the\n \t * server it is already 12/25. If this boolean is true, it will be transformed to 12/25, while\n-\t * the client sees 12/24.\n-\t * </p>\n+\t * the client sees 12/24. </p>\n \t * \n \t * @param dateStyle\n \t *            Date style to use. The first character is the date style, and the second character\n@@ -119,6 +115,8 @@ public final String getDatePattern(Locale locale)\n \t@Override\n \tprotected DateTimeFormatter getFormat(Locale locale)\n \t{\n-\t\treturn DateTimeFormat.forPattern(getDatePattern(locale)).withPivotYear(2000);\n+\t\treturn DateTimeFormat.forPattern(getDatePattern(locale))\n+\t\t\t.withLocale(locale)\n+\t\t\t.withPivotYear(2000);\n \t}\n }\n\\ No newline at end of file\n",
        "project": "wicket",
        "linesAdd": 5,
        "jira_id": "3598",
        "nb_skipped": 0,
        "commit": "7c364566",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1394,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.http.servlet.ServletWebRequestTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\nindex 9d0245d0eb..9d46baf7cc 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n@@ -146,6 +146,11 @@\n {\n \tprivate static final String HIDDEN_DIV_START = \"<div style=\\\"width:0px;height:0px;position:absolute;left:-100px;top:-100px;overflow:hidden\\\">\";\n \n+\t/**\n+\t * The value of HTMLFormElement's <code>enctype</code> attribute needed for file uploading.\n+\t */\n+\tpublic static final String ENCTYPE_MULTIPART_FORM_DATA = \"multipart/form-data\";\n+\n \t/**\n \t * Visitor used for validation\n \t * \n@@ -1540,7 +1545,7 @@ protected void onComponentTag(final ComponentTag tag)\n \t\t\t\t\ttag.put(\"method\", METHOD_POST.toLowerCase(Locale.ENGLISH));\n \t\t\t\t}\n \n-\t\t\t\ttag.put(\"enctype\", \"multipart/form-data\");\n+\t\t\t\ttag.put(\"enctype\", ENCTYPE_MULTIPART_FORM_DATA);\n \t\t\t\t//\n \t\t\t\t// require the application-encoding for multipart/form-data to be sure to\n \t\t\t\t// get multipart-uploaded characters with the proper encoding on the following\n@@ -1555,7 +1560,7 @@ protected void onComponentTag(final ComponentTag tag)\n \t\t\t{\n \t\t\t\t// sanity check\n \t\t\t\tString enctype = (String)tag.getAttributes().get(\"enctype\");\n-\t\t\t\tif (\"multipart/form-data\".equalsIgnoreCase(enctype))\n+\t\t\t\tif (ENCTYPE_MULTIPART_FORM_DATA.equalsIgnoreCase(enctype))\n \t\t\t\t{\n \t\t\t\t\t// though not set explicitly in Java, this is a multipart\n \t\t\t\t\t// form\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WebApplication.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WebApplication.java\nindex 42ab5d1f27..117947d156 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WebApplication.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WebApplication.java\n@@ -44,6 +44,7 @@\n import org.apache.wicket.markup.html.WebPage;\n import org.apache.wicket.markup.html.form.AutoLabelResolver;\n import org.apache.wicket.markup.html.form.AutoLabelTextResolver;\n+import org.apache.wicket.markup.html.form.Form;\n import org.apache.wicket.markup.html.pages.AccessDeniedPage;\n import org.apache.wicket.markup.html.pages.InternalErrorPage;\n import org.apache.wicket.markup.html.pages.PageExpiredErrorPage;\n@@ -79,6 +80,7 @@\n import org.apache.wicket.util.lang.PackageName;\n import org.apache.wicket.util.string.Strings;\n import org.apache.wicket.util.time.Duration;\n+import org.apache.wicket.util.upload.FileUploadException;\n import org.apache.wicket.util.watch.IModificationWatcher;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -486,6 +488,23 @@ WebRequest createWebRequest(HttpServletRequest servletRequest, final String filt\n \n \t\tWebRequest webRequest = newWebRequest(servletRequest, filterPath);\n \n+\t\tString contentType = servletRequest.getContentType();\n+\t\tString method = servletRequest.getMethod();\n+\n+\t\tif (webRequest instanceof ServletWebRequest && Form.METHOD_POST.equalsIgnoreCase(method) &&\n+\t\t\t\tStrings.isEmpty(contentType) == false && contentType.toLowerCase().startsWith(Form.ENCTYPE_MULTIPART_FORM_DATA))\n+\t\t{\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\treturn ((ServletWebRequest)webRequest).newMultipartWebRequest(\n+\t\t\t\t\tgetApplicationSettings().getDefaultMaximumUploadSize(), \"externalForm\");\n+\t\t\t}\n+\t\t\tcatch (FileUploadException e)\n+\t\t\t{\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t}\n+\n \t\treturn webRequest;\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 23,
        "jira_id": "4715",
        "nb_skipped": 5,
        "commit": "4fc82e35",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 372,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "wicket.protocol.http.request.AbstractWebRequestCodingStrategyTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/wicket/protocol/http/request/AbstractWebRequestCodingStrategy.java b/wicket/src/main/java/wicket/protocol/http/request/AbstractWebRequestCodingStrategy.java\nindex 35342cdd5d..dadc06202a 100644\n--- a/wicket/src/main/java/wicket/protocol/http/request/AbstractWebRequestCodingStrategy.java\n+++ b/wicket/src/main/java/wicket/protocol/http/request/AbstractWebRequestCodingStrategy.java\n@@ -333,7 +333,26 @@ protected CharSequence encode(RequestCycle requestCycle,\n \n \n \t\t\t// Add <page-map-name>:<bookmarkable-page-class>\n-\t\t\turl.append(pageMapName + Component.PATH_SEPARATOR + pageClass.getName());\n+\t\t\tString pageClassName = pageClass.getName();\n+\n+\t\t\t/*\n+\t\t\t * Encode the url so it is correct even for class names containing\n+\t\t\t * non ASCII characters, like \u00e4, \u00e6, \u00f8, \u00e5 etc.\n+\t\t\t * \n+\t\t\t * The reason for this is that when redirecting to these\n+\t\t\t * bookmarkable pages, we need to have the url encoded correctly\n+\t\t\t * because we can't rely on the browser to interpret the unencoded\n+\t\t\t * url correctly.\n+\t\t\t */\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tpageClassName = URLEncoder.encode(pageClassName, \"UTF-8\");\n+\t\t\t}\n+\t\t\tcatch (UnsupportedEncodingException e)\n+\t\t\t{\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t\turl.append(pageMapName + Component.PATH_SEPARATOR + pageClassName);\n \t\t}\n \n \t\t// Is it a bookmarkable interface listener?\n",
        "project": "wicket",
        "linesAdd": 11,
        "jira_id": "16",
        "nb_skipped": 0,
        "commit": "3431e60d",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 141,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.string.StringValueTest"
        ],
        "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/string/StringValue.java b/wicket-util/src/main/java/org/apache/wicket/util/string/StringValue.java\nindex de5206cedb..fa5ba542fc 100755\n--- a/wicket-util/src/main/java/org/apache/wicket/util/string/StringValue.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/string/StringValue.java\n@@ -592,69 +592,69 @@ public final Long toLongObject() throws StringValueConversionException\n \t}\r\n \r\n \t/**\r\n-\t * Convert to object types, returning null if text is null.\r\n+\t * Convert to object types, returning null if text is null or empty.\r\n \t * \r\n \t * @return converted\r\n \t * @throws StringValueConversionException\r\n \t */\r\n \tpublic final Boolean toOptionalBoolean() throws StringValueConversionException\r\n \t{\r\n-\t\treturn (text == null) ? null : toBooleanObject();\r\n+\t\treturn Strings.isEmpty(text) ? null : toBooleanObject();\r\n \t}\r\n \r\n \t/**\r\n-\t * Convert to object types, returning null if text is null.\r\n+\t * Convert to object types, returning null if text is null or empty.\r\n \t * \r\n \t * @return converted\r\n \t * @throws StringValueConversionException\r\n \t */\r\n \tpublic final Character toOptionalCharacter() throws StringValueConversionException\r\n \t{\r\n-\t\treturn (text == null) ? null : toCharacter();\r\n+\t\treturn Strings.isEmpty(text) ? null : toCharacter();\r\n \t}\r\n \r\n \t/**\r\n-\t * Convert to object types, returning null if text is null.\r\n+\t * Convert to object types, returning null if text is null or empty.\r\n \t * \r\n \t * @return converted\r\n \t * @throws StringValueConversionException\r\n \t */\r\n \tpublic final Double toOptionalDouble() throws StringValueConversionException\r\n \t{\r\n-\t\treturn (text == null) ? null : toDoubleObject();\r\n+\t\treturn Strings.isEmpty(text) ? null : toDoubleObject();\r\n \t}\r\n \r\n \t/**\r\n-\t * Convert to object types, returning null if text is null.\r\n+\t * Convert to object types, returning null if text is null or empty.\r\n \t * \r\n \t * @return converted\r\n \t * @throws StringValueConversionException\r\n \t */\r\n \tpublic final Duration toOptionalDuration() throws StringValueConversionException\r\n \t{\r\n-\t\treturn (text == null) ? null : toDuration();\r\n+\t\treturn Strings.isEmpty(text) ? null : toDuration();\r\n \t}\r\n \r\n \t/**\r\n-\t * Convert to object types, returning null if text is null.\r\n+\t * Convert to object types, returning null if text is null or empty.\r\n \t * \r\n \t * @return converted\r\n \t * @throws StringValueConversionException\r\n \t */\r\n \tpublic final Integer toOptionalInteger() throws StringValueConversionException\r\n \t{\r\n-\t\treturn (text == null) ? null : toInteger();\r\n+\t\treturn Strings.isEmpty(text) ? null : toInteger();\r\n \t}\r\n \r\n \t/**\r\n-\t * Convert to object types, returning null if text is null.\r\n+\t * Convert to object types, returning null if text is null or empty.\r\n \t * \r\n \t * @return converted\r\n \t * @throws StringValueConversionException\r\n \t */\r\n \tpublic final Long toOptionalLong() throws StringValueConversionException\r\n \t{\r\n-\t\treturn (text == null) ? null : toLongObject();\r\n+\t\treturn Strings.isEmpty(text) ? null : toLongObject();\r\n \t}\r\n \r\n \t/**\r\n@@ -668,14 +668,14 @@ public final String toOptionalString()\n \t}\r\n \r\n \t/**\r\n-\t * Convert to object types, returning null if text is null.\r\n+\t * Convert to object types, returning null if text is null or empty.\r\n \t * \r\n \t * @return converted\r\n \t * @throws StringValueConversionException\r\n \t */\r\n \tpublic final Time toOptionalTime() throws StringValueConversionException\r\n \t{\r\n-\t\treturn (text == null) ? null : toTime();\r\n+\t\treturn Strings.isEmpty(text) ? null : toTime();\r\n \t}\r\n \r\n \t/**\r\n",
        "project": "wicket",
        "linesAdd": 7,
        "jira_id": "4309",
        "nb_skipped": 0,
        "commit": "b4274415",
        "nb_failure": 1,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 12,
        "nb_test": 188,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.convert.converters.ConvertersTest"
        ],
        "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractDecimalConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractDecimalConverter.java\nindex 09485fac63..f16ad920c5 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractDecimalConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractDecimalConverter.java\n@@ -16,14 +16,11 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n-import java.text.DecimalFormat;\n import java.text.NumberFormat;\n import java.util.Locale;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n \n /**\n- * Base class for all number converters.\n+ * Base class for all converters of decimal numbers.\n  * \n  * @author Jonathan Locke\n  * @param <N>\n@@ -32,25 +29,6 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n-\t/** The date format to use */\n-\tprivate final Map<Locale, NumberFormat> numberFormats = new ConcurrentHashMap<>();\n-\n-\t/**\n-\t * @param locale\n-\t * @return Returns the numberFormat.\n-\t */\n-\t@Override\n-\tpublic NumberFormat getNumberFormat(final Locale locale)\n-\t{\n-\t\tNumberFormat numberFormat = numberFormats.get(locale);\n-\t\tif (numberFormat == null)\n-\t\t{\n-\t\t\tnumberFormat = newNumberFormat(locale);\n-\t\t\tsetNumberFormat(locale, numberFormat);\n-\t\t}\n-\t\treturn (NumberFormat)numberFormat.clone();\n-\t}\n-\n \t/**\n \t * Creates a new {@link NumberFormat} for the given locale. The instance is later cached and is\n \t * accessible through {@link #getNumberFormat(Locale)}\n@@ -58,24 +36,9 @@ public NumberFormat getNumberFormat(final Locale locale)\n \t * @param locale\n \t * @return number format\n \t */\n+\t@Override\n \tprotected NumberFormat newNumberFormat(final Locale locale)\n \t{\n \t\treturn NumberFormat.getInstance(locale);\n \t}\n-\n-\t/**\n-\t * @param locale\n-\t *            The Locale that was used for this NumberFormat\n-\t * @param numberFormat\n-\t *            The numberFormat to set.\n-\t */\n-\tpublic final void setNumberFormat(final Locale locale, final NumberFormat numberFormat)\n-\t{\n-\t\tif (numberFormat instanceof DecimalFormat)\n-\t\t{\n-\t\t\t((DecimalFormat)numberFormat).setParseBigDecimal(true);\n-\t\t}\n-\n-\t\tnumberFormats.put(locale, numberFormat);\n-\t}\n }\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractIntegerConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractIntegerConverter.java\nindex 88639c04a4..04998145ee 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractIntegerConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractIntegerConverter.java\n@@ -18,10 +18,9 @@\n \n import java.text.NumberFormat;\n import java.util.Locale;\n-import java.util.concurrent.ConcurrentHashMap;\n \n /**\n- * Base class for all number converters.\n+ * Base class for all converters of integer numbers.\n  * \n  * @author Jonathan Locke\n  * @param <I>\n@@ -30,29 +29,12 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n-\t/** The date format to use */\n-\tprivate final ConcurrentHashMap<Locale, NumberFormat> numberFormats = new ConcurrentHashMap<>();\n-\n-\t/**\n-\t * @param locale\n-\t *            The locale\n-\t * @return Returns the numberFormat.\n-\t */\n \t@Override\n-\tpublic NumberFormat getNumberFormat(final Locale locale)\n-\t{\n-\t\tNumberFormat numberFormat = numberFormats.get(locale);\n-\t\tif (numberFormat == null)\n+\tprotected NumberFormat newNumberFormat(Locale locale)\n \t{\n-\t\t\tnumberFormat = NumberFormat.getIntegerInstance(locale);\n+\t\tNumberFormat numberFormat  = NumberFormat.getIntegerInstance(locale);\n \t\tnumberFormat.setParseIntegerOnly(true);\n \t\tnumberFormat.setGroupingUsed(false);\n-\t\t\tNumberFormat tmpNumberFormat = numberFormats.putIfAbsent(locale, numberFormat);\n-\t\t\tif (tmpNumberFormat != null)\n-\t\t\t{\n-\t\t\t\tnumberFormat = tmpNumberFormat;\n-\t\t\t}\n-\t\t}\n-\t\treturn (NumberFormat)numberFormat.clone();\n+\t\treturn numberFormat;\n \t}\n }\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractNumberConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractNumberConverter.java\nindex 5c448c0a6d..da3df42ab4 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractNumberConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractNumberConverter.java\n@@ -16,8 +16,11 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n+import java.math.BigDecimal;\n+import java.text.DecimalFormat;\n import java.text.NumberFormat;\n import java.util.Locale;\n+import java.util.concurrent.ConcurrentHashMap;\n \n import org.apache.wicket.util.convert.ConversionException;\n \n@@ -32,11 +35,45 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n+\t/** The date format to use */\n+\tprivate final ConcurrentHashMap<Locale, NumberFormat> numberFormats = new ConcurrentHashMap<>();\n+\n \t/**\n \t * @param locale\n+\t *            The locale\n \t * @return Returns the numberFormat.\n \t */\n-\tpublic abstract NumberFormat getNumberFormat(Locale locale);\n+\tpublic NumberFormat getNumberFormat(final Locale locale)\n+\t{\n+\t\tNumberFormat numberFormat = numberFormats.get(locale);\n+\t\tif (numberFormat == null)\n+\t\t{\n+\t\t\tnumberFormat = newNumberFormat(locale);\n+\n+\t\t\tif (numberFormat instanceof DecimalFormat)\n+\t\t\t{\n+\t\t\t\t// always try to parse BigDecimals\n+\t\t\t\t((DecimalFormat)numberFormat).setParseBigDecimal(true);\n+\t\t\t}\n+\n+\t\t\tNumberFormat tmpNumberFormat = numberFormats.putIfAbsent(locale, numberFormat);\n+\t\t\tif (tmpNumberFormat != null)\n+\t\t\t{\n+\t\t\t\tnumberFormat = tmpNumberFormat;\n+\t\t\t}\n+\t\t}\n+\t\t// return a clone because NumberFormat.get..Instance use a pool\n+\t\treturn (NumberFormat)numberFormat.clone();\n+\t}\n+\n+\t/**\n+\t * Creates a new {@link NumberFormat} for the given locale. The instance is later cached and is\n+\t * accessible through {@link #getNumberFormat(Locale)}\n+\t *\n+\t * @param locale\n+\t * @return number format\n+\t */\n+\tprotected abstract NumberFormat newNumberFormat(final Locale locale);\n \n \t/**\n \t * Parses a value as a String and returns a Number.\n@@ -44,15 +81,15 @@\n \t * @param value\n \t *            The object to parse (after converting with toString())\n \t * @param min\n-\t *            The minimum allowed value\n+\t *            The minimum allowed value or {@code null} if none\n \t * @param max\n-\t *            The maximum allowed value\n+\t *            The maximum allowed value or {@code null} if none\n \t * @param locale\n \t * @return The number\n \t * @throws ConversionException\n \t *             if value is unparsable or out of range\n \t */\n-\tprotected N parse(Object value, final double min, final double max, Locale locale)\n+\tprotected BigDecimal parse(Object value, final BigDecimal min, final BigDecimal max, Locale locale)\n \t{\n \t\tif (locale == null)\n \t\t{\n@@ -78,19 +115,30 @@ else if (value instanceof String)\n \t\t\treturn null;\n \t\t}\n \n-\t\tif (number.doubleValue() < min)\n+\t\tBigDecimal bigDecimal;\n+\t\tif (number instanceof BigDecimal)\n+\t\t{\n+\t\t\tbigDecimal = (BigDecimal)number;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\t// should occur rarely, see #getNumberFormat(Locale)\n+\t\t\tbigDecimal = new BigDecimal(number.toString());\n+\t\t}\n+\n+\t\tif (min != null && bigDecimal.compareTo(min) < 0)\n \t\t{\n-\t\t\tthrow newConversionException(\"Value cannot be less than \" + min, value, locale).setFormat(\n-\t\t\t\tnumberFormat);\n+\t\t\tthrow newConversionException(\"Value cannot be less than \" + min, value, locale)\n+\t\t\t\t\t.setFormat(numberFormat);\n \t\t}\n \n-\t\tif (number.doubleValue() > max)\n+\t\tif (max != null && bigDecimal.compareTo(max) > 0)\n \t\t{\n-\t\t\tthrow newConversionException(\"Value cannot be greater than \" + max, value, locale).setFormat(\n-\t\t\t\tnumberFormat);\n+\t\t\tthrow newConversionException(\"Value cannot be greater than \" + max, value, locale)\n+\t\t\t\t\t.setFormat(numberFormat);\n \t\t}\n \n-\t\treturn number;\n+\t\treturn bigDecimal;\n \t}\n \n \t@Override\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/BigDecimalConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/BigDecimalConverter.java\nindex dd6e0bac2e..162a6de2ac 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/BigDecimalConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/BigDecimalConverter.java\n@@ -44,33 +44,6 @@ public BigDecimal convertToObject(final String value, final Locale locale)\n \t\t\treturn null;\r\n \t\t}\r\n \r\n-\t\tfinal Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);\r\n-\r\n-\t\tif (number instanceof BigDecimal)\r\n-\t\t{\r\n-\t\t\treturn (BigDecimal)number;\r\n-\t\t}\r\n-\t\telse if (number instanceof Double)\r\n-\t\t{\r\n-\t\t\t// See link why the String is preferred for doubles\r\n-\t\t\t// http://java.sun.com/j2se/1.4.2/docs/api/java/math/BigDecimal.html#BigDecimal%28double%29\r\n-\t\t\treturn new BigDecimal(Double.toString(number.doubleValue()));\r\n-\t\t}\r\n-\t\telse if (number instanceof Long)\r\n-\t\t{\r\n-\t\t\treturn new BigDecimal(number.longValue());\r\n-\t\t}\r\n-\t\telse if (number instanceof Float)\r\n-\t\t{\r\n-\t\t\treturn new BigDecimal(number.floatValue());\r\n-\t\t}\r\n-\t\telse if (number instanceof Integer)\r\n-\t\t{\r\n-\t\t\treturn new BigDecimal(number.intValue());\r\n-\t\t}\r\n-\t\telse\r\n-\t\t{\r\n-\t\t\treturn new BigDecimal(value);\r\n-\t\t}\r\n+\t\treturn parse(value, null, null, locale);\r\n \t}\r\n }\r\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/BigIntegerConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/BigIntegerConverter.java\nindex 22077be67c..5da0034098 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/BigIntegerConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/BigIntegerConverter.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n+import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.util.Locale;\n \n@@ -44,23 +45,13 @@ public BigInteger convertToObject(final String value, final Locale locale)\n \t\t\treturn null;\n \t\t}\n \n-\t\tfinal Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);\n+\t\tfinal BigDecimal number = parse(value, null, null, locale);\n \n-\t\tif (number instanceof BigInteger)\n+\t\tif (number == null)\n \t\t{\n-\t\t\treturn (BigInteger)number;\n-\t\t}\n-\t\telse if (number instanceof Long)\n-\t\t{\n-\t\t\treturn BigInteger.valueOf(number.longValue());\n-\t\t}\n-\t\telse if (number instanceof Integer)\n-\t\t{\n-\t\t\treturn BigInteger.valueOf(number.intValue());\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treturn new BigInteger(value);\n+\t\t\treturn null;\n \t\t}\n+\n+\t\treturn new BigInteger(number.toString());\n \t}\n }\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ByteConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ByteConverter.java\nindex 8c351e4601..885016504a 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ByteConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ByteConverter.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n+import java.math.BigDecimal;\n import java.util.Locale;\n \n import org.apache.wicket.util.convert.IConverter;\n@@ -31,6 +32,9 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n+\tprivate static final BigDecimal MIN_VALUE = new BigDecimal(Byte.MIN_VALUE);\n+\tprivate static final BigDecimal MAX_VALUE = new BigDecimal(Byte.MAX_VALUE);\n+\n \t/**\n \t * The singleton instance for a byte converter\n \t */\n@@ -42,7 +46,7 @@\n \t@Override\n \tpublic Byte convertToObject(final String value, final Locale locale)\n \t{\n-\t\tfinal Number number = parse(value, Byte.MIN_VALUE, Byte.MAX_VALUE, locale);\n+\t\tfinal BigDecimal number = parse(value, MIN_VALUE, MAX_VALUE, locale);\n \n \t\tif (number == null)\n \t\t{\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/DoubleConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/DoubleConverter.java\nindex fbf5862a21..ce2ca99188 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/DoubleConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/DoubleConverter.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n+import java.math.BigDecimal;\n import java.util.Locale;\n \n import org.apache.wicket.util.convert.IConverter;\n@@ -31,6 +32,11 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n+\t// Double.MIN is the smallest nonzero positive number, not the largest\n+\t// negative number\n+\tprivate static final BigDecimal MIN_VALUE = new BigDecimal(-Double.MAX_VALUE);\n+\tprivate static final BigDecimal MAX_VALUE = new BigDecimal(Double.MAX_VALUE);\n+\n \t/**\n \t * The singleton instance for a double converter\n \t */\n@@ -42,9 +48,7 @@\n \t@Override\n \tpublic Double convertToObject(final String value, final Locale locale)\n \t{\n-\t\tfinal Number number = parse(value, -Double.MAX_VALUE, Double.MAX_VALUE, locale);\n-\t\t// Double.MIN is the smallest nonzero positive number, not the largest\n-\t\t// negative number\n+\t\tfinal BigDecimal number = parse(value, MIN_VALUE, MAX_VALUE, locale);\n \n \t\tif (number == null)\n \t\t{\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/FloatConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/FloatConverter.java\nindex bc1562a0f5..c4b2b79aca 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/FloatConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/FloatConverter.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n+import java.math.BigDecimal;\n import java.util.Locale;\n \n import org.apache.wicket.util.convert.IConverter;\n@@ -31,6 +32,11 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n+\t// Float.MIN is the smallest nonzero positive number, not the largest\n+\t// negative number\n+\tprivate static final BigDecimal MIN_VALUE = new BigDecimal(-Float.MAX_VALUE);\n+\tprivate static final BigDecimal MAX_VALUE = new BigDecimal(Float.MAX_VALUE);\n+\n \t/**\n \t * The singleton instance for a float converter\n \t */\n@@ -42,7 +48,7 @@\n \t@Override\n \tpublic Float convertToObject(final String value, final Locale locale)\n \t{\n-\t\tfinal Number number = parse(value, -Float.MAX_VALUE, Float.MAX_VALUE, locale);\n+\t\tfinal BigDecimal number = parse(value, MIN_VALUE, MAX_VALUE, locale);\n \n \t\tif (number == null)\n \t\t{\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/IntegerConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/IntegerConverter.java\nindex 8fd1edfaaf..5055d4a4c6 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/IntegerConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/IntegerConverter.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n+import java.math.BigDecimal;\n import java.util.Locale;\n \n import org.apache.wicket.util.convert.IConverter;\n@@ -31,6 +32,9 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n+\tprivate static final BigDecimal MIN_VALUE = new BigDecimal(Integer.MIN_VALUE);\n+\tprivate static final BigDecimal MAX_VALUE = new BigDecimal(Integer.MAX_VALUE);\n+\n \t/**\n \t * The singleton instance for a integer converter\n \t */\n@@ -42,7 +46,7 @@\n \t@Override\n \tpublic Integer convertToObject(final String value, final Locale locale)\n \t{\n-\t\tfinal Number number = parse(value, Integer.MIN_VALUE, Integer.MAX_VALUE, locale);\n+\t\tfinal BigDecimal number = parse(value, MIN_VALUE, MAX_VALUE, locale);\n \n \t\tif (number == null)\n \t\t{\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/LongConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/LongConverter.java\nindex 67401b2ecf..0cf8db6805 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/LongConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/LongConverter.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n+import java.math.BigDecimal;\n import java.util.Locale;\n \n import org.apache.wicket.util.convert.IConverter;\n@@ -31,6 +32,9 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n+\tprivate static final BigDecimal MIN_VALUE = new BigDecimal(Long.MIN_VALUE);\n+\tprivate static final BigDecimal MAX_VALUE = new BigDecimal(Long.MAX_VALUE);\n+\n \t/**\n \t * The singleton instance for a long converter\n \t */\n@@ -42,7 +46,7 @@\n \t@Override\n \tpublic Long convertToObject(final String value, final Locale locale)\n \t{\n-\t\tfinal Number number = parse(value, Long.MIN_VALUE, Long.MAX_VALUE, locale);\n+\t\tfinal BigDecimal number = parse(value, MIN_VALUE, MAX_VALUE, locale);\n \n \t\tif (number == null)\n \t\t{\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ShortConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ShortConverter.java\nindex 4d2a2fafa7..30aa1b7734 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ShortConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ShortConverter.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.wicket.util.convert.converter;\n \n+import java.math.BigDecimal;\n import java.util.Locale;\n \n import org.apache.wicket.util.convert.IConverter;\n@@ -31,6 +32,9 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n+\tprivate static final BigDecimal MIN_VALUE = new BigDecimal(Short.MIN_VALUE);\n+\tprivate static final BigDecimal MAX_VALUE = new BigDecimal(Short.MAX_VALUE);\n+\n \t/**\n \t * The singleton instance for a short converter\n \t */\n@@ -42,7 +46,7 @@\n \t@Override\n \tpublic Short convertToObject(final String value, final Locale locale)\n \t{\n-\t\tfinal Number number = parse(value, Short.MIN_VALUE, Short.MAX_VALUE, locale);\n+\t\tfinal BigDecimal number = parse(value, MIN_VALUE, MAX_VALUE, locale);\n \n \t\tif (number == null)\n \t\t{\ndiff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ZeroPaddingIntegerConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ZeroPaddingIntegerConverter.java\nindex 84c4f62ce5..181be0b6ad 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ZeroPaddingIntegerConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/ZeroPaddingIntegerConverter.java\n@@ -24,8 +24,10 @@\n  * @author Eelco Hillenius\n  * @author Jonathan Locke\n  * @author Al Maw\n+ * \n+ * @deprecated use an {@link IntegerConverter} with suitable format string instead\n  */\n-public class ZeroPaddingIntegerConverter extends AbstractIntegerConverter<Integer>\n+public class ZeroPaddingIntegerConverter extends IntegerConverter\n {\n \tprivate static final long serialVersionUID = 1L;\n \n@@ -58,29 +60,4 @@ public String convertToString(final Integer value, final Locale locale)\n \n \t\treturn result;\n \t}\n-\n-\t/**\n-\t * @see org.apache.wicket.util.convert.IConverter#convertToObject(java.lang.String,Locale)\n-\t */\n-\t@Override\n-\tpublic Integer convertToObject(final String value, final Locale locale)\n-\t{\n-\t\tfinal Number number = parse(value, Integer.MIN_VALUE, Integer.MAX_VALUE, locale);\n-\n-\t\tif (number == null)\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n-\n-\t\treturn number.intValue();\n-\t}\n-\n-\t/**\n-\t * @see org.apache.wicket.util.convert.converter.AbstractConverter#getTargetType()\n-\t */\n-\t@Override\n-\tprotected Class<Integer> getTargetType()\n-\t{\n-\t\treturn Integer.class;\n-\t}\n }\n\\ No newline at end of file\n",
        "project": "wicket",
        "linesAdd": 87,
        "jira_id": "5853",
        "nb_skipped": 2,
        "commit": "b80f6640",
        "nb_failure": 1,
        "linesRem": 118,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1639,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.settings.ISecuritySettingsTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\nindex 60764fa1a3..bf7e64bf16 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n@@ -19,11 +19,11 @@\n import java.util.List;\n \n import org.apache.wicket.Application;\n-import org.apache.wicket.core.request.handler.PageProvider;\n-import org.apache.wicket.core.request.handler.RenderPageRequestHandler;\n+import org.apache.wicket.request.IRequestMapper;\n import org.apache.wicket.request.Request;\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.component.IRequestablePage;\n+import org.apache.wicket.request.mapper.ICompoundRequestMapper;\n import org.apache.wicket.request.mapper.info.PageComponentInfo;\n import org.apache.wicket.request.mapper.parameter.IPageParametersEncoder;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n@@ -118,9 +118,7 @@ protected UrlInfo parseRequest(Request request)\n \t\t\t\t\t\tif (!pageClass.equals(application.getHomePage()))\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\t// WICKET-5094 only enforce mount if page is mounted\n-\t\t\t\t\t\t\tUrl reverseUrl = application.getRootRequestMapper().mapHandler(\n-\t\t\t\t\t\t\t\tnew RenderPageRequestHandler(new PageProvider(pageClass)));\n-\t\t\t\t\t\t\tif (!matches(request.cloneWithUrl(reverseUrl)))\n+\t\t\t\t\t\t\tif (isPageMounted(pageClass, application))\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n@@ -138,6 +136,27 @@ protected UrlInfo parseRequest(Request request)\n \t\treturn null;\n \t}\n \n+\tprivate boolean isPageMounted(Class<? extends IRequestablePage> pageClass,\n+\t\tApplication application)\n+\t{\n+\t    ICompoundRequestMapper applicationMappers = application.getRootRequestMapperAsCompound();\n+\t    \n+\t    for (IRequestMapper requestMapper : applicationMappers)\n+\t    {\n+\t\tif(requestMapper instanceof AbstractBookmarkableMapper  && requestMapper != this)\n+\t\t{\n+\t\t    AbstractBookmarkableMapper mapper = (AbstractBookmarkableMapper) requestMapper;  \n+\t\t    \n+\t\t    if(mapper.checkPageClass(pageClass))\n+\t\t    {\n+\t\t\treturn true;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t    \n+\t    return false;\n+\t}\n+\n \t@Override\n \tprotected boolean pageMustHaveBeenCreatedBookmarkable()\n \t{\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\nindex 4f0f10795a..ff13a62efc 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n@@ -221,4 +221,11 @@ protected boolean pageMustHaveBeenCreatedBookmarkable()\n \t{\n \t\treturn false;\n \t}\n+\t\n+\t@Override\n+\tprotected boolean checkPageClass(Class<? extends IRequestablePage> pageClass)\n+\t{\n+\t\tPackageName pageClassPackageName = PackageName.forClass(pageClass);\n+\t\treturn packageName.equals(pageClassPackageName);\n+\t}\n }\n",
        "project": "wicket",
        "linesAdd": 31,
        "jira_id": "5560",
        "nb_skipped": 2,
        "commit": "aa82ccfc",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1187,
        "nb_error": 5,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.internal.HeaderResponseTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HeaderResponse.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HeaderResponse.java\nindex dbde5620e6..25e908aeae 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HeaderResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HeaderResponse.java\n@@ -25,7 +25,6 @@\n import org.apache.wicket.markup.html.WicketEventReference;\n import org.apache.wicket.request.IRequestHandler;\n import org.apache.wicket.request.Response;\n-import org.apache.wicket.request.Url;\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.request.handler.resource.ResourceReferenceRequestHandler;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n@@ -378,22 +377,22 @@ public boolean isClosed()\n \t}\n \n \t/**\n+\t * Rewrites a relative url into a context-relative one, leaves absolute urls alone\n \t * \n-\t * @param location\n+\t * @param url\n \t * @return relative path\n \t */\n-\tprivate String relative(final String location)\n+\tprivate String relative(final String url)\n \t{\n-\t\tArgs.notEmpty(location, \"location\");\n+\t\tArgs.notEmpty(url, \"location\");\n \n-\t\tif (location.startsWith(\"http://\") || location.startsWith(\"https://\") ||\n-\t\t\tlocation.startsWith(\"/\"))\n+\t\tif (url.startsWith(\"http://\") || url.startsWith(\"https://\") || url.startsWith(\"/\"))\n \t\t{\n-\t\t\treturn location;\n+\t\t\treturn url;\n \t\t}\n \n \t\tRequestCycle rc = RequestCycle.get();\n-\t\treturn rc.getUrlRenderer().renderUrl(Url.parse(location, rc.getRequest().getCharset()));\n+\t\treturn rc.getUrlRenderer().renderContextRelativeUrl(url);\n \t}\n \n \t/**\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/mock/MockWebRequest.java b/wicket-core/src/main/java/org/apache/wicket/mock/MockWebRequest.java\nindex 3b266214f5..c79b71616d 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/mock/MockWebRequest.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/mock/MockWebRequest.java\n@@ -47,7 +47,7 @@\n \tprivate Locale locale = Locale.getDefault();\n \tprivate String contextPath;\n \tprivate String filterPath;\n-\tprivate String prefixToContextPath;\n+\tprivate String prefixToContextPath = \"\";\n \n \t/**\n \t * Construct.\n",
        "project": "wicket",
        "linesAdd": 6,
        "jira_id": "4030",
        "nb_skipped": 2,
        "commit": "5f69685d",
        "nb_failure": 0,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1333,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.internal.InlineEnclosureTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\nindex 06a193aaa6..e0596579d1 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\n@@ -176,11 +176,7 @@ public Component resolve(final MarkupContainer container, final MarkupStream mar\n \t\tString inlineEnclosureChildId = getInlineEnclosureAttribute(tag);\r\n \t\tif (Strings.isEmpty(inlineEnclosureChildId) == false)\r\n \t\t{\r\n-\t\t\tString id = tag.getId();\r\n-\t\t\tif (id.equals(INLINE_ENCLOSURE_ID_PREFIX))\r\n-\t\t\t{\r\n-\t\t\t\tid = id + container.getPage().getAutoIndex();\r\n-\t\t\t}\r\n+\t\t\tString id = tag.getId() + container.getPage().getAutoIndex();\r\n \t\t\t// Yes, we handled the tag\r\n \t\t\treturn new InlineEnclosure(id, inlineEnclosureChildId);\r\n \t\t}\r\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "4520",
        "nb_skipped": 8,
        "commit": "ccb8fc9e",
        "nb_failure": 3,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 880,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.resource.WriteCallbackTest",
            "org.apache.wicket.util.resource.UrlResourceStreamTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/request/resource/AbstractResource.java b/wicket/src/main/java/org/apache/wicket/request/resource/AbstractResource.java\nindex 1f6f526560..00358a067c 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/resource/AbstractResource.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/resource/AbstractResource.java\n@@ -463,7 +463,7 @@ public void write(byte[] b) throws IOException\n \t\t\t\t@Override\n \t\t\t\tpublic void write(byte[] b, int off, int len) throws IOException\n \t\t\t\t{\n-\t\t\t\t\tif (off == 0 || len == b.length)\n+\t\t\t\t\tif (off == 0 && len == b.length)\n \t\t\t\t\t{\n \t\t\t\t\t\twrite(b);\n \t\t\t\t\t}\ndiff --git a/wicket/src/main/java/org/apache/wicket/util/resource/UrlResourceStream.java b/wicket/src/main/java/org/apache/wicket/util/resource/UrlResourceStream.java\nindex 8a0cef7c52..02a144bf39 100644\n--- a/wicket/src/main/java/org/apache/wicket/util/resource/UrlResourceStream.java\n+++ b/wicket/src/main/java/org/apache/wicket/util/resource/UrlResourceStream.java\n@@ -192,6 +192,8 @@ public URL getURL()\n \t */\n \t@Override\n \tpublic Time lastModifiedTime()\n+\t{\n+\t\ttry\n \t\t{\n \t\t\tif (file != null)\n \t\t\t{\n@@ -207,12 +209,10 @@ public Time lastModifiedTime()\n \t\t\t\tif (lastModified != this.lastModified)\n \t\t\t\t{\n \t\t\t\t\tthis.lastModified = lastModified;\n-\t\t\t\tcontentLength = (int)file.length();\n+\t\t\t\t\tsetContentLength();\n \t\t\t\t}\n \t\t\t}\n \t\t\telse\n-\t\t{\n-\t\t\ttry\n \t\t\t{\n \t\t\t\tlong lastModified = Connections.getLastModified(url);\n \n@@ -221,10 +221,10 @@ public Time lastModifiedTime()\n \t\t\t\t{\n \t\t\t\t\tthis.lastModified = lastModified;\n \n-\t\t\t\t\tURLConnection connection = url.openConnection();\n-\t\t\t\t\tcontentLength = connection.getContentLength();\n-\t\t\t\t\tConnections.close(connection);\n+\t\t\t\t\tsetContentLength();\n+\t\t\t\t}\n \t\t\t}\n+\t\t\treturn Time.milliseconds(lastModified);\n \t\t}\n \t\tcatch (IOException e)\n \t\t{\n@@ -243,9 +243,13 @@ public Time lastModifiedTime()\n \t\t\t// allow modification watcher to detect the problem\n \t\t\treturn null;\n \t\t}\n-\n \t}\n-\t\treturn Time.milliseconds(lastModified);\n+\n+\tprivate void setContentLength() throws IOException\n+\t{\n+\t\tURLConnection connection = url.openConnection();\n+\t\tcontentLength = connection.getContentLength();\n+\t\tConnections.close(connection);\n \t}\n \n \t/**\n",
        "project": "wicket",
        "linesAdd": 13,
        "jira_id": "2839",
        "nb_skipped": 1,
        "commit": "15477252",
        "nb_failure": 2,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1706,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.mapper.AbstractBookmarkableMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\nindex 658c98f28c..0a047ac74a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n@@ -265,7 +265,12 @@ protected IRequestHandler processHybrid(PageInfo pageInfo,\n \t\t}\n \t\telse\n \t\t{\n-\t\t\tPageParameters constructionPageParameters = provider.getPageInstance().getPageParameters();\n+\t\t\t/** \n+\t\t\t * https://issues.apache.org/jira/browse/WICKET-5734\n+\t\t\t * */\n+\t\t\tPageParameters constructionPageParameters = provider.hasPageInstance() ? \n+\t\t\t\tprovider.getPageInstance().getPageParameters() : new PageParameters();\n+\n \t\t\tif (PageParameters.equals(constructionPageParameters, pageParameters) == false)\n \t\t\t{\n \t\t\t\t// create a fresh page instance because the request page parameters are different than the ones\n",
        "project": "wicket",
        "linesAdd": 3,
        "jira_id": "5734",
        "nb_skipped": 1,
        "commit": "71674df5",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1077,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.header.testing.HeaderTest",
            "org.apache.wicket.ajax.form.OnChangeAjaxBehaviorTest",
            "org.apache.wicket.markup.html.border.ComponentBorderTest",
            "org.apache.wicket.ajax.AjaxHeaderContributionTest",
            "org.apache.wicket.markup.html.panel.PanelTest",
            "org.apache.wicket.markup.MarkupParserTest",
            "org.apache.wicket.markup.html.header.HeaderScopingTest",
            "org.apache.wicket.ComponentTest",
            "org.apache.wicket.ajax.markup.html.ajaxLink.AjaxLinkTest",
            "org.apache.wicket.markup.html.header.inheritance.InheritanceHeadTest",
            "org.apache.wicket.ajax.DomReadyOrderTest",
            "org.apache.wicket.ajax.markup.html.componentMap.SimpleTestPanelTest",
            "org.apache.wicket.ajax.form.AjaxFormSubmitTest",
            "org.apache.wicket.markup.html.basic.SimplePageTest",
            "org.apache.wicket.ajax.AjaxRequestTargetTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/util/string/JavaScriptUtils.java b/wicket-core/src/main/java/org/apache/wicket/util/string/JavaScriptUtils.java\nindex 6101006071..8897e62110 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/util/string/JavaScriptUtils.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/util/string/JavaScriptUtils.java\n@@ -27,22 +27,22 @@\n public class JavaScriptUtils\n {\n \t/** Script open tag */\n-\tpublic final static String SCRIPT_OPEN_TAG = \"<script type=\\\"text/javascript\\\"><!--/*--><![CDATA[/*><!--*/\\n\";\n+\tpublic final static String SCRIPT_OPEN_TAG = \"<script type=\\\"text/javascript\\\">\\n/*<![CDATA[*/\\n\";\n \n \t/** Script close tag */\n-\tpublic final static String SCRIPT_CLOSE_TAG = \"\\n/*-->]]>*/</script>\\n\";\n+\tpublic final static String SCRIPT_CLOSE_TAG = \"\\n/*]]>*/\\n</script>\\n\";\n \n \t/**\n \t * Script open tag. If this tag is changed, also update Wicket.Head.Contributor.processScript()\n \t * function from wicket-ajax.js\n \t */\n-\tpublic final static String SCRIPT_CONTENT_PREFIX = \"<!--/*--><![CDATA[/*><!--*/\\n\";\n+\tpublic final static String SCRIPT_CONTENT_PREFIX = \"\\n/*<![CDATA[*/\\n\";\n \n \t/**\n \t * Script close tag. If this tag is changed, also update Wicket.Head.Contributor.processScript()\n \t * function from wicket-ajax.js\n \t */\n-\tpublic final static String SCRIPT_CONTENT_SUFFIX = \"\\n/*-->]]>*/\";\n+\tpublic final static String SCRIPT_CONTENT_SUFFIX = \"\\n/*]]>*/\\n\";\n \n \n \t/** The response object */\n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "3597",
        "nb_skipped": 0,
        "commit": "5e2c6702",
        "nb_failure": 23,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 4,
        "nb_test": 887,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.internal.EnclosureTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket/src/main/java/org/apache/wicket/MarkupContainer.java\nindex c2d8431b5e..a7a1964340 100644\n--- a/wicket/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -34,6 +34,7 @@\n import org.apache.wicket.markup.MarkupType;\n import org.apache.wicket.markup.RawMarkup;\n import org.apache.wicket.markup.WicketTag;\n+import org.apache.wicket.markup.html.border.Border;\n import org.apache.wicket.markup.resolver.ComponentResolvers;\n import org.apache.wicket.model.IComponentInheritedModel;\n import org.apache.wicket.model.IModel;\n@@ -138,6 +139,24 @@ public MarkupContainer add(final Component... childs)\n \t\t\t\tthrow new IllegalArgumentException(\"argument child may not be null\");\n \t\t\t}\n \n+\t\t\tMarkupContainer parent = getParent();\n+\t\t\twhile (parent != null)\n+\t\t\t{\n+\t\t\t\tif (child == parent)\n+\t\t\t\t{\n+\t\t\t\t\tString msg = \"You can not add a component's parent as child to the component (loop): Component: \" +\n+\t\t\t\t\t\tthis.toString(false) + \"; parent == child: \" + parent.toString(false);\n+\t\t\t\t\tif (child instanceof Border.BorderBodyContainer)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tmsg += \". Please consider using Border.addToBorder(new \" +\n+\t\t\t\t\t\t\tthis.getClass().getSimpleName() + \"(\\\"\" + this.getId() +\n+\t\t\t\t\t\t\t\"\\\", ...) instead of add(...)\";\n+\t\t\t\t\t}\n+\t\t\t\t\tthrow new WicketRuntimeException(msg);\n+\t\t\t\t}\n+\t\t\t\tparent = parent.getParent();\n+\t\t\t}\n+\n \t\t\tcheckHierarchyChange(child);\n \n \t\t\tif (log.isDebugEnabled())\n@@ -955,10 +973,7 @@ private final void addedComponent(final Component child)\n \t\tif (page != null)\n \t\t{\n \t\t\tchild.initialize();\n-\t\t}\n \n-\t\tif (page != null)\n-\t\t{\n \t\t\t// Tell the page a component has been added\n \t\t\tpage.componentAdded(child);\n \t\t}\ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java b/wicket/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\nindex 4398671282..e2f0076fa3 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/internal/Enclosure.java\n@@ -23,12 +23,14 @@\n import org.apache.wicket.markup.ComponentTag;\n import org.apache.wicket.markup.MarkupException;\n import org.apache.wicket.markup.MarkupStream;\n-import org.apache.wicket.markup.html.TransparentWebMarkupContainer;\n+import org.apache.wicket.markup.html.WebMarkupContainer;\n import org.apache.wicket.markup.html.basic.EnclosureContainer;\n import org.apache.wicket.markup.html.form.Form;\n import org.apache.wicket.markup.html.form.FormComponent;\n import org.apache.wicket.markup.html.form.IFormSubmittingComponent;\n import org.apache.wicket.markup.parser.filter.EnclosureHandler;\n+import org.apache.wicket.markup.resolver.ComponentResolvers;\n+import org.apache.wicket.markup.resolver.IComponentResolver;\n import org.apache.wicket.request.Response;\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.response.NullResponse;\n@@ -82,7 +84,7 @@\n  * @author Juergen Donnerstag\n  * @since 1.3\n  */\n-public class Enclosure extends TransparentWebMarkupContainer\n+public class Enclosure extends WebMarkupContainer implements IComponentResolver\n {\n \tprivate static final long serialVersionUID = 1L;\n \n@@ -113,6 +115,25 @@ public Enclosure(final String id, final CharSequence childId)\n \t\tthis.childId = childId;\n \t}\n \n+\t/**\n+\t * @see org.apache.wicket.Component#onInitialize()\n+\t */\n+\t@Override\n+\tprotected void onInitialize()\n+\t{\n+\t\tsuper.onInitialize();\n+\n+\t\t// enclosure's parent container\n+\t\tMarkupContainer container = getEnclosureParent();\n+\n+\t\t// clear the cache\n+\t\tchildComponent = null;\n+\n+\t\t// get Child Component. If not \"added\", ask a resolver to find it.\n+\t\tchildComponent = getChildComponent(new MarkupStream(getMarkup()), container);\n+\t\tcheckChildComponent(childComponent);\n+\t}\n+\n \t/**\n \t * Get the real parent container\n \t * \n@@ -121,7 +142,7 @@ public Enclosure(final String id, final CharSequence childId)\n \tprivate MarkupContainer getEnclosureParent()\n \t{\n \t\tMarkupContainer parent = getParent();\n-\t\twhile (parent.isAuto())\n+\t\twhile ((parent != null) && parent.isAuto())\n \t\t{\n \t\t\tparent = parent.getParent();\n \t\t}\n@@ -139,16 +160,11 @@ private MarkupContainer getEnclosureParent()\n \t *      org.apache.wicket.markup.ComponentTag)\n \t */\n \t@Override\n-\tprotected void onComponentTagBody(MarkupStream markupStream, ComponentTag openTag)\n+\tprotected void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag)\n \t{\n-\t\t// enclosure's parent container\n-\t\tMarkupContainer container = getEnclosureParent();\n-\n-\t\tComponent controller = container.get(childId.toString());\n-\t\tcheckChildComponent(controller);\n-\n+\t\t// TODO this is where I wish we had something like \"enum(TAG, BODY, NONE, ALL) isVisible()\"\n \t\t// set the enclosure visibility\n-\t\tboolean visible = controller.determineVisibility();\n+\t\tboolean visible = childComponent.determineVisibility();\n \n \t\t// We want to know which components are rendered inside the enclosure\n \t\tfinal IComponentOnAfterRenderListener listener = new EnclosureListener(this);\n@@ -185,6 +201,59 @@ protected void onComponentTagBody(MarkupStream markupStream, ComponentTag openTa\n \t\t}\n \t}\n \n+\t/**\n+\t * @param markupStream\n+\t * @param container\n+\t * @return The component associated with the\n+\t */\n+\tprivate Component getChildComponent(final MarkupStream markupStream, MarkupContainer container)\n+\t{\n+\t\tComponent controller = container.get(childId.toString());\n+\t\tif (controller == null)\n+\t\t{\n+\t\t\tint orgIndex = markupStream.getCurrentIndex();\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\twhile (markupStream.hasMore())\n+\t\t\t\t{\n+\t\t\t\t\tmarkupStream.next();\n+\t\t\t\t\tif (markupStream.skipUntil(ComponentTag.class))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tComponentTag tag = markupStream.getTag();\n+\t\t\t\t\t\tif ((tag != null) && (tag.isOpen() || tag.isOpenClose()))\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tif (childId.equals(tag.getId()))\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tcontroller = ComponentResolvers.resolveByComponentHierarchy(\n+\t\t\t\t\t\t\t\t\tcontainer, markupStream, tag);\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tmarkupStream.setCurrentIndex(orgIndex);\n+\t\t\t}\n+\t\t}\n+\t\treturn controller;\n+\t}\n+\n+\t/**\n+\t * \n+\t * @see org.apache.wicket.markup.resolver.IComponentResolver#resolve(org.apache.wicket.MarkupContainer,\n+\t *      org.apache.wicket.markup.MarkupStream, org.apache.wicket.markup.ComponentTag)\n+\t */\n+\tpublic Component resolve(MarkupContainer container, MarkupStream markupStream, ComponentTag tag)\n+\t{\n+\t\tif (childId.equals(tag.getId()))\n+\t\t{\n+\t\t\treturn childComponent;\n+\t\t}\n+\t\treturn getEnclosureParent().get(tag.getId());\n+\t}\n+\n \t/**\n \t * \n \t * @param controller\n@@ -218,6 +287,7 @@ private EnclosureListener(final Enclosure enclosure)\n \t\t/**\n \t\t * @see org.apache.wicket.application.IComponentOnBeforeRenderListener#onBeforeRender(org.apache.wicket.Component)\n \t\t */\n+\t\t@SuppressWarnings(\"unchecked\")\n \t\tpublic void onAfterRender(final Component component)\n \t\t{\n \t\t\tif (log.isWarnEnabled())\ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/resolver/ComponentResolvers.java b/wicket/src/main/java/org/apache/wicket/markup/resolver/ComponentResolvers.java\nindex d94dc482b7..daf1ab6d37 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/resolver/ComponentResolvers.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/resolver/ComponentResolvers.java\n@@ -50,34 +50,67 @@ public static Component resolve(final MarkupContainer container,\n \t\tfinal MarkupStream markupStream, final ComponentTag tag)\r\n \t{\r\n \t\t// try to resolve using component hierarchy\r\n+\t\tComponent component = resolveByComponentHierarchy(container, markupStream, tag);\r\n \r\n-\t\tComponent cursor = container;\r\n-\t\twhile (cursor != null)\r\n+\t\tif (component == null)\r\n \t\t{\r\n-\t\t\tif (cursor instanceof IComponentResolver)\r\n+\t\t\t// fallback to application-level resolvers\r\n+\t\t\tcomponent = resolveByApplication(container, markupStream, tag);\r\n+\t\t}\r\n+\r\n+\t\treturn component;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Attempts to resolve a component via application registered resolvers.\r\n+\t * \r\n+\t * @param container\r\n+\t * @param markupStream\r\n+\t * @param tag\r\n+\t * @return Null, if no component was found\r\n+\t */\r\n+\tpublic static Component resolveByApplication(final MarkupContainer container,\r\n+\t\tfinal MarkupStream markupStream, final ComponentTag tag)\r\n+\t{\r\n+\t\tfor (final IComponentResolver resolver : Application.get()\r\n+\t\t\t.getPageSettings()\r\n+\t\t\t.getComponentResolvers())\r\n \t\t{\r\n-\t\t\t\tIComponentResolver resolver = (IComponentResolver)cursor;\r\n \t\t\tComponent component = resolver.resolve(container, markupStream, tag);\r\n \t\t\tif (component != null)\r\n \t\t\t{\r\n \t\t\t\treturn component;\r\n \t\t\t}\r\n \t\t}\r\n-\t\t\tcursor = cursor.getParent();\r\n-\t\t}\r\n \r\n-\t\t// fallback to application-level resolvers\r\n+\t\treturn null;\r\n+\t}\r\n \r\n-\t\tfor (final IComponentResolver resolver : Application.get()\r\n-\t\t\t.getPageSettings()\r\n-\t\t\t.getComponentResolvers())\r\n+\t/**\r\n+\t * Attempts to resolve a component via the component hierarchy using resolvers.\r\n+\t * \r\n+\t * @param container\r\n+\t * @param markupStream\r\n+\t * @param tag\r\n+\t * @return Null, if no component was found\r\n+\t */\r\n+\tpublic static Component resolveByComponentHierarchy(final MarkupContainer container,\r\n+\t\tfinal MarkupStream markupStream, final ComponentTag tag)\r\n+\t{\r\n+\t\tComponent cursor = container;\r\n+\t\twhile (cursor != null)\r\n \t\t{\r\n+\t\t\tif (cursor instanceof IComponentResolver)\r\n+\t\t\t{\r\n+\t\t\t\tIComponentResolver resolver = (IComponentResolver)cursor;\r\n \t\t\t\tComponent component = resolver.resolve(container, markupStream, tag);\r\n \t\t\t\tif (component != null)\r\n \t\t\t\t{\r\n \t\t\t\t\treturn component;\r\n \t\t\t\t}\r\n \t\t\t}\r\n+\t\t\tcursor = cursor.getParent();\r\n+\t\t}\r\n \r\n \t\treturn null;\r\n \t}\r\ndiff --git a/wicket/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java b/wicket/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\nindex 983dc58c18..7bb49484be 100644\n--- a/wicket/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\n+++ b/wicket/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\n@@ -493,4 +493,13 @@ public void write(byte[] b, int off, int len) throws IOException\n \t\t\tresponse.write(stream.toByteArray());\n \t\t}\n \t}\n+\n+\t/**\n+\t * @see java.lang.Object#toString()\n+\t */\n+\t@Override\n+\tpublic String toString()\n+\t{\n+\t\treturn charSequenceAction.builder.toString();\n+\t}\n }\n",
        "project": "wicket",
        "linesAdd": 115,
        "jira_id": "2882",
        "nb_skipped": 1,
        "commit": "ebe56869",
        "nb_failure": 0,
        "linesRem": 22,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1202,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.handler.ListenerInterfaceRequestHandlerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/ListenerInterfaceRequestHandler.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/ListenerInterfaceRequestHandler.java\nindex de801efa5e..a74d0980ee 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/ListenerInterfaceRequestHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/ListenerInterfaceRequestHandler.java\n@@ -26,6 +26,8 @@\n import org.apache.wicket.request.http.WebRequest;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n import org.apache.wicket.util.lang.Args;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Request handler that invokes the listener interface on component and renders page afterwards.\n@@ -37,6 +39,9 @@\n \t\tIPageRequestHandler,\n \t\tIComponentRequestHandler\n {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(ListenerInterfaceRequestHandler.class);\n+\n \tprivate final IPageAndComponentProvider pageComponentProvider;\n \n \tprivate final RequestListenerInterface listenerInterface;\n@@ -146,19 +151,42 @@ public Integer getBehaviorIndex()\n \t */\n \tpublic void respond(final IRequestCycle requestCycle)\n \t{\n+\t\tfinal boolean isNewPageInstance = pageComponentProvider.isNewPageInstance();\n+\t\tfinal boolean isAjax = ((WebRequest)requestCycle.getRequest()).isAjax();\n \t\tfinal IRequestablePage page = getPage();\n+\t\tfinal boolean isStateless = page.isPageStateless();\n+\t\tfinal IPageProvider pageProvider = new PageProvider(page);\n+\n \t\tif (getComponent().getPage() == page)\n \t\t{\n-\t\t\tboolean isAjax = ((WebRequest)requestCycle.getRequest()).isAjax();\n+\t\t\tRedirectPolicy policy = isStateless ? RedirectPolicy.NEVER_REDIRECT\n+\t\t\t\t: RedirectPolicy.AUTO_REDIRECT;\n+\n+\t\t\tif (isNewPageInstance)\n+\t\t\t{\n+\t\t\t\tif (LOG.isDebugEnabled())\n+\t\t\t\t{\n+\t\t\t\t\tLOG.debug(\n+\t\t\t\t\t\t\"A ListenerInterface '{}' assigned to '{}' is executed on an expired page. \"\n+\t\t\t\t\t\t\t+ \"Scheduling re-create of the page and ignoring the listener interface...\",\n+\t\t\t\t\t\tlistenerInterface, getComponentPath());\n+\t\t\t\t}\n+\n+\t\t\t\tif (isAjax)\n+\t\t\t\t{\n+\t\t\t\t\tpolicy = RedirectPolicy.ALWAYS_REDIRECT;\n+\t\t\t\t}\n+\n+\t\t\t\trequestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(\n+\t\t\t\t\tpageProvider, policy));\n+\t\t\t\treturn;\n+\t\t\t}\n+\n \t\t\tif (isAjax == false && listenerInterface.isRenderPageAfterInvocation())\n \t\t\t{\n \t\t\t\t// schedule page render after current request handler is done. this can be\n \t\t\t\t// overridden during invocation of listener\n \t\t\t\t// method (i.e. by calling RequestCycle#setResponsePage)\n-\t\t\t\tfinal IPageProvider pageProvider = new PageProvider(page);\n-\t\t\t\tfinal RedirectPolicy policy = page.isPageStateless()\n-\t\t\t\t\t? RedirectPolicy.NEVER_REDIRECT : RedirectPolicy.AUTO_REDIRECT;\n-\n \t\t\t\trequestCycle.scheduleRequestHandlerAfterCurrent(new RenderPageRequestHandler(\n \t\t\t\t\tpageProvider, policy));\n \t\t\t}\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\nindex f000badad4..ed9af8f2d7 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\n@@ -59,6 +59,8 @@\n \n \tprivate PageParameters pageParameters;\n \n+\tprivate Boolean isNewInstance = null;\n+\n \t/**\n \t * Creates a new page provider object. Upon calling of {@link #getPageInstance()} this provider\n \t * will return page instance with specified id.\n@@ -198,17 +200,20 @@ else if (isNewPageInstance() == false)\n \t */\n \tpublic boolean isNewPageInstance()\n \t{\n-\t\tboolean isNew = pageInstance == null;\n-\t\tif (isNew && pageId != null)\n+\t\tif (isNewInstance == null)\n+\t\t{\n+\t\t\tisNewInstance = pageInstance == null;\n+\t\t\tif (isNewInstance && pageId != null)\n \t\t\t{\n \t\t\t\tIRequestablePage storedPageInstance = getStoredPage(pageId);\n \t\t\t\tif (storedPageInstance != null)\n \t\t\t\t{\n \t\t\t\t\tpageInstance = storedPageInstance;\n-\t\t\t\tisNew = false;\n+\t\t\t\t\tisNewInstance = false;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\treturn isNew;\n+\t\treturn isNewInstance;\n \t}\n \n \t/**\n@@ -292,6 +297,14 @@ private IRequestablePage getStoredPage(final int pageId)\n \t\t\t(pageClass == null || pageClass.equals(storedPageInstance.getClass())))\n \t\t{\n \t\t\tpageInstance = storedPageInstance;\n+\n+\t\t\tif (pageInstance != null)\n+\t\t\t{\n+\t\t\t\tif (renderCount != null && pageInstance.getRenderCount() != renderCount)\n+\t\t\t\t{\n+\t\t\t\t\tthrow new StalePageException(pageInstance);\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\treturn storedPageInstance;\n \t}\n",
        "project": "wicket",
        "linesAdd": 50,
        "jira_id": "4116",
        "nb_skipped": 2,
        "commit": "4624ab3d",
        "nb_failure": 0,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 782,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.list.TableTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/html/list/PageableListView.java b/wicket/src/main/java/org/apache/wicket/markup/html/list/PageableListView.java\nindex 707cef46ba..e1b2e77cc6 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/list/PageableListView.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/list/PageableListView.java\n@@ -84,7 +84,7 @@ public PageableListView(final String id, final List<T> list, final int rowsPerPa\n \tpublic final int getCurrentPage()\n \t{\n \t\t// If first cell is out of range, bring page back into range\n-\t\twhile ((currentPage * rowsPerPage) >= getList().size())\n+\t\twhile ((currentPage > 0) && ((currentPage * rowsPerPage) >= getList().size()))\n \t\t{\n \t\t\tcurrentPage--;\n \t\t}\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "2181",
        "nb_skipped": 0,
        "commit": "d79d0192",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1422,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.https.HttpsMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/https/HttpsMapper.java b/wicket-core/src/main/java/org/apache/wicket/protocol/https/HttpsMapper.java\nindex a5f765a123..aaa1a3e120 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/https/HttpsMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/https/HttpsMapper.java\n@@ -170,11 +170,8 @@ final Url mapHandler(IRequestHandler handler, Request request)\n \t\t\t// the generated url does not have the correct scheme, set it (which in turn will cause\n \t\t\t// the url to be rendered in its full representation)\n \t\t\turl.setProtocol(desired.urlName());\n-\t\t\tif (url.getPort() != null || !desired.usesStandardPort(config))\n-\t\t\t{\n \t\t\turl.setPort(desired.getPort(config));\n \t\t}\n-\t\t}\n \t\treturn url;\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 0,
        "jira_id": "4824",
        "nb_skipped": 5,
        "commit": "ad849602",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 794,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.stateless.pages.StatelessFormTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/request/target/component/BookmarkableListenerInterfaceRequestTarget.java b/wicket/src/main/java/org/apache/wicket/request/target/component/BookmarkableListenerInterfaceRequestTarget.java\nindex 097d44bca8..892b17ae94 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/target/component/BookmarkableListenerInterfaceRequestTarget.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/target/component/BookmarkableListenerInterfaceRequestTarget.java\n@@ -117,11 +117,11 @@ public void processEvents(RequestCycle requestCycle)\n \t\tif (page == null)\r\n \t\t{\r\n \t\t\tpage = Session.get().getPage(getPageMapName(), componentPath, -1);\r\n-\t\t\tif (page != null)\n+\t\t\tif (page != null && page.getClass() == getPageClass())\r\n \t\t\t{\r\n \t\t\t\tsetPage(page);\r\n \t\t\t}\r\n-\t\t\telse if (page == null)\n+\t\t\telse\r\n \t\t\t{\r\n \t\t\t\tpage = getPage(requestCycle);\r\n \t\t\t}\r\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "1897",
        "nb_skipped": 0,
        "commit": "8ee095bf",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1067,
        "nb_error": 0,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.wicket.markup.RefreshingViewOnRemoveTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex 422dc3f075..beca6b15b2 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -631,6 +631,7 @@ public final void removeAll()\n \n \t\t\t\t\t// Do not call remove() because the state change would than be\n \t\t\t\t\t// recorded twice.\n+\t\t\t\t\tchild.internalOnRemove();\n \t\t\t\t\tchild.detachModel();\n \t\t\t\t\tchild.setParent(null);\n \t\t\t\t}\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "3455",
        "nb_skipped": 0,
        "commit": "f30bd1cb",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 1,
        "nb_test": 89,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.UrlTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 9fb454cb63..191ebbef11 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -232,8 +232,11 @@ public static Url parse(CharSequence _url, Charset charset)\n \t\t\tfinal String afterProto = absoluteUrl.substring(protocolAt + 3);\n \t\t\tfinal String hostAndPort;\n \n-\t\t\tfinal int relativeAt = afterProto.indexOf('/');\n-\n+\t\t\tint relativeAt = afterProto.indexOf('/');\n+\t\t\tif (relativeAt == -1)\n+\t\t\t{\n+\t\t\t\trelativeAt = afterProto.indexOf(';');\n+\t\t\t}\n \t\t\tif (relativeAt == -1)\n \t\t\t{\n \t\t\t\trelativeUrl = \"\";\n",
        "project": "wicket",
        "linesAdd": 5,
        "jira_id": "4877",
        "nb_skipped": 0,
        "commit": "6470c3f7",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1027,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.model.AbstractPropertyModelObjectClassTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/model/AbstractPropertyModel.java b/wicket/src/main/java/org/apache/wicket/model/AbstractPropertyModel.java\nindex b95679c9f1..6df54faaf4 100644\n--- a/wicket/src/main/java/org/apache/wicket/model/AbstractPropertyModel.java\n+++ b/wicket/src/main/java/org/apache/wicket/model/AbstractPropertyModel.java\n@@ -247,8 +247,11 @@ else if (this.target instanceof IObjectClassAwareModel)\n \t\t{\n \t\t\ttry\n \t\t\t{\n-\t\t\t\treturn PropertyResolver.getPropertyClass(expression,\n-\t\t\t\t\t((IObjectClassAwareModel<?>)this.target).getObjectClass());\n+\t\t\t\tClass<?> targetClass = ((IObjectClassAwareModel<?>)this.target).getObjectClass();\n+\t\t\t\tif (targetClass != null)\n+\t\t\t\t{\n+\t\t\t\t\treturn PropertyResolver.getPropertyClass(expression, targetClass);\n+\t\t\t\t}\n \t\t\t}\n \t\t\tcatch (WicketRuntimeException e)\n \t\t\t{\n",
        "project": "wicket",
        "linesAdd": 5,
        "jira_id": "3253",
        "nb_skipped": 0,
        "commit": "71b6e905",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1529,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.behavior.ImmutableBehaviorIdsTest",
            "org.apache.wicket.markup.html.basic.SimplePageTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Behaviors.java b/wicket-core/src/main/java/org/apache/wicket/Behaviors.java\nindex a743e8b03c..3d406f2c7a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Behaviors.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Behaviors.java\n@@ -63,7 +63,7 @@ public void add(Behavior... behaviors)\n \tprivate void internalAdd(final Behavior behavior)\r\n \t{\r\n \t\tcomponent.data_add(behavior);\r\n-\t\tif (behavior.getStatelessHint(component))\r\n+\t\tif (behavior.getStatelessHint(component) == false)\r\n \t\t{\r\n \t\t\tgetBehaviorId(behavior);\r\n \t\t}\r\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "5400",
        "nb_skipped": 2,
        "commit": "6cefb9f8",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 169,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.string.StringValueTest"
        ],
        "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/string/StringValue.java b/wicket-util/src/main/java/org/apache/wicket/util/string/StringValue.java\nindex fa5bbbdaad..2887f95ca9 100755\n--- a/wicket-util/src/main/java/org/apache/wicket/util/string/StringValue.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/string/StringValue.java\n@@ -361,8 +361,8 @@ public final CharSequence replaceAll(final CharSequence searchFor,\n \t\t\treturn (T)toEnum((Class)type);\n \t\t}\n \n-\t\tthrow new StringValueConversionException(\"Cannot convert '\" + toString() + \"'to type \" +\n-\t\t\ttype);\n+\t\tthrow new StringValueConversionException(\"Cannot convert '\" + toString() + \"'to type \"\n+\t\t\t+ type);\n \t}\n \n \t/**\n@@ -394,7 +394,8 @@ public final boolean toBoolean() throws StringValueConversionException\n \t * \n \t * @param defaultValue\n \t *            the default value\n-\t * @return the converted text as a boolean or the default value if text is empty or inconvertible\n+\t * @return the converted text as a boolean or the default value if text is empty or\n+\t *         inconvertible\n \t * @see Strings#isTrue(String)\n \t */\n \tpublic final boolean toBoolean(final boolean defaultValue)\n@@ -410,7 +411,8 @@ public final boolean toBoolean(final boolean defaultValue)\n \t\t\t\tif (LOG.isDebugEnabled())\n \t\t\t\t{\n \t\t\t\t\tLOG.debug(String.format(\n-\t\t\t\t\t\t\"An error occurred while converting '%s' to a boolean: %s\", text, x.getMessage()), x);\n+\t\t\t\t\t\t\"An error occurred while converting '%s' to a boolean: %s\", text,\n+\t\t\t\t\t\tx.getMessage()), x);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -444,7 +446,8 @@ public final char toChar() throws StringValueConversionException\n \t * \n \t * @param defaultValue\n \t *            the default value\n-\t * @return the converted text as a primitive char or the default value if text is not a single character\n+\t * @return the converted text as a primitive char or the default value if text is not a single\n+\t *         character\n \t */\n \tpublic final char toChar(final char defaultValue)\n \t{\n@@ -459,7 +462,8 @@ public final char toChar(final char defaultValue)\n \t\t\t\tif (LOG.isDebugEnabled())\n \t\t\t\t{\n \t\t\t\t\tLOG.debug(String.format(\n-\t\t\t\t\t\t\"An error occurred while converting '%s' to a character: %s\", text, x.getMessage()), x);\n+\t\t\t\t\t\t\"An error occurred while converting '%s' to a character: %s\", text,\n+\t\t\t\t\t\tx.getMessage()), x);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -491,8 +495,8 @@ public final double toDouble() throws StringValueConversionException\n \t\t}\n \t\tcatch (ParseException e)\n \t\t{\n-\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text +\n-\t\t\t\t\"' to a double value\", e);\n+\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text\n+\t\t\t\t+ \"' to a double value\", e);\n \t\t}\n \t}\n \n@@ -516,7 +520,8 @@ public final double toDouble(final double defaultValue)\n \t\t\t\tif (LOG.isDebugEnabled())\n \t\t\t\t{\n \t\t\t\t\tLOG.debug(String.format(\n-\t\t\t\t\t\t\"An error occurred while converting '%s' to a double: %s\", text, x.getMessage()), x);\n+\t\t\t\t\t\t\"An error occurred while converting '%s' to a double: %s\", text,\n+\t\t\t\t\t\tx.getMessage()), x);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -551,7 +556,8 @@ public final Duration toDuration() throws StringValueConversionException\n \t * \n \t * @param defaultValue\n \t *            the default value\n-\t * @return the converted text as a duration or the default value if text is empty or inconvertible\n+\t * @return the converted text as a duration or the default value if text is empty or\n+\t *         inconvertible\n \t * @see Duration#valueOf(String, java.util.Locale)\n \t */\n \tpublic final Duration toDuration(final Duration defaultValue)\n@@ -567,7 +573,8 @@ public final Duration toDuration(final Duration defaultValue)\n \t\t\t\tif (LOG.isDebugEnabled())\n \t\t\t\t{\n \t\t\t\t\tLOG.debug(String.format(\n-\t\t\t\t\t\t\"An error occurred while converting '%s' to a Duration: %s\", text, x.getMessage()), x);\n+\t\t\t\t\t\t\"An error occurred while converting '%s' to a Duration: %s\", text,\n+\t\t\t\t\t\tx.getMessage()), x);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -588,8 +595,8 @@ public final int toInt() throws StringValueConversionException\n \t\t}\n \t\tcatch (NumberFormatException e)\n \t\t{\n-\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text +\n-\t\t\t\t\"' to an int value\", e);\n+\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text\n+\t\t\t\t+ \"' to an int value\", e);\n \t\t}\n \t}\n \n@@ -613,7 +620,8 @@ public final int toInt(final int defaultValue)\n \t\t\t\tif (LOG.isDebugEnabled())\n \t\t\t\t{\n \t\t\t\t\tLOG.debug(String.format(\n-\t\t\t\t\t\t\"An error occurred while converting '%s' to an integer: %s\", text, x.getMessage()), x);\n+\t\t\t\t\t\t\"An error occurred while converting '%s' to an integer: %s\", text,\n+\t\t\t\t\t\tx.getMessage()), x);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -634,8 +642,8 @@ public final Integer toInteger() throws StringValueConversionException\n \t\t}\n \t\tcatch (NumberFormatException e)\n \t\t{\n-\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text +\n-\t\t\t\t\"' to an Integer value\", e);\n+\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text\n+\t\t\t\t+ \"' to an Integer value\", e);\n \t\t}\n \t}\n \n@@ -653,8 +661,8 @@ public final long toLong() throws StringValueConversionException\n \t\t}\n \t\tcatch (NumberFormatException e)\n \t\t{\n-\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text +\n-\t\t\t\t\"' to a long value\", e);\n+\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text\n+\t\t\t\t+ \"' to a long value\", e);\n \t\t}\n \t}\n \n@@ -663,7 +671,8 @@ public final long toLong() throws StringValueConversionException\n \t * \n \t * @param defaultValue\n \t *            the default value\n-\t * @return the converted text as a long integer or the default value if text is empty or inconvertible\n+\t * @return the converted text as a long integer or the default value if text is empty or\n+\t *         inconvertible\n \t */\n \tpublic final long toLong(final long defaultValue)\n \t{\n@@ -678,7 +687,8 @@ public final long toLong(final long defaultValue)\n \t\t\t\tif (LOG.isDebugEnabled())\n \t\t\t\t{\n \t\t\t\t\tLOG.debug(String.format(\n-\t\t\t\t\t\t\"An error occurred while converting '%s' to a long: %s\", text, x.getMessage()), x);\n+\t\t\t\t\t\t\"An error occurred while converting '%s' to a long: %s\", text,\n+\t\t\t\t\t\tx.getMessage()), x);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -699,8 +709,8 @@ public final Long toLongObject() throws StringValueConversionException\n \t\t}\n \t\tcatch (NumberFormatException e)\n \t\t{\n-\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text +\n-\t\t\t\t\"' to a Long value\", e);\n+\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text\n+\t\t\t\t+ \"' to a Long value\", e);\n \t\t}\n \t}\n \n@@ -826,8 +836,8 @@ public final Time toTime() throws StringValueConversionException\n \t\t}\n \t\tcatch (ParseException e)\n \t\t{\n-\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text +\n-\t\t\t\t\"' to a Time value\", e);\n+\t\t\tthrow new StringValueConversionException(\"Unable to convert '\" + text\n+\t\t\t\t+ \"' to a Time value\", e);\n \t\t}\n \t}\n \n@@ -851,7 +861,8 @@ public final Time toTime(final Time defaultValue)\n \t\t\t\tif (LOG.isDebugEnabled())\n \t\t\t\t{\n \t\t\t\t\tLOG.debug(String.format(\n-\t\t\t\t\t\t\"An error occurred while converting '%s' to a Time: %s\", text, x.getMessage()), x);\n+\t\t\t\t\t\t\"An error occurred while converting '%s' to a Time: %s\", text,\n+\t\t\t\t\t\tx.getMessage()), x);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -968,8 +979,7 @@ public boolean equals(final Object obj)\n \t\tif (obj instanceof StringValue)\n \t\t{\n \t\t\tStringValue stringValue = (StringValue)obj;\n-\t\t\treturn Objects.isEqual(text, stringValue.text) &&\n-\t\t\t\tObjects.isEqual(locale, stringValue.locale);\n+\t\t\treturn Objects.isEqual(text, stringValue.text) && locale.equals(stringValue.locale);\n \t\t}\n \t\telse\n \t\t{\n",
        "project": "wicket",
        "linesAdd": 29,
        "jira_id": "5359",
        "nb_skipped": 0,
        "commit": "61122bab",
        "nb_failure": 0,
        "linesRem": 23,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 2,
        "nb_test": 1080,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ComponentEventsTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ComponentEventSender.java b/wicket-core/src/main/java/org/apache/wicket/ComponentEventSender.java\nindex efbd0ff0da..a01f8d4072 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ComponentEventSender.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ComponentEventSender.java\n@@ -164,6 +164,10 @@ private void depth(final ComponentEvent<?> event)\n \t\t{\n \t\t\tVisits.visitPostOrder(cursor, new ComponentEventVisitor(event, dispatcher));\n \t\t}\n+\t\telse\n+\t\t{\n+\t\t\tdispatcher.dispatchEvent(cursor, event);\n+\t\t}\n \t\tif (event.isStop())\n \t\t{\n \t\t\treturn;\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/event/Broadcast.java b/wicket-core/src/main/java/org/apache/wicket/event/Broadcast.java\nindex 401a4f2f96..532863743f 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/event/Broadcast.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/event/Broadcast.java\n@@ -39,6 +39,12 @@\n \t * <li>{@link Component}s</li>\n \t * </ol>\n \t * \n+\t * Components receive the event with a preorder breadth-first traversal, eg: Apply recursively:\n+\t * <ol>\n+\t * <li>The component receives the event</li>\n+\t * <li>The component's children receive the event</li>\n+\t * </ol>\n+\t * \n \t * Any sink along the path can be specified and traversal will start with the specified sink as\n \t * root, eg:\n \t * \n@@ -61,6 +67,12 @@\n \t * <li>{@link Application}</li>\n \t * </ol>\n \t * \n+\t * Components receive the event with a postorder depth-first traversal, eg: Apply recursively:\n+\t * <ol>\n+\t * <li>The component's children receive the event</li>\n+\t * <li>The component receives the event</li>\n+\t * </ol>\n+\t * \n \t * Any sink along the path can be specified and traversal will start with the specified sink as\n \t * root, eg:\n \t * \n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "3539",
        "nb_skipped": 0,
        "commit": "a4459ef4",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 170,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.convert.converters.ConvertersTest"
        ],
        "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractNumberConverter.java b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractNumberConverter.java\nindex b3b970eccf..5c448c0a6d 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractNumberConverter.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/convert/converter/AbstractNumberConverter.java\n@@ -65,10 +65,9 @@ protected N parse(Object value, final double min, final double max, Locale local\n \t\t}\n \t\telse if (value instanceof String)\n \t\t{\n-\t\t\t// Convert spaces to no-break space (U+00A0) to fix problems with\n-\t\t\t// browser conversions.\n-\t\t\t// Space is not valid thousands-separator, but no-br space is.\n-\t\t\tvalue = ((String)value).replace(' ', '\\u00A0');\n+\t\t\t// Convert spaces to no-break space (U+00A0) as required by Java formats:\n+\t\t\t// http://bugs.sun.com/view_bug.do?bug_id=4510618\n+\t\t\tvalue = ((String)value).replaceAll(\"(\\\\d+)\\\\s(?=\\\\d)\", \"$1\\u00A0\");\n \t\t}\n \n \t\tfinal NumberFormat numberFormat = getNumberFormat(locale);\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "4988",
        "nb_skipped": 0,
        "commit": "a4a3a9a6",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 760,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.string.JavascriptStripperTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/util/string/JavascriptStripper.java b/wicket/src/main/java/org/apache/wicket/util/string/JavascriptStripper.java\nindex e21e9d41bd..10d05a25a6 100644\n--- a/wicket/src/main/java/org/apache/wicket/util/string/JavascriptStripper.java\n+++ b/wicket/src/main/java/org/apache/wicket/util/string/JavascriptStripper.java\n@@ -78,6 +78,7 @@ public static String stripCommentsAndWhitespace(String original)\n \t\t// let's be optimistic\n \t\tAppendingStringBuffer result = new AppendingStringBuffer(original.length() / 2);\n \t\tint state = REGULAR_TEXT;\n+\t\tboolean wasNewLineInWhitespace = false;\n \n \t\tfor (int i = 0; i < original.length(); ++i)\n \t\t{\n@@ -87,6 +88,12 @@ public static String stripCommentsAndWhitespace(String original)\n \n \t\t\tif (state == WHITE_SPACE)\n \t\t\t{\n+\t\t\t\t// WICKET 2060\n+\t\t\t\tif (c == '\\n' && !wasNewLineInWhitespace)\n+\t\t\t\t{\n+\t\t\t\t\tresult.append(\"\\n\");\n+\t\t\t\t\twasNewLineInWhitespace = true;\n+\t\t\t\t}\n \t\t\t\tif (Character.isWhitespace(next) == false)\n \t\t\t\t{\n \t\t\t\t\tstate = REGULAR_TEXT;\n@@ -123,7 +130,7 @@ else if (c == '/')\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (tmp == '=' || tmp == '(' || tmp == '{' || tmp == ':' || tmp == ',' ||\n-\t\t\t\t\t\t\ttmp == '[')\n+\t\t\t\t\t\t\ttmp == '[' || tmp == ';')\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tstate = REG_EXP;\n \t\t\t\t\t\t\tbreak;\n@@ -133,9 +140,18 @@ else if (c == '/')\n \t\t\t\t}\n \t\t\t\telse if (Character.isWhitespace(c) && Character.isWhitespace(next))\n \t\t\t\t{\n+\t\t\t\t\t// WICKET-2060\n+\t\t\t\t\tif (c == '\\n' || next == '\\n')\n+\t\t\t\t\t{\n+\t\t\t\t\t\tc = '\\n';\n+\t\t\t\t\t\twasNewLineInWhitespace = true;\n+\t\t\t\t\t}\n+\t\t\t\t\telse\n+\t\t\t\t\t{\n+\t\t\t\t\t\tc = ' ';\n+\t\t\t\t\t}\n \t\t\t\t\t// ignore all whitespace characters after this one\n \t\t\t\t\tstate = WHITE_SPACE;\n-\t\t\t\t\tc = '\\n';\n \t\t\t\t}\n \t\t\t\telse if (c == '\\'')\n \t\t\t\t{\n",
        "project": "wicket",
        "linesAdd": 16,
        "jira_id": "2060",
        "nb_skipped": 0,
        "commit": "0578d6ee",
        "nb_failure": 9,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1210,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.behavior.ImmutableBehaviorIdsTest",
            "org.apache.wicket.markup.html.basic.SimplePageTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Behaviors.java b/wicket-core/src/main/java/org/apache/wicket/Behaviors.java\nindex 2e358e25cf..627d4e668c 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Behaviors.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Behaviors.java\n@@ -70,7 +70,7 @@ public void add(Behavior... behaviors)\n \tprivate void internalAdd(final Behavior behavior)\r\n \t{\r\n \t\tcomponent.data_add(behavior);\r\n-\t\tif (behavior.isStateless(component))\r\n+\t\tif (behavior.getStatelessHint(component))\r\n \t\t{\r\n \t\t\tgetBehaviorId(behavior);\r\n \t\t}\r\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/behavior/Behavior.java b/wicket-core/src/main/java/org/apache/wicket/behavior/Behavior.java\nindex ff2e04a2bb..a809405335 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/behavior/Behavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/behavior/Behavior.java\n@@ -177,23 +177,6 @@ public boolean isTemporary(Component component)\n \t\treturn false;\n \t}\n \n-\t/**\n-\t * Returns whether or not this behavior is stateless. Most behaviors should either not override\n-\t * this method or return {@code false} because most behavior are not stateless.\n-\t * \n-\t * A small subset of behaviors are made specifically to be stateless and as such should override\n-\t * this method and return {@code true}. One sideeffect of this method is that the behavior id\n-\t * will be generated eagerly when the behavior is added to the component instead of before\n-\t * render when a method to create the url is called - this allows for stateless callback urls.\n-\t * \n-\t * @param component\n-\t * @return whether or not this behavior is stateless\n-\t */\n-\tpublic boolean isStateless(Component component)\n-\t{\n-\t\treturn false;\n-\t}\n-\n \t/**\n \t * Checks if a listener can be invoked on this behavior\n \t * \n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "3764",
        "nb_skipped": 1,
        "commit": "48454f4d",
        "nb_failure": 2,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1298,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.outputTransformer.OutputTransformerContainerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltOutputTransformerContainer.java b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltOutputTransformerContainer.java\nindex d09c100d56..4d1724be89 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltOutputTransformerContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltOutputTransformerContainer.java\n@@ -19,7 +19,6 @@\n import org.apache.wicket.AttributeModifier;\n import org.apache.wicket.Component;\n import org.apache.wicket.markup.MarkupResourceStream;\n-import org.apache.wicket.markup.MarkupType;\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.model.Model;\n \n@@ -29,9 +28,8 @@\n  * with an associated markup and must have a filename equal to the component's id.\n  * <p>\n  * The containers tag will be the root element of the xml data applied for transformation to ensure\n- * the xml data are well formed (single root element). In addition the attribute\n- * <code>xmlns:wicket=\"http://wicket.apache.org/dtds.data/wicket-xhtml1.3-strict.dtd</code> is added\n- * to the root element to allow the XSL processor to handle the wicket namespace.\n+ * the xml data are well formed (single root element). In addition the attribute <code>xmlns:wicket=\"http://wicket.apache.org/dtds.data/wicket-xhtml1.3-strict.dtd</code>\n+ * is added to the root element to allow the XSL processor to handle the wicket namespace.\n  * <p>\n  * Similar to this container, a <code>IBehavior</code> is available which does the same, but does\n  * not require an additional Container.\n@@ -104,12 +102,6 @@ public XsltOutputTransformerContainer(final String id)\n \t\tthis(id, null, null);\n \t}\n \n-\t@Override\n-\tpublic MarkupType getMarkupType()\n-\t{\n-\t\treturn new MarkupType(\"xsl\", null);\n-\t}\n-\n \t@Override\n \tpublic CharSequence transform(final Component component, final CharSequence output)\n \t\tthrows Exception\n",
        "project": "wicket",
        "linesAdd": 0,
        "jira_id": "4391",
        "nb_skipped": 4,
        "commit": "5d64196a",
        "nb_failure": 0,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 22,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.extensions.ajax.markup.html.AjaxEditableTest"
        ],
        "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/ajax/markup/html/AjaxEditableLabel.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/ajax/markup/html/AjaxEditableLabel.java\nindex 15dc1c1291..ee3006e6b1 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/ajax/markup/html/AjaxEditableLabel.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/ajax/markup/html/AjaxEditableLabel.java\n@@ -30,6 +30,7 @@\n import org.apache.wicket.markup.html.form.TextField;\n import org.apache.wicket.markup.html.panel.Panel;\n import org.apache.wicket.model.IModel;\n+import org.apache.wicket.model.IObjectClassAwareModel;\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.util.convert.IConverter;\n import org.apache.wicket.util.string.JavaScriptUtils;\n@@ -391,7 +392,7 @@ protected String getLabelAjaxEvent()\n \t{\n \t\tif (editor == null)\n \t\t{\n-\t\t\tinitLabelAndEditor(getDelegatingParentModel());\n+\t\t\tinitLabelAndEditor(new WrapperModel());\n \t\t}\n \t\treturn editor;\n \t}\n@@ -405,7 +406,7 @@ protected final Component getLabel()\n \t{\n \t\tif (label == null)\n \t\t{\n-\t\t\tinitLabelAndEditor(getDelegatingParentModel());\n+\t\t\tinitLabelAndEditor(new WrapperModel());\n \t\t}\n \t\treturn label;\n \t}\n@@ -420,7 +421,7 @@ protected void onBeforeRender()\n \t\t// lazily add label and editor\n \t\tif (editor == null)\n \t\t{\n-\t\t\tinitLabelAndEditor(getDelegatingParentModel());\n+\t\t\tinitLabelAndEditor(new WrapperModel());\n \t\t}\n \t\t// obsolete with WICKET-1919\n \t\t// label.setEnabled(isEnabledInHierarchy());\n@@ -510,16 +511,11 @@ private void initLabelAndEditor(final IModel<T> model)\n \t}\n \n \t/**\n-\t * get a model that accesses the parent model lazily. this is required since we eventually\n-\t * request the parents model before the component is added to the parent.\n-\t * \n-\t * @return model\n+\t * Model that accesses the parent model lazily. this is required since we eventually request the\n+\t * parents model before the component is added to the parent.\n \t */\n-\tprivate IModel<T> getDelegatingParentModel()\n-\t{\n-\t\treturn new IModel<T>()\n+\tprivate class WrapperModel implements IModel<T>, IObjectClassAwareModel<T>\n \t{\n-\t\t\tprivate static final long serialVersionUID = 1L;\n \n \t\tpublic T getObject()\n \t\t{\n@@ -534,10 +530,21 @@ public void setObject(final T object)\n \t\tpublic void detach()\n \t\t{\n \t\t\tgetParentModel().detach();\n-\t\t\t}\n-\t\t};\n+\n \t\t}\n \n+\t\tpublic Class<T> getObjectClass()\n+\t\t{\n+\t\t\tif (getParentModel() instanceof IObjectClassAwareModel)\n+\t\t\t{\n+\t\t\t\treturn ((IObjectClassAwareModel)getParentModel()).getObjectClass();\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\t}\n \n \t/**\n \t * @return Gets the parent model in case no explicit model was specified.\n",
        "project": "wicket",
        "linesAdd": 18,
        "jira_id": "4259",
        "nb_skipped": 0,
        "commit": "1f128536",
        "nb_failure": 1,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1013,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.validation.validator.UrlValidatorTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java b/wicket/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\nindex cf42f3e55c..b9db5ee7c8 100644\n--- a/wicket/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\n+++ b/wicket/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\n@@ -484,7 +484,7 @@ protected boolean isValidPath(String path)\n \t\t}\n \n \t\tint slashCount = countToken(\"/\", path);\n-\t\tint dot2Count = countToken(\"..\", path);\n+\t\tint dot2Count = countToken(\"/..\", path);\n \t\tif (dot2Count > 0)\n \t\t{\n \t\t\tif ((slashCount - slash2Count - 1) <= dot2Count)\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "3196",
        "nb_skipped": 0,
        "commit": "f1c0f263",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 88,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.UrlTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 364b5d36e6..9fb454cb63 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -81,8 +81,7 @@\n \t * \n \t * @author igor\n \t */\n-\tpublic static enum StringMode \n-\t{\n+\tpublic static enum StringMode {\n \t\t/** local urls are rendered without the host name */\n \t\tLOCAL,\n \t\t/**\n@@ -123,13 +122,13 @@ public Url(final Url url)\n \t{\n \t\tArgs.notNull(url, \"url\");\n \n-\t\tthis.protocol = url.protocol;\n-\t\tthis.host = url.host;\n-\t\tthis.port = url.port;\n-\t\tthis.segments = new ArrayList<String>(url.segments);\n-\t\tthis.parameters = new ArrayList<QueryParameter>(url.parameters);\n-\t\tthis.charsetName = url.charsetName;\n-\t\tthis._charset = url._charset;\n+\t\tprotocol = url.protocol;\n+\t\thost = url.host;\n+\t\tport = url.port;\n+\t\tsegments = new ArrayList<String>(url.segments);\n+\t\tparameters = new ArrayList<QueryParameter>(url.parameters);\n+\t\tcharsetName = url.charsetName;\n+\t\t_charset = url._charset;\n \t}\n \n \t/**\n@@ -938,12 +937,12 @@ public void resolveRelative(final Url relative)\n \t{\n \t\tif (getSegments().size() > 0)\n \t\t{\n-\t\t\t// strip the first non-folder segment\n+\t\t\t// strip the first non-folder segment (if it is not empty)\n \t\t\tgetSegments().remove(getSegments().size() - 1);\n \t\t}\n \n-\t\t// remove leading './' (current folder) and empty segments, process any ../ segments from the\n-\t\t// relative url\n+\t\t// remove leading './' (current folder) and empty segments, process any ../ segments from\n+\t\t// the relative url\n \t\twhile (!relative.getSegments().isEmpty())\n \t\t{\n \t\t\tif (\".\".equals(relative.getSegments().get(0)))\n@@ -968,6 +967,11 @@ else if (\"..\".equals(relative.getSegments().get(0)))\n \t\t\t}\n \t\t}\n \n+\t\tif (!getSegments().isEmpty() && relative.getSegments().isEmpty())\n+\t\t{\n+\t\t\tgetSegments().add(\"\");\n+\t\t}\n+\n \t\t// append the remaining relative segments\n \t\tgetSegments().addAll(relative.getSegments());\n \n@@ -1107,32 +1111,37 @@ public String getQueryString()\n \n \n \t/**\n-\t * Try to reduce url by eliminating '..' and '.' from the path where appropriate\n-\t * (this is somehow similar to {@link java.io.File#getCanonicalPath()}).\n-\t * Either by different / unexpected browser behavior or by malicious attacks it \n-\t * can happen that these kind of redundant urls are processed by wicket. These urls \n-\t * can cause some trouble when mapping the request.\n+\t * Try to reduce url by eliminating '..' and '.' from the path where appropriate (this is\n+\t * somehow similar to {@link java.io.File#getCanonicalPath()}). Either by different / unexpected\n+\t * browser behavior or by malicious attacks it can happen that these kind of redundant urls are\n+\t * processed by wicket. These urls can cause some trouble when mapping the request.\n \t * <p/>\n \t * <strong>example:</strong>\n \t * \n \t * the url\n \t * \n-\t * <pre>  /example/..;jsessionid=234792?0</pre> \n+\t * <pre>\n+\t * /example/..;jsessionid=234792?0\n+\t * </pre>\n \t * \n-\t * will not get normalized by the browser due to the ';jsessionid' string that \n-\t * gets appended by the servlet container. After wicket strips the \n-\t * jsessionid part the resulting internal url will be\n+\t * will not get normalized by the browser due to the ';jsessionid' string that gets appended by\n+\t * the servlet container. After wicket strips the jsessionid part the resulting internal url\n+\t * will be\n \t * \n-\t * <pre>  /example/..</pre>\n+\t * <pre>\n+\t * /example/..\n+\t * </pre>\n \t * \n \t * instead of\n \t * \n-\t * <pre>  /</pre>\n+\t * <pre>\n+\t * /\n+\t * </pre>\n \t * \n \t * <p/>\n \t * \n-\t * This code correlates to \n-\t * <a href=\"https://issues.apache.org/jira/browse/WICKET-4303\">WICKET-4303</a>\n+\t * This code correlates to <a\n+\t * href=\"https://issues.apache.org/jira/browse/WICKET-4303\">WICKET-4303</a>\n \t * \n \t * @return canonical url\n \t */\n@@ -1141,9 +1150,9 @@ public Url canonical()\n \t\tUrl url = new Url(this);\n \t\turl.segments.clear();\n \n-\t\tfor (int i = 0; i < this.segments.size(); i++)\n+\t\tfor (int i = 0; i < segments.size(); i++)\n \t\t{\n-\t\t\tfinal String segment = this.segments.get(i);\n+\t\t\tfinal String segment = segments.get(i);\n \n \t\t\t// drop '.' from path\n \t\t\tif (\".\".equals(segment))\n@@ -1152,7 +1161,7 @@ public Url canonical()\n \t\t\t}\n \n \t\t\t// skip segment if following segment is a '..'\n-\t\t\tif ((i + 1) < this.segments.size() && \"..\".equals(this.segments.get(i + 1)))\n+\t\t\tif ((i + 1) < segments.size() && \"..\".equals(segments.get(i + 1)))\n \t\t\t{\n \t\t\t\ti++;\n \t\t\t\tcontinue;\n",
        "project": "wicket",
        "linesAdd": 16,
        "jira_id": "4789",
        "nb_skipped": 0,
        "commit": "6f0863f4",
        "nb_failure": 2,
        "linesRem": 12,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1425,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ConverterLocatorTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ConverterLocator.java b/wicket-core/src/main/java/org/apache/wicket/ConverterLocator.java\nindex 5e48a832d3..6c85808cd6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ConverterLocator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ConverterLocator.java\n@@ -189,8 +189,10 @@ public ConverterLocator()\n \tpublic final <C> IConverter<C> get(Class<C> c)\n \t{\n \t\t@SuppressWarnings(\"unchecked\")\n-\t\tfinal IConverter<C> converter;\n+\t\tIConverter<C> converter = (IConverter<C>)classToConverter.get(c.getName());\n \n+\t\tif (converter == null)\n+\t\t{\n \t\t\t// Date based converters work with thread unsafe DateFormats and\n \t\t\t// a new instance should be created for each usage\n \t\t\tif (Date.class.equals(c))\n@@ -213,9 +215,6 @@ else if (Calendar.class.equals(c))\n \t\t\t{\n \t\t\t\tconverter = (IConverter<C>) new CalendarConverter();\n \t\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tconverter = (IConverter<C>)classToConverter.get(c.getName());\n \t\t}\n \t\treturn converter;\n \t}\n",
        "project": "wicket",
        "linesAdd": 3,
        "jira_id": "4839",
        "nb_skipped": 5,
        "commit": "8b294488",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 4,
        "nb_test": 1130,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.resolver.issue3989.Issue3989Test"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\nindex 30671b47ab..d8ac442f21 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\n@@ -24,6 +24,7 @@\n import org.apache.wicket.markup.MarkupStream;\n import org.apache.wicket.markup.html.internal.HtmlHeaderContainer;\n import org.apache.wicket.markup.parser.XmlTag.TagType;\n+import org.apache.wicket.markup.resolver.IComponentResolver;\n \n /**\n  * Implements boilerplate as needed by many markup sourcing strategies.\n@@ -41,6 +42,40 @@ public AbstractMarkupSourcingStrategy()\n \n \tpublic abstract IMarkupFragment getMarkup(final MarkupContainer container, final Component child);\n \n+\t/**\n+\t * If the child has not been directly added to the container, but via a\n+\t * TransparentWebMarkupContainer, then we are in trouble. In general Wicket iterates over the\n+\t * markup elements and searches for associated components, not the other way around. Because of\n+\t * TransparentWebMarkupContainer (or more generally resolvers), there is no \"synchronous\" search\n+\t * possible.\n+\t * \n+\t * @param container\n+\t *            the parent container.\n+\t * @param child\n+\t *            The component to find the markup for.\n+\t * @return the markup fragment for the child, or {@code null}.\n+\t */\n+\tprotected IMarkupFragment searchMarkupInTransparentResolvers(final MarkupContainer container,\n+\t\tfinal Component child)\n+\t{\n+\t\tIMarkupFragment markup = null;\n+\n+\t\tfor (Component ch : container)\n+\t\t{\n+\t\t\tif ((ch != child) && (ch instanceof MarkupContainer) &&\n+\t\t\t\t(ch instanceof IComponentResolver))\n+\t\t\t{\n+\t\t\t\tmarkup = ((MarkupContainer)ch).getMarkup(child);\n+\t\t\t\tif (markup != null)\n+\t\t\t\t{\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn markup;\n+\t}\n+\n \t/**\n \t * Make sure we open up open-close tags to open-body-close\n \t */\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java\nindex 3b61f9702a..d3196c6240 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java\n@@ -119,6 +119,12 @@ public IMarkupFragment getMarkup(final MarkupContainer parent, final Component c\n \t\t\treturn associatedMarkup;\n \t\t}\n \n+\t\tassociatedMarkup = searchMarkupInTransparentResolvers(parent, child);\n+\t\tif (associatedMarkup != null)\n+\t\t{\n+\t\t\treturn associatedMarkup;\n+\t\t}\n+\n \t\treturn findMarkupInAssociatedFileHeader(parent, child);\n \t}\n \ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\nindex 9173181a71..24a09e9c45 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n@@ -23,7 +23,6 @@\n import org.apache.wicket.markup.MarkupStream;\n import org.apache.wicket.markup.html.internal.HtmlHeaderContainer;\n import org.apache.wicket.markup.html.list.AbstractItem;\n-import org.apache.wicket.markup.resolver.IComponentResolver;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -32,7 +31,7 @@\n  * \n  * @author Juergen Donnerstag\n  */\n-public final class DefaultMarkupSourcingStrategy implements IMarkupSourcingStrategy\n+public final class DefaultMarkupSourcingStrategy extends AbstractMarkupSourcingStrategy\n {\n \t/** Log for reporting. */\n \tprivate static final Logger log = LoggerFactory.getLogger(DefaultMarkupSourcingStrategy.class);\n@@ -58,6 +57,7 @@ private DefaultMarkupSourcingStrategy()\n \t/**\n \t * Nothing to add to the response by default\n \t */\n+\t@Override\n \tpublic void onComponentTag(final Component component, final ComponentTag tag)\n \t{\n \t}\n@@ -65,6 +65,7 @@ public void onComponentTag(final Component component, final ComponentTag tag)\n \t/**\n \t * Invoke the component's onComponentTagBody().\n \t */\n+\t@Override\n \tpublic void onComponentTagBody(final Component component, final MarkupStream markupStream,\n \t\tfinal ComponentTag openTag)\n \t{\n@@ -74,6 +75,7 @@ public void onComponentTagBody(final Component component, final MarkupStream mar\n \t/**\n \t * Get the markup for the child component, which is assumed to be a child of 'container'.\n \t */\n+\t@Override\n \tpublic IMarkupFragment getMarkup(final MarkupContainer container, final Component child)\n \t{\n \t\t// If the sourcing strategy did not provide one, than ask the component.\n@@ -96,23 +98,11 @@ public IMarkupFragment getMarkup(final MarkupContainer container, final Componen\n \t\t\treturn markup;\n \t\t}\n \n-\t\t// If the child has not been directly added to the container, but via a\n-\t\t// TransparentWebMarkupContainer, then we are in trouble. In general Wicket iterates over\n-\t\t// the markup elements and searches for associated components, not the other way around.\n-\t\t// Because of TransparentWebMarkupContainer (or more generally resolvers), there is no\n-\t\t// \"synchronous\" search possible.\n-\t\tfor (Component ch : container)\n-\t\t{\n-\t\t\tif ((ch != child) && (ch instanceof MarkupContainer) &&\n-\t\t\t\t(ch instanceof IComponentResolver))\n-\t\t\t{\n-\t\t\t\tmarkup = ((MarkupContainer)ch).getMarkup(child);\n+\t\tmarkup = searchMarkupInTransparentResolvers(container, child);\n \t\tif (markup != null)\n \t\t{\n \t\t\treturn markup;\n \t\t}\n-\t\t\t}\n-\t\t}\n \n \t\t// This is to make migration for Items from 1.4 to 1.5 more easy\n \t\tif (Character.isDigit(child.getId().charAt(0)))\n@@ -156,6 +146,7 @@ public IMarkupFragment getMarkup(final MarkupContainer container, final Componen\n \t/**\n \t * Empty: nothing will be added to the header by default\n \t */\n+\t@Override\n \tpublic void renderHead(final Component component, HtmlHeaderContainer container)\n \t{\n \t}\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/IMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/IMarkupSourcingStrategy.java\nindex bfc2240853..7cc8fb262b 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/IMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/IMarkupSourcingStrategy.java\n@@ -22,6 +22,7 @@\n import org.apache.wicket.markup.IMarkupFragment;\n import org.apache.wicket.markup.MarkupStream;\n import org.apache.wicket.markup.html.internal.HtmlHeaderContainer;\n+import org.apache.wicket.markup.resolver.IComponentResolver;\n \n /**\n  * Markup sourcing strategies determine whether a Component behaves like a \"Panel\" pulling its\n@@ -79,10 +80,11 @@ void onComponentTagBody(final Component component, final MarkupStream markupStre\n \t * @see MarkupContainer#getMarkup(Component)\n \t * \n \t * @param container\n-\t *            The parent containing the child. (@TODO Is container ever != child.getParent()??)\n+\t *            The parent containing the child. This is not the direct parent, transparent\n+\t *            component {@link IComponentResolver resolver} may be in the hierarchy between.\n \t * @param child\n \t *            The component to find the markup for.\n-\t * @return markup fragment\n+\t * @return the markup fragment for the child, or {@code null}.\n \t */\n \tIMarkupFragment getMarkup(final MarkupContainer container, final Component child);\n }\n",
        "project": "wicket",
        "linesAdd": 35,
        "jira_id": "3989",
        "nb_skipped": 2,
        "commit": "6a8fc1cc",
        "nb_failure": 0,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1703,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.mapper.CryptoMapperTest",
            "org.apache.wicket.settings.ISecuritySettingsTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\nindex 05e7c30865..99f7afc878 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\n@@ -16,6 +16,7 @@\n  */\r\n package org.apache.wicket.core.request.mapper;\r\n \r\n+import java.util.Iterator;\r\n import java.util.List;\r\n \r\n import org.apache.wicket.Application;\r\n@@ -25,6 +26,7 @@\n import org.apache.wicket.request.Request;\r\n import org.apache.wicket.request.Url;\r\n import org.apache.wicket.request.mapper.IRequestMapperDelegate;\r\n+import org.apache.wicket.request.mapper.info.PageComponentInfo;\r\n import org.apache.wicket.util.IProvider;\r\n import org.apache.wicket.util.crypt.ICrypt;\r\n import org.apache.wicket.util.crypt.ICryptFactory;\r\n@@ -34,16 +37,37 @@\n import org.slf4j.LoggerFactory;\r\n \r\n /**\r\n- * Request mapper that encrypts urls generated by another mapper. The original URL (both segments\r\n- * and parameters) is encrypted and is represented as URL segment. To be able to handle relative\r\n- * URLs for images in .css file the same amount of URL segments that the original URL had are\r\n- * appended to the encrypted URL. Each segment has a precise 5 character value, calculated using a\r\n- * checksum. This helps in calculating the relative distance from the original URL. When a URL is\r\n- * returned by the browser, we iterate through these checksummed placeholder URL segments. If the\r\n- * segment matches the expected checksum, then the segment it deemed to be the corresponding segment\r\n- * in the encrypted URL. If the segment does not match the expected checksum, then the segment is\r\n- * deemed a plain text sibling of the corresponding segment in the encrypted URL, and all subsequent\r\n+ * <p>\r\n+ * A request mapper that encrypts URLs generated by another mapper. This mapper encrypts the segments\r\n+ * and query parameters of URLs starting with {@code /wicket/}, and the just the {@link PageComponentInfo}\r\n+ * parameter for mounted URLs.\r\n+ * </p>\r\n+ * \r\n+ * <p>\r\n+ * This mapper can be mounted before or after mounting other pages, but will only encrypt URLs for\r\n+ * pages mounted before the {@link CryptoMapper}. If required, multiple {@link CryptoMapper}s may be\r\n+ * installed in an {@link Application}.\r\n+ * </p>\r\n+ * \r\n+ * <p>\r\n+ * When encrypting URLs in the Wicket namespace (starting with {@code /wicket/}), the entire URL, including\r\n+ * segments and parameters, is encrypted, with the encrypted form stored in the first segment of the encrypted URL.\r\n+ * </p>\r\n+ * \r\n+ * <p>\r\n+ * To be able to handle relative URLs, like for image URLs in a CSS file, checksum segments are appended to the\r\n+ * encrypted URL until the encrypted URL has the same number of segments as the original URL had.\r\n+ * Each checksum segment has a precise 5 character value, calculated using a checksum. This helps in calculating\r\n+ * the relative distance from the original URL. When a URL is returned by the browser, we iterate through these\r\n+ * checksummed placeholder URL segments. If the segment matches the expected checksum, then the segment it deemed\r\n+ * to be the corresponding segment in the original URL. If the segment does not match the expected checksum, then\r\n+ * the segment is deemed a plain text sibling of the corresponding segment in the original URL, and all subsequent\r\n  * segments are considered plain text children of the current segment.\r\n+ * </p>\r\n+ * \r\n+ * <p>\r\n+ * When encrypting mounted URLs, we look for the {@link PageComponentInfo} parameter, and encrypt only that parameter.\r\n+ * </p>\r\n  * \r\n  * @author igor.vaynberg\r\n  * @author Jesse Long\r\n@@ -53,6 +77,11 @@\n {\r\n \tprivate static final Logger log = LoggerFactory.getLogger(CryptoMapper.class);\r\n \r\n+\t/**\r\n+\t * Name of the parameter which contains encrypted page component info.\r\n+\t */\r\n+\tprivate static final String ENCRYPTED_PAGE_COMPONENT_INFO_PARAMETER = \"wicket\";\r\n+\r\n \tprivate final IRequestMapper wrappedMapper;\r\n \tprivate final IProvider<ICrypt> cryptProvider;\r\n \r\n@@ -87,12 +116,34 @@ public CryptoMapper(final IRequestMapper wrappedMapper, final IProvider<ICrypt>\n \t\tthis.cryptProvider = Args.notNull(cryptProvider, \"cryptProvider\");\r\n \t}\r\n \r\n+\t/**\r\n+\t * {@inheritDoc}\r\n+\t * <p>\r\n+\t * This implementation decrypts the URL and passes the decrypted URL to the wrapped mapper.\r\n+\t * </p>\r\n+\t * @param request\r\n+\t *\t\tThe request for which to get a compatability score.\r\n+\t * \r\n+\t * @return The compatability score.\r\n+\t */\r\n \t@Override\r\n \tpublic int getCompatibilityScore(final Request request)\r\n \t{\r\n-\t\treturn wrappedMapper.getCompatibilityScore(request);\r\n+\t\tUrl decryptedUrl = decryptUrl(request, request.getUrl());\r\n+\r\n+\t\tif (decryptedUrl == null)\r\n+\t\t{\r\n+\t\t\treturn 0;\r\n \t\t}\r\n \r\n+\t\tRequest decryptedRequest = request.cloneWithUrl(decryptedUrl);\r\n+\r\n+\t\treturn wrappedMapper.getCompatibilityScore(decryptedRequest);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * {@inheritDoc}\r\n+\t */\r\n \t@Override\r\n \tpublic Url mapHandler(final IRequestHandler requestHandler)\r\n \t{\r\n@@ -112,6 +163,9 @@ public Url mapHandler(final IRequestHandler requestHandler)\n \t\treturn encryptUrl(url);\r\n \t}\r\n \r\n+\t/**\r\n+\t * {@inheritDoc}\r\n+\t */\r\n \t@Override\r\n \tpublic IRequestHandler mapRequest(final Request request)\r\n \t{\r\n@@ -119,7 +173,7 @@ public IRequestHandler mapRequest(final Request request)\n \r\n \t\tif (url == null)\r\n \t\t{\r\n-\t\t\treturn wrappedMapper.mapRequest(request);\r\n+\t\t\treturn null;\r\n \t\t}\r\n \r\n \t\tRequest decryptedRequest = request.cloneWithUrl(url);\r\n@@ -152,18 +206,44 @@ public final IRequestMapper getDelegateMapper()\n \t\treturn wrappedMapper;\r\n \t}\r\n \r\n+\t/**\r\n+\t * Encrypts a URL. This method should return a new, encrypted instance of the URL. If the URL starts with {@code /wicket/},\r\n+\t * the entire URL is encrypted.\r\n+\t * \r\n+\t * @param url\r\n+\t *\t\tThe URL to encrypt.\r\n+\t * \r\n+\t * @return A new, encrypted version of the URL.\r\n+\t */\r\n \tprotected Url encryptUrl(final Url url)\r\n \t{\r\n-\t\tif (url.getSegments().isEmpty())\r\n+\t\tif (url.getSegments().size() > 0\r\n+\t\t\t&& url.getSegments().get(0).equals(Application.get().getMapperContext().getNamespace()))\r\n \t\t{\r\n-\t\t\treturn url;\r\n+\t\t\treturn encryptEntireUrl(url);\r\n \t\t}\r\n+\t\telse\r\n+\t\t{\r\n+\t\t\treturn encryptRequestListenerParameter(url);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Encrypts an entire URL, segments and query parameters.\r\n+\t * \r\n+\t * @param url\r\n+\t *\t\tThe URL to encrypt.\r\n+\t * \r\n+\t * @return An encrypted form of the URL.\r\n+\t */\r\n+\tprotected Url encryptEntireUrl(final Url url)\r\n+\t{\r\n \t\tString encryptedUrlString = getCrypt().encryptUrlSafe(url.toString());\r\n \r\n \t\tUrl encryptedUrl = new Url(url.getCharset());\r\n \t\tencryptedUrl.getSegments().add(encryptedUrlString);\r\n \r\n-\t\tint numberOfSegments = url.getSegments().size();\r\n+\t\tint numberOfSegments = url.getSegments().size() - 1;\r\n \t\tHashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\r\n \t\tfor (int segNo = 0; segNo < numberOfSegments; segNo++)\r\n \t\t{\r\n@@ -172,25 +252,108 @@ protected Url encryptUrl(final Url url)\n \t\treturn encryptedUrl;\r\n \t}\r\n \r\n+\t/**\r\n+\t * Encrypts the {@link PageComponentInfo} query parameter in the URL, if any is found.\r\n+\t * \r\n+\t * @param url\r\n+\t *\t\tThe URL to encrypt.\r\n+\t * \r\n+\t * @return An encrypted form of the URL.\r\n+\t */\r\n+\tprotected Url encryptRequestListenerParameter(final Url url)\r\n+\t{\r\n+\t\tUrl encryptedUrl = new Url(url);\r\n+\r\n+\t\tfor (Iterator<Url.QueryParameter> it = encryptedUrl.getQueryParameters().iterator(); it.hasNext();)\r\n+\t\t{\r\n+\t\t\tUrl.QueryParameter qp = it.next();\r\n+\r\n+\t\t\tif (Strings.isEmpty(qp.getValue()) == true && Strings.isEmpty(qp.getName()) == false)\r\n+\t\t\t{\r\n+\t\t\t\tif (PageComponentInfo.parse(qp.getName()) != null)\r\n+\t\t\t\t{\r\n+\t\t\t\t\tit.remove();\r\n+\t\t\t\t\tString encryptedParameterValue = getCrypt().encryptUrlSafe(qp.getName());\r\n+\t\t\t\t\tUrl.QueryParameter encryptedParameter\r\n+\t\t\t\t\t\t= new Url.QueryParameter(ENCRYPTED_PAGE_COMPONENT_INFO_PARAMETER, encryptedParameterValue);\r\n+\t\t\t\t\tencryptedUrl.getQueryParameters().add(0, encryptedParameter);\r\n+\t\t\t\t\tbreak;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n+\r\n+\t\treturn encryptedUrl;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Decrypts a {@link Url}. This method should return {@code null} if the URL is not decryptable, or if the\r\n+\t * URL should have been encrypted but was not. Returning {@code null} results in a 404 error.\r\n+\t * \r\n+\t * @param request\r\n+\t *\t\tThe {@link Request}.\r\n+\t * @param encryptedUrl\r\n+\t *\t\tThe encrypted {@link Url}.\r\n+\t * \r\n+\t * @return Returns a decrypted {@link Url}.\r\n+\t */\r\n \tprotected Url decryptUrl(final Request request, final Url encryptedUrl)\r\n+\t{\r\n+\t\tUrl url = decryptEntireUrl(request, encryptedUrl);\r\n+\r\n+\t\tif (url == null)\r\n+\t\t{\r\n+\t\t\tif (encryptedUrl.getSegments().size() > 0\r\n+\t\t\t\t&& encryptedUrl.getSegments().get(0).equals(Application.get().getMapperContext().getNamespace()))\r\n \t\t\t{\r\n \t\t\t\t/*\r\n-\t\t * If the encrypted URL has no segments it is the home page URL, and does not need\r\n-\t\t * decrypting.\r\n+\t\t\t\t * This URL should have been encrypted, but was not. We should refuse to handle this, except when\r\n+\t\t\t\t * there is more than one CryptoMapper installed, and the request was decrypted by some other\r\n+\t\t\t\t * CryptoMapper.\r\n \t\t\t\t */\r\n-\t\tif (encryptedUrl.getSegments().isEmpty())\r\n+\t\t\t\tif (request.getOriginalUrl().getSegments().size() > 0\r\n+\t\t\t\t\t&& request.getOriginalUrl().getSegments().get(0).equals(Application.get().getMapperContext().getNamespace()))\r\n+\t\t\t\t{\r\n+\t\t\t\t\treturn null;\r\n+\t\t\t\t}\r\n+\t\t\t\telse\r\n \t\t\t\t{\r\n \t\t\t\t\treturn encryptedUrl;\r\n \t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n \r\n-\t\tList<String> encryptedSegments = encryptedUrl.getSegments();\r\n+\t\tif (url == null)\r\n+\t\t{\r\n+\t\t\turl = decryptRequestListenerParameter(request, encryptedUrl);\r\n+\t\t}\r\n \r\n+\t\treturn url;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Decrypts an entire URL, which was previously encrypted by {@link #encryptEntireUrl(org.apache.wicket.request.Url)}.\r\n+\t * This method should return {@code null} if the URL is not decryptable.\r\n+\t * \r\n+\t * @param request\r\n+\t *\t\tThe request that was made.\r\n+\t * @param encryptedUrl\r\n+\t *\t\tThe encrypted URL.\r\n+\t * \r\n+\t * @return A decrypted form of the URL, or {@code null} if the URL is not decryptable.\r\n+\t */\r\n+\tprotected Url decryptEntireUrl(final Request request, final Url encryptedUrl)\r\n+\t{\r\n \t\tUrl url = new Url(request.getCharset());\r\n-\t\ttry\r\n+\r\n+\t\tList<String> encryptedSegments = encryptedUrl.getSegments();\r\n+\r\n+\t\tif (encryptedSegments.isEmpty())\r\n \t\t{\r\n+\t\t\treturn null;\r\n+\t\t}\r\n+\r\n \t\t/*\r\n-\t\t\t * The first encrypted segment contains an encrypted version of the entire plain text\r\n-\t\t\t * url.\r\n+\t\t * The first encrypted segment contains an encrypted version of the entire plain text url.\r\n \t\t */\r\n \t\tString encryptedUrlString = encryptedSegments.get(0);\r\n \t\tif (Strings.isEmpty(encryptedUrlString))\r\n@@ -198,7 +361,17 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\t\treturn null;\r\n \t\t}\r\n \r\n-\t\t\tString decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\r\n+\t\tString decryptedUrl;\r\n+\t\ttry\r\n+\t\t{\r\n+\t\t\tdecryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\r\n+\t\t}\r\n+\t\tcatch (Exception e)\r\n+\t\t{\r\n+\t\t\tlog.error(\"Error decrypting URL\", e);\r\n+\t\t\treturn null;\r\n+\t\t}\r\n+\r\n \t\tif (decryptedUrl == null)\r\n \t\t{\r\n \t\t\treturn null;\r\n@@ -208,6 +382,28 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\tint originalNumberOfSegments = originalUrl.getSegments().size();\r\n \t\tint encryptedNumberOfSegments = encryptedUrl.getSegments().size();\r\n \r\n+\t\tif (originalNumberOfSegments > 0)\r\n+\t\t{\r\n+\t\t\t/*\r\n+\t\t\t * This should always be true. Home page URLs are the only ones without\r\n+\t\t\t * segments, and we dont encrypt those with this method.\r\n+\t\t\t * \r\n+\t\t\t * We always add the first segment of the URL, because we encrypt a URL like:\r\n+\t\t\t *\t/path/to/something\r\n+\t\t\t * to:\r\n+\t\t\t *\t/encrypted_full/hash/hash\r\n+\t\t\t * \r\n+\t\t\t * Notice the consistent number of segments. If we applied the following relative URL:\r\n+\t\t\t *\t../../something\r\n+\t\t\t * then the resultant URL would be:\r\n+\t\t\t *\t/something\r\n+\t\t\t * \r\n+\t\t\t * Hence, the mere existence of the first, encrypted version of complete URL, segment\r\n+\t\t\t * tells us that the first segment of the original URL is still to be used.\r\n+\t\t\t */\r\n+\t\t\turl.getSegments().add(originalUrl.getSegments().get(0));\r\n+\t\t}\r\n+\r\n \t\tHashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\r\n \t\tint segNo = 1;\r\n \t\tfor (; segNo < encryptedNumberOfSegments; segNo++)\r\n@@ -222,18 +418,18 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\t\tif (!next.equals(encryptedSegment))\r\n \t\t\t{\r\n \t\t\t\t/*\r\n-\t\t\t\t\t * This segment received from the browser is not the same as the expected\r\n-\t\t\t\t\t * segment generated by the HashSegmentGenerator. Hence it, and all subsequent\r\n-\t\t\t\t\t * segments are considered plain text siblings of the original encrypted url.\r\n+\t\t\t\t * This segment received from the browser is not the same as the expected segment generated\r\n+\t\t\t\t * by the HashSegmentGenerator. Hence it, and all subsequent segments are considered plain\r\n+\t\t\t\t * text siblings of the original encrypted url.\r\n \t\t\t\t */\r\n \t\t\t\tbreak;\r\n \t\t\t}\r\n \r\n \t\t\t/*\r\n-\t\t\t\t * This segments matches the expected checksum, so we add the corresponding segment\r\n-\t\t\t\t * from the original URL.\r\n+\t\t\t * This segments matches the expected checksum, so we add the corresponding segment from the\r\n+\t\t\t * original URL.\r\n \t\t\t */\r\n-\t\t\t\turl.getSegments().add(originalUrl.getSegments().get(segNo - 1));\r\n+\t\t\turl.getSegments().add(originalUrl.getSegments().get(segNo));\r\n \t\t}\r\n \t\t/*\r\n \t\t * Add all remaining segments from the encrypted url as plain text segments.\r\n@@ -247,11 +443,83 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\turl.getQueryParameters().addAll(originalUrl.getQueryParameters());\r\n \t\t// WICKET-4923 additional parameters\r\n \t\turl.getQueryParameters().addAll(encryptedUrl.getQueryParameters());\r\n+\r\n+\t\treturn url;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Decrypts a URL which may contain an encrypted {@link PageComponentInfo} query parameter.\r\n+\t * \r\n+\t * @param request\r\n+\t *\t\tThe request that was made.\r\n+\t * @param encryptedUrl\r\n+\t *\t\tThe (potentially) encrypted URL.\r\n+\t * \r\n+\t * @return A decrypted form of the URL.\r\n+\t */\r\n+\tprotected Url decryptRequestListenerParameter(final Request request, Url encryptedUrl)\r\n+\t{\r\n+\t\tUrl url = new Url(encryptedUrl);\r\n+\r\n+\t\turl.getQueryParameters().clear();\r\n+\r\n+\t\tfor (Url.QueryParameter qp : encryptedUrl.getQueryParameters())\r\n+\t\t{\r\n+\t\t\tif (Strings.isEmpty(qp.getValue()) && Strings.isEmpty(qp.getName()) == false)\r\n+\t\t\t{\r\n+\t\t\t\tif (PageComponentInfo.parse(qp.getName()) != null)\r\n+\t\t\t\t{\r\n+\t\t\t\t\t/*\r\n+\t\t\t\t\t * Plain text request listener parameter found. This should have been encrypted, so we\r\n+\t\t\t\t\t * refuse to map the request unless the original URL did not include this parameter, which\r\n+\t\t\t\t\t * case there are likely to be multiple cryptomappers installed.\r\n+\t\t\t\t\t */\r\n+\t\t\t\t\tif (request.getOriginalUrl().getQueryParameter(qp.getName()) == null)\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\turl.getQueryParameters().add(qp);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\treturn null;\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\telse if (ENCRYPTED_PAGE_COMPONENT_INFO_PARAMETER.equals(qp.getName()))\r\n+\t\t\t{\r\n+\t\t\t\tString encryptedValue = qp.getValue();\r\n+\r\n+\t\t\t\tif (Strings.isEmpty(encryptedValue))\r\n+\t\t\t\t{\r\n+\t\t\t\t\turl.getQueryParameters().add(qp);\r\n+\t\t\t\t}\r\n+\t\t\t\telse\r\n+\t\t\t\t{\r\n+\t\t\t\t\tString decryptedValue = null;\r\n+\r\n+\t\t\t\t\ttry\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\tdecryptedValue = getCrypt().decryptUrlSafe(encryptedValue);\r\n \t\t\t\t\t}\r\n \t\t\t\t\tcatch (Exception e)\r\n \t\t\t\t\t{\r\n-\t\t\tlog.error(\"Error decrypting URL\", e);\r\n-\t\t\turl = null;\r\n+\t\t\t\t\t\tlog.error(\"Error decrypting encrypted request listener query parameter\", e);\r\n+\t\t\t\t\t}\r\n+\r\n+\t\t\t\t\tif (Strings.isEmpty(decryptedValue))\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\turl.getQueryParameters().add(qp);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\tUrl.QueryParameter decryptedParamter = new Url.QueryParameter(decryptedValue, \"\");\r\n+\t\t\t\t\t\turl.getQueryParameters().add(0, decryptedParamter);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\telse\r\n+\t\t\t{\r\n+\t\t\t\turl.getQueryParameters().add(qp);\r\n+\t\t\t}\r\n \t\t}\r\n \r\n \t\treturn url;\r\n",
        "project": "wicket",
        "linesAdd": 159,
        "jira_id": "5326",
        "nb_skipped": 1,
        "commit": "ded3c583",
        "nb_failure": 15,
        "linesRem": 12,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1127,
        "nb_error": 8,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.ComponentMarkupIdTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 6644c24a63..e81ffa5b79 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -1499,18 +1499,20 @@ public final ValueMap getMarkupAttributes()\n \t */\n \tpublic final Object getMarkupIdImpl()\n \t{\n-\t\tString id = getMarkupIdFromMarkup();\n-\t\tif (id != null)\n-\t\t{\n-\t\t\treturn id;\n-\t\t}\n-\n \t\tif (generatedMarkupId != -1)\n \t\t{\n \t\t\treturn generatedMarkupId;\n \t\t}\n \n-\t\treturn getMetaData(MARKUP_ID_KEY);\n+\t\tString id = getMetaData(MARKUP_ID_KEY);\n+\n+\t\t// if still no markup id is found, and the component has been attached to a page, try to\n+\t\t// retrieve the id from the markup file.\n+\t\tif (id == null && findPage() != null)\n+\t\t{\n+\t\t\tid = getMarkupIdFromMarkup();\n+\t\t}\n+\t\treturn id;\n \t}\n \n \t/**\n",
        "project": "wicket",
        "linesAdd": 7,
        "jira_id": "3647",
        "nb_skipped": 0,
        "commit": "1b57b51c",
        "nb_failure": 0,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1545,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.tester.WicketTesterLazyIsPageStatelessRedirectToRenderTest",
            "org.apache.wicket.util.tester.WicketTesterLazyIsPageStatelessRedirectToBufferTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Page.java b/wicket-core/src/main/java/org/apache/wicket/Page.java\nindex 2be236d342..1a3e9aa2ad 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Page.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Page.java\n@@ -801,11 +801,8 @@ protected void onBeforeRender()\n \t\t// Make sure it is really empty\n \t\trenderedComponents = null;\n \n-\t\t// if the page is stateless, reset the flag so that it is tested again\n-\t\tif (Boolean.TRUE.equals(stateless))\n-\t\t{\n+\t\t// rendering might remove or add stateful components, so clear flag to force reevaluation\n \t\tstateless = null;\n-\t\t}\n \n \t\tsuper.onBeforeRender();\n \n@@ -1020,6 +1017,8 @@ public void renderPage()\n \t\t{\n \t\t\t++renderCount;\n \t\t\trender();\n+\n+\t\t\t// stateless = null;\n \t\t}\n \t\tfinally\n \t\t{\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "5426",
        "nb_skipped": 2,
        "commit": "fb45a781",
        "nb_failure": 2,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 156,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.time.DurationTest"
        ],
        "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/time/Duration.java b/wicket-util/src/main/java/org/apache/wicket/util/time/Duration.java\nindex fc232bf5f3..c366990edc 100755\n--- a/wicket-util/src/main/java/org/apache/wicket/util/time/Duration.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/time/Duration.java\n@@ -526,7 +526,7 @@ public String toString(final Locale locale)\n \t\t\t\treturn unitString(seconds(), \"second\", locale);\r\n \t\t\t}\r\n \r\n-\t\t\treturn unitString(seconds(), \"millisecond\", locale);\r\n+\t\t\treturn unitString(getMilliseconds(), \"millisecond\", locale);\r\n \t\t}\r\n \t\telse\r\n \t\t{\r\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "4597",
        "nb_skipped": 0,
        "commit": "9dab1bb5",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 408,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "wicket.request.target.coding.PackageRequestTargetUrlCodingStrategyTest"
        ],
        "patch": "diff --git a/jdk-1.4/wicket/src/main/java/wicket/protocol/http/request/WebRequestCodingStrategy.java b/jdk-1.4/wicket/src/main/java/wicket/protocol/http/request/WebRequestCodingStrategy.java\nindex e8b827210c..958029633f 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/protocol/http/request/WebRequestCodingStrategy.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/protocol/http/request/WebRequestCodingStrategy.java\n@@ -968,6 +968,12 @@ public IRequestTargetUrlCodingStrategy strategyForPath(String path)\n \t\t\t\tfinal String key = (String)entry.getKey();\n \t\t\t\tif (path.startsWith(key))\n \t\t\t\t{\n+\t\t\t\t\t/*\n+\t\t\t\t\t * We need to match /mount/point or\n+\t\t\t\t\t * /mount/point/with/extra/path, but not /mount/pointXXX\n+\t\t\t\t\t */\n+\t\t\t\t\tString remainder = path.substring(key.length());\n+\t\t\t\t\tif (remainder.length() == 0 || remainder.startsWith(\"/\"))\n \t\t\t\t\t\treturn (IRequestTargetUrlCodingStrategy)entry.getValue();\n \t\t\t\t}\n \t\t\t}\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/request/target/coding/PackageRequestTargetUrlCodingStrategy.java b/jdk-1.4/wicket/src/main/java/wicket/request/target/coding/PackageRequestTargetUrlCodingStrategy.java\nindex eaa6fd3133..f18bf62833 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/request/target/coding/PackageRequestTargetUrlCodingStrategy.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/request/target/coding/PackageRequestTargetUrlCodingStrategy.java\n@@ -16,6 +16,9 @@\n  */\n package wicket.request.target.coding;\n \n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+\n import wicket.IRequestTarget;\n import wicket.PageParameters;\n import wicket.Session;\n@@ -35,6 +38,7 @@\n  */\n public class PackageRequestTargetUrlCodingStrategy extends AbstractRequestTargetUrlCodingStrategy\n {\n+\tprivate static final Log log = LogFactory.getLog(PackageRequestTargetUrlCodingStrategy.class);\n \t/** package for this mount. */\n \tprivate final PackageName packageName;\n \n@@ -57,7 +61,9 @@ public PackageRequestTargetUrlCodingStrategy(final String path, PackageName pack\n \t */\n \tpublic IRequestTarget decode(RequestParameters requestParameters)\n \t{\n+\t\tlog.debug(\"path=\"+requestParameters.getPath());\n \t\tString remainder = requestParameters.getPath().substring(getMountPath().length());\n+\t\tlog.debug(\"remainder=\"+remainder);\n \t\tfinal String parametersFragment;\n \t\tint ix = remainder.indexOf('/', 1);\n \t\tif (ix == -1)\n@@ -75,7 +81,14 @@ public IRequestTarget decode(RequestParameters requestParameters)\n \t\t\tremainder = remainder.substring(1);\n \t\t\tix--;\n \t\t}\n+\t\telse\n+\t\t{\n+\t\t\t// There is nothing after the mount path!\n+\t\t\treturn null;\n+\t\t}\n \n+\t\tlog.debug(\"remainder=\"+remainder);\n+\t\tlog.debug(\"parametersFragment=\"+parametersFragment);\n \t\tfinal String bookmarkablePageClassName = packageName + \".\" + remainder.substring(0, ix);\n \t\tClass bookmarkablePageClass = Session.get().getClassResolver().resolveClass(\n \t\t\t\tbookmarkablePageClassName);\n",
        "project": "wicket",
        "linesAdd": 14,
        "jira_id": "294",
        "nb_skipped": 0,
        "commit": "5c592d85",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1084,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.page.PersistentPageManagerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/pageStore/DefaultPageStore.java b/wicket-core/src/main/java/org/apache/wicket/pageStore/DefaultPageStore.java\nindex 17a812b8a3..675f320520 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/pageStore/DefaultPageStore.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/pageStore/DefaultPageStore.java\n@@ -22,7 +22,6 @@\n import java.util.Iterator;\n import java.util.List;\n \n-import org.apache.wicket.Page;\n import org.apache.wicket.page.IManageablePage;\n import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.lang.Objects;\n@@ -275,7 +274,7 @@ public Object restoreAfterSerialization(final Serializable serializable)\n \t\t{\n \t\t\treturn null;\n \t\t}\n-\t\telse if (!storeAfterSessionReplication() || serializable instanceof Page)\n+\t\telse if (!storeAfterSessionReplication() || serializable instanceof IManageablePage)\n \t\t{\n \t\t\treturn serializable;\n \t\t}\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "3420",
        "nb_skipped": 0,
        "commit": "be97d017",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1744,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.form.FormValidationDisabledFormComponentTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/feedback/IFeedbackMessageFilter.java b/wicket-core/src/main/java/org/apache/wicket/feedback/IFeedbackMessageFilter.java\nindex 83706e5624..fdd305737a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/feedback/IFeedbackMessageFilter.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/feedback/IFeedbackMessageFilter.java\n@@ -28,7 +28,7 @@\n \t/**\n \t * Filter that returns simply all available messages.\n \t */\n-\tpublic static final IFeedbackMessageFilter ALL = new IFeedbackMessageFilter()\n+\tIFeedbackMessageFilter ALL = new IFeedbackMessageFilter()\n \t{\n \t\tprivate static final long serialVersionUID = 1L;\n \n@@ -42,7 +42,7 @@ public boolean accept(FeedbackMessage message)\n \t/**\n \t * Filter that does not match any message\n \t */\n-\tpublic static final IFeedbackMessageFilter NONE = new IFeedbackMessageFilter()\n+\tIFeedbackMessageFilter NONE = new IFeedbackMessageFilter()\n \t{\n \t\tprivate static final long serialVersionUID = 1L;\n \ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\nindex 93adebe1cd..aa6ba6369c 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n@@ -1145,7 +1145,7 @@ private boolean anyFormComponentError()\n \t\t\t@Override\n \t\t\tpublic void component(final Component component, final IVisit<Boolean> visit)\n \t\t\t{\n-\t\t\t\tif (component.hasErrorMessage())\n+\t\t\t\tif (component.isVisibleInHierarchy() && component.isEnabledInHierarchy() && component.hasErrorMessage())\n \t\t\t\t{\n \t\t\t\t\tvisit.stop(true);\n \t\t\t\t}\n",
        "project": "wicket",
        "linesAdd": 3,
        "jira_id": "5883",
        "nb_skipped": 1,
        "commit": "cd3b9234",
        "nb_failure": 2,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1498,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.parser.filter.OpenCloseTagExpanderTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/OpenCloseTagExpander.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/OpenCloseTagExpander.java\nindex f737c749e3..9e3abf8c51 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/OpenCloseTagExpander.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/OpenCloseTagExpander.java\n@@ -37,6 +37,10 @@\n  */\r\n public class OpenCloseTagExpander extends AbstractMarkupFilter\r\n {\r\n+\t// A list of elements which should not be expanded from TagType.OPEN_CLOSE to TagType.OPEN + TagType.CLOSE\r\n+\t// http://www.w3.org/TR/html-markup/syntax.html#void-element\r\n+\t// area, base, br, col, command, embed, hr, img, input, keygen, link, meta, param, source, track, wbr\r\n+\r\n \tprivate static final List<String> replaceForTags = Arrays.asList(\"a\", \"q\", \"sub\", \"sup\",\r\n \t\t\"abbr\", \"acronym\", \"cite\", \"code\", \"del\", \"dfn\", \"em\", \"ins\", \"kbd\", \"samp\", \"var\",\r\n \t\t\"label\", \"textarea\", \"tr\", \"td\", \"th\", \"caption\", \"thead\", \"tbody\", \"tfoot\", \"dl\", \"dt\",\r\n@@ -52,12 +56,9 @@\n \t\t\"b\",\r\n \t\t\"e\",\r\n \t\t\"select\",\r\n-\t\t\"col\",\r\n \r\n-\t\t// New HTML5 elements (excluding: open-close tags:\r\n-\t\t// wbr, source, time, embed, keygen\r\n \t\t// @TODO by now an exclude list is probably shorter\r\n-\t\t\"article\", \"aside\", \"command\", \"details\", \"summary\", \"figure\", \"figcaption\", \"footer\",\r\n+\t\t\"article\", \"aside\", \"details\", \"summary\", \"figure\", \"figcaption\", \"footer\",\r\n \t\t\"header\", \"hgroup\", \"mark\", \"meter\", \"nav\", \"progress\", \"ruby\", \"rt\", \"rp\", \"section\",\r\n \t\t\"audio\", \"video\", \"canvas\", \"datalist\", \"output\");\r\n \r\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "5237",
        "nb_skipped": 4,
        "commit": "b61fe92c",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 98,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.UrlTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex b9769e85fd..596163e9ac 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -263,7 +263,8 @@ public static Url parse(CharSequence _url, Charset charset)\n \t\t\t\thostAndPort = afterProto.substring(0, relativeAt);\n \t\t\t}\n \n-\t\t\tfinal int portAt = hostAndPort.lastIndexOf(':');\n+\t\t\tfinal int credentialsAt = hostAndPort.lastIndexOf('@') + 1;\n+\t\t\tfinal int portAt = hostAndPort.substring(credentialsAt).lastIndexOf(':');\n \n \t\t\tif (portAt == -1)\n \t\t\t{\n@@ -272,8 +273,8 @@ public static Url parse(CharSequence _url, Charset charset)\n \t\t\t}\n \t\t\telse\n \t\t\t{\n-\t\t\t\tresult.host = hostAndPort.substring(0, portAt);\n-\t\t\t\tresult.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\n+\t\t\t\tresult.host = hostAndPort.substring(0, portAt + credentialsAt);\n+\t\t\t\tresult.port = Integer.parseInt(hostAndPort.substring(portAt + credentialsAt + 1));\n \t\t\t}\n \n \t\t\tif (relativeAt < 0)\n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "5259",
        "nb_skipped": 0,
        "commit": "a9e56e1e",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.bean.validation.DefaultPropertyResolverTest"
        ],
        "patch": "diff --git a/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/DefaultPropertyResolver.java b/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/DefaultPropertyResolver.java\nindex 91eb1a3882..442bca2627 100644\n--- a/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/DefaultPropertyResolver.java\n+++ b/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/DefaultPropertyResolver.java\n@@ -3,6 +3,7 @@\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n \n+import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.markup.html.form.FormComponent;\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.model.IPropertyReflectionAwareModel;\n@@ -50,11 +51,26 @@ public Property resolveProperty(FormComponent<?> component)\n \t\t\treturn new Property(field.getDeclaringClass(), field.getName());\n \t\t}\n \n+\t\tString name;\n \t\tMethod getter = delegate.getPropertyGetter();\n \t\tif (getter != null)\n \t\t{\n-\t\t\tString name = getter.getName().substring(3, 4).toLowerCase() +\n-\t\t\t\tgetter.getName().substring(4);\n+\t\t\tString methodName = getter.getName();\n+\t\t\tif (methodName.startsWith(\"get\"))\n+\t\t\t{\n+\t\t\t\tname = methodName.substring(3, 4).toLowerCase() +\n+\t\t\t\t\tmethodName.substring(4);\n+\t\t\t}\n+\t\t\telse if (methodName.startsWith(\"is\"))\n+\t\t\t{\n+\t\t\t\tname = methodName.substring(2, 3).toLowerCase() +\n+\t\t\t\t\t\tmethodName.substring(3);\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tthrow new WicketRuntimeException(\"Invalid name for a getter method: '\"\n+\t\t\t\t\t\t+ methodName + \"'. It must start either with 'get' or 'is'.\");\n+\t\t\t}\n \t\t\treturn new Property(getter.getDeclaringClass(), name);\n \t\t}\n \n",
        "project": "wicket",
        "linesAdd": 18,
        "jira_id": "5505",
        "nb_skipped": 0,
        "commit": "6cceff44",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 1504,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.resource.PackageResourceReferenceTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/CssResourceReference.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/CssResourceReference.java\nindex 55955d7d90..7d15d6193f 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/CssResourceReference.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/CssResourceReference.java\n@@ -76,8 +76,10 @@ public CssResourceReference(Key key)\n \t@Override\n \tpublic CssPackageResource getResource()\n \t{\n-\t\treturn new CssPackageResource(getScope(), getName(), getLocale(), getStyle(),\n+        final CssPackageResource resource = new CssPackageResource(getScope(), getName(), getLocale(), getStyle(),\n                 getVariation());\n+        removeCompressFlagIfUnnecessary(resource);\n+        return resource;\n \t}\n \n }\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/JavaScriptResourceReference.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/JavaScriptResourceReference.java\nindex 43e4a0dd38..d320f5977b 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/JavaScriptResourceReference.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/JavaScriptResourceReference.java\n@@ -78,7 +78,9 @@ public JavaScriptResourceReference(Key key)\n \t@Override\n \tpublic JavaScriptPackageResource getResource()\n \t{\n-\t\treturn new JavaScriptPackageResource(getScope(), getName(), getLocale(), getStyle(),\n+        final JavaScriptPackageResource resource = new JavaScriptPackageResource(getScope(), getName(), getLocale(), getStyle(),\n                 getVariation());\n+        removeCompressFlagIfUnnecessary(resource);\n+        return resource;\n \t}\n }\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\nindex ca248a0f73..a127aa71b8 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\n@@ -129,13 +129,27 @@ else if (JAVASCRIPT_EXTENSION.equals(extension))\n \t\t\t\tgetVariation());\n \t\t}\n \n+        removeCompressFlagIfUnnecessary(resource);\n+\n+        return resource;\n+    }\n+\n+    /**\n+     * Method allowing to remove the compress flag if the resource has been detected as a minified one\n+     * (i.e. ending with .min.EXT)\n+     * This method is to be called by subclasses overriding <code>getResource</code>\n+     * if they want to rely on default minification detection handling\n+     *\n+     * see WICKET-5250 for further explanation\n+     * @param resource resource to check\n+     */\n+    protected void removeCompressFlagIfUnnecessary(final PackageResource resource)\n+    {\n         String minifiedName = MINIFIED_NAMES_CACHE.get(this);\n         if (minifiedName != null && minifiedName != NO_MINIFIED_NAME)\n         {\n             resource.setCompress(false);\n         }\n-\n-\t\treturn resource;\n     }\n \n     private ResourceReference.UrlAttributes getUrlAttributes(Locale locale, String style, String variation)\n",
        "project": "wicket",
        "linesAdd": 13,
        "jira_id": "5250",
        "nb_skipped": 3,
        "commit": "6122df49",
        "nb_failure": 2,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 757,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ajax.AjaxPreprocessingCallDecoratorTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/ajax/calldecorator/AjaxPreprocessingCallDecorator.java b/wicket/src/main/java/org/apache/wicket/ajax/calldecorator/AjaxPreprocessingCallDecorator.java\nindex f57a2d482a..a37d6edc9a 100644\n--- a/wicket/src/main/java/org/apache/wicket/ajax/calldecorator/AjaxPreprocessingCallDecorator.java\n+++ b/wicket/src/main/java/org/apache/wicket/ajax/calldecorator/AjaxPreprocessingCallDecorator.java\n@@ -49,8 +49,9 @@ public AjaxPreprocessingCallDecorator(IAjaxCallDecorator delegate)\n \t */\n \tpublic CharSequence decorateScript(CharSequence script)\n \t{\n-\t\tCharSequence s = (delegate == null) ? script : delegate.decorateScript(script);\n-\t\treturn preDecorateScript(s);\n+\t\tCharSequence s = preDecorateScript(script);\n+\t\treturn (delegate == null) ? s : delegate.decorateScript(s);\n+\n \t}\n \n \t/**\n@@ -58,8 +59,8 @@ public CharSequence decorateScript(CharSequence script)\n \t */\n \tpublic CharSequence decorateOnSuccessScript(CharSequence script)\n \t{\n-\t\tCharSequence s = (delegate == null) ? script : delegate.decorateOnSuccessScript(script);\n-\t\treturn preDecorateOnSuccessScript(s);\n+\t\tCharSequence s = preDecorateOnSuccessScript(script);\n+\t\treturn (delegate == null) ? s : delegate.decorateOnSuccessScript(s);\n \t}\n \n \t/**\n@@ -67,8 +68,9 @@ public CharSequence decorateOnSuccessScript(CharSequence script)\n \t */\n \tpublic CharSequence decorateOnFailureScript(CharSequence script)\n \t{\n-\t\tCharSequence s = (delegate == null) ? script : delegate.decorateOnFailureScript(script);\n-\t\treturn preDecorateOnFailureScript(s);\n+\t\tCharSequence s = preDecorateOnFailureScript(script);\n+\n+\t\treturn (delegate == null) ? s : delegate.decorateOnFailureScript(s);\n \t}\n \n \n",
        "project": "wicket",
        "linesAdd": 8,
        "jira_id": "2057",
        "nb_skipped": 0,
        "commit": "e2d88568",
        "nb_failure": 3,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 10,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.UrlTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 6d77f1d3b9..247197e9c3 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -116,10 +116,11 @@ public static Url parse(final String url)\n \t * Parses the given URL string.\n \t * \n \t * @param url\n+\t *           full absolute or relative url with query string\n \t * @param charset\n \t * @return Url object\n \t */\n-\tpublic static Url parse(final String url, Charset charset)\n+\tpublic static Url parse(String url, Charset charset)\n \t{\n \t\tArgs.notNull(url, \"url\");\n \n@@ -128,36 +129,79 @@ public static Url parse(final String url, Charset charset)\n \t\t// the url object resolved the charset, use that\n \t\tcharset = result.getCharset();\n \n-\t\tString segments;\n-\t\tString query;\n+\t\t// extract query string part\n+\t\tfinal String queryString;\n+\t\tfinal String absoluteUrl;\n \n-\t\tint qIndex = url.indexOf('?');\n+\t\tint queryAt = url.indexOf('?');\n \n-\t\tif (qIndex == -1)\n+\t\tif (queryAt == -1)\n \t\t{\n-\t\t\tsegments = url;\n-\t\t\tquery = \"\";\n+\t\t\tqueryString = \"\";\n+\t\t\tabsoluteUrl = url;\n \t\t}\n \t\telse\n \t\t{\n-\t\t\tsegments = url.substring(0, qIndex);\n-\t\t\tquery = url.substring(qIndex + 1);\n+\t\t\tabsoluteUrl = url.substring(0, queryAt);\n+\t\t\tqueryString = url.substring(queryAt + 1);\n \t\t}\n \t\t\n-\t\tif (segments.length() > 0)\n+\t\t// get absolute / relative part of url\n+\t\tString relativeUrl;\n+\n+\t\t// absolute urls contain a scheme://\n+\t\tfinal int protocolAt = absoluteUrl.indexOf(\"://\");\n+\n+\t\tif (protocolAt != -1)\n \t\t{\n+\t\t\tresult.protocol = absoluteUrl.substring(0, protocolAt);\n+\t\t\tfinal String afterProto = absoluteUrl.substring(protocolAt + 3);\n+\t\t\tfinal String hostAndPort;\n+\n+\t\t\tint relativeAt = afterProto.indexOf('/');\n \n+\t\t\tif (relativeAt == -1)\n+\t\t\t{\n+\t\t\t\trelativeUrl = \"\";\n+\t\t\t\thostAndPort = afterProto;\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\trelativeUrl = afterProto.substring(relativeAt);\n+\t\t\t\thostAndPort = afterProto.substring(0, relativeAt);\n+\t\t\t}\n+\n+\t\t\tint portAt = hostAndPort.indexOf(':');\n+\n+\t\t\tif (portAt == -1)\n+\t\t\t{\n+\t\t\t\tresult.host = hostAndPort;\n+\t\t\t\tresult.port = null;\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tresult.host = hostAndPort.substring(0, portAt);\n+\t\t\t\tresult.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\n+\t\t\t}\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\trelativeUrl = absoluteUrl;\n+\t\t}\n+\n+\t\tif (relativeUrl.length() > 0)\n+\t\t{\n \t\t\tboolean removeLast = false;\n-\t\t\tif (segments.endsWith(\"/\"))\n+\t\t\tif (relativeUrl.endsWith(\"/\"))\n \t\t\t{\n \t\t\t\t// we need to append something and remove it after splitting\n \t\t\t\t// because otherwise the\n \t\t\t\t// trailing slashes will be lost\n-\t\t\t\tsegments += \"/x\";\n+\t\t\t\trelativeUrl += \"/x\";\n \t\t\t\tremoveLast = true;\n \t\t\t}\n \n-\t\t\tString segmentArray[] = Strings.split(segments, '/');\n+\t\t\tString segmentArray[] = Strings.split(relativeUrl, '/');\n \n \t\t\tif (removeLast)\n \t\t\t{\n@@ -173,9 +217,9 @@ public static Url parse(final String url, Charset charset)\n \t\t\t}\n \t\t}\n \n-\t\tif (query.length() > 0)\n+\t\tif (queryString.length() > 0)\n \t\t{\n-\t\t\tString queryArray[] = Strings.split(query, '&');\n+\t\t\tString queryArray[] = Strings.split(queryString, '&');\n \t\t\tfor (String s : queryArray)\n \t\t\t{\n \t\t\t\tresult.parameters.add(parseQueryParameter(s, charset));\n",
        "project": "wicket",
        "linesAdd": 55,
        "jira_id": "3834",
        "nb_skipped": 0,
        "commit": "30255f11",
        "nb_failure": 1,
        "linesRem": 15,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1463,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.settings.ISecuritySettingsTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\nindex f8c7ffeaf2..b1418bf730 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n@@ -17,6 +17,8 @@\n package org.apache.wicket.core.request.mapper;\n \n import org.apache.wicket.Application;\n+import org.apache.wicket.core.request.handler.PageProvider;\n+import org.apache.wicket.core.request.handler.RenderPageRequestHandler;\n import org.apache.wicket.request.Request;\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.component.IRequestablePage;\n@@ -91,14 +93,6 @@ protected Url buildUrl(UrlInfo info)\n \t@Override\n \tprotected UrlInfo parseRequest(Request request)\n \t{\n-\t\tif (Application.exists())\n-\t\t{\n-\t\t\tif (Application.get().getSecuritySettings().getEnforceMounts())\n-\t\t\t{\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\n \t\tUrl url = request.getUrl();\n \t\tif (matches(url))\n \t\t{\n@@ -111,6 +105,25 @@ protected UrlInfo parseRequest(Request request)\n \n \t\t\tif (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass))\n \t\t\t{\n+\t\t\t\tif (Application.exists())\n+\t\t\t\t{\n+\t\t\t\t\tApplication application = Application.get();\n+\n+\t\t\t\t\tif (application.getSecuritySettings().getEnforceMounts())\n+\t\t\t\t\t{\n+\t\t\t\t\t\t// we make an excepion if the homepage itself was mounted, see WICKET-1898\n+\t\t\t\t\t\tif (!pageClass.equals(application.getHomePage()))\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t// WICKET-5094 only enforce mount if page is mounted\n+\t\t\t\t\t\t\tUrl reverseUrl = application.getRootRequestMapper().mapHandler(\n+\t\t\t\t\t\t\t\tnew RenderPageRequestHandler(new PageProvider(pageClass)));\n+\t\t\t\t\t\t\tif (!matches(reverseUrl))\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\treturn null;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n \n \t\t\t\t// extract the PageParameters from URL if there are any\n \t\t\t\tPageParameters pageParameters = extractPageParameters(request, 3,\n",
        "project": "wicket",
        "linesAdd": 19,
        "jira_id": "5094",
        "nb_skipped": 3,
        "commit": "74e77676",
        "nb_failure": 1,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1564,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.form.CheckGroupTest",
            "org.apache.wicket.markup.html.form.RadioGroupTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Check.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Check.java\nindex 5d09f6feb1..bc5c77b561 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Check.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Check.java\n@@ -219,19 +219,6 @@ else if (collection.contains(getDefaultModelObject()))\n \t\t\ttag.put(ATTR_DISABLED, ATTR_DISABLED);\n \t\t}\n \n-\t\t// put group id into the class so we can easily identify all radios belonging to the group\n-\t\tfinal String marker = \"wicket-\" + getGroup().getMarkupId();\n-\t\tString clazz = tag.getAttribute(\"class\");\n-\t\tif (Strings.isEmpty(clazz))\n-\t\t{\n-\t\t\tclazz = marker;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tclazz = clazz + \" \" + marker;\n-\t\t}\n-\t\ttag.put(\"class\", clazz);\n-\n \t}\n \n \t/**\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Radio.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Radio.java\nindex d1bebbcddf..282b711e96 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Radio.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Radio.java\n@@ -23,7 +23,6 @@\n import org.apache.wicket.markup.html.WebMarkupContainer;\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n-import org.apache.wicket.util.string.Strings;\n \n /**\n  * Component representing a single radio choice in a org.apache.wicket.markup.html.form.RadioGroup.\n@@ -205,19 +204,6 @@ else if (group.getModelComparator().compare(group, getDefaultModelObject()))\n \t\t\ttag.put(ATTR_DISABLED, ATTR_DISABLED);\n \t\t}\n \n-\t\t// put group id into the class so we can easily identify all radios belonging to the group\n-\t\tfinal String marker = \"wicket-\" + getGroup().getMarkupId();\n-\t\tString clazz = tag.getAttribute(\"class\");\n-\t\tif (Strings.isEmpty(clazz))\n-\t\t{\n-\t\t\tclazz = marker;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tclazz = clazz + \" \" + marker;\n-\t\t}\n-\t\ttag.put(\"class\", clazz);\n-\n \t}\n \n \t/**\n",
        "project": "wicket",
        "linesAdd": 0,
        "jira_id": "5476",
        "nb_skipped": 2,
        "commit": "813d8bee",
        "nb_failure": 5,
        "linesRem": 25,
        "singleLine": false
    },
    {
        "files": 0,
        "nb_test": 8,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.ws.util.tester.WebSocketTesterRequestCycleListenerTest"
        ],
        "patch": "",
        "project": "wicket",
        "linesAdd": 0,
        "jira_id": "5701",
        "nb_skipped": 0,
        "commit": "087c0a26",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 5,
        "nb_test": 1242,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.outputTransformer.OutputTransformerContainerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex ebbe98fa58..17f43d72da 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -1811,12 +1811,8 @@ public void component(Component component, IVisit<Void> visit)\n \tprotected void onAfterRenderChildren()\n \t{\n \t\t// Loop through child components\n-\t\tfinal Iterator<? extends Component> iter = iterator();\n-\t\twhile (iter.hasNext())\n+\t\tfor (Component child : this)\n \t\t{\n-\t\t\t// Get next child\n-\t\t\tfinal Component child = iter.next();\n-\n \t\t\t// Call end request on the child\n \t\t\tchild.afterRender();\n \t\t}\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/MarkupResourceStream.java b/wicket-core/src/main/java/org/apache/wicket/markup/MarkupResourceStream.java\nindex 95cd456c1d..9e26187f23 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/MarkupResourceStream.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/MarkupResourceStream.java\n@@ -45,6 +45,9 @@\n \n \tprivate static final Logger log = LoggerFactory.getLogger(MarkupResourceStream.class);\n \n+\t/** */\n+\tpublic static final String WICKET_XHTML_DTD = \"http://wicket.apache.org/dtds.data/wicket-xhtml1.4-strict.dtd\";\n+\n \tprivate static final Pattern DOCTYPE_REGEX = Pattern.compile(\"!DOCTYPE\\\\s+(.*)\\\\s*\");\n \n \t/** The associated markup resource stream */\n@@ -68,10 +71,7 @@\n \t/** The encoding as found in <?xml ... encoding=\"\" ?>. Null, else */\n \tprivate String encoding;\n \n-\t/**\n-\t * Wicket namespace: <html\n-\t * xmlns:wicket=\"http://wicket.apache.org/dtds.data/wicket-xhtml1.3-strict.dtd>\n-\t */\n+\t/** Wicket namespace: see WICKET_XHTML_DTD */\n \tprivate String wicketNamespace;\n \n \t/** == wicket namespace name + \":id\" */\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/AbstractTransformerBehavior.java b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/AbstractTransformerBehavior.java\nindex 0e82dc3d30..be0490b983 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/AbstractTransformerBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/AbstractTransformerBehavior.java\n@@ -19,7 +19,6 @@\n import org.apache.wicket.Component;\n import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.behavior.Behavior;\n-import org.apache.wicket.markup.ComponentTag;\n import org.apache.wicket.protocol.http.BufferedWebResponse;\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.request.http.WebResponse;\n@@ -58,12 +57,6 @@ protected BufferedWebResponse newResponse(final WebResponse originalResponse)\n \t\treturn new BufferedWebResponse(originalResponse);\n \t}\n \n-\t@Override\n-\tpublic void onComponentTag(final Component component, final ComponentTag tag)\n-\t{\n-\t\ttag.put(\"xmlns:wicket\", \"http://wicket.apache.org\");\n-\t}\n-\n \t@Override\n \tpublic void beforeRender(Component component)\n \t{\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltOutputTransformerContainer.java b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltOutputTransformerContainer.java\nindex 873c47652e..d09c100d56 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltOutputTransformerContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltOutputTransformerContainer.java\n@@ -18,6 +18,7 @@\n \n import org.apache.wicket.AttributeModifier;\n import org.apache.wicket.Component;\n+import org.apache.wicket.markup.MarkupResourceStream;\n import org.apache.wicket.markup.MarkupType;\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.model.Model;\n@@ -74,7 +75,7 @@ public XsltOutputTransformerContainer(final String id, final IModel<?> model,\n \t\t// Make the XSLT processor happy and allow him to handle the wicket\n \t\t// tags and attributes which are in the wicket namespace\n \t\tadd(AttributeModifier.replace(\"xmlns:wicket\",\n-\t\t\tModel.of(\"http://wicket.apache.org/dtds.data/wicket-xhtml1.3-strict.dtd\")));\n+\t\t\tModel.of(MarkupResourceStream.WICKET_XHTML_DTD)));\n \t}\n \n \t/**\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltTransformerBehavior.java b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltTransformerBehavior.java\nindex 97a16808dd..d1c3efabd4 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltTransformerBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/transformer/XsltTransformerBehavior.java\n@@ -20,6 +20,7 @@\n import org.apache.wicket.Page;\n import org.apache.wicket.WicketRuntimeException;\n import org.apache.wicket.markup.ComponentTag;\n+import org.apache.wicket.markup.MarkupResourceStream;\n \n /**\n  * An IBehavior which can be added to any component except ListView. It allows to post-process\n@@ -69,10 +70,10 @@ public XsltTransformerBehavior(final String xslFilePath)\n \t@Override\n \tpublic void onComponentTag(final Component component, final ComponentTag tag)\n \t{\n-\t\ttag.put(\"xmlns:wicket\", \"http://wicket.apache.org/dtds.data/wicket-xhtml1.3-strict.dtd\");\n-\n \t\t// Make the XSLT processor happy and allow it to handle the wicket tags\n \t\t// and attributes that are in the wicket namespace\n+\t\ttag.put(\"xmlns:wicket\", MarkupResourceStream.WICKET_XHTML_DTD);\n+\n \t\tsuper.onComponentTag(component, tag);\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 8,
        "jira_id": "3861",
        "nb_skipped": 2,
        "commit": "d1e0e411",
        "nb_failure": 2,
        "linesRem": 14,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.cdi.ComponentInjectorTest"
        ],
        "patch": "diff --git a/wicket-cdi/src/main/java/org/apache/wicket/cdi/ComponentInjector.java b/wicket-cdi/src/main/java/org/apache/wicket/cdi/ComponentInjector.java\nindex 0316004c1c..c921706b7c 100644\n--- a/wicket-cdi/src/main/java/org/apache/wicket/cdi/ComponentInjector.java\n+++ b/wicket-cdi/src/main/java/org/apache/wicket/cdi/ComponentInjector.java\n@@ -48,7 +48,8 @@ public void onInstantiation(Component component)\n \t{\r\n \t\tClass<? extends Component> componentClass = component.getClass();\r\n \r\n-\t\tif (componentClass.isMemberClass() && Modifier.isStatic(componentClass.getModifiers()) == false)\r\n+\t\tif (componentClass.isAnonymousClass() ||\r\n+\t\t\t(componentClass.isMemberClass() && Modifier.isStatic(componentClass.getModifiers()) == false))\r\n \t\t{\r\n \t\t\tLOG.debug(\"Skipping non-static inner class '{}' \", componentClass);\r\n \t\t}\r\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "5226",
        "nb_skipped": 0,
        "commit": "8e518d88",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 2,
        "nb_test": 1577,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.mapper.PackageMapperTest",
            "org.apache.wicket.core.request.mapper.BookmarkableMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractComponentMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractComponentMapper.java\nindex b1480eeaad..efd77c6006 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractComponentMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractComponentMapper.java\n@@ -130,9 +130,28 @@ protected void encodePageComponentInfo(Url url, PageComponentInfo info)\n \t */\n \tprotected Class<? extends IRequestablePage> getPageClass(String name)\n \t{\n-\t\tArgs.notEmpty(name, \"name\");\n+\t\tString cleanedClassName = cleanClassName(name);\n+\t\treturn WicketObjects.resolveClass(cleanedClassName);\n+\t}\n+\n+\t/**\n+\t * Cleans the class name from any extra information that may be there.\n+\t *\n+\t * @param className\n+\t *              The raw class name parsed from the url\n+\t * @return The cleaned class name\n+\t */\n+\tprotected String cleanClassName(String className)\n+\t{\n+\t\tArgs.notEmpty(className, \"className\");\n+\n+\t\tif (Strings.indexOf(className, ';') > -1)\n+\t\t{\n+\t\t\t// remove any path parameters set manually by the user. WICKET-5500\n+\t\t\tclassName = Strings.beforeFirst(className, ';');\n+\t\t}\n \n-\t\treturn WicketObjects.resolveClass(name);\n+\t\treturn className;\n \t}\n \n \t/**\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\nindex 41c6696f88..ad15d6d2e1 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n@@ -139,7 +139,8 @@ protected UrlInfo parseRequest(Request request)\n \t\t\tPageComponentInfo info = getPageComponentInfo(url);\n \n \t\t\t// load the page class\n-\t\t\tString className = url.getSegments().get(mountSegments.length);\n+\t\t\tString name = url.getSegments().get(mountSegments.length);\n+\t\t\tString className = cleanClassName(name);\n \n \t\t\tif (isValidClassName(className) == false)\n \t\t\t{\n",
        "project": "wicket",
        "linesAdd": 15,
        "jira_id": "5500",
        "nb_skipped": 2,
        "commit": "825da305",
        "nb_failure": 2,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1128,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.cycle.RequestCycleListenerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycleListenerCollection.java b/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycleListenerCollection.java\nindex 7422820ec4..821b883246 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycleListenerCollection.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/cycle/RequestCycleListenerCollection.java\n@@ -19,14 +19,13 @@\n import java.util.ArrayList;\r\n import java.util.List;\r\n \r\n-import org.apache.wicket.WicketRuntimeException;\r\n import org.apache.wicket.request.IRequestHandler;\r\n import org.apache.wicket.util.listener.ListenerCollection;\r\n import org.slf4j.Logger;\r\n import org.slf4j.LoggerFactory;\r\n \r\n /**\r\n- * \r\n+ * Special, Wicket internal composite {@link IRequestCycleListener} that\r\n  */\r\n public class RequestCycleListenerCollection extends ListenerCollection<IRequestCycleListener>\r\n \timplements\r\n@@ -57,6 +56,13 @@ public void notify(IRequestCycleListener listener)\n \t\t});\r\n \t}\r\n \r\n+\t/**\r\n+\t * Notifies all registered listeners of the exception and calls the first handler that was\r\n+\t * returned by the listeners.\r\n+\t * \r\n+\t * @see org.apache.wicket.request.cycle.IRequestCycleListener#onException(org.apache.wicket.request.cycle.RequestCycle,\r\n+\t *      java.lang.Exception)\r\n+\t */\r\n \tpublic IRequestHandler onException(final RequestCycle cycle, final Exception ex)\r\n \t{\r\n \t\tfinal List<IRequestHandler> handlers = new ArrayList<IRequestHandler>();\r\n@@ -77,14 +83,12 @@ public void notify(IRequestCycleListener listener)\n \t\t{\r\n \t\t\treturn null;\r\n \t\t}\r\n-\r\n \t\tif (handlers.size() > 1)\r\n \t\t{\r\n-\t\t\tthrow new WicketRuntimeException(\r\n-\t\t\t\t\"More than one request cycle listener returned a request handler while handling the exception.\",\r\n-\t\t\t\tex);\r\n+\t\t\tlogger.debug(\r\n+\t\t\t\t\"{} exception handlers available for exception {}, using the first handler\",\r\n+\t\t\t\thandlers.size(), ex);\r\n \t\t}\r\n-\r\n \t\treturn handlers.get(0);\r\n \t}\r\n \r\n",
        "project": "wicket",
        "linesAdd": 3,
        "jira_id": "3644",
        "nb_skipped": 0,
        "commit": "ab1856db",
        "nb_failure": 0,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1529,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.panel.FragmentTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/FragmentMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/FragmentMarkupSourcingStrategy.java\nindex ac47e37d07..400ea8df5c 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/FragmentMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/FragmentMarkupSourcingStrategy.java\n@@ -152,7 +152,7 @@ public IMarkupFragment getMarkup(final MarkupContainer container, final Componen\n \t\t\t{\n \t\t\t\tthrow new MarkupNotFoundException(\"Markup found for Fragment '\" + markupId\n \t\t\t\t\t+ \"' in providing markup container \" + getMarkupProvider(container)\n-\t\t\t\t\t+ \" is not a fragment tag\");\n+\t\t\t\t\t+ \" is not a <wicket:fragment> tag\");\n \t\t\t}\n \t\t}\n \n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "5060",
        "nb_skipped": 2,
        "commit": "8e6a6ec5",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1251,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.validation.validator.UrlValidatorTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java b/wicket-core/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\nindex 9cc917c9de..a259c51175 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/validation/validator/UrlValidator.java\n@@ -427,7 +427,7 @@ protected boolean isValidAuthority(String authority)\n \t\t\tif (segmentCount > 1)\n \t\t\t{\n \t\t\t\tString topLevel = domainSegment[segmentCount - 1];\n-\t\t\t\tif (topLevel.length() < 2 || topLevel.length() > 4)\n+\t\t\t\tif (topLevel.length() < 2)\n \t\t\t\t{\n \t\t\t\t\treturn false;\n \t\t\t\t}\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "4255",
        "nb_skipped": 3,
        "commit": "c250db9c",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 1646,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ajax.form.OnChangeAjaxBehaviorTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/form/OnChangeAjaxBehavior.java b/wicket-core/src/main/java/org/apache/wicket/ajax/form/OnChangeAjaxBehavior.java\nindex 965ae56bf8..863eded957 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/form/OnChangeAjaxBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/form/OnChangeAjaxBehavior.java\n@@ -16,7 +16,11 @@\n  */\n package org.apache.wicket.ajax.form;\n \n+import org.apache.wicket.Component;\n+import org.apache.wicket.ajax.attributes.AjaxRequestAttributes;\n import org.apache.wicket.markup.html.form.FormComponent;\n+import org.apache.wicket.markup.html.form.TextArea;\n+import org.apache.wicket.markup.html.form.TextField;\n \n /**\n  * A behavior that updates the hosting {@link FormComponent} via Ajax when value of the component is\n@@ -42,14 +46,33 @@\n \t * for text input form component depending on the browser.\n \t * 'change' is used as a fallback for all other form component types.\n \t */\n-\tpublic static final String EVENT_NAME = \"inputchange change\";\n+\tpublic static final String EVENT_INPUTCHANGE = \"inputchange\";\n+\tpublic static final String EVENT_CHANGE = \"change\";\n \n \t/**\n \t * Constructor.\n \t */\n \tpublic OnChangeAjaxBehavior()\n \t{\n-\t\tsuper(EVENT_NAME);\n+\t\tsuper(EVENT_INPUTCHANGE + \" \" + EVENT_CHANGE);\n \t}\n \n+\t@Override\n+\tprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) \n+\t{\n+\t\tsuper.updateAjaxAttributes(attributes);\n+\t\t\n+\t\tComponent component = getComponent();\n+\t\t\n+\t\t//textfiels and textareas will trigger this behavior with event 'inputchange'\n+\t\t//while all the other components will use 'change'\n+\t\tif (component instanceof TextField || component instanceof TextArea) \n+\t\t{\n+\t\t\tattributes.setEventNames(EVENT_INPUTCHANGE);\n+\t\t} \n+\t\telse \n+\t\t{\n+\t\t\tattributes.setEventNames(EVENT_CHANGE);\n+\t\t}\n+\t}\n }\n",
        "project": "wicket",
        "linesAdd": 23,
        "jira_id": "5603",
        "nb_skipped": 2,
        "commit": "240ab3c3",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1500,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.resource.PackageResourceReferenceTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\nindex cc7273173d..710eef26dc 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/PackageResourceReference.java\n@@ -207,7 +207,14 @@ protected String getMinifiedName()\n \t\tif (idxOfExtension > -1)\n \t\t{\n \t\t\tString extension = name.substring(idxOfExtension);\n-\t\t\tminifiedName = name.substring(0, name.length() - extension.length() + 1) + \"min\" + extension;\n+            final String baseName = name.substring(0, name.length() - extension.length() + 1);\n+            if (!\".min\".equals(extension) && !baseName.endsWith(\".min.\"))\n+            {\n+                minifiedName = baseName + \"min\" + extension;\n+            } else\n+            {\n+                minifiedName = name;\n+            }\n \t\t} else\n \t\t{\n \t\t\tminifiedName = name + \".min\";\n",
        "project": "wicket",
        "linesAdd": 8,
        "jira_id": "5251",
        "nb_skipped": 3,
        "commit": "6ce34ccf",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 5,
        "nb_test": 1472,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.panel.PanelTest",
            "org.apache.wicket.ajax.markup.html.ajaxLink.AjaxLinkTest",
            "org.apache.wicket.markup.html.basic.SimplePageTest",
            "org.apache.wicket.markup.html.border.ComponentBorderTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java b/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\nindex eea361d6d5..81829d0483 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\n@@ -56,7 +56,7 @@ public IRequestHandler map(Exception e)\n \t\t\tResponse response = RequestCycle.get().getResponse();\n \t\t\tif (response instanceof WebResponse)\n \t\t\t{\n-\t\t\t\t// we don't wan't to cache an exceptional reply in the browser\n+\t\t\t\t// we don't want to cache an exceptional reply in the browser\n \t\t\t\t((WebResponse)response).disableCaching();\n \t\t\t}\n \t\t\treturn internalMap(e);\n@@ -92,7 +92,7 @@ private IRequestHandler internalMap(Exception e)\n \n \t\tif (e instanceof StalePageException)\n \t\t{\n-\t\t\t// If the page was stale, just rerender it\n+\t\t\t// If the page was stale, just re-render it\n \t\t\t// (the url should always be updated by an redirect in that case)\n \t\t\treturn new RenderPageRequestHandler(new PageProvider(((StalePageException)e).getPage()));\n \t\t}\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/Page.java b/wicket-core/src/main/java/org/apache/wicket/Page.java\nindex 1467798dcb..86c0472eda 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Page.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Page.java\n@@ -450,6 +450,8 @@ public final boolean isPageStateless()\n \n \t\tif (stateless == null)\n \t\t{\n+\t\t\tinternalInitialize();\n+\n \t\t\tif (isStateless() == false)\n \t\t\t{\n \t\t\t\tstateless = Boolean.FALSE;\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/page/AbstractPageManager.java b/wicket-core/src/main/java/org/apache/wicket/page/AbstractPageManager.java\nindex 263bb62b94..da259e4b75 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/page/AbstractPageManager.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/page/AbstractPageManager.java\n@@ -127,10 +127,6 @@ public void newSessionCreated()\n \t@Override\n \tpublic void touchPage(IManageablePage page)\n \t{\n-\t\tif (!page.isPageStateless())\n-\t\t{\n-\t\t\tgetContext().bind();\n-\t\t}\n \t\tgetRequestAdapter().touch(page);\n \t}\n }\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\nindex be577f3338..f40a0c955d 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\n@@ -431,6 +431,23 @@ public void init(final boolean isServlet, final FilterConfig filterConfig)\n \t\t\t\tThreadContext.detach();\n \t\t\t}\n \t\t}\n+\t\tcatch (Exception e)\n+\t\t{\n+\t\t\t// #destroy() might not be called by the web container when #init() fails,\n+\t\t\t// so destroy now\n+\t\t\tlog.warn(\"initialization failed, destroying now\");\n+\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tdestroy();\n+\t\t\t}\n+\t\t\tcatch (Exception destroyException)\n+\t\t\t{\n+\t\t\t\tlog.warn(\"Unable to destroy after initialization failure\", destroyException);\n+\t\t\t}\n+\n+\t\t\tthrow new ServletException(e);\n+\t\t}\n \t\tfinally\n \t\t{\n \t\t\tif (newClassLoader != previousClassLoader)\n@@ -577,9 +594,16 @@ public void destroy()\n \t\t}\n \n \t\tif (applicationFactory != null)\n+\t\t{\n+\t\t\ttry\n \t\t\t{\n \t\t\t\tapplicationFactory.destroy(this);\n \t\t\t}\n+\t\t\tfinally\n+\t\t\t{\n+\t\t\t\tapplicationFactory = null;\n+\t\t\t}\n+\t\t}\n \t}\n \n \t/**\n@@ -781,7 +805,7 @@ private void initIgnorePaths(final FilterConfig filterConfig)\n \t * level \"/\" then an empty string should be used instead.\n \t * \n \t * @param filterPath\n-\t * @return\n+\t * @return canonic filter path\n \t */\n \tstatic String canonicaliseFilterPath(String filterPath)\n \t{\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/cycle/PageRequestHandlerTracker.java b/wicket-core/src/main/java/org/apache/wicket/request/cycle/PageRequestHandlerTracker.java\nindex caa5a6d748..b2390a6580 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/cycle/PageRequestHandlerTracker.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/cycle/PageRequestHandlerTracker.java\n@@ -59,6 +59,13 @@ public void onRequestHandlerScheduled(RequestCycle cycle, IRequestHandler handle\n \t\tregisterLastHandler(cycle,handler);\n \t}\n \n+\t@Override\n+\tpublic void onExceptionRequestHandlerResolved(RequestCycle cycle, IRequestHandler handler, Exception exception)\n+\t{\n+\t\tsuper.onExceptionRequestHandlerResolved(cycle, handler, exception);\n+\t\tregisterLastHandler(cycle,handler);\n+\t}\n+\n \t/**\n \t * Registers pagerequesthandler when it's resolved ,keeps up with the most recent handler resolved\n \t *\n",
        "project": "wicket",
        "linesAdd": 31,
        "jira_id": "5147",
        "nb_skipped": 3,
        "commit": "184e51e9",
        "nb_failure": 7,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1547,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.mapper.PackageMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\nindex 54729e901c..63e5914a87 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PackageMapper.java\n@@ -216,7 +216,7 @@ protected String transformForUrl(final String className)\n \t@Override\n \tprotected boolean pageMustHaveBeenCreatedBookmarkable()\n \t{\n-\t\treturn true;\n+\t\treturn false;\n \t}\n \n \t/**\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "5043",
        "nb_skipped": 2,
        "commit": "2b1ce91d",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1636,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ajax.markup.html.componentMap.SimpleTestPanelTest",
            "org.apache.wicket.ajax.AjaxTimerBehaviorTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractAjaxTimerBehavior.java b/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractAjaxTimerBehavior.java\nindex 39c3cc6aa3..5ecf56eb04 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractAjaxTimerBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractAjaxTimerBehavior.java\n@@ -18,9 +18,7 @@\n \n import org.apache.wicket.Component;\n import org.apache.wicket.Page;\n-import org.apache.wicket.core.util.string.JavaScriptUtils;\n import org.apache.wicket.markup.head.IHeaderResponse;\n-import org.apache.wicket.markup.head.JavaScriptHeaderItem;\n import org.apache.wicket.markup.head.OnLoadHeaderItem;\n import org.apache.wicket.util.time.Duration;\n \n@@ -36,7 +34,6 @@\n {\n \tprivate static final long serialVersionUID = 1L;\n \n-\tprivate static final String WICKET_TIMERS_ID = AbstractAjaxTimerBehavior.class.getSimpleName() + \"-timers\";\n \t/** The update interval */\n \tprivate Duration updateInterval;\n \n@@ -88,10 +85,6 @@ public void renderHead(Component component, IHeaderResponse response)\n \t{\n \t\tsuper.renderHead(component, response);\n \n-\t\tresponse.render(JavaScriptHeaderItem.forScript(\n-\t\t\t\"if (typeof(Wicket.TimerHandles) === 'undefined') {Wicket.TimerHandles = {}}\",\n-\t\t\tWICKET_TIMERS_ID));\n-\n \t\tif (component.getRequestCycle().find(AjaxRequestTarget.class) == null)\n \t\t{\n \t\t\t// complete page is rendered, so timeout has to be rendered again\n@@ -112,19 +105,9 @@ public void renderHead(Component component, IHeaderResponse response)\n \tprotected final String getJsTimeoutCall(final Duration updateInterval)\n \t{\n \t\tCharSequence js = getCallbackScript();\n-\t\tjs = JavaScriptUtils.escapeQuotes(js);\n-\n-\t\tString timeoutHandle = getTimeoutHandle();\n-\t\t// this might look strange, but it is necessary for IE not to leak :(\n-\t\treturn timeoutHandle+\" = setTimeout('\" + js + \"', \" +\n-\t\t\tupdateInterval.getMilliseconds() + ')';\n-\t}\n \n-\t/**\n-\t * @return the name of the handle that is used to stop any scheduled timer\n-\t */\n-\tprivate String getTimeoutHandle() {\n-\t\treturn \"Wicket.TimerHandles['\"+getComponent().getMarkupId() + \"']\";\n+\t\treturn String.format(\"Wicket.Timer.set('%s', function(){%s}, %d);\",\n+\t\t\t\tgetComponent().getMarkupId(), js, updateInterval.getMilliseconds());\n \t}\n \n \t/**\n@@ -218,9 +201,7 @@ private void clearTimeout(IHeaderResponse headerResponse)\n \t\t{\n \t\t\thasTimeout = false;\n \n-\t\t\tString timeoutHandle = getTimeoutHandle();\n-\t\t\theaderResponse.render(OnLoadHeaderItem.forScript(\"clearTimeout(\" + timeoutHandle\n-\t\t\t\t+ \"); delete \" + timeoutHandle + \";\"));\n+\t\t\theaderResponse.render(OnLoadHeaderItem.forScript(\"Wicket.Timer.clear('\" + getComponent().getMarkupId() + \"');\"));\n \t\t}\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 3,
        "jira_id": "5570",
        "nb_skipped": 2,
        "commit": "57d8f051",
        "nb_failure": 7,
        "linesRem": 18,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 10,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.extensions.markup.html.basic.DefaultLinkParserTest"
        ],
        "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/DefaultLinkParser.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/DefaultLinkParser.java\nindex 2c956102ca..ff824a1478 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/DefaultLinkParser.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/DefaultLinkParser.java\n@@ -29,7 +29,7 @@\n public class DefaultLinkParser extends LinkParser\n {\n \t/** Email address pattern */\n-\tprivate static final String emailPattern = \"[\\\\w\\\\.-]+@[\\\\w\\\\.-]+\";\n+\tprivate static final String emailPattern = \"[\\\\w\\\\.-\\\\\\\\+]+@[\\\\w\\\\.-]+\";\n \n \t/** URL pattern */\n \tprivate static final String urlPattern = \"([a-zA-Z]+://[\\\\w\\\\.\\\\-\\\\:\\\\/~]+)[\\\\w\\\\.:\\\\-/?&=%]*\";\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "3174",
        "nb_skipped": 0,
        "commit": "0cf14725",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 902,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.mapper.BookmarkableMapperTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/request/mapper/BookmarkableMapper.java b/wicket/src/main/java/org/apache/wicket/request/mapper/BookmarkableMapper.java\nindex 1b82594480..1b0edf9036 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/mapper/BookmarkableMapper.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/mapper/BookmarkableMapper.java\n@@ -16,7 +16,6 @@\n  */\n package org.apache.wicket.request.mapper;\n \n-import org.apache.wicket.Page;\n import org.apache.wicket.request.Request;\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.component.IRequestablePage;\n@@ -103,7 +102,7 @@ protected UrlInfo parseRequest(Request request)\n \t\t\tString className = url.getSegments().get(2);\n \t\t\tClass<? extends IRequestablePage> pageClass = getPageClass(className);\n \n-\t\t\tif (Page.class.isAssignableFrom(pageClass))\n+\t\t\tif (pageClass != null && IRequestablePage.class.isAssignableFrom(pageClass))\n \t\t\t{\n \n \t\t\t\t// extract the PageParameters from URL if there are any\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "2993",
        "nb_skipped": 1,
        "commit": "0b4f78cc",
        "nb_failure": 8,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 963,
        "nb_error": 2,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.wicket.request.mapper.HomePageMapperTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/request/mapper/HomePageMapper.java b/wicket/src/main/java/org/apache/wicket/request/mapper/HomePageMapper.java\nindex e4f6c8b300..b44207d1cb 100644\n--- a/wicket/src/main/java/org/apache/wicket/request/mapper/HomePageMapper.java\n+++ b/wicket/src/main/java/org/apache/wicket/request/mapper/HomePageMapper.java\n@@ -87,6 +87,7 @@ public IRequestHandler mapRequest(Request request)\n \t\t\t{\n \t\t\t\tpageProvider = new PageProvider(homePageClass);\n \t\t\t}\n+\t\t\tpageProvider.setPageSource(getContext());\n \n \t\t\treturn new RenderPageRequestHandler(pageProvider);\n \t\t}\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "3065",
        "nb_skipped": 1,
        "commit": "b293b75c",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 1,
        "nb_test": 1107,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.http.BufferedWebResponseTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\nindex 2ec9997bbd..83c05561e4 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\n@@ -20,6 +20,7 @@\n import java.io.IOException;\n import java.io.OutputStream;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n \n import javax.servlet.http.Cookie;\n@@ -88,9 +89,14 @@ public String encodeURL(CharSequence url)\n \t\t}\n \t}\n \n-\tprivate static abstract class Action\n+\tprivate static abstract class Action implements Comparable<Action>\n \t{\n \t\tprotected abstract void invoke(WebResponse response);\n+\n+\t\tpublic int compareTo(Action o)\n+\t\t{\n+\t\t\treturn 0;\n+\t\t}\n \t}\n \n \t/**\n@@ -100,6 +106,12 @@ public String encodeURL(CharSequence url)\n \t */\n \tprivate static abstract class MetaDataAction extends Action\n \t{\n+\t\t@Override\n+\t\tpublic int compareTo(Action o)\n+\t\t{\n+\t\t\t// write first in response\n+\t\t\treturn Integer.MIN_VALUE;\n+\t\t}\n \t}\n \n \tprivate static class WriteCharSequenceAction extends Action\n@@ -135,6 +147,13 @@ protected void invoke(WebResponse response)\n \t\t\t}\n \t\t\tresponse.write(builder);\n \t\t}\n+\n+\t\t@Override\n+\t\tpublic int compareTo(Action o)\n+\t\t{\n+\t\t\t// needs to be invoked after set header actions\n+\t\t\treturn Integer.MAX_VALUE;\n+\t\t}\n \t}\n \n \tprivate static class WriteDataAction extends Action\n@@ -163,6 +182,13 @@ protected void invoke(WebResponse response)\n \t\t{\n \t\t\twriteStream(response, stream);\n \t\t}\n+\n+\t\t@Override\n+\t\tpublic int compareTo(Action o)\n+\t\t{\n+\t\t\t// needs to be invoked after set header actions\n+\t\t\treturn Integer.MAX_VALUE;\n+\t\t}\n \t}\n \n \tprivate static class CloseAction extends Action\n@@ -242,7 +268,7 @@ protected void invoke(WebResponse response)\n \t\t}\n \t}\n \n-\tprivate static class SetContentLengthAction extends Action\n+\tprivate static class SetContentLengthAction extends MetaDataAction\n \t{\n \t\tprivate final long contentLength;\n \n@@ -258,7 +284,7 @@ protected void invoke(WebResponse response)\n \t\t}\n \t}\n \n-\tprivate static class SetContentTypeAction extends Action\n+\tprivate static class SetContentTypeAction extends MetaDataAction\n \t{\n \t\tprivate final String contentType;\n \n@@ -482,6 +508,8 @@ public void writeTo(final WebResponse response)\n \t{\n \t\tArgs.notNull(response, \"response\");\n \n+\t\tCollections.sort(actions);\n+\n \t\tfor (Action action : actions)\n \t\t{\n \t\t\taction.invoke(response);\n",
        "project": "wicket",
        "linesAdd": 28,
        "jira_id": "3618",
        "nb_skipped": 0,
        "commit": "fbfd17e6",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 86,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.mapper.parameter.PageParametersTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParameters.java b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParameters.java\nindex 5c5391f6d6..956ea75d19 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParameters.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParameters.java\n@@ -456,9 +456,20 @@ public PageParameters mergeWith(final PageParameters other)\n \t\tif (this != other)\n \t\t{\n \t\t\tfor (int index = 0; index < other.getIndexedCount(); index++)\n+\t\t\t{\n+\t\t\t\tif (!other.get(index).isNull())\n+\t\t\t\t{\n \t\t\t\t\tset(index, other.get(index));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfor (String name : other.getNamedKeys())\n+\t\t\t{\n+\t\t\t\tremove(name);\n+\t\t\t}\n \t\t\tfor (NamedPair curNamed : other.getAllNamed())\n-\t\t\t\tset(curNamed.getKey(), curNamed.getValue());\n+\t\t\t{\n+\t\t\t\tadd(curNamed.getKey(), curNamed.getValue());\n+\t\t\t}\n \t\t}\n \t\treturn this;\n \t}\n",
        "project": "wicket",
        "linesAdd": 12,
        "jira_id": "4775",
        "nb_skipped": 0,
        "commit": "1ac05533",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1111,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.response.filter.ResponseFilterTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java b/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\nindex 0c73aff3e4..f6ff1adadb 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxRequestTarget.java\n@@ -600,8 +600,8 @@ public final void respond(final IRequestCycle requestCycle)\n \t\t\t{\n \t\t\t\tfinal StringResponse bodyResponse = new StringResponse();\n \t\t\t\tcontructResponseBody(bodyResponse, encoding);\n-\t\t\t\tinvokeResponseFilters(bodyResponse);\n-\t\t\t\tresponse.write(bodyResponse.getBuffer());\n+\t\t\t\tCharSequence filteredResponse = invokeResponseFilters(bodyResponse);\n+\t\t\t\tresponse.write(filteredResponse);\n \t\t\t}\n \t\t\tfinally\n \t\t\t{\n@@ -670,8 +670,9 @@ private void contructResponseBody(final Response bodyResponse, final String enco\n \t * \n \t * @param contentResponse\n \t *            the Ajax {@link Response} body\n+\t * @return filtered response\n \t */\n-\tprivate void invokeResponseFilters(final StringResponse contentResponse)\n+\tprivate AppendingStringBuffer invokeResponseFilters(final StringResponse contentResponse)\n \t{\n \t\tAppendingStringBuffer responseBuffer = new AppendingStringBuffer(\n \t\t\tcontentResponse.getBuffer());\n@@ -684,9 +685,10 @@ private void invokeResponseFilters(final StringResponse contentResponse)\n \t\t{\n \t\t\tfor (IResponseFilter filter : responseFilters)\n \t\t\t{\n-\t\t\t\tfilter.filter(responseBuffer);\n+\t\t\t\tresponseBuffer = filter.filter(responseBuffer);\n \t\t\t}\n \t\t}\n+\t\treturn responseBuffer;\n \t}\n \n \t/**\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\nindex 83c05561e4..03e18f9d09 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/BufferedWebResponse.java\n@@ -142,10 +142,10 @@ protected void invoke(WebResponse response)\n \t\t\t{\n \t\t\t\tfor (IResponseFilter filter : responseFilters)\n \t\t\t\t{\n-\t\t\t\t\tfilter.filter(responseBuffer);\n+\t\t\t\t\tresponseBuffer = filter.filter(responseBuffer);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tresponse.write(builder);\n+\t\t\tresponse.write(responseBuffer);\n \t\t}\n \n \t\t@Override\n",
        "project": "wicket",
        "linesAdd": 7,
        "jira_id": "3620",
        "nb_skipped": 0,
        "commit": "1a2bc1bc",
        "nb_failure": 2,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1864,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.http.WicketFilterTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\nindex 679cfbf016..d73a4a7039 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java\n@@ -519,6 +519,10 @@ protected String getFilterPathFromAnnotation(boolean isServlet)\n \t\t\t\tpattern = \"\";\n \t\t\t}\n \n+\t\t\tif (pattern.endsWith(\"*\"))\n+\t\t\t{\n+\t\t\t\tpattern = pattern.substring(0, pattern.length() - 1);\n+\t\t\t}\n \t\t\treturn pattern;\n \t\t}\n \t\treturn null;\n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "5980",
        "nb_skipped": 1,
        "commit": "294b0b2f",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 13,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.extensions.markup.html.repeater.data.table.DataTableTest"
        ],
        "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/HeadersToolbar.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/HeadersToolbar.java\nindex 4fbeab2733..9935c68b61 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/HeadersToolbar.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/repeater/data/table/HeadersToolbar.java\n@@ -21,6 +21,7 @@\n import org.apache.wicket.extensions.markup.html.repeater.data.sort.ISortStateLocator;\n import org.apache.wicket.extensions.markup.html.repeater.data.sort.OrderByBorder;\n import org.apache.wicket.markup.html.WebMarkupContainer;\n+import org.apache.wicket.markup.html.border.Border;\n import org.apache.wicket.markup.html.list.AbstractItem;\n import org.apache.wicket.markup.repeater.RepeatingView;\n \n@@ -87,7 +88,14 @@ protected String getCssClass()\n \n \t\t\titem.add(header);\n \t\t\titem.setRenderBodyOnly(true);\n+\t\t\tif (header instanceof Border)\n+\t\t\t{\n+\t\t\t\t((Border)header).addToBody(column.getHeader(\"label\"));\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n \t\t\t\theader.add(column.getHeader(\"label\"));\n+\t\t\t}\n \n \t\t}\n \t}\n",
        "project": "wicket",
        "linesAdd": 8,
        "jira_id": "3702",
        "nb_skipped": 0,
        "commit": "a08562a7",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1372,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.form.FormSubmitTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\nindex 35ac561cab..53898a60a8 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n@@ -928,18 +928,19 @@ public void process(IFormSubmitter submittingComponent)\n \t */\n \tprotected void callOnError(IFormSubmitter submitter)\n \t{\n+\t\tfinal Form<?> processingForm = findFormToProcess(submitter);\n+\n \t\tif (submitter != null)\n \t\t{\n \t\t\tsubmitter.onError();\n \t\t}\n-\t\tonError();\n-\t\t// call onError on nested forms\n-\t\tvisitChildren(Form.class, new IVisitor<Component, Void>()\n+\n+\t\t// invoke Form#onSubmit(..) going from innermost to outermost\n+\t\tVisits.visitPostOrder(processingForm, new IVisitor<Form<?>, Void>()\n \t\t{\n \t\t\t@Override\n-\t\t\tpublic void component(final Component component, final IVisit<Void> visit)\n+\t\t\tpublic void component(Form<?> form, IVisit<Void> visit)\n \t\t\t{\n-\t\t\t\tfinal Form<?> form = (Form<?>)component;\n \t\t\t\tif (!form.isEnabledInHierarchy() || !form.isVisibleInHierarchy())\n \t\t\t\t{\n \t\t\t\t\tvisit.dontGoDeeper();\n@@ -950,7 +951,7 @@ public void component(final Component component, final IVisit<Void> visit)\n \t\t\t\t\tform.onError();\n \t\t\t\t}\n \t\t\t}\n-\t\t});\n+\t\t}, new ClassVisitFilter(Form.class));\n \t}\n \n \n@@ -1208,8 +1209,8 @@ protected void beforeUpdateFormComponentModels()\n \t * processing to clients.\n \t * <p>\n \t * This implementation first finds out whether the form processing was triggered by a nested\n-\t * IFormSubmittingComponent of this form. If that is the case, that component's onSubmit is\n-\t * called first.\n+\t * IFormSubmittingComponent of this form. If that is the case, that component's\n+\t * onSubmitBefore/AfterForm methods are called appropriately..\n \t * </p>\n \t * <p>\n \t * Regardless of whether a submitting component was found, the form's onSubmit method is called\n",
        "project": "wicket",
        "linesAdd": 6,
        "jira_id": "4616",
        "nb_skipped": 5,
        "commit": "dd1df04b",
        "nb_failure": 3,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 151,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.file.FilesTest"
        ],
        "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/file/Files.java b/wicket-util/src/main/java/org/apache/wicket/util/file/Files.java\nindex 3b5b97ce66..f9d25796b9 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/file/Files.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/file/Files.java\n@@ -23,7 +23,9 @@\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n import java.net.URL;\n+import java.net.URLDecoder;\n \n import org.apache.wicket.util.io.IOUtils;\n import org.apache.wicket.util.io.Streams;\n@@ -363,7 +365,16 @@ public static void copy(final File sourceFile, final File targetFile) throws IOE\n \t */\n \tpublic static File getLocalFileFromUrl(URL url)\n \t{\n-\t\treturn getLocalFileFromUrl(Args.notNull(url, \"url\").toExternalForm());\n+\t\tfinal URL location = Args.notNull(url, \"url\");\n+\n+\t\ttry\n+\t\t{\n+\t\t\treturn getLocalFileFromUrl(URLDecoder.decode(location.toExternalForm(), \"UTF-8\"));\n+\t\t}\n+\t\tcatch (UnsupportedEncodingException ex)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n \t}\n \n \t/**\n",
        "project": "wicket",
        "linesAdd": 12,
        "jira_id": "4509",
        "nb_skipped": 0,
        "commit": "b672cb2d",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 7,
        "nb_test": 1692,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.queueing.transparentresolvers.DequeueingTransparentWebMarkupContainerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex b607b4e273..1ec4f02a73 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -1535,7 +1535,7 @@ private void dequeueAutoComponents()\n \t\t\t\tComponentTag.IAutoComponentFactory autoComponentFactory = tag.getAutoComponentFactory();\n \t\t\t\tif (autoComponentFactory != null)\n \t\t\t\t{\n-\t\t\t\t\tqueue(autoComponentFactory.newComponent(tag));\n+\t\t\t\t\tqueue(autoComponentFactory.newComponent(this, tag));\n \t\t\t\t}\n \t\t\t}\n \t\t}\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/ComponentTag.java b/wicket-core/src/main/java/org/apache/wicket/markup/ComponentTag.java\nindex b572677197..bffde4e3ce 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/ComponentTag.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/ComponentTag.java\n@@ -25,6 +25,7 @@\n import java.util.Map;\n \n import org.apache.wicket.Component;\n+import org.apache.wicket.MarkupContainer;\n import org.apache.wicket.behavior.Behavior;\n import org.apache.wicket.markup.parser.XmlTag;\n import org.apache.wicket.markup.parser.XmlTag.TagType;\n@@ -65,7 +66,7 @@\n \t\t/**\n \t\t * Creates a new instance of auto component to be queued\n \t\t */\n-\t\tComponent newComponent(ComponentTag tag);\n+\t\tComponent newComponent(MarkupContainer container, ComponentTag tag);\n \t}\n \n \ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/EnclosureHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/EnclosureHandler.java\nindex 4a47f38157..098533ca16 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/EnclosureHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/EnclosureHandler.java\n@@ -56,7 +56,7 @@\n \tprivate static final IAutoComponentFactory FACTORY = new IAutoComponentFactory()\n \t{\n \t\t@Override\n-\t\tpublic Component newComponent(ComponentTag tag)\n+\t\tpublic Component newComponent(MarkupContainer container, ComponentTag tag)\n \t\t{\n \t\t\treturn new Enclosure(tag.getId(), tag\n \t\t\t\t.getAttribute(EnclosureHandler.CHILD_ATTRIBUTE));\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\nindex 0f859645ee..6d08c95a52 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\n@@ -49,8 +49,8 @@\n  */\n public final class HtmlHeaderSectionHandler extends AbstractMarkupFilter\n {\n-\tprivate static final String BODY = \"body\";\n-\tprivate static final String HEAD = \"head\";\n+\tpublic static final String BODY = \"body\";\n+\tpublic static final String HEAD = \"head\";\n \n \t/** The automatically assigned wicket:id to &gt;head&lt; tag */\n \tpublic static final String HEADER_ID = \"_header_\";\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\nindex e3c953a043..0014b92d1a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/InlineEnclosureHandler.java\n@@ -127,7 +127,7 @@ protected MarkupElement onComponentTag(final ComponentTag tag) throws ParseExcep\n \t\t\t\t\ttag.setAutoComponentFactory(new ComponentTag.IAutoComponentFactory()\r\n \t\t\t\t\t{\r\n \t\t\t\t\t\t@Override\r\n-\t\t\t\t\t\tpublic Component newComponent(ComponentTag tag)\r\n+\t\t\t\t\t\tpublic Component newComponent(MarkupContainer container, ComponentTag tag)\r\n \t\t\t\t\t\t{\r\n \t\t\t\t\t\t\tString attributeName = getInlineEnclosureAttributeName(null);\r\n \t\t\t\t\t\t\tString childId = tag.getAttribute(attributeName);\r\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/RelativePathPrefixHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/RelativePathPrefixHandler.java\nindex 0ae97ee1b3..79edb52a66 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/RelativePathPrefixHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/RelativePathPrefixHandler.java\n@@ -86,8 +86,8 @@ public void onComponentTag(Component component, ComponentTag tag)\n \t\t\t{\n \t\t\t\tString attrValue = tag.getAttributes().getString(attrName);\n \n-\t\t\t\tif ((attrValue != null) && (attrValue.startsWith(\"/\") == false) &&\n-\t\t\t\t\t(!attrValue.contains(\":\")) && !(attrValue.startsWith(\"#\")))\n+\t\t\t\tif ((attrValue != null) && (attrValue.startsWith(\"/\") == false)\n+\t\t\t\t\t&& (!attrValue.contains(\":\")) && !(attrValue.startsWith(\"#\")))\n \t\t\t\t{\n \t\t\t\t\ttag.getAttributes().put(attrName,\n \t\t\t\t\t\tUrlUtils.rewriteToContextRelative(attrValue, RequestCycle.get()));\n@@ -96,6 +96,14 @@ public void onComponentTag(Component component, ComponentTag tag)\n \t\t}\n \t};\n \t\n+\t/** \n+\t * https://issues.apache.org/jira/browse/WICKET-5724\n+\t * \n+\t * Says if we are inside an head tag or wicket:head tag. \n+\t * \n+\t * */\n+\tprivate boolean insideHead;\n+\n \t/**\n \t * Constructor for the IComponentResolver role.\n \t */\n@@ -106,6 +114,7 @@ public RelativePathPrefixHandler()\n \n \t/**\n \t * Constructor for the IMarkupFilter role\n+\t * \n \t * @param markup\n \t *            The markup created by reading the markup file\n \t */\n@@ -119,14 +128,26 @@ protected final MarkupElement onComponentTag(ComponentTag tag) throws ParseExcep\n \t{\n \t\tif (tag.isClose())\n \t\t{\n+\t\t\tif (isHeadTag(tag))\t\n+\t\t\t{\n+\t\t\t\t//outside head tag\n+\t\t\t\tinsideHead = false;\n+\t\t\t}\n+\t\t\t\n \t\t\treturn tag;\n \t\t}\n \n+\t\tif (isHeadTag(tag))\t\n+\t\t{\n+\t\t\t//inside head tag\n+\t\t\tinsideHead = true;\n+\t\t}\n+\n \t\tString wicketIdAttr = getWicketNamespace() + \":\" + \"id\";\n \n \t\t// Don't touch any wicket:id component and any auto-components\n-\t\tif ((tag instanceof WicketTag) || (tag.isAutolinkEnabled() == true) ||\n-\t\t\t(tag.getAttributes().get(wicketIdAttr) != null))\n+\t\tif ((tag instanceof WicketTag) || (tag.isAutolinkEnabled() == true)\n+\t\t\t|| (tag.getAttributes().get(wicketIdAttr) != null))\n \t\t{\n \t\t\treturn tag;\n \t\t}\n@@ -136,13 +157,33 @@ protected final MarkupElement onComponentTag(ComponentTag tag) throws ParseExcep\n \t\tfor (String attrName : attributeNames)\n \t\t{\n \t\t\tString attrValue = tag.getAttributes().getString(attrName);\n-\t\t\tif ((attrValue != null) && (attrValue.startsWith(\"/\") == false) &&\n-\t\t\t\t(!attrValue.contains(\":\")) && !(attrValue.startsWith(\"#\")))\n+\t\t\tif ((attrValue != null) && (attrValue.startsWith(\"/\") == false)\n+\t\t\t\t&& (!attrValue.contains(\":\")) && !(attrValue.startsWith(\"#\")))\n \t\t\t{\n \t\t\t\tif (tag.getId() == null)\n \t\t\t\t{\n \t\t\t\t\ttag.setId(getWicketRelativePathPrefix(null));\n \t\t\t\t\ttag.setAutoComponentTag(true);\n+\t\t\t\t\t\n+\t\t\t\t\t/**\n+\t\t\t\t\t * https://issues.apache.org/jira/browse/WICKET-5724\n+\t\t\t\t\t * Transparent component inside page body must allow \n+\t\t\t\t\t * queued children components.\n+\t\t\t\t\t */\n+\t\t\t\t\tif(!insideHead)\n+\t\t\t\t\t{\n+\t\t\t\t\t\ttag.setAutoComponentFactory(new ComponentTag.IAutoComponentFactory()\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tpublic Component newComponent(MarkupContainer container, ComponentTag tag)\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tString id = tag.getId() + container.getPage().getAutoIndex();\n+\t\t\t\t\t\t\t\ttag.setId(id);\n+\t\n+\t\t\t\t\t\t\t\treturn new TransparentWebMarkupContainer(id);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\t\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\ttag.addBehavior(RELATIVE_PATH_BEHAVIOR);\n \t\t\t\ttag.setModified(true);\n@@ -153,6 +194,16 @@ protected final MarkupElement onComponentTag(ComponentTag tag) throws ParseExcep\n \t\treturn tag;\n \t}\n \t\n+\tprivate boolean isHeadTag(ComponentTag tag)\n+\t{\n+\t\tif (HtmlHeaderSectionHandler.HEAD.equalsIgnoreCase(tag.getName()))\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\t\n+\t\t\n+\t\treturn false;\n+\t}\n+\t\n \t@Override\n \tpublic Component resolve(final MarkupContainer container, final MarkupStream markupStream,\n \t\tfinal ComponentTag tag)\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/resolver/IComponentResolver.java b/wicket-core/src/main/java/org/apache/wicket/markup/resolver/IComponentResolver.java\nindex b8d1588e2b..9e83b7182c 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/resolver/IComponentResolver.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/resolver/IComponentResolver.java\n@@ -28,6 +28,8 @@\n  * are first looked up in a component's hierarchy before falling back to a list of\n  * IComponentResolvers maintained in {@link PageSettings}.\n  * \n+ * NOTE: implementations for this interface must be thread-safe!\n+ * \n  * @see ComponentResolvers\n  * \n  * @author Juergen Donnerstag\n",
        "project": "wicket",
        "linesAdd": 50,
        "jira_id": "5724",
        "nb_skipped": 1,
        "commit": "b92591f6",
        "nb_failure": 0,
        "linesRem": 12,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1481,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ajax.form.AjaxFormChoiceComponentUpdatingBehaviorTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/form/AjaxFormComponentUpdatingBehavior.java b/wicket-core/src/main/java/org/apache/wicket/ajax/form/AjaxFormComponentUpdatingBehavior.java\nindex c5b15ecc8b..2d6cf0e728 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/form/AjaxFormComponentUpdatingBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/form/AjaxFormComponentUpdatingBehavior.java\n@@ -46,7 +46,8 @@\n  */\n public abstract class AjaxFormComponentUpdatingBehavior extends AjaxEventBehavior\n {\n-\tprivate static final Logger log = LoggerFactory.getLogger(AjaxFormComponentUpdatingBehavior.class);\n+\tprivate static final Logger log = LoggerFactory\n+\t\t.getLogger(AjaxFormComponentUpdatingBehavior.class);\n \n \t/**\n \t * \n@@ -76,8 +77,8 @@ protected void onBind()\n \t\tComponent component = getComponent();\n \t\tif (!(component instanceof FormComponent))\n \t\t{\n-\t\t\tthrow new WicketRuntimeException(\"Behavior \" + getClass().getName() +\n-\t\t\t\t\" can only be added to an instance of a FormComponent\");\n+\t\t\tthrow new WicketRuntimeException(\"Behavior \" + getClass().getName()\n+\t\t\t\t+ \" can only be added to an instance of a FormComponent\");\n \t\t}\n \n \t\tcheckComponent((FormComponent<?>)component);\n@@ -94,10 +95,11 @@ protected void onBind()\n \t */\n \tprotected void checkComponent(FormComponent<?> component)\n \t{\n-\t\tif (Application.get().usesDevelopmentConfig() &&\n-\t\t\tAjaxFormChoiceComponentUpdatingBehavior.appliesTo(component))\n+\t\tif (Application.get().usesDevelopmentConfig()\n+\t\t\t&& AjaxFormChoiceComponentUpdatingBehavior.appliesTo(component))\n \t\t{\n-\t\t\tlog.warn(String.format(\n+\t\t\tlog.warn(String\n+\t\t\t\t.format(\n \t\t\t\t\t\"AjaxFormComponentUpdatingBehavior is not supposed to be added in the form component at path: \\\"%s\\\". \"\n \t\t\t\t\t\t+ \"Use the AjaxFormChoiceComponentUpdatingBehavior instead, that is meant for choices/groups that are not one component in the html but many\",\n \t\t\t\t\tcomponent.getPageRelativePath()));\n@@ -139,13 +141,7 @@ protected final void onEvent(final AjaxRequestTarget target)\n \t\t{\n \t\t\tformComponent.inputChanged();\n \t\t\tformComponent.validate();\n-\t\t\tif (formComponent.hasErrorMessage())\n-\t\t\t{\n-\t\t\t\tformComponent.invalid();\n-\n-\t\t\t\tonError(target, null);\n-\t\t\t}\n-\t\t\telse\n+\t\t\tif (formComponent.isValid())\n \t\t\t{\n \t\t\t\tformComponent.valid();\n \t\t\t\tif (getUpdateModel())\n@@ -155,6 +151,12 @@ protected final void onEvent(final AjaxRequestTarget target)\n \n \t\t\t\tonUpdate(target);\n \t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tformComponent.invalid();\n+\n+\t\t\t\tonError(target, null);\n+\t\t\t}\n \t\t}\n \t\tcatch (RuntimeException e)\n \t\t{\n",
        "project": "wicket",
        "linesAdd": 15,
        "jira_id": "5230",
        "nb_skipped": 4,
        "commit": "9c8f658a",
        "nb_failure": 1,
        "linesRem": 13,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 163,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.lang.NumbersTest"
        ],
        "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/lang/Numbers.java b/wicket-util/src/main/java/org/apache/wicket/util/lang/Numbers.java\nindex f4e7858376..260d8d1463 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/lang/Numbers.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/lang/Numbers.java\n@@ -38,8 +38,8 @@ private Numbers()\n \t * \n \t * @param numberType\n \t *            the type of the number for which the minimum value will be returned\n-\t * @return the minimum value of the numberType or {@value Double#MIN_VALUE} if the numberType\n-\t *         itself is either {@code null} or has no minimum value\n+\t * @return the minimum value of the numberType or Double if the numberType itself is either\n+\t *         {@code null} or has no minimum value\n \t */\n \tpublic static Number getMinValue(Class<? extends Number> numberType)\n \t{\n@@ -54,11 +54,11 @@ else if (Long.class == numberType || long.class == numberType)\n \t\t}\n \t\telse if (Float.class == numberType || float.class == numberType)\n \t\t{\n-\t\t\tresult = Float.MIN_VALUE;\n+\t\t\tresult = -Float.MAX_VALUE;\n \t\t}\n \t\telse if (Double.class == numberType || double.class == numberType)\n \t\t{\n-\t\t\tresult = Double.MIN_VALUE;\n+\t\t\tresult = -Double.MAX_VALUE;\n \t\t}\n \t\telse if (Byte.class == numberType || byte.class == numberType)\n \t\t{\n@@ -70,8 +70,8 @@ else if (Short.class == numberType || short.class == numberType)\n \t\t}\n \t\telse\n \t\t{ // null of any other Number\n-\t\t\tLOG.debug(\"'{}' has no minimum value. Falling back to Double.MIN_VALUE.\", numberType);\n-\t\t\tresult = Double.MIN_VALUE;\n+\t\t\tLOG.debug(\"'{}' has no minimum value. Falling back to Double.\", numberType);\n+\t\t\tresult = -Double.MAX_VALUE;\n \t\t}\n \n \t\treturn result;\n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "4696",
        "nb_skipped": 0,
        "commit": "f5f802c5",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 891,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ComponentInitializationTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/Component.java b/wicket/src/main/java/org/apache/wicket/Component.java\nindex 380637be9c..f71a97a47b 100644\n--- a/wicket/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket/src/main/java/org/apache/wicket/Component.java\n@@ -967,8 +967,8 @@ void initialize()\n \t{\n \t\tif (!getFlag(FLAG_INITIALIZED))\n \t\t{\n-\t\t\tonInitialize();\n \t\t\tsetFlag(FLAG_INITIALIZED, true);\n+\t\t\tonInitialize();\n \t\t}\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "2961",
        "nb_skipped": 1,
        "commit": "3d8c9d75",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1499,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.mapper.MountedMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\nindex 12f8985e43..c55222e9c8 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/MountedMapper.java\n@@ -424,6 +424,11 @@ protected Url buildUrl(UrlInfo info)\n \t\t\tString optionalPlaceholder = getOptionalPlaceholder(mountSegments[i]);\n \t\t\tif (placeholder != null)\n \t\t\t{\n+\t\t\t\tif (!copy.getNamedKeys().contains(placeholder))\n+\t\t\t\t{\n+\t\t\t\t\t// no value for placeholder - cannot mount\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n \t\t\t\turl.getSegments().set(i - dropped, copy.get(placeholder).toString(\"\"));\n \t\t\t\tcopy.remove(placeholder);\n \t\t\t}\n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "5247",
        "nb_skipped": 3,
        "commit": "44a4132f",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 187,
        "nb_error": 0,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.wicket.util.io.ConnectionsTest"
        ],
        "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/io/Connections.java b/wicket-util/src/main/java/org/apache/wicket/util/io/Connections.java\nindex 5336af676f..167cefd71c 100644\n--- a/wicket-util/src/main/java/org/apache/wicket/util/io/Connections.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/io/Connections.java\n@@ -57,7 +57,6 @@ public static Time getLastModified(final URL url) throws IOException\n \r\n \t\t// otherwise open the url and proceed\r\n \t\tURLConnection connection = url.openConnection();\r\n-\t\tconnection.setDoInput(false);\r\n \r\n \t\tfinal long milliseconds;\r\n \r\n",
        "project": "wicket",
        "linesAdd": 0,
        "jira_id": "5838",
        "nb_skipped": 2,
        "commit": "e93fdd5a",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": true,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 1638,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.queueing.transparentresolvers.DequeueingTransparentWebMarkupContainerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex 30293fb45b..55e3184ba9 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -2178,9 +2178,13 @@ else if (wicketTag.isFragmentTag())\n \t\t\t{\n \t\t\t\treturn DequeueTagAction.SKIP;\n \t\t\t}\n+\t\t\telse if (wicketTag.isChildTag())\n+\t\t\t{\n+\t\t\t\treturn DequeueTagAction.DEQUEUE;\n+\t\t\t}\n \t\t\telse\n \t\t\t{\n-\t\t\t\treturn null; // dont know\n+\t\t\t\treturn null; // don't know\n \t\t\t}\n \t\t}\n \t\treturn DequeueTagAction.DEQUEUE;\n",
        "project": "wicket",
        "linesAdd": 5,
        "jira_id": "5572",
        "nb_skipped": 2,
        "commit": "cd414fa5",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 0,
        "nb_test": 171,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.io.XmlReaderTest"
        ],
        "patch": "",
        "project": "wicket",
        "linesAdd": 0,
        "jira_id": "5416",
        "nb_skipped": 0,
        "commit": "87fa630f",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 377,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "wicket.ajax.AjaxTimerBehaviorTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/wicket/ajax/AbstractAjaxTimerBehavior.java b/wicket/src/main/java/wicket/ajax/AbstractAjaxTimerBehavior.java\nindex a297a5fcc7..59eeabc6c8 100644\n--- a/wicket/src/main/java/wicket/ajax/AbstractAjaxTimerBehavior.java\n+++ b/wicket/src/main/java/wicket/ajax/AbstractAjaxTimerBehavior.java\n@@ -16,6 +16,7 @@\n  */\n package wicket.ajax;\n \n+import wicket.RequestCycle;\n import wicket.markup.html.IHeaderResponse;\n import wicket.markup.html.WebPage;\n import wicket.util.time.Duration;\n@@ -66,10 +67,16 @@ public void renderHead(IHeaderResponse response)\n \t\tif (this.attachedBodyOnLoadModifier == false)\n \t\t{\n \t\t\tthis.attachedBodyOnLoadModifier = true;\n+\t\t\tif (RequestCycle.get().getRequestTarget() instanceof AjaxRequestTarget) {\n+\t\t\t\tresponse.renderJavascript(getJsTimeoutCall(updateInterval), getComponent().getMarkupId());\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n \t\t\t\t((WebPage)getComponent().getPage()).getBodyContainer().addOnLoadModifier(\n \t\t\t\t\t\tgetJsTimeoutCall(updateInterval), getComponent());\n \t\t\t}\n \t\t}\n+\t}\n \n \t/**\n \t * @param updateInterval\n@@ -78,7 +85,8 @@ public void renderHead(IHeaderResponse response)\n \t */\n \tprotected final String getJsTimeoutCall(final Duration updateInterval)\n \t{\n-\t\treturn \"setTimeout(function() { \" + getCallbackScript(false, true) + \" }, \"\n+\t\t// this might look strange, but it is necessary for IE not to leak :(\n+\t\treturn \"setTimeout(\\\"\" + getCallbackScript(false, true) + \"\\\", \"\n \t\t\t\t+ updateInterval.getMilliseconds() + \");\";\n \t}\n \n@@ -92,11 +100,7 @@ protected final void respond(final AjaxRequestTarget target)\n \n \t\tif (!stopped)\n \t\t{\n-\t\t\t// this might look strange, but it is necessary for IE not to leak\n-\t\t\tString js = \"setTimeout(\\\"\" + getCallbackScript(false, true) + \"\\\", \"\n-\t\t\t\t\t+ updateInterval.getMilliseconds() + \");\";\n-\n-\t\t\ttarget.appendJavascript(js);\n+\t\t\ttarget.appendJavascript(getJsTimeoutCall(updateInterval));\n \t\t}\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 9,
        "jira_id": "208",
        "nb_skipped": 0,
        "commit": "b224bad8",
        "nb_failure": 2,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 407,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "wicket.util.collections.MiniMapTest"
        ],
        "patch": "diff --git a/jdk-1.4/wicket/src/main/java/wicket/util/collections/MiniMap.java b/jdk-1.4/wicket/src/main/java/wicket/util/collections/MiniMap.java\nindex 7581c2144f..d63c8368ac 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/util/collections/MiniMap.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/util/collections/MiniMap.java\n@@ -229,19 +229,19 @@ public Iterator iterator()\n \t\t\t\t{\n \t\t\t\t\tpublic boolean hasNext()\n \t\t\t\t\t{\n-\t\t\t\t\t\treturn i < size;\n+\t\t\t\t\t\treturn i < size - 1;\n \t\t\t\t\t}\n \n \t\t\t\t\tpublic Object next()\n \t\t\t\t\t{\n-\t\t\t\t\t\t// Find next key\n-\t\t\t\t\t\ti = nextKey(nextIndex(i));\n-\n \t\t\t\t\t\t// Just in case... (WICKET-428)\n \t\t\t\t\t\tif (!hasNext()) {\n \t\t\t\t\t\t\tthrow new NoSuchElementException();\n \t\t\t\t\t\t}\n \t\t\t\t\t\t\n+\t\t\t\t\t\t// Find next key\n+\t\t\t\t\t\ti = nextKey(nextIndex(i));\n+\t\t\t\t\t\t\n \t\t\t\t\t\t// Get key\n \t\t\t\t\t\treturn keys[i];\n \t\t\t\t\t}\n@@ -273,6 +273,9 @@ public Collection values()\n \t\t{\n \t\t\tpublic Object get(final int index)\n \t\t\t{\n+\t\t\t\tif (index > size - 1) {\n+\t\t\t\t\tthrow new IndexOutOfBoundsException();\n+\t\t\t\t}\n \t\t\t\tint keyIndex = nextKey(0);\n \n \t\t\t\tfor (int i = 0; i < index; i++)\n",
        "project": "wicket",
        "linesAdd": 6,
        "jira_id": "428",
        "nb_skipped": 0,
        "commit": "4a6a573b",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1870,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.MarkupContainerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex 7941203c5e..b739d47b32 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -1016,15 +1016,17 @@ public void component(final Component component, final IVisit<Void> visit)\n \t@Deprecated\n \tpublic final Component get(int index)\n \t{\n+\t\tfinal int requestedIndex = index;\n \t\tComponent childAtIndex = null;\n \t\tIterator<Component> childIterator = iterator();\n-\t\twhile (index-- >= 0 && childIterator.hasNext())\n+\t\twhile (index >= 0 && childIterator.hasNext())\n \t\t{\n \t\t\tchildAtIndex = childIterator.next();\n+\t\t\tindex--;\n \t\t}\n-\t\tif(childAtIndex == null) \n+\t\tif(index >= 0 || childAtIndex == null)\n \t\t{\n-\t\t\tthrow new ArrayIndexOutOfBoundsException(Integer.toString(index));\n+\t\t\tthrow new ArrayIndexOutOfBoundsException(Integer.toString(requestedIndex));\n \t\t}\n \t\treturn childAtIndex;\n \t}\n",
        "project": "wicket",
        "linesAdd": 5,
        "jira_id": "5981",
        "nb_skipped": 1,
        "commit": "eb125865",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1199,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.form.AutoFormLabelPickupTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/AutoLabelTextResolver.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/AutoLabelTextResolver.java\nindex 85cf7ce5af..34cfe822d1 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/AutoLabelTextResolver.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/AutoLabelTextResolver.java\n@@ -28,7 +28,10 @@\n import org.apache.wicket.markup.parser.XmlTag;\r\n import org.apache.wicket.markup.parser.filter.WicketTagIdentifier;\r\n import org.apache.wicket.markup.resolver.IComponentResolver;\r\n+import org.apache.wicket.model.IModel;\r\n+import org.apache.wicket.model.LoadableDetachableModel;\r\n import org.apache.wicket.model.Model;\r\n+import org.apache.wicket.model.StringResourceModel;\r\n import org.apache.wicket.request.cycle.RequestCycle;\r\n import org.apache.wicket.util.string.Strings;\r\n \r\n@@ -130,76 +133,95 @@ protected void onComponentTag(final ComponentTag tag)\n \t\t@Override\r\n \t\tpublic void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag)\r\n \t\t{\r\n-\t\t\tboolean storeLabelText = false;\r\n \r\n \t\t\t// try and find some form of label content...\r\n-\t\t\tString labelText = null;\r\n+\t\t\tIModel<String> labelModel = findLabelContent(markupStream, openTag);\r\n+\t\t\t// print the label text\r\n+\t\t\treplaceComponentTagBody(markupStream, openTag,\r\n+\t\t\t\tlabelModel != null ? labelModel.getObject() : \"\");\r\n \r\n-\t\t\t// check if the labeled component is a label provider\r\n+\t\t\t// store the label text in FormComponent's label model so its available to errors\r\n+\t\t\tif (labelModel != null)\r\n+\t\t\t{\r\n+\t\t\t\tif (labeled instanceof FormComponent)\r\n+\t\t\t\t{\r\n+\t\t\t\t\tFormComponent<?> fc = (FormComponent<?>)labeled;\r\n+\t\t\t\t\tfc.setLabel(labelModel);\r\n+\t\t\t\t}\r\n+\t\t\t\telse\r\n+\t\t\t\t{\r\n+\t\t\t\t\t// if we can't hand off the labelmodel to a component, we have to detach it\r\n+\t\t\t\t\tlabelModel.detach();\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n \r\n+\t\tprivate IModel<String> findLabelContent(final MarkupStream markupStream,\r\n+\t\t\tfinal ComponentTag tag)\r\n+\t\t{\r\n \t\t\tif (labeled instanceof ILabelProvider)\r\n \t\t\t{\r\n+\t\t\t\t// check if the labeled component is a label provider\r\n \t\t\t\tILabelProvider<String> provider = (ILabelProvider<String>)labeled;\r\n \t\t\t\tif (provider.getLabel() != null)\r\n \t\t\t\t{\r\n-\t\t\t\t\tString text = provider.getLabel().getObject();\r\n-\t\t\t\t\tif (!Strings.isEmpty(text))\r\n+\t\t\t\t\tif (!Strings.isEmpty(provider.getLabel().getObject()))\r\n+\r\n \t\t\t\t\t{\r\n-\t\t\t\t\t\tlabelText = text;\r\n+\t\t\t\t\t\treturn provider.getLabel();\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \r\n \t\t\t// check if the labeled component is a form component\r\n-\r\n-\t\t\tif (labelText == null && labeled instanceof FormComponent)\r\n+\t\t\tif (labeled instanceof FormComponent)\r\n \t\t\t{\r\n-\t\t\t\tString text = ((FormComponent<?>)labeled).getDefaultLabel(\"wicket:unknown\");\r\n+\t\t\t\tfinal FormComponent<?> formComponent = (FormComponent<?>)labeled;\r\n+\t\t\t\tString text = formComponent.getDefaultLabel(\"wicket:unknown\");\r\n \t\t\t\tif (!\"wicket:unknown\".equals(text) && !Strings.isEmpty(text))\r\n \t\t\t\t{\r\n-\t\t\t\t\tlabelText = text;\r\n+\t\t\t\t\treturn new LoadableDetachableModel<String>()\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\t@Override\r\n+\t\t\t\t\t\tprotected String load()\r\n+\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\treturn formComponent.getDefaultLabel(\"wicket:unknown\");\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t};\r\n \t\t\t\t}\r\n \t\t\t}\r\n \r\n \t\t\t// check if wicket:label tag has a message key\r\n-\t\t\tif (labelText == null && openTag.getAttribute(\"key\") != null)\r\n \t\t\t{\r\n-\t\t\t\tString text = labeled.getString(openTag.getAttribute(\"key\"));\r\n+\t\t\t\tString resourceKey = tag.getAttribute(\"key\");\r\n+\t\t\t\tif (resourceKey != null)\r\n+\t\t\t\t{\r\n+\t\t\t\t\tString text = labeled.getString(resourceKey);\r\n \t\t\t\t\tif (!Strings.isEmpty(text))\r\n \t\t\t\t\t{\r\n-\t\t\t\t\tlabelText = text;\r\n-\t\t\t\t\tstoreLabelText = true;\r\n+\t\t\t\t\t\treturn new StringResourceModel(resourceKey, labeled, null);\r\n+\t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \r\n \t\t\t// as last resort use the tag body\r\n-\t\t\tif (labelText == null)\r\n \t\t\t{\r\n \t\t\t\tString text = new ResponseBufferZone(RequestCycle.get(), markupStream)\r\n \t\t\t\t{\r\n \t\t\t\t\t@Override\r\n \t\t\t\t\tprotected void executeInsideBufferedZone()\r\n \t\t\t\t\t{\r\n-\t\t\t\t\t\tTextLabel.super.onComponentTagBody(markupStream, openTag);\r\n+\t\t\t\t\t\tTextLabel.super.onComponentTagBody(markupStream, tag);\r\n \t\t\t\t\t}\r\n \t\t\t\t}.execute().toString();\r\n \r\n \t\t\t\tif (!Strings.isEmpty(text))\r\n \t\t\t\t{\r\n-\t\t\t\t\tlabelText = text;\r\n-\t\t\t\t\tstoreLabelText = true;\r\n+\t\t\t\t\treturn Model.of(text);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \r\n-\t\t\t// print the label text\r\n-\t\t\treplaceComponentTagBody(markupStream, openTag, labelText);\r\n-\r\n-\t\t\t// store the label text in FormComponent's label model so its available to errors\r\n-\t\t\tif (labeled instanceof FormComponent)\r\n-\t\t\t{\r\n-\t\t\t\tFormComponent<?> fc = (FormComponent<?>)labeled;\r\n-\t\t\t\tfc.setLabel(Model.of(labelText));\r\n-\t\t\t}\r\n+\t\t\treturn null;\r\n \t\t}\r\n \t}\r\n \r\n",
        "project": "wicket",
        "linesAdd": 45,
        "jira_id": "4102",
        "nb_skipped": 2,
        "commit": "e743fd7e",
        "nb_failure": 2,
        "linesRem": 24,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1142,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.mapper.CryptoMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/CryptoMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/CryptoMapper.java\nindex 4e632f80e7..bc2b297d94 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/CryptoMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/CryptoMapper.java\n@@ -125,10 +125,6 @@ private Url encryptUrl(final Url url)\n \t\tencryptedUrl.getSegments().add(encryptedUrlString);\r\n \r\n \t\tint numberOfSegments = url.getSegments().size();\r\n-\t\tif (numberOfSegments == 0 && !url.getQueryParameters().isEmpty())\r\n-\t\t{\r\n-\t\t\tnumberOfSegments = 1;\r\n-\t\t}\r\n \t\tchar[] encryptedChars = encryptedUrlString.toCharArray();\r\n \t\tint hash = 0;\r\n \t\tfor (int segNo = 0; segNo < numberOfSegments; segNo++)\r\n@@ -157,7 +153,7 @@ private Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\t}\r\n \r\n \t\tList<String> segments = encryptedUrl.getSegments();\r\n-\t\tif (segments.size() < 2)\r\n+\t\tif (segments.size() < 1)\r\n \t\t{\r\n \t\t\treturn null;\r\n \t\t}\r\n@@ -175,11 +171,6 @@ private Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\t\tUrl originalUrl = Url.parse(decryptedUrl, request.getCharset());\r\n \r\n \t\t\tint originalNumberOfSegments = originalUrl.getSegments().size();\r\n-\t\t\tif (originalNumberOfSegments == 0 &&\r\n-\t\t\t\toriginalUrl.getQueryParameters().isEmpty() == false)\r\n-\t\t\t{\r\n-\t\t\t\toriginalNumberOfSegments = 1;\r\n-\t\t\t}\r\n \t\t\tint numberOfSegments = encryptedUrl.getSegments().size();\r\n \r\n \t\t\tchar[] encryptedChars = encryptedUrlString.toCharArray();\r\n@@ -207,6 +198,12 @@ private Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\t\t\t}\r\n \t\t\t\telse\r\n \t\t\t\t{\r\n+\t\t\t\t\t// append new segments from browser\r\n+\t\t\t\t\twhile (segNo < numberOfSegments)\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\turl.getSegments().add(encryptedUrl.getSegments().get(segNo));\r\n+\t\t\t\t\t\tsegNo++;\r\n+\t\t\t\t\t}\r\n \t\t\t\t\tbreak;\r\n \t\t\t\t}\r\n \t\t\t}\r\n",
        "project": "wicket",
        "linesAdd": 6,
        "jira_id": "3514",
        "nb_skipped": 2,
        "commit": "2b6da516",
        "nb_failure": 2,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1549,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.mapper.PackageMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\nindex 0be5d76db3..2c015a4e7f 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\n@@ -259,12 +259,6 @@ private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePag\n \t\tif (pageId != null)\n \t\t{\n \t\t\tpage = getStoredPage(pageId);\n-\n-\t\t\tif (page == null)\n-\t\t\t{\n-\t\t\t\t// WICKET-4594 - ignore the parsed parameters for stateful pages\n-\t\t\t\tpageParameters = null;\n-\t\t\t}\n \t\t}\n \n \t\tif (page == null)\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\nindex 15694686e0..8a305789bc 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n@@ -271,11 +271,11 @@ protected IRequestHandler processListener(PageComponentInfo pageComponentInfo,\n \n \t\tif (listenerInterface != null)\n \t\t{\n-//\t\t\tif (pageInfo.getPageId() != null)\n-//\t\t\t{\n-//\t\t\t\t// WICKET-4594 - ignore the parsed parameters for stateful pages\n-//\t\t\t\tpageParameters = null;\n-//\t\t\t}\n+\t\t\tif (pageInfo.getPageId() != null)\n+\t\t\t{\n+\t\t\t\t// WICKET-4594 - ignore the parsed parameters for stateful pages\n+\t\t\t\tpageParameters = null;\n+\t\t\t}\n \n \t\t\tPageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(),\n \t\t\t\tpageClass, pageParameters, renderCount, componentInfo.getComponentPath());\n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "4686",
        "nb_skipped": 2,
        "commit": "89184b79",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1526,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.parser.XmlPullParserTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/XmlPullParser.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/XmlPullParser.java\nindex 262b79576f..377138a63b 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/XmlPullParser.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/XmlPullParser.java\n@@ -17,9 +17,9 @@\n package org.apache.wicket.markup.parser;\n \n import java.io.BufferedInputStream;\n-import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.StringReader;\n import java.text.ParseException;\n \n import org.apache.wicket.markup.parser.XmlTag.TagType;\n@@ -48,10 +48,9 @@\n \tpublic static final String SCRIPT = \"script\";\n \n \t/**\n-\t * Reads the xml data from an input stream and converts the chars according to its encoding\n-\t * (<?xml ... encoding=\"...\" ?>)\n+\t * The encoding of the XML.\n \t */\n-\tprivate XmlReader xmlReader;\n+\tprivate String encoding;\n \n \t/**\n \t * A XML independent reader which loads the whole source data into memory and which provides\n@@ -84,7 +83,7 @@ public XmlPullParser()\n \t@Override\n \tpublic final String getEncoding()\n \t{\n-\t\treturn xmlReader.getEncoding();\n+\t\treturn encoding;\n \t}\n \n \t@Override\n@@ -544,7 +543,10 @@ else if (charAt == ch)\n \t@Override\n \tpublic void parse(final CharSequence string) throws IOException\n \t{\n-\t\tparse(new ByteArrayInputStream(string.toString().getBytes()), null);\n+\t\tArgs.notNull(string, \"string\");\n+\n+\t\tthis.input = new FullyBufferedReader(new StringReader(string.toString()));\n+\t\tthis.encoding = null;\n \t}\n \n \t/**\n@@ -554,6 +556,8 @@ public void parse(final CharSequence string) throws IOException\n \t * @param in\n \t *            The input stream to read and parse\n \t * @throws IOException\n+\t * \n+\t * @see {@link #parse(InputStream, String)}\n \t */\n \t@Override\n \tpublic void parse(final InputStream in) throws IOException\n@@ -563,7 +567,9 @@ public void parse(final InputStream in) throws IOException\n \t}\n \n \t/**\n-\t * Reads and parses markup from an input stream\n+\t * Reads and parses markup from an input stream.\n+\t * <p>\n+\t * Note: The input is closed after parsing.\n \t * \n \t * @param inputStream\n \t *            The input stream to read and parse\n@@ -578,13 +584,14 @@ public void parse(final InputStream inputStream, final String encoding) throws I\n \n \t\ttry\n \t\t{\n-\t\t\txmlReader = new XmlReader(new BufferedInputStream(inputStream, 4000), encoding);\n-\t\t\tinput = new FullyBufferedReader(xmlReader);\n+\t\t\tXmlReader xmlReader = new XmlReader(new BufferedInputStream(inputStream, 4000),\n+\t\t\t\tencoding);\n+\t\t\tthis.input = new FullyBufferedReader(xmlReader);\n+\t\t\tthis.encoding = xmlReader.getEncoding();\n \t\t}\n \t\tfinally\n \t\t{\n \t\t\tIOUtils.closeQuietly(inputStream);\n-\t\t\tIOUtils.closeQuietly(xmlReader);\n \t\t}\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 11,
        "jira_id": "5398",
        "nb_skipped": 2,
        "commit": "19e7c1cd",
        "nb_failure": 1,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1646,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.resolver.issue5569.Issue5569Test"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\nindex c7fe735779..cbddd25609 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\n@@ -26,6 +26,8 @@\n import org.apache.wicket.markup.parser.XmlTag.TagType;\n import org.apache.wicket.markup.resolver.IComponentResolver;\n import org.apache.wicket.util.lang.Classes;\n+import org.apache.wicket.util.visit.IVisit;\n+import org.apache.wicket.util.visit.IVisitor;\n \n /**\n  * Implements boilerplate as needed by many markup sourcing strategies.\n@@ -60,22 +62,37 @@ public AbstractMarkupSourcingStrategy()\n \tprotected IMarkupFragment searchMarkupInTransparentResolvers(final MarkupContainer container,\n \t\tfinal Component child)\n \t{\n-\t\tIMarkupFragment markup = null;\n+\t\treturn container.visitChildren(MarkupContainer.class, new IVisitor<MarkupContainer, IMarkupFragment>()\n+\t\t{\n+\t\t\t@Override\n+\t\t\tpublic void component(MarkupContainer resolvingContainer, IVisit<IMarkupFragment> visit)\n+\t\t\t{\n+\t\t\t\tif (resolvingContainer instanceof IComponentResolver)\n+\t\t\t\t{\n+\t\t\t\t\tIMarkupFragment childMarkup = resolvingContainer.getMarkup(child);\n \n-\t\tfor (Component ch : container)\n+\t\t\t\t\tif (childMarkup != null && childMarkup.size() > 0)\n \t\t\t\t\t{\n-\t\t\tif ((ch != child) && (ch instanceof MarkupContainer) &&\n-\t\t\t\t(ch instanceof IComponentResolver))\n+\t\t\t\t\t\tIComponentResolver componentResolver = (IComponentResolver)resolvingContainer;\n+\n+\t\t\t\t\t\tMarkupStream stream = new MarkupStream(childMarkup);\n+\n+\t\t\t\t\t\tComponentTag tag = stream.getTag();\n+\n+\t\t\t\t\t\tComponent resolvedComponent = resolvingContainer.get(tag.getId());\n+\t\t\t\t\t\tif (resolvedComponent == null)\n \t\t\t\t\t\t{\n-\t\t\t\tmarkup = ((MarkupContainer)ch).getMarkup(child);\n-\t\t\t\tif (markup != null)\n+\t\t\t\t\t\t\tresolvedComponent = componentResolver.resolve(resolvingContainer, stream, tag);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif (child == resolvedComponent)\n \t\t\t\t\t\t{\n-\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\tvisit.stop(childMarkup);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n-\n-\t\treturn markup;\n+\t\t\t}\n+\t\t});\n \t}\n \n \t/**\n",
        "project": "wicket",
        "linesAdd": 26,
        "jira_id": "5569",
        "nb_skipped": 2,
        "commit": "5efb8091",
        "nb_failure": 1,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1861,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.queueing.ComponentQueueingTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\nindex 0ea0002cf1..5b79f80d43 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\n@@ -18,11 +18,16 @@\n \n import java.text.ParseException;\n \n+import org.apache.wicket.Component;\n+import org.apache.wicket.MarkupContainer;\n import org.apache.wicket.markup.ComponentTag;\n+import org.apache.wicket.markup.ComponentTag.IAutoComponentFactory;\n import org.apache.wicket.markup.Markup;\n import org.apache.wicket.markup.MarkupElement;\n import org.apache.wicket.markup.MarkupException;\n import org.apache.wicket.markup.MarkupStream;\n+import org.apache.wicket.markup.html.internal.HtmlHeaderContainer;\n+import org.apache.wicket.markup.html.internal.HtmlHeaderItemsContainer;\n import org.apache.wicket.markup.parser.AbstractMarkupFilter;\n import org.apache.wicket.markup.parser.XmlTag.TagType;\n import org.apache.wicket.markup.resolver.HtmlHeaderResolver;\n@@ -72,6 +77,24 @@\n \t/** The Markup available so far for the resource */\n \tprivate final Markup markup;\n \n+\tprivate static final IAutoComponentFactory HTML_HEADER_FACTORY = new IAutoComponentFactory()\n+\t{\n+\t\t@Override\n+\t\tpublic Component newComponent(MarkupContainer container, ComponentTag tag)\n+\t\t{\n+\t\t\treturn new HtmlHeaderContainer(tag.getId());\n+\t\t}\n+\t};\n+\t\n+\tprivate static final IAutoComponentFactory HTML_HEADER_ITEMS_FACTORY = new IAutoComponentFactory()\n+\t{\n+\t\t@Override\n+\t\tpublic Component newComponent(MarkupContainer container, ComponentTag tag)\n+\t\t{\n+\t\t\treturn new HtmlHeaderItemsContainer(tag.getId());\n+\t\t}\n+\t};\n+\t\n \t/**\n \t * Construct.\n \t * \n@@ -164,6 +187,7 @@ else if (foundClosingHead)\n \t\ttag.setId(HEADER_ID);\n \t\ttag.setAutoComponentTag(true);\n \t\ttag.setModified(true);\n+\t\ttag.setAutoComponentFactory(HTML_HEADER_ITEMS_FACTORY);\n \t}\n \n \t/**\n@@ -188,6 +212,7 @@ private void handleHeadTag(ComponentTag tag)\n \t\t\t\ttag.setId(HEADER_ID);\n \t\t\t\ttag.setAutoComponentTag(true);\n \t\t\t\ttag.setModified(true);\n+\t\t\t\ttag.setAutoComponentFactory(HTML_HEADER_FACTORY);\n \t\t\t}\n \t\t}\n \t\telse if (tag.isClose())\n@@ -201,6 +226,7 @@ else if (tag.isClose())\n \t\t\t\theadOpenTag.setAutoComponentTag(false);\n \t\t\t\theadOpenTag.setModified(false);\n \t\t\t\theadOpenTag.setFlag(ComponentTag.RENDER_RAW, true);\n+\t\t\t\theadOpenTag.setAutoComponentFactory(null);\n \t\t\t}\n \n \t\t\tfoundClosingHead = true;\n@@ -217,6 +243,7 @@ private void insertHeadTag()\n \t\topenTag.setId(HEADER_ID);\n \t\topenTag.setAutoComponentTag(true);\n \t\topenTag.setModified(true);\n+\t\topenTag.setAutoComponentFactory(HTML_HEADER_FACTORY);\n \n \t\tfinal ComponentTag closeTag = new ComponentTag(HEAD, TagType.CLOSE);\n \t\tcloseTag.setOpenTag(openTag);\n",
        "project": "wicket",
        "linesAdd": 27,
        "jira_id": "5965",
        "nb_skipped": 1,
        "commit": "31c88569",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1470,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.mapper.PageInstanceMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\nindex 776e54668d..fb9b3bdaa8 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\n@@ -59,9 +59,9 @@ public PageInstanceMapper()\n \t@Override\n \tpublic IRequestHandler mapRequest(Request request)\n \t{\n-\t\tUrl url = request.getUrl();\n-\t\tif (matches(url))\n+\t\tif (matches(request))\n \t\t{\n+\t\t\tUrl url = request.getUrl();\n \t\t\tPageComponentInfo info = getPageComponentInfo(url);\n \t\t\tif (info != null && info.getPageInfo().getPageId() != null)\n \t\t\t{\n@@ -153,16 +153,38 @@ else if (requestHandler instanceof ListenerInterfaceRequestHandler)\n \tpublic int getCompatibilityScore(final Request request)\n \t{\n \t\tint score = 0;\n-\t\tUrl url = request.getUrl();\n-\t\tif (matches(url))\n+\t\tif (matches(request))\n \t\t{\n \t\t\tscore = Integer.MAX_VALUE;\n \t\t}\n \t\treturn score;\n \t}\n \n-\tprivate boolean matches(final Url url)\n+\t/**\n+\t * Matches when the request url starts with\n+\t * {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}/{@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n+\t * or when the base url starts with {@link org.apache.wicket.core.request.mapper.IMapperContext#getNamespace()}\n+\t * and the request url with {@link org.apache.wicket.core.request.mapper.IMapperContext#getPageIdentifier()}\n+\n+\t * @param request\n+\t *      the request to check\n+\t * @return {@code true} if the conditions match\n+\t */\n+\tprivate boolean matches(final Request request)\n \t{\n-\t\treturn urlStartsWith(url, getContext().getNamespace(), getContext().getPageIdentifier());\n+\t\tboolean matches = false;\n+\t\tUrl url = request.getUrl();\n+\t\tString namespace = getContext().getNamespace();\n+\t\tString pageIdentifier = getContext().getPageIdentifier();\n+\t\tif (urlStartsWith(url, namespace, pageIdentifier))\n+\t\t{\n+\t\t\tmatches = true;\n+\t\t}\n+\t\telse if (urlStartsWith(request.getClientUrl(), namespace) && urlStartsWith(url, pageIdentifier))\n+\t\t{\n+\t\t\tmatches = true;\n+\t\t}\n+\n+\t\treturn matches;\n \t}\n }\n",
        "project": "wicket",
        "linesAdd": 19,
        "jira_id": "5071",
        "nb_skipped": 4,
        "commit": "a2f848f2",
        "nb_failure": 0,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1792,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.cycle.RerenderPageTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HtmlHeaderContainer.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HtmlHeaderContainer.java\nindex 1ce6809861..e906560db6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HtmlHeaderContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/internal/HtmlHeaderContainer.java\n@@ -314,9 +314,8 @@ public boolean okToRenderComponent(final String scope, final String id)\n \t}\n \n \t@Override\n-\tprotected void onDetach()\n-\t{\n-\t\tsuper.onDetach();\n+\tprotected void onAfterRender() {\n+\t\tsuper.onAfterRender();\n \n \t\trenderedComponentsPerScope = null;\n \t\theaderResponse = null;\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "5960",
        "nb_skipped": 1,
        "commit": "03663750",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 48,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.mapper.parameter.PageParametersTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParameters.java b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParameters.java\nindex 03c3dc57bd..bb11fa49f3 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParameters.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParameters.java\n@@ -483,7 +483,8 @@ public PageParameters set(final String name, final Object value, final int index\n \t */\n \tpublic PageParameters set(final String name, final Object value)\n \t{\n-\t\tset(name, value, -1);\n+\t\tint position = getPosition(name);\n+\t\tset(name, value, position);\n \t\treturn this;\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "3906",
        "nb_skipped": 0,
        "commit": "aadaa4e9",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1410,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.util.string.JavaScriptUtilsTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/util/string/JavaScriptUtils.java b/wicket-core/src/main/java/org/apache/wicket/core/util/string/JavaScriptUtils.java\nindex f07d5151f1..42d9274b8b 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/util/string/JavaScriptUtils.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/util/string/JavaScriptUtils.java\n@@ -143,7 +143,7 @@ public static void writeJavaScriptUrl(final Response response, final CharSequenc\n \t\t\tresponse.write(\"charset=\\\"\" + Strings.escapeMarkup(charset) + \"\\\" \");\n \t\t}\n \t\tresponse.write(\"src=\\\"\");\n-\t\tresponse.write(Strings.escapeMarkup(url));\n+\t\tresponse.write(url);\n \t\tresponse.write(\"\\\"></script>\");\n \t\tresponse.write(\"\\n\");\n \t}\n@@ -201,7 +201,7 @@ public static void writeOpenTag(final Response response, String id)\n \t\tresponse.write(\"<script type=\\\"text/javascript\\\" \");\n \t\tif (id != null)\n \t\t{\n-\t\t\tresponse.write(\"id=\\\"\" + id + \"\\\"\");\n+\t\t\tresponse.write(\"id=\\\"\" + Strings.escapeMarkup(id) + \"\\\"\");\n \t\t}\n \t\tresponse.write(\">\");\n \t\tresponse.write(SCRIPT_CONTENT_PREFIX);\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "4777",
        "nb_skipped": 5,
        "commit": "eccb3b11",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 791,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ajax.form.OnChangeAjaxBehaviorTest",
            "org.apache.wicket.protocol.http.WebResponseExceptionsTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/protocol/http/MockWebApplication.java b/wicket/src/main/java/org/apache/wicket/protocol/http/MockWebApplication.java\nindex 59e69e021a..bde3d6715b 100644\n--- a/wicket/src/main/java/org/apache/wicket/protocol/http/MockWebApplication.java\n+++ b/wicket/src/main/java/org/apache/wicket/protocol/http/MockWebApplication.java\n@@ -544,7 +544,22 @@ public final void postProcessRequestCycle(WebRequestCycle cycle)\n \t\t\t\tcycle = createRequestCycle();\n \t\t\t\tcycle.request();\n \t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tString url = httpResponse.getHeader(\"Ajax-Location\");\n+\t\t\t\tif (url != null)\n+\t\t\t\t{\n+\t\t\t\t\tMockHttpServletRequest newHttpRequest = new MockHttpServletRequest(application,\n+\t\t\t\t\t\tservletSession, application.getServletContext());\n+\t\t\t\t\tnewHttpRequest.setRequestToRedirectString(url);\n+\t\t\t\t\twicketRequest = application.newWebRequest(newHttpRequest);\n+\n+\t\t\t\t\tcycle = createRequestCycle();\n+\t\t\t\t\tcycle.request();\n \t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n \t\tlastRenderedPage = generateLastRenderedPage(cycle);\n \n \t\tSession.set(getWicketSession());\n",
        "project": "wicket",
        "linesAdd": 15,
        "jira_id": "2261",
        "nb_skipped": 0,
        "commit": "089303f4",
        "nb_failure": 4,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1368,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ComponentTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 4470dbc714..b616d1bf63 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -2080,11 +2080,6 @@ public final boolean isRenderAllowed()\n \t */\n \tpublic final boolean isStateless()\n \t{\n-\t\tif (!getStatelessHint())\n-\t\t{\n-\t\t\treturn false;\n-\t\t}\n-\n \t\tif (\n \t\t\t// the component is either invisible or disabled\n \t\t\t(isVisibleInHierarchy() && isEnabledInHierarchy()) == false &&\n@@ -2097,6 +2092,11 @@ public final boolean isStateless()\n \t\t\treturn true;\n \t\t}\n \n+\t\tif (!getStatelessHint())\n+\t\t{\n+\t\t\treturn false;\n+\t\t}\n+\n \t\tfor (Behavior behavior : getBehaviors())\n \t\t{\n \t\t\tif (!behavior.getStatelessHint(this))\n",
        "project": "wicket",
        "linesAdd": 5,
        "jira_id": "4578",
        "nb_skipped": 8,
        "commit": "c66cf607",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1296,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.http.mock.MockHttpServletRequestTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletRequest.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletRequest.java\nindex a93eb7f340..73dc26f091 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletRequest.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/MockHttpServletRequest.java\n@@ -1068,11 +1068,7 @@ public String getServletPath()\n \t@Override\r\n \tpublic HttpSession getSession()\r\n \t{\r\n-\t\tif (session instanceof MockHttpSession && ((MockHttpSession)session).isTemporary())\r\n-\t\t{\r\n-\t\t\treturn null;\r\n-\t\t}\r\n-\t\treturn session;\r\n+\t\treturn getSession(true);\r\n \t}\r\n \r\n \t/**\r\n@@ -1085,11 +1081,21 @@ public HttpSession getSession()\n \t@Override\r\n \tpublic HttpSession getSession(boolean b)\r\n \t{\r\n-\t\tif (b && session instanceof MockHttpSession)\r\n+\t\tHttpSession sess = null;\r\n+\t\tif (session instanceof MockHttpSession)\r\n+\t\t{\r\n+\t\t\tMockHttpSession mockHttpSession = (MockHttpSession) session;\r\n+\t\t\tif (b)\r\n \t\t\t{\r\n-\t\t\t((MockHttpSession)session).setTemporary(false);\r\n+\t\t\t\tmockHttpSession.setTemporary(false);\r\n+\t\t\t}\r\n+\r\n+\t\t\tif (mockHttpSession.isTemporary() == false)\r\n+\t\t\t{\r\n+\t\t\t\tsess = session;\r\n+\t\t\t}\r\n \t\t}\r\n-\t\treturn getSession();\r\n+\t\treturn sess;\r\n \t}\r\n \r\n \t/**\r\n",
        "project": "wicket",
        "linesAdd": 14,
        "jira_id": "4370",
        "nb_skipped": 4,
        "commit": "7ca927c1",
        "nb_failure": 2,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 52,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.UrlTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 2c3289bceb..6950de276c 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -592,8 +592,8 @@ public String toString()\n \t}\n \n \t/**\n-\t * render full representation of url (including protocol, host and port) \n-\t * into string representation\n+\t * render full representation of url (including protocol, host and port) into string\n+\t * representation\n \t */\n \tpublic String toAbsoluteString()\n \t{\n@@ -601,8 +601,8 @@ public String toAbsoluteString()\n \t}\n \n \t/**\n-\t * render full representation of url (including protocol, host and port) \n-\t * into string representation\n+\t * render full representation of url (including protocol, host and port) into string\n+\t * representation\n \t * \n \t * @param charset\n \t * \n@@ -879,10 +879,12 @@ public String toString(final Charset charset)\n \t *            relative url\n \t */\n \tpublic void resolveRelative(final Url relative)\n+\t{\n+\t\tif (getSegments().size() > 0)\n \t\t{\n \t\t\t// strip the first non-folder segment\n \t\t\tgetSegments().remove(getSegments().size() - 1);\n-\n+\t\t}\n \t\t// remove all './' (current folder) from the relative url\n \t\tif (!relative.getSegments().isEmpty() && \".\".equals(relative.getSegments().get(0)))\n \t\t{\n",
        "project": "wicket",
        "linesAdd": 3,
        "jira_id": "4072",
        "nb_skipped": 0,
        "commit": "7d5b8645",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 794,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.form.validation.HomePageTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/html/form/Form.java b/wicket/src/main/java/org/apache/wicket/markup/html/form/Form.java\nindex 521e01422d..a1d958f8d6 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/form/Form.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/form/Form.java\n@@ -1238,12 +1238,16 @@ public Object component(final Component component)\n \t\t\t}\n \t\t};\n \n-\t\tvisitChildren(FormComponent.class, new IVisitor<Component>()\n+\t\tvisitChildren(Component.class, new IVisitor<Component>()\n \t\t{\n \t\t\tpublic Object component(final Component component)\n+\t\t\t{\n+\t\t\t\tif ((component instanceof Form) || (component instanceof FormComponent))\n \t\t\t\t{\n \t\t\t\t\treturn visitor.component(component);\n \t\t\t\t}\n+\t\t\t\treturn Component.IVisitor.CONTINUE_TRAVERSAL;\n+\t\t\t}\n \t\t});\n \n \t\tif (!error[0])\n",
        "project": "wicket",
        "linesAdd": 5,
        "jira_id": "2202",
        "nb_skipped": 0,
        "commit": "24ac1a35",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 1753,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.TransparentWebMarkupContainerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\nindex 27407cf773..b49f2f44a9 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AbstractMarkupSourcingStrategy.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.wicket.markup.html.panel;\n \n+import java.util.Iterator;\n+\n import org.apache.wicket.Component;\n import org.apache.wicket.MarkupContainer;\n import org.apache.wicket.markup.ComponentTag;\n@@ -26,8 +28,6 @@\n import org.apache.wicket.markup.parser.XmlTag.TagType;\n import org.apache.wicket.markup.resolver.IComponentResolver;\n import org.apache.wicket.util.lang.Classes;\n-import org.apache.wicket.util.visit.IVisit;\n-import org.apache.wicket.util.visit.IVisitor;\n \n /**\n  * Implements boilerplate as needed by many markup sourcing strategies.\n@@ -55,53 +55,58 @@ public AbstractMarkupSourcingStrategy()\n \t * \n \t * @param container\n \t *            the parent container.\n+\t * @param\n+\t * \t\t  containerMarkup\n+\t * \t\t\t  the markup of the container.           \n \t * @param child\n \t *            The component to find the markup for.\n \t * @return the markup fragment for the child, or {@code null}.\n \t */\n-\tprotected IMarkupFragment searchMarkupInTransparentResolvers(final MarkupContainer container,\n-\t\tfinal Component child)\n-\t{\n-\t\treturn container.visitChildren(MarkupContainer.class, new IVisitor<MarkupContainer, IMarkupFragment>()\n-\t\t{\n-\t\t\t@Override\n-\t\t\tpublic void component(MarkupContainer resolvingContainer, IVisit<IMarkupFragment> visit)\n+\tprotected IMarkupFragment searchMarkupInTransparentResolvers(MarkupContainer container,\n+\t\tIMarkupFragment containerMarkup, Component child)\n \t{\n-\t\t\t\t//prevents possible searching loops\n-\t\t\t\tif (child == resolvingContainer) \n+\t\tIMarkupFragment childMarkupFound = null;\n+\t\tIterator<Component> siblingsIterator = container.iterator();\n+\t\t\n+\t\twhile (siblingsIterator.hasNext() && childMarkupFound == null)\n \t\t{\n-\t\t\t\t\tvisit.dontGoDeeper();\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n+\t\t\tComponent sibling = siblingsIterator.next();\n \t\t\t\n-\t\t\t\tif (resolvingContainer instanceof IComponentResolver)\n+\t\t\tif(sibling == child || !sibling.isVisible())\n \t\t\t{\n-\t\t\t\t\tvisit.dontGoDeeper();\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\t\n-\t\t\t\t\tIMarkupFragment childMarkup = resolvingContainer.getMarkup(child);\n+\t\t\tIMarkupFragment siblingMarkup = containerMarkup.find(sibling.getId());\n \t\t\t\n-\t\t\t\t\tif (childMarkup != null && childMarkup.size() > 0)\n+\t\t\tif (siblingMarkup != null && sibling instanceof MarkupContainer)\n \t\t\t{\n-\t\t\t\t\t\tIComponentResolver componentResolver = (IComponentResolver)resolvingContainer;\n+\t\t\t\tIMarkupFragment childMarkup  = siblingMarkup.find(child.getId());\n \t\t\t\t\n+\t\t\t\tif (childMarkup != null && sibling instanceof IComponentResolver)\n+\t\t\t\t{\n+\t\t\t\t\tIComponentResolver componentResolver = (IComponentResolver)sibling;\n \t\t\t\t\tMarkupStream stream = new MarkupStream(childMarkup);\n-\n \t\t\t\t\tComponentTag tag = stream.getTag();\n \t\t\t\t\t\n-\t\t\t\t\t\tComponent resolvedComponent = resolvingContainer.get(tag.getId());\n+\t\t\t\t\tComponent resolvedComponent = sibling.get(tag.getId());\n \t\t\t\t\tif (resolvedComponent == null)\n \t\t\t\t\t{\n-\t\t\t\t\t\t\tresolvedComponent = componentResolver.resolve(resolvingContainer, stream, tag);\n+\t\t\t\t\t\tresolvedComponent = componentResolver.resolve((MarkupContainer)sibling, stream, tag);\n \t\t\t\t\t}\n \t\t\t\t\t\n \t\t\t\t\tif (child == resolvedComponent)\n \t\t\t\t\t{\n-\t\t\t\t\t\t\tvisit.stop(childMarkup);\n+\t\t\t\t\t\tchildMarkupFound = childMarkup;\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\telse \n+\t\t\t\t{\n+\t\t\t\t\tchildMarkupFound = searchMarkupInTransparentResolvers((MarkupContainer)sibling, siblingMarkup, child);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\t});\n+\t\treturn childMarkupFound;\n \t}\n \n \t/**\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java\nindex 0ac0647454..5f547ac9fe 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/AssociatedMarkupSourcingStrategy.java\n@@ -120,7 +120,7 @@ public IMarkupFragment getMarkup(final MarkupContainer parent, final Component c\n \t\t\treturn associatedMarkup;\n \t\t}\n \n-\t\tassociatedMarkup = searchMarkupInTransparentResolvers(parent, child);\n+\t\tassociatedMarkup = searchMarkupInTransparentResolvers(parent, markup, child);\n \t\tif (associatedMarkup != null)\n \t\t{\n \t\t\treturn associatedMarkup;\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\nindex 6699a6839c..7506d236d6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/panel/DefaultMarkupSourcingStrategy.java\n@@ -78,26 +78,24 @@ public IMarkupFragment getMarkup(final MarkupContainer container, final Componen\n \t{\n \t\t// If the sourcing strategy did not provide one, than ask the component.\n \t\t// Get the markup for the container\n-\t\tIMarkupFragment markup = container.getMarkup();\n-\t\tif (markup == null)\n+\t\tIMarkupFragment containerMarkup = container.getMarkup();\n+\t\tif (containerMarkup == null)\n \t\t{\n \t\t\treturn null;\n \t\t}\n \n \t\tif (child == null)\n \t\t{\n-\t\t\treturn markup;\n+\t\t\treturn containerMarkup;\n \t\t}\n \t\t\n \t\t// Find the child's markup\n-\t\tmarkup = markup.find(child.getId());\n-\t\tif (markup != null)\n+\t\tIMarkupFragment childMarkup = containerMarkup.find(child.getId());\n+\t\tif (childMarkup != null)\n \t\t{\n-\t\t\treturn markup;\n+\t\t\treturn childMarkup;\n \t\t}\n \t\t\n-\t\tmarkup = searchMarkupInTransparentResolvers(container, child);\n-\t\t\n-\t\treturn markup;\n+\t\treturn searchMarkupInTransparentResolvers(container, containerMarkup, child);\n \t}\n }\n",
        "project": "wicket",
        "linesAdd": 34,
        "jira_id": "5898",
        "nb_skipped": 1,
        "commit": "ffdd0864",
        "nb_failure": 0,
        "linesRem": 33,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 179,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.time.TimeTest"
        ],
        "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/time/Time.java b/wicket-util/src/main/java/org/apache/wicket/util/time/Time.java\nindex cc5f630b97..2aac2be5b5 100755\n--- a/wicket-util/src/main/java/org/apache/wicket/util/time/Time.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/time/Time.java\n@@ -349,7 +349,7 @@ public int getHour()\n \t */\r\n \tpublic int getHour(final Calendar calendar)\r\n \t{\r\n-\t\treturn get(calendar, Calendar.HOUR);\r\n+\t\treturn get(calendar, Calendar.HOUR_OF_DAY);\r\n \t}\r\n \r\n \t/**\r\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "5442",
        "nb_skipped": 0,
        "commit": "a382917f",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1706,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ajax.AjaxCallbackFunctionTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractDefaultAjaxBehavior.java b/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractDefaultAjaxBehavior.java\nindex a309635233..bc0989d9d1 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractDefaultAjaxBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/AbstractDefaultAjaxBehavior.java\n@@ -504,30 +504,28 @@ public CharSequence getCallbackFunctionBody(CallbackParameter... extraParameters\n \t\tsb.append(\"var attrs = \");\n \t\tsb.append(attrsJson);\n \t\tsb.append(\";\\n\");\n-\t\tsb.append(\"var params = {\");\n-\t\tboolean first = true;\n+\t\tJSONArray jsonArray = new JSONArray();\n \t\tfor (CallbackParameter curExtraParameter : extraParameters)\n \t\t{\n \t\t\tif (curExtraParameter.getAjaxParameterName() != null)\n \t\t\t{\n-\t\t\t\tif (!first)\n-\t\t\t\t\tsb.append(',');\n-\t\t\t\telse\n-\t\t\t\t\tfirst = false;\n-\t\t\t\tsb.append('\\'').append(curExtraParameter.getAjaxParameterName()).append(\"': \")\n-\t\t\t\t\t.append(curExtraParameter.getAjaxParameterCode());\n-\t\t\t}\n-\t\t}\n-\t\tsb.append(\"};\\n\");\n-\t\tif (attributes.getExtraParameters().isEmpty())\n+\t\t\t\ttry\n \t\t\t\t{\n-\t\t\tsb.append(\"attrs.\").append(AjaxAttributeName.EXTRA_PARAMETERS).append(\" = params;\\n\");\n+\t\t\t\t\tJSONObject object = new JSONObject();\n+\t\t\t\t\tobject.put(\"name\", curExtraParameter.getAjaxParameterName());\n+\t\t\t\t\tobject.put(\"value\", new JsonFunction(curExtraParameter.getAjaxParameterCode()));\n+\t\t\t\t\tjsonArray.put(object);\n \t\t\t\t}\n-\t\telse\n+\t\t\t\tcatch (JSONException e)\n \t\t\t\t{\n-\t\t\tsb.append(\"attrs.\").append(AjaxAttributeName.EXTRA_PARAMETERS).append(\" = Wicket.merge(attrs.\")\n-\t\t\t\t\t.append(AjaxAttributeName.EXTRA_PARAMETERS).append(\", params);\\n\");\n+\t\t\t\t\tthrow new WicketRuntimeException(e);\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n+\t\tsb.append(\"var params = \").append(jsonArray).append(\";\\n\");\n+\t\tsb.append(\"attrs.\").append(AjaxAttributeName.EXTRA_PARAMETERS)\n+\t\t\t\t.append(\" = params.concat(attrs.\")\n+\t\t\t\t.append(AjaxAttributeName.EXTRA_PARAMETERS).append(\");\\n\");\n \t\tsb.append(\"Wicket.Ajax.ajax(attrs);\\n\");\n \t\treturn sb;\n \t}\n",
        "project": "wicket",
        "linesAdd": 14,
        "jira_id": "5759",
        "nb_skipped": 1,
        "commit": "0374c040",
        "nb_failure": 7,
        "linesRem": 16,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1131,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.validation.validator.CreditCardValidatorTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java b/wicket-core/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\nindex df071d4cad..33c268e5c7 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/validation/validator/CreditCardValidator.java\n@@ -539,7 +539,7 @@ private CreditCard isVisa(String creditCardNumber)\n \t\t{\n \t\t\tif (creditCardNumber.startsWith(\"4\"))\n \t\t\t{\n-\t\t\t\treturn CreditCard.SWITCH;\n+\t\t\t\treturn CreditCard.VISA;\n \t\t\t}\n \t\t}\n \n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "3998",
        "nb_skipped": 2,
        "commit": "b76f9c44",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 1510,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.mapper.CryptoMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\nindex 58e704ee7c..91708a348c 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\n@@ -43,7 +43,6 @@\n  * deemed a plain text sibling of the corresponding segment in the encrypted URL, and all subsequent\r\n  * segments are considered plain text children of the current segment.\r\n  * \r\n- *\r\n  * @author igor.vaynberg\r\n  * @author Jesse Long\r\n  * @author svenmeier\r\n@@ -98,6 +97,12 @@ public Url mapHandler(final IRequestHandler requestHandler)\n \t\t\treturn null;\r\n \t\t}\r\n \r\n+\t\tif (url.isFull())\r\n+\t\t{\r\n+\t\t\t// do not encrypt full urls\r\n+\t\t\treturn url;\r\n+\t\t}\r\n+\r\n \t\treturn encryptUrl(url);\r\n \t}\r\n \r\n@@ -163,8 +168,8 @@ protected Url encryptUrl(final Url url)\n \tprotected Url decryptUrl(final Request request, final Url encryptedUrl)\r\n \t{\r\n \t\t/*\r\n-\t\t * If the encrypted URL has no segments it is the home page URL,\r\n-\t\t * and does not need decrypting.\r\n+\t\t * If the encrypted URL has no segments it is the home page URL, and does not need\r\n+\t\t * decrypting.\r\n \t\t */\r\n \t\tif (encryptedUrl.getSegments().isEmpty())\r\n \t\t{\r\n@@ -177,8 +182,8 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\ttry\r\n \t\t{\r\n \t\t\t/*\r\n-\t\t\t * The first encrypted segment contains an encrypted version of the\r\n-\t\t\t * entire plain text url.\r\n+\t\t\t * The first encrypted segment contains an encrypted version of the entire plain text\r\n+\t\t\t * url.\r\n \t\t\t */\r\n \t\t\tString encryptedUrlString = encryptedSegments.get(0);\r\n \t\t\tif (Strings.isEmpty(encryptedUrlString))\r\n@@ -210,17 +215,16 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\t\t\tif (!next.equals(encryptedSegment))\r\n \t\t\t\t{\r\n \t\t\t\t\t/*\r\n-\t\t\t\t\t * This segment received from the browser is not the same as the\r\n-\t\t\t\t\t * expected segment generated by the HashSegmentGenerator. Hence it,\r\n-\t\t\t\t\t * and all subsequent segments are considered plain text siblings of the\r\n-\t\t\t\t\t * original encrypted url.\r\n+\t\t\t\t\t * This segment received from the browser is not the same as the expected\r\n+\t\t\t\t\t * segment generated by the HashSegmentGenerator. Hence it, and all subsequent\r\n+\t\t\t\t\t * segments are considered plain text siblings of the original encrypted url.\r\n \t\t\t\t\t */\r\n \t\t\t\t\tbreak;\r\n \t\t\t\t}\r\n \r\n \t\t\t\t/*\r\n-\t\t\t\t * This segments matches the expected checksum, so we add the corresponding\r\n-\t\t\t\t * segment from the original URL.\r\n+\t\t\t\t * This segments matches the expected checksum, so we add the corresponding segment\r\n+\t\t\t\t * from the original URL.\r\n \t\t\t\t */\r\n \t\t\t\turl.getSegments().add(originalUrl.getSegments().get(segNo - 1));\r\n \t\t\t}\r\n",
        "project": "wicket",
        "linesAdd": 5,
        "jira_id": "5319",
        "nb_skipped": 2,
        "commit": "c863b032",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1251,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.authorization.ComponentIsRenderedAllowedTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex e9e5a60006..1d2ccc3be3 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -971,6 +971,9 @@ private final void internalBeforeRender()\n \t{\n \t\tconfigure();\n \n+\t\t// check authorization\n+\t\tsetRenderAllowed();\n+\n \t\tif ((determineVisibility()) && !getFlag(FLAG_RENDERING) &&\n \t\t\t!getFlag(FLAG_PREPARED_FOR_RENDER))\n \t\t{\n@@ -2210,11 +2213,6 @@ public void internalPrepareForRender(boolean setRenderingFlag)\n \t\t}\n \n \t\tmarkRendering(setRenderingFlag);\n-\n-\t\t// check authorization\n-\t\t// first the component itself\n-\t\t// (after attach as otherwise list views etc wont work)\n-\t\tsetRenderAllowed();\n \t}\n \n \t/**\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "4256",
        "nb_skipped": 3,
        "commit": "09166ea8",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1575,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ajax.json.JsonUtilsTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/json/JsonUtils.java b/wicket-core/src/main/java/org/apache/wicket/ajax/json/JsonUtils.java\nindex f4b8a9b062..ece4997152 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/json/JsonUtils.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/json/JsonUtils.java\n@@ -58,7 +58,9 @@ public static JSONArray asArray(Map<String, Object> map) throws JSONException\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\telse if (value.getClass().isArray())\n+\t\t\t\telse if (value != null)\n+\t\t\t\t{\n+\t\t\t\t\tif (value.getClass().isArray())\n \t\t\t\t\t{\n \t\t\t\t\t\tObject[] array = (Object[]) value;\n \t\t\t\t\t\tfor (Object v : array)\n@@ -73,8 +75,6 @@ else if (value.getClass().isArray())\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tif (value != null)\n \t\t\t\t\t{\n \t\t\t\t\t\tJSONObject object = new JSONObject();\n \t\t\t\t\t\tobject.put(\"name\", name);\n",
        "project": "wicket",
        "linesAdd": 3,
        "jira_id": "5497",
        "nb_skipped": 2,
        "commit": "724066f4",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.bean.validation.DefaultPropertyResolverTest"
        ],
        "patch": "diff --git a/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/DefaultPropertyResolver.java b/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/DefaultPropertyResolver.java\nindex 64caf18a87..91eb1a3882 100644\n--- a/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/DefaultPropertyResolver.java\n+++ b/wicket-experimental/wicket-bean-validation/src/main/java/org/apache/wicket/bean/validation/DefaultPropertyResolver.java\n@@ -6,6 +6,7 @@\n import org.apache.wicket.markup.html.form.FormComponent;\n import org.apache.wicket.model.IModel;\n import org.apache.wicket.model.IPropertyReflectionAwareModel;\n+import org.apache.wicket.model.IWrapModel;\n import org.apache.wicket.model.PropertyModel;\n \n /**\n@@ -23,8 +24,21 @@ public Property resolveProperty(FormComponent<?> component)\n \t{\n \t\tIModel<?> model = component.getModel();\n \n-\t\tif (!(model instanceof IPropertyReflectionAwareModel))\n+\t\twhile (true)\n \t\t{\n+\t\t\tif (model == null)\n+\t\t\t{\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tif (model instanceof IPropertyReflectionAwareModel)\n+\t\t\t{\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif (model instanceof IWrapModel<?>)\n+\t\t\t{\n+\t\t\t\tmodel = ((IWrapModel<?>)model).getWrappedModel();\n+\t\t\t\tcontinue;\n+\t\t\t}\n \t\t\treturn null;\n \t\t}\n \n@@ -39,7 +53,7 @@ public Property resolveProperty(FormComponent<?> component)\n \t\tMethod getter = delegate.getPropertyGetter();\n \t\tif (getter != null)\n \t\t{\n-\t\t\tString name = getter.getName().substring(3, 1).toLowerCase() +\n+\t\t\tString name = getter.getName().substring(3, 4).toLowerCase() +\n \t\t\t\tgetter.getName().substring(4);\n \t\t\treturn new Property(getter.getDeclaringClass(), name);\n \t\t}\n",
        "project": "wicket",
        "linesAdd": 16,
        "jira_id": "5102",
        "nb_skipped": 0,
        "commit": "d110e307",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1871,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.internal.headeritems.HtmlHeaderItemsContainerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\nindex 5b79f80d43..b695713a89 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/HtmlHeaderSectionHandler.java\n@@ -31,6 +31,7 @@\n import org.apache.wicket.markup.parser.AbstractMarkupFilter;\n import org.apache.wicket.markup.parser.XmlTag.TagType;\n import org.apache.wicket.markup.resolver.HtmlHeaderResolver;\n+import org.apache.wicket.util.tester.BaseWicketTester;\n \n \n /**\n@@ -172,7 +173,7 @@ private void handleBodyTag()\n \t */\n \tprivate void handleHeaderItemsTag(ComponentTag tag)\n \t{\n-\t\tif (foundHeaderItemsTag)\n+\t\tif ((tag.isOpen() || tag.isOpenClose()) && foundHeaderItemsTag)\n \t\t{\n \t\t\tthrow new MarkupException(new MarkupStream(markup),\n \t\t\t\t\t\"More than one <wicket:header-items/> detected in the <head> element. Only one is allowed.\");\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "5989",
        "nb_skipped": 1,
        "commit": "a255bbca",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1239,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.handler.ListenerInterfaceRequestHandlerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/ListenerInterfaceRequestHandler.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/ListenerInterfaceRequestHandler.java\nindex a4b581719c..0c497d5fc8 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/ListenerInterfaceRequestHandler.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/ListenerInterfaceRequestHandler.java\n@@ -249,8 +249,16 @@ private void invokeListener()\n \n \tpublic final boolean isPageInstanceCreated()\n \t{\n-\t\t// this request handler always operates on a created page instance\n-\t\treturn true;\n+\t\t// FIXME wicket.next remove the workaround for page providers that don't implement the\n+\t\t// interface\n+\t\tif (!(pageComponentProvider instanceof IIntrospectablePageProvider))\n+\t\t{\n+\t\t\tLOG.warn(\n+\t\t\t\t\"{} used by this application does not implement {}, the request handler is falling back on using incorrect behavior\",\n+\t\t\t\tIPageProvider.class, IIntrospectablePageProvider.class);\n+\t\t\treturn !pageComponentProvider.isNewPageInstance();\n+\t\t}\n+\t\treturn ((IIntrospectablePageProvider)pageComponentProvider).hasPageInstance();\n \t}\n \n \tpublic final String getComponentPath()\n",
        "project": "wicket",
        "linesAdd": 8,
        "jira_id": "4185",
        "nb_skipped": 3,
        "commit": "5fd03973",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1404,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.link.DownloadLinkTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/link/DownloadLink.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/link/DownloadLink.java\nindex 3974b186cf..293a239592 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/link/DownloadLink.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/link/DownloadLink.java\n@@ -135,7 +135,18 @@ public DownloadLink(String id, File file, String fileName)\n \tpublic DownloadLink(String id, IModel<File> fileModel, IModel<String> fileNameModel)\n \t{\n \t\tsuper(id, fileModel);\n-\t\tthis.fileNameModel = fileNameModel;\n+\t\tthis.fileNameModel = wrap(fileNameModel);\n+\t}\n+\n+\t@Override\n+\tpublic void detachModels()\n+\t{\n+\t\tsuper.detachModels();\n+\n+\t\tif (fileNameModel != null)\n+\t\t{\n+\t\t\tfileNameModel.detach();\n+\t\t}\n \t}\n \n \t@Override\n",
        "project": "wicket",
        "linesAdd": 12,
        "jira_id": "4738",
        "nb_skipped": 5,
        "commit": "a7ce7f91",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1690,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.settings.ISecuritySettingsTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\nindex eca607b6ab..bf1d8885e1 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n@@ -24,6 +24,7 @@\n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.component.IRequestablePage;\n import org.apache.wicket.request.mapper.ICompoundRequestMapper;\n+import org.apache.wicket.request.mapper.IRequestMapperDelegate;\n import org.apache.wicket.request.mapper.info.PageComponentInfo;\n import org.apache.wicket.request.mapper.parameter.IPageParametersEncoder;\n import org.apache.wicket.request.mapper.parameter.PageParameters;\n@@ -119,7 +120,7 @@ protected UrlInfo parseRequest(Request request)\n \t\t\t\t\t\tif (!pageClass.equals(application.getHomePage()))\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\t// WICKET-5094 only enforce mount if page is mounted\n-\t\t\t\t\t\t\tif (isPageMounted(pageClass, application))\n+\t\t\t\t\t\t\tif (isPageMounted(pageClass, application.getRootRequestMapperAsCompound()))\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\treturn null;\n \t\t\t\t\t\t\t}\n@@ -137,11 +138,23 @@ protected UrlInfo parseRequest(Request request)\n \t\treturn null;\n \t}\n \n-\tprivate boolean isPageMounted(Class<? extends IRequestablePage> pageClass, Application application)\n+\tprivate boolean isPageMounted(Class<? extends IRequestablePage> pageClass, ICompoundRequestMapper compoundMapper)\n \t{\n-\t\tICompoundRequestMapper applicationMappers = application.getRootRequestMapperAsCompound();\n+\t\tfor (IRequestMapper requestMapper : compoundMapper)\n+\t\t{\n+\t\t\twhile (requestMapper instanceof IRequestMapperDelegate)\n+\t\t\t{\n+\t\t\t\trequestMapper = ((IRequestMapperDelegate)requestMapper).getDelegateMapper();\n+\t\t\t}\n \n-\t\tfor (IRequestMapper requestMapper : applicationMappers)\n+\t\t\tif (requestMapper instanceof ICompoundRequestMapper)\n+\t\t\t{\n+\t\t\t\tif (isPageMounted(pageClass, (ICompoundRequestMapper)requestMapper))\n+\t\t\t\t{\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse\n \t\t\t{\n \t\t\t\tif (requestMapper instanceof AbstractBookmarkableMapper  && requestMapper != this)\n \t\t\t\t{\n@@ -153,6 +166,7 @@ private boolean isPageMounted(Class<? extends IRequestablePage> pageClass, Appli\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n \n \t\treturn false;\n \t}\n",
        "project": "wicket",
        "linesAdd": 18,
        "jira_id": "5712",
        "nb_skipped": 1,
        "commit": "145da021",
        "nb_failure": 2,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1187,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.tester.FormTesterTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractBookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractBookmarkableMapper.java\nindex 2f6bfc682b..caa61ca139 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractBookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractBookmarkableMapper.java\n@@ -88,13 +88,16 @@ public UrlInfo(PageComponentInfo pageComponentInfo,\n \t\t */\n \t\tprivate PageParameters cleanPageParameters(final PageParameters originalParameters)\n \t\t{\n-\t\t\tPageParameters cleanParameters = new PageParameters(originalParameters);\n+\t\t\tPageParameters cleanParameters = null;\n+\t\t\tif (originalParameters != null)\n+\t\t\t{\n+\t\t\t\tcleanParameters = new PageParameters(originalParameters);\n \n \t\t\t\t// WICKET-4038: Ajax related parameters are set by wicket-ajax.js when needed.\n \t\t\t\t// They shouldn't be propagated to the next requests\n \t\t\t\tcleanParameters.remove(WebRequest.PARAM_AJAX);\n \t\t\t\tcleanParameters.remove(WebRequest.PARAM_AJAX_BASE_URL);\n-\n+\t\t\t}\n \t\t\treturn cleanParameters;\n \t\t}\n \n",
        "project": "wicket",
        "linesAdd": 5,
        "jira_id": "4038",
        "nb_skipped": 2,
        "commit": "f3d7565c",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 715,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.list.PagedTableNavigatorTest",
            "org.apache.wicket.markup.html.list.PagedTableNavigatorWithMarginTest",
            "org.apache.wicket.markup.html.list.PagedTableNavigatorWithLabelProviderTest",
            "org.apache.wicket.markup.html.list.PagedTableTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/markup/html/navigation/paging/PagingNavigation.java b/wicket/src/main/java/org/apache/wicket/markup/html/navigation/paging/PagingNavigation.java\nindex 3342762875..60c5499087 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/navigation/paging/PagingNavigation.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/navigation/paging/PagingNavigation.java\n@@ -345,7 +345,8 @@ protected void populateItem(final Loop.LoopItem loopItem)\n \t\t\t@Override\n \t\t\tpublic boolean isEnabled()\n \t\t\t{\n-\t\t\t\treturn PagingNavigation.this.isEnabled() && PagingNavigation.this.isEnableAllowed();\n+\t\t\t\treturn super.isEnabled() && PagingNavigation.this.isEnabled() &&\n+\t\t\t\t\tPagingNavigation.this.isEnableAllowed();\n \t\t\t}\n \t\t};\n \t}\ndiff --git a/wicket/src/main/java/org/apache/wicket/markup/html/navigation/paging/PagingNavigator.java b/wicket/src/main/java/org/apache/wicket/markup/html/navigation/paging/PagingNavigator.java\nindex 018d16550e..9d9fd4711c 100644\n--- a/wicket/src/main/java/org/apache/wicket/markup/html/navigation/paging/PagingNavigator.java\n+++ b/wicket/src/main/java/org/apache/wicket/markup/html/navigation/paging/PagingNavigator.java\n@@ -119,7 +119,8 @@ protected void onBeforeRender()\n \t\t\t@Override\n \t\t\tpublic boolean isEnabled()\n \t\t\t{\n-\t\t\t\treturn PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\n+\t\t\t\treturn super.isEnabled() && PagingNavigator.this.isEnabled() &&\n+\t\t\t\t\tPagingNavigator.this.isEnableAllowed();\n \t\t\t}\n \t\t};\n \t}\n@@ -145,9 +146,11 @@ public boolean isEnabled()\n \t\t\t@Override\n \t\t\tpublic boolean isEnabled()\n \t\t\t{\n-\t\t\t\treturn PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\n+\t\t\t\treturn super.isEnabled() && PagingNavigator.this.isEnabled() &&\n+\t\t\t\t\tPagingNavigator.this.isEnableAllowed();\n \t\t\t}\n \t\t};\n+\n \t}\n \n \t/**\n@@ -169,7 +172,8 @@ protected PagingNavigation newNavigation(final IPageable pageable,\n \t\t\t@Override\n \t\t\tpublic boolean isEnabled()\n \t\t\t{\n-\t\t\t\treturn PagingNavigator.this.isEnabled() && PagingNavigator.this.isEnableAllowed();\n+\t\t\t\treturn super.isEnabled() && PagingNavigator.this.isEnabled() &&\n+\t\t\t\t\tPagingNavigator.this.isEnableAllowed();\n \t\t\t}\n \t\t};\n \t}\n",
        "project": "wicket",
        "linesAdd": 9,
        "jira_id": "1619",
        "nb_skipped": 0,
        "commit": "b154d12f",
        "nb_failure": 4,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1411,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ConverterLocatorTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ConverterLocator.java b/wicket-core/src/main/java/org/apache/wicket/ConverterLocator.java\nindex 437ed8c1a3..e2d9cc6a12 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ConverterLocator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ConverterLocator.java\n@@ -105,16 +105,19 @@ public C convertToObject(String value, Locale locale)\n \t\t\t\t{\n \t\t\t\t\treturn converted;\n \t\t\t\t}\n-\t\t\t\telse\n+\n+\t\t\t\tif (theType.isInstance(value))\n \t\t\t\t{\n-\t\t\t\t\tthrow new ConversionException(\"Could not convert value: \" + value +\n-\t\t\t\t\t\t\" to type: \" + theType.getName() + \". Could not find compatible converter.\").setSourceValue(value);\n+\t\t\t\t\treturn theType.cast(value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception e)\n \t\t\t{\n \t\t\t\tthrow new ConversionException(e.getMessage(), e).setSourceValue(value);\n \t\t\t}\n+\n+\t\t\tthrow new ConversionException(\"Could not convert value: \" + value + \" to type: \" +\n+\t\t\t\ttheType.getName() + \". Could not find compatible converter.\").setSourceValue(value);\n \t\t}\n \n \t\t/**\n",
        "project": "wicket",
        "linesAdd": 6,
        "jira_id": "4755",
        "nb_skipped": 5,
        "commit": "87ae870f",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1410,
        "nb_error": 0,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.wicket.util.string.JavaScriptStripperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/util/string/JavaScriptStripper.java b/wicket-core/src/main/java/org/apache/wicket/core/util/string/JavaScriptStripper.java\nindex 79c6542086..46988d676d 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/util/string/JavaScriptStripper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/util/string/JavaScriptStripper.java\n@@ -173,6 +173,7 @@ else if (c == '\"')\n \t\t\t\tif (c == '\\n' || c == '\\r')\n \t\t\t\t{\n \t\t\t\t\tstate = REGULAR_TEXT;\n+\t\t\t\t\tresult.append(c);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "4760",
        "nb_skipped": 5,
        "commit": "2f1ece4b",
        "nb_failure": 6,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 1,
        "nb_test": 1325,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.handler.PageProviderTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\nindex f239c4dea3..50402f65ee 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/handler/PageProvider.java\n@@ -294,18 +294,22 @@ private void resolvePageInstance(Integer pageId, Class<? extends IRequestablePag\n \tprivate IRequestablePage getStoredPage(final int pageId)\n \t{\n \t\tIRequestablePage storedPageInstance = getPageSource().getPageInstance(pageId);\n-\t\tif (storedPageInstance != null &&\n-\t\t\t(pageClass == null || pageClass.equals(storedPageInstance.getClass())))\n+\t\tif (storedPageInstance != null)\n+\t\t{\n+\t\t\tif (pageClass == null || pageClass.equals(storedPageInstance.getClass()))\n \t\t\t{\n \t\t\t\tpageInstance = storedPageInstance;\n \t\t\t\tpageInstanceIsFresh = false;\n-\t\t\tif (pageInstance != null)\n-\t\t\t{\n \t\t\t\tif (renderCount != null && pageInstance.getRenderCount() != renderCount)\n \t\t\t\t{\n \t\t\t\t\tthrow new StalePageException(pageInstance);\n \t\t\t\t}\n \t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\t// the found page class doesn't match the requested one\n+\t\t\t\tstoredPageInstance = null;\n+\t\t\t}\n \t\t}\n \t\treturn storedPageInstance;\n \t}\n",
        "project": "wicket",
        "linesAdd": 7,
        "jira_id": "4488",
        "nb_skipped": 8,
        "commit": "e6582c52",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 164,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.string.StringsTest"
        ],
        "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java b/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java\nindex fceb4990a2..27a9987dfe 100755\n--- a/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java\n@@ -22,6 +22,7 @@\n import java.security.PrivilegedAction;\r\n import java.util.ArrayList;\r\n import java.util.List;\r\n+import java.util.Locale;\r\n import java.util.regex.Matcher;\r\n import java.util.regex.Pattern;\r\n \r\n@@ -906,19 +907,19 @@ public static String stripEnding(final String s, final String ending)\n \t */\r\n \tpublic static String stripJSessionId(final String url)\r\n \t{\r\n-\t\tif (url == null)\r\n+\t\tif (Strings.isEmpty(url))\r\n \t\t{\r\n-\t\t\treturn null;\r\n+\t\t\treturn url;\r\n \t\t}\r\n \r\n \t\t// http://.../abc;jsessionid=...?param=...\r\n-\t\tint ixSemiColon = url.indexOf(\";\");\r\n+\t\tint ixSemiColon = url.toLowerCase(Locale.ENGLISH).indexOf(\";jsessionid=\");\r\n \t\tif (ixSemiColon == -1)\r\n \t\t{\r\n \t\t\treturn url;\r\n \t\t}\r\n \r\n-\t\tint ixQuestionMark = url.indexOf(\"?\");\r\n+\t\tint ixQuestionMark = url.indexOf('?');\r\n \t\tif (ixQuestionMark == -1)\r\n \t\t{\r\n \t\t\t// no query paramaters; cut off at \";\"\r\n",
        "project": "wicket",
        "linesAdd": 5,
        "jira_id": "4816",
        "nb_skipped": 0,
        "commit": "66bfc885",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1281,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.model.StringResourceModelTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/model/StringResourceModel.java b/wicket-core/src/main/java/org/apache/wicket/model/StringResourceModel.java\nindex fe74c2fb7f..573a162375 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/model/StringResourceModel.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/model/StringResourceModel.java\n@@ -232,6 +232,15 @@ public void detach()\n \t\t\tStringResourceModel.this.detach();\n \t\t}\n \n+\t\t@Override\n+\t\tprotected void onDetach()\n+\t\t{\n+\t\t\tif (StringResourceModel.this.component == null)\n+\t\t\t{\n+\t\t\t\tStringResourceModel.this.onDetach();\n+\t\t\t}\n+\t\t}\n+\n \t\t@Override\n \t\tprotected String load()\n \t\t{\n@@ -582,6 +591,8 @@ protected String load()\n \t@Override\n \tprotected final void onDetach()\n \t{\n+\t\tsuper.onDetach();\n+\n \t\t// detach any model\n \t\tif (model != null)\n \t\t{\n",
        "project": "wicket",
        "linesAdd": 11,
        "jira_id": "4323",
        "nb_skipped": 4,
        "commit": "e24874da",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 1163,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.stateless.StatelessComponentTest",
            "org.apache.wicket.markup.html.internal.EnclosureTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 13ab5e16e0..a76203555c 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -3284,15 +3284,18 @@ public String toString(final boolean detailed)\n \tpublic final CharSequence urlFor(final Behavior behaviour,\n \t\tfinal RequestListenerInterface listener)\n \t{\n-\t\tPageAndComponentProvider provider = new PageAndComponentProvider(getPage(), this);\n \t\tint id = getBehaviorId(behaviour);\n+\t\tPage page = getPage();\n \t\tIRequestHandler handler;\n-\t\tif (getPage().isPageStateless())\n+\t\tif (page.isPageStateless())\n \t\t{\n+\t\t\tPageAndComponentProvider provider = new PageAndComponentProvider(page.getPageClass(),\n+\t\t\t\tpage.getPageParameters(), getPageRelativePath());\n \t\t\thandler = new BookmarkableListenerInterfaceRequestHandler(provider, listener, id);\n \t\t}\n \t\telse\n \t\t{\n+\t\t\tPageAndComponentProvider provider = new PageAndComponentProvider(page, this);\n \t\t\thandler = new ListenerInterfaceRequestHandler(provider, listener, id);\n \t\t}\n \t\treturn getRequestCycle().urlFor(handler);\n@@ -3324,14 +3327,17 @@ public final CharSequence urlFor(final IRequestHandler requestHandler)\n \t */\n \tpublic final CharSequence urlFor(final RequestListenerInterface listener)\n \t{\n-\t\tPageAndComponentProvider provider = new PageAndComponentProvider(getPage(), this);\n+\t\tPage page = getPage();\n \t\tIRequestHandler handler;\n-\t\tif (getPage().isPageStateless())\n+\t\tif (page.isPageStateless())\n \t\t{\n+\t\t\tPageAndComponentProvider provider = new PageAndComponentProvider(page.getPageClass(),\n+\t\t\t\tpage.getPageParameters(), getPageRelativePath());\n \t\t\thandler = new BookmarkableListenerInterfaceRequestHandler(provider, listener);\n \t\t}\n \t\telse\n \t\t{\n+\t\t\tPageAndComponentProvider provider = new PageAndComponentProvider(page, this);\n \t\t\thandler = new ListenerInterfaceRequestHandler(provider, listener);\n \t\t}\n \t\treturn getRequestCycle().urlFor(handler);\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/mock/MockPageManager.java b/wicket-core/src/main/java/org/apache/wicket/mock/MockPageManager.java\nindex 3cf92139ee..cf18216620 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/mock/MockPageManager.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/mock/MockPageManager.java\n@@ -77,9 +77,12 @@ public boolean supportsVersioning()\n \t}\n \n \tpublic void touchPage(IManageablePage page)\n+\t{\n+\t\tif (page.isPageStateless() == false)\n \t\t{\n \t\t\tpages.put(page.getPageId(), page);\n \t\t}\n+\t}\n \n \t/**\n \t * @see org.apache.wicket.page.IPageManager#getContext()\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\nindex 379b473430..c9569a889c 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\n@@ -17,6 +17,7 @@\n package org.apache.wicket.request.handler;\n \n import org.apache.wicket.Application;\n+import org.apache.wicket.Page;\n import org.apache.wicket.Session;\n import org.apache.wicket.page.IPageManager;\n import org.apache.wicket.protocol.http.PageExpiredException;\n@@ -148,6 +149,10 @@ public PageProvider(IRequestablePage page)\n \t\tArgs.notNull(page, \"page\");\n \n \t\tpageInstance = page;\n+\t\tif (pageInstance instanceof Page)\n+\t\t{\n+\t\t\t((Page)pageInstance).setStatelessHint(false);\n+\t\t}\n \t}\n \n \t/**\n",
        "project": "wicket",
        "linesAdd": 18,
        "jira_id": "3965",
        "nb_skipped": 2,
        "commit": "6051019b",
        "nb_failure": 6,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1495,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.mapper.BookmarkableMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\nindex 1fd71d630a..a9fd2123c7 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/BookmarkableMapper.java\n@@ -190,6 +190,11 @@ else if (baseUrl.getSegments().size() == 3 && urlStartsWith(baseUrl, namespace,\n \t\t{\n \t\t\tmatches = true;\n \t\t}\n+\t\t// baseUrl = 'bookmarkable/com.example.SomePage', requestUrl = 'bookmarkable/com.example.SomePage'\n+\t\telse if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, bookmarkableIdentifier) && url.getSegments().size() == 2 && urlStartsWith(url, bookmarkableIdentifier))\n+\t\t{\n+\t\t\tmatches = true;\n+\t\t}\n \t\t// baseUrl = 'wicket/page[?...]', requestUrl = 'bookmarkable/com.example.SomePage'\n \t\telse if (baseUrl.getSegments().size() == 2 && urlStartsWith(baseUrl, namespace, pageIdentifier) && url.getSegments().size() >= 2 && urlStartsWith(url, bookmarkableIdentifier))\n \t\t{\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\nindex 3789a9f355..a03464270a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/PageInstanceMapper.java\n@@ -175,17 +175,19 @@ private boolean matches(final Request request)\n \t{\n \t\tboolean matches = false;\n \t\tUrl url = request.getUrl();\n+\t\tUrl baseUrl = request.getClientUrl();\n \t\tString namespace = getContext().getNamespace();\n \t\tString pageIdentifier = getContext().getPageIdentifier();\n+\n \t\tif (urlStartsWith(url, namespace, pageIdentifier))\n \t\t{\n \t\t\tmatches = true;\n \t\t}\n-\t\telse if (urlStartsWith(request.getClientUrl(), namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier))\n+\t\telse if (urlStartsWith(baseUrl, namespace, pageIdentifier) && urlStartsWith(url, pageIdentifier))\n \t\t{\n \t\t\tmatches = true;\n \t\t}\n-\t\telse if (urlStartsWith(request.getClientUrl(), pageIdentifier) && urlStartsWith(url, pageIdentifier))\n+\t\telse if (urlStartsWith(baseUrl, pageIdentifier) && urlStartsWith(url, pageIdentifier))\n \t\t{\n \t\t\tmatches = true;\n \t\t}\n",
        "project": "wicket",
        "linesAdd": 8,
        "jira_id": "5071",
        "nb_skipped": 4,
        "commit": "d3d42d42",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1679,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.model.InheritedModelTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex c1d1826fe9..d998680381 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -2977,6 +2977,9 @@ public Component setDefaultModel(final IModel<?> model)\n \t\t\tmodelChanging();\n \t\t\tsetModelImpl(wrap(model));\n \t\t\tmodelChanged();\n+\n+\t\t\t// WICKET-3413 reset 'inherited model' when model is explicitely set\n+\t\t\tsetFlag(FLAG_INHERITABLE_MODEL, false);\n \t\t}\n \n \t\treturn this;\n@@ -3005,12 +3008,6 @@ void setModelImpl(IModel<?> model)\n \t\t\tif (model != null)\n \t\t\t{\n \t\t\t\tdata_set(0, model);\n-\t\t\t\t// WICKET-3413 reset 'inherited model' flag if model changed\n-\t\t\t\t// and a new one is not IComponentInheritedModel\n-\t\t\t\tif (getFlag(FLAG_INHERITABLE_MODEL) && !(model instanceof IComponentInheritedModel))\n-\t\t\t\t{\n-\t\t\t\t\tsetFlag(FLAG_INHERITABLE_MODEL, false);\n-\t\t\t\t}\n \t\t\t}\n \t\t\telse\n \t\t\t{\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "5655",
        "nb_skipped": 2,
        "commit": "d558004b",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 24,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.spring.injection.annot.SpringBeanTest"
        ],
        "patch": "diff --git a/wicket-spring/src/main/java/org/apache/wicket/spring/SpringBeanLocator.java b/wicket-spring/src/main/java/org/apache/wicket/spring/SpringBeanLocator.java\nindex a0227921c1..a2791260eb 100644\n--- a/wicket-spring/src/main/java/org/apache/wicket/spring/SpringBeanLocator.java\n+++ b/wicket-spring/src/main/java/org/apache/wicket/spring/SpringBeanLocator.java\n@@ -19,6 +19,7 @@\n import java.lang.ref.WeakReference;\n \n import org.apache.wicket.proxy.IProxyTargetLocator;\n+import org.apache.wicket.util.lang.Args;\n import org.apache.wicket.util.lang.Objects;\n import org.apache.wicket.core.util.lang.WicketObjects;\n import org.springframework.beans.factory.NoSuchBeanDefinitionException;\n@@ -73,14 +74,8 @@ public SpringBeanLocator(final Class<?> beanType, final ISpringContextLocator lo\n \tpublic SpringBeanLocator(final String beanName, final Class<?> beanType,\n \t\tfinal ISpringContextLocator locator)\n \t{\n-\t\tif (locator == null)\n-\t\t{\n-\t\t\tthrow new IllegalArgumentException(\"[locator] argument cannot be null\");\n-\t\t}\n-\t\tif (beanType == null)\n-\t\t{\n-\t\t\tthrow new IllegalArgumentException(\"[beanType] argument cannot be null\");\n-\t\t}\n+\t\tArgs.notNull(locator, \"locator\");\n+\t\tArgs.notNull(beanType, \"beanType\");\n \n \t\tbeanTypeCache = new WeakReference<Class<?>>(beanType);\n \t\tbeanTypeName = beanType.getName();\n@@ -122,9 +117,6 @@ public boolean isSingletonBean()\n \t\treturn clazz;\n \t}\n \n-\t/**\n-\t * @see org.apache.wicket.proxy.IProxyTargetLocator#locateProxyTarget()\n-\t */\n \t@Override\n \tpublic Object locateProxyTarget()\n \t{\n@@ -174,11 +166,10 @@ public final ISpringContextLocator getSpringContextLocator()\n \t *            bean name\n \t * @param clazz\n \t *            bean class\n-\t * @throws IllegalStateException\n+\t * @throws java.lang.IllegalStateException\n \t * @return found bean\n \t */\n-\tprivate static Object lookupSpringBean(final ApplicationContext ctx, final String name,\n-\t\tfinal Class<?> clazz)\n+\tprivate Object lookupSpringBean(ApplicationContext ctx, String name, Class<?> clazz)\n \t{\n \t\ttry\n \t\t{\n@@ -194,7 +185,7 @@ private static Object lookupSpringBean(final ApplicationContext ctx, final Strin\n \t\tcatch (NoSuchBeanDefinitionException e)\n \t\t{\n \t\t\tthrow new IllegalStateException(\"bean with name [\" + name + \"] and class [\" +\n-\t\t\t\tclazz.getName() + \"] not found\");\n+\t\t\t\tclazz.getName() + \"] not found\", e);\n \t\t}\n \t}\n \ndiff --git a/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java b/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\nindex 648d2c7ccc..6b7d071164 100644\n--- a/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\n+++ b/wicket-spring/src/main/java/org/apache/wicket/spring/injection/annot/AnnotProxyFieldValueFactory.java\n@@ -110,7 +110,23 @@ public Object getFieldValue(final Field field, final Object fieldOwner)\n \t{\n \t\tif (supportsField(field))\n \t\t{\n-\t\t\tString beanName = getBeanName(field);\n+\t\t\tSpringBean annot = field.getAnnotation(SpringBean.class);\n+\n+\t\t\tString name;\n+\t\t\tboolean required;\n+\t\t\tif (annot != null)\n+\t\t\t{\n+\t\t\t\tname = annot.name();\n+\t\t\t\trequired = annot.required();\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tNamed named = field.getAnnotation(Named.class);\n+\t\t\t\tname = named != null ? named.value() : \"\";\n+\t\t\t\trequired = false;\n+\t\t\t}\n+\n+\t\t\tString beanName = getBeanName(field, name, required);\n \n \t\t\tif (beanName == null)\n \t\t\t{\n@@ -128,13 +144,26 @@ public Object getFieldValue(final Field field, final Object fieldOwner)\n \t\t\t}\n \n \t\t\tObject target;\n-\t\t\tif (wrapInProxies)\n+\t\t\ttry\n \t\t\t{\n-\t\t\t\ttarget = LazyInitProxyFactory.createProxy(field.getType(), locator);\n+\t\t\t\t// check whether there is a bean with the provided properties\n+\t\t\t\ttarget = locator.locateProxyTarget();\n+\t\t\t}\n+\t\t\tcatch (IllegalStateException isx)\n+\t\t\t{\n+\t\t\t\tif (required)\n+\t\t\t\t{\n+\t\t\t\t\tthrow isx;\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n-\t\t\t\ttarget = locator.locateProxyTarget();\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (wrapInProxies)\n+\t\t\t{\n+\t\t\t\ttarget = LazyInitProxyFactory.createProxy(field.getType(), locator);\n \t\t\t}\n \n \t\t\t// only put the proxy into the cache if the bean is a singleton\n@@ -156,31 +185,20 @@ public Object getFieldValue(final Field field, final Object fieldOwner)\n \t * @param field\n \t * @return bean name\n \t */\n-\tprivate String getBeanName(final Field field)\n+\tprivate String getBeanName(final Field field, String name, boolean required)\n \t{\n-\t\tSpringBean annot = field.getAnnotation(SpringBean.class);\n-\t\t\n-\t\tString name;\n-\t\tboolean required;\n-\t\tif (annot != null) {\n-\t\t\tname = annot.name();\n-\t\t\trequired = annot.required();\n-\t\t} else {\n-\t\t\tNamed named = field.getAnnotation(Named.class);\n-\t\t\tname = named != null ? named.value() : \"\";\n-\t\t\trequired = false;\n-\t\t}\n \n \t\tif (Strings.isEmpty(name))\n \t\t{\n-\t\t\tname = beanNameCache.get(field.getType());\n+\t\t\tClass<?> fieldType = field.getType();\n+\t\t\tname = beanNameCache.get(fieldType);\n \t\t\tif (name == null)\n \t\t\t{\n-\t\t\t\tname = getBeanNameOfClass(contextLocator.getSpringContext(), field.getType(), required);\n+\t\t\t\tname = getBeanNameOfClass(contextLocator.getSpringContext(), fieldType, required);\n \n \t\t\t\tif (name != null)\n \t\t\t\t{\n-\t\t\t\t\tString tmpName = beanNameCache.putIfAbsent(field.getType(), name);\n+\t\t\t\t\tString tmpName = beanNameCache.putIfAbsent(fieldType, name);\n \t\t\t\t\tif (tmpName != null)\n \t\t\t\t\t{\n \t\t\t\t\t\tname = tmpName;\n",
        "project": "wicket",
        "linesAdd": 42,
        "jira_id": "5662",
        "nb_skipped": 0,
        "commit": "9aec4f33",
        "nb_failure": 1,
        "linesRem": 31,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1292,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.stateless.StatelessFormUrlTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\nindex a0f3654823..46dbefc37b 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n@@ -796,10 +796,6 @@ else if (hasError())\n \t */\n \tpublic void process(IFormSubmitter submittingComponent)\n \t{\n-\t\t// save the page in case the component is removed during submit\n-\t\tfinal Page page = getPage();\n-\t\tString hiddenFieldId = getHiddenFieldId();\n-\n \t\tif (!isEnabledInHierarchy() || !isVisibleInHierarchy())\n \t\t{\n \t\t\t// since process() can be called outside of the default form workflow, an additional\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/StatelessForm.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/StatelessForm.java\nindex 034519c3bc..2442556ae2 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/StatelessForm.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/StatelessForm.java\n@@ -17,6 +17,9 @@\n package org.apache.wicket.markup.html.form;\n \n import org.apache.wicket.model.IModel;\n+import org.apache.wicket.request.mapper.parameter.PageParameters;\n+import org.apache.wicket.util.visit.IVisit;\n+import org.apache.wicket.util.visit.IVisitor;\n \n /**\n  * This StatelessForm is the same as a normal form but with the statelesshint default to true. The\n@@ -72,4 +75,33 @@ protected CharSequence getActionUrl()\n \t{\n \t\treturn urlFor(IFormSubmitListener.INTERFACE, getPage().getPageParameters());\n \t}\n+\n+\t/**\n+\t * Remove the page parameters for all form component otherwise they get appended to action URL\n+\t *\n+\t * {@inheritDoc}\n+\t */\n+\t@Override\n+\tpublic void process(IFormSubmitter submittingComponent)\n+\t{\n+\t\tsuper.process(submittingComponent);\n+\n+\t\tfinal PageParameters parameters = getPage().getPageParameters();\n+\t\tif (parameters != null)\n+\t\t{\n+\t\t\tvisitFormComponents(new IVisitor<FormComponent<?>, Void>()\n+\t\t\t{\n+\t\t\t\tpublic void component(final FormComponent<?> formComponent, final IVisit<Void> visit)\n+\t\t\t\t{\n+\t\t\t\t\tparameters.remove(formComponent.getInputName());\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tparameters.remove(getHiddenFieldId());\n+\t\t\tif (submittingComponent instanceof AbstractSubmitLink)\n+\t\t\t{\n+\t\t\t\tAbstractSubmitLink submitLink = (AbstractSubmitLink)submittingComponent;\n+\t\t\t\tparameters.remove(submitLink.getInputName());\n+\t\t\t}\n+\t\t}\n+\t}\n }\n",
        "project": "wicket",
        "linesAdd": 27,
        "jira_id": "4365",
        "nb_skipped": 4,
        "commit": "1485a856",
        "nb_failure": 2,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 105,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.mapper.parameter.PageParametersEncoderTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParametersEncoder.java b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParametersEncoder.java\nindex 13e45ec64b..aa095deea2 100644\n--- a/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParametersEncoder.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/mapper/parameter/PageParametersEncoder.java\n@@ -18,6 +18,7 @@\n \n import org.apache.wicket.request.Url;\n import org.apache.wicket.request.Url.QueryParameter;\n+import org.apache.wicket.util.string.Strings;\n \n /**\n  * Simple encoder with direct indexed/named parameters mapping.\n@@ -47,7 +48,11 @@ public PageParameters decodePageParameters(final Url url)\n \n \t\tfor (QueryParameter p : url.getQueryParameters())\n \t\t{\n-\t\t\tparameters.add(p.getName(), p.getValue(), INamedParameters.Type.QUERY_STRING);\n+\t\t\tString parameterName = p.getName();\n+\t\t\tif (Strings.isEmpty(parameterName) == false)\n+\t\t\t{\n+\t\t\t\tparameters.add(parameterName, p.getValue(), INamedParameters.Type.QUERY_STRING);\n+\t\t\t}\n \t\t}\n \n \t\treturn parameters.isEmpty() ? null : parameters;\n",
        "project": "wicket",
        "linesAdd": 6,
        "jira_id": "5770",
        "nb_skipped": 0,
        "commit": "cf6172bd",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1181,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.mapper.ResourceMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/ResourceMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/ResourceMapper.java\nindex 9e15ba48c5..bc39efb028 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/ResourceMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/ResourceMapper.java\n@@ -237,11 +237,23 @@ protected void removeCachingDecoration(Url url, PageParameters parameters)\n \n \t\tif (segments.isEmpty() == false)\n \t\t{\n+\t\t\t// get filename (the last segment)\n \t\t\tfinal int lastSegmentAt = segments.size() - 1;\n-\t\t\tfinal ResourceUrl resourceUrl = new ResourceUrl(segments.get(lastSegmentAt), parameters);\n+\t\t\tString filename = segments.get(lastSegmentAt);\n \t\t\t\n+\t\t\t// ignore requests with empty filename\n+\t\t\tif(Strings.isEmpty(filename))\n+\t\t\t{\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\t\n+\t\t\t// create resource url from filename and query parameters\n+\t\t\tfinal ResourceUrl resourceUrl = new ResourceUrl(filename, parameters);\n+\n+\t\t\t// remove caching information from request\n \t\t\tgetCachingStrategy().undecorateUrl(resourceUrl);\n \t\t\t\n+\t\t\t// check for broken caching strategy (this must never happen)\n \t\t\tif (Strings.isEmpty(resourceUrl.getFileName()))\n \t\t\t{\n \t\t\t\tthrow new IllegalStateException(\"caching strategy returned empty name for \" + resourceUrl);\n",
        "project": "wicket",
        "linesAdd": 8,
        "jira_id": "4020",
        "nb_skipped": 2,
        "commit": "081cdeb2",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 1460,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.mapper.MountedMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\nindex 668d0a46fd..93c22d2df7 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/AbstractBookmarkableMapper.java\n@@ -246,9 +246,14 @@ protected IRequestHandler processListener(PageComponentInfo pageComponentInfo,\n \n \t\tif (listenerInterface != null)\n \t\t{\n-\t\t\t// WICKET-4594 - ignore the parsed parameters as they have nothing to do with the page\n+\t\t\tif (pageInfo.getPageId() != null)\n+\t\t\t{\n+\t\t\t\t// WICKET-4594 - ignore the parsed parameters for stateful pages\n+\t\t\t\tpageParameters = null;\n+\t\t\t}\n+\n \t\t\tPageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(),\n-\t\t\t\tpageClass, null, renderCount, componentInfo.getComponentPath());\n+\t\t\t\tpageClass, pageParameters, renderCount, componentInfo.getComponentPath());\n \n \t\t\tprovider.setPageSource(getContext());\n \n",
        "project": "wicket",
        "linesAdd": 6,
        "jira_id": "4594",
        "nb_skipped": 3,
        "commit": "5e1bf8d8",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 96,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.UrlTest",
            "org.apache.wicket.request.mapper.parameter.UrlPathPageParametersEncoderTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex c9ddc699f5..2e24b5cad7 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -714,7 +714,12 @@ else if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false)\n \n \n \t\tresult.append(path);\n-\t\tresult.append(getQueryString(charset));\n+        \n+        final String queryString = getQueryString(charset);\n+        if (queryString != null)\n+        {\n+            result.append('?').append(queryString);\n+        }\n \t\treturn result.toString();\n \t}\n \n",
        "project": "wicket",
        "linesAdd": 6,
        "jira_id": "4664",
        "nb_skipped": 0,
        "commit": "2fcb3417",
        "nb_failure": 26,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1634,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.handler.render.WebPageRendererTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\nindex 1b98beda73..0b5dee4b4a 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/render/WebPageRenderer.java\n@@ -33,6 +33,7 @@\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.request.http.WebRequest;\n import org.apache.wicket.request.http.WebResponse;\n+import org.apache.wicket.util.lang.Objects;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -338,11 +339,12 @@ protected boolean shouldRenderPageAndWriteResponse(RequestCycle cycle, Url curre\n \t\t\treturn false;\n \t\t}\n \n-\t\treturn neverRedirect(getRedirectPolicy())\n+\t\treturn (compatibleProtocols(currentUrl.getProtocol(), targetUrl.getProtocol())) &&\n+\t\t\t\t(neverRedirect(getRedirectPolicy())\n \t\t\t|| ((isOnePassRender() && notForcedRedirect(getRedirectPolicy())) || (targetUrl\n \t\t\t\t.equals(currentUrl) && notNewAndNotStatelessPage(isNewPageInstance(),\n \t\t\t\tisPageStateless()))) || (targetUrl.equals(currentUrl) && isRedirectToRender())\n-\t\t\t|| (shouldPreserveClientUrl(cycle) && notForcedRedirect(getRedirectPolicy()));\n+\t\t\t|| (shouldPreserveClientUrl(cycle) && notForcedRedirect(getRedirectPolicy())));\n \t}\n \n \tprivate static boolean notNewAndNotStatelessPage(boolean newPageInstance, boolean pageStateless)\n@@ -365,4 +367,23 @@ private static boolean notForcedRedirect(RedirectPolicy redirectPolicy)\n \t\treturn !alwaysRedirect(redirectPolicy);\n \t}\n \n+\t/**\n+\t * Compares the protocols of two {@link Url}s\n+\t *\n+\t * @param p1\n+\t *      the first protocol\n+\t * @param p2\n+\t *      the second protocol\n+\t * @return {@code false} if the protocols are both non-null and not equal,\n+\t *          {@code true} - otherwise\n+\t */\n+\tprotected boolean compatibleProtocols(String p1, String p2)\n+\t{\n+\t\tif (p1 != null && p2 != null)\n+\t\t{\n+\t\t\treturn Objects.equal(p1, p2);\n+\t\t}\n+\n+\t\treturn true;\n+\t}\n }\n",
        "project": "wicket",
        "linesAdd": 13,
        "jira_id": "5522",
        "nb_skipped": 2,
        "commit": "5b730c0b",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1544,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.resource.caching.FilenameWithVersionResourceCachingStrategyTest",
            "org.apache.wicket.request.resource.caching.QueryStringWithVersionResourceCachingStrategyTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/caching/FilenameWithVersionResourceCachingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/caching/FilenameWithVersionResourceCachingStrategy.java\nindex 2125f35b0e..087ea13a33 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/caching/FilenameWithVersionResourceCachingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/caching/FilenameWithVersionResourceCachingStrategy.java\n@@ -195,8 +195,13 @@ public void undecorateUrl(ResourceUrl url)\n \t */\n \t@Override\n \tpublic void decorateResponse(AbstractResource.ResourceResponse response, IStaticCacheableResource resource)\n+\t{\n+\t\tString requestedVersion = RequestCycle.get().getMetaData(URL_VERSION);\n+\t\tString calculatedVersion = this.resourceVersion.getVersion(resource);\n+\t\tif (calculatedVersion != null && calculatedVersion.equals(requestedVersion))\n \t\t{\n \t\t\tresponse.setCacheDurationToMaximum();\n \t\t\tresponse.setCacheScope(WebResponse.CacheScope.PUBLIC);\n \t\t}\n \t}\n+}\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/request/resource/caching/QueryStringWithVersionResourceCachingStrategy.java b/wicket-core/src/main/java/org/apache/wicket/request/resource/caching/QueryStringWithVersionResourceCachingStrategy.java\nindex 292f159050..e40e0829b9 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/resource/caching/QueryStringWithVersionResourceCachingStrategy.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/resource/caching/QueryStringWithVersionResourceCachingStrategy.java\n@@ -126,8 +126,13 @@ public void undecorateUrl(ResourceUrl url)\n \n \t@Override\n \tpublic void decorateResponse(AbstractResource.ResourceResponse response, IStaticCacheableResource resource)\n+\t{\n+\t\tString requestedVersion = RequestCycle.get().getMetaData(URL_VERSION);\n+\t\tString calculatedVersion = this.resourceVersion.getVersion(resource);\n+\t\tif (calculatedVersion != null && calculatedVersion.equals(requestedVersion))\n \t\t{\n \t\t\tresponse.setCacheDurationToMaximum();\n \t\t\tresponse.setCacheScope(WebResponse.CacheScope.PUBLIC);\n \t\t}\n \t}\n+}\n",
        "project": "wicket",
        "linesAdd": 10,
        "jira_id": "5441",
        "nb_skipped": 2,
        "commit": "8ccb1f6d",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1438,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.core.request.mapper.CryptoMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\nindex 86c551a50b..bb65517056 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\n@@ -234,6 +234,8 @@ private Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\t\t}\r\n \r\n \t\t\turl.getQueryParameters().addAll(originalUrl.getQueryParameters());\r\n+\t\t\t// WICKET-4923 additional parameters\r\n+\t\t\turl.getQueryParameters().addAll(encryptedUrl.getQueryParameters());\r\n \t\t}\r\n \t\tcatch (Exception e)\r\n \t\t{\r\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "4923",
        "nb_skipped": 5,
        "commit": "d78132be",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 1,
        "nb_test": 1718,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.ajax.AjaxEventBehaviorTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java b/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\nindex b1a6f98b34..aba06de550 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/ajax/AjaxEventBehavior.java\n@@ -16,11 +16,16 @@\n  */\n package org.apache.wicket.ajax;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n import org.apache.wicket.Component;\n import org.apache.wicket.ajax.attributes.AjaxRequestAttributes;\n import org.apache.wicket.markup.head.IHeaderResponse;\n import org.apache.wicket.markup.head.OnDomReadyHeaderItem;\n import org.apache.wicket.util.lang.Args;\n+import org.apache.wicket.util.lang.Checks;\n+import org.apache.wicket.util.string.Strings;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -44,6 +49,13 @@\n  * represents, and so anytime a user clicks this div the {@link #onEvent(AjaxRequestTarget)} of the\n  * behavior is invoked.\n  *\n+ * <p>\n+ * <strong>Note</strong>: {@link #getEvent()} method cuts any <em>on</em> prefix from the given event name(s).\n+ * This is being done for easier migration of applications coming from Wicket 1.5.x where Wicket used\n+ * inline attributes like 'onclick=...'. If the application needs to use custom events with names starting with\n+ * <em>on</em> then {@link #getEvent()} should be overridden.\n+ * </p>\n+ *\n  * @since 1.2\n  * \n  * @author Igor Vaynberg (ivaynberg)\n@@ -69,18 +81,6 @@ public AjaxEventBehavior(String event)\n \n \t\tonCheckEvent(event);\n \n-\t\tevent = event.toLowerCase();\n-\t\tif (event.startsWith(\"on\"))\n-\t\t{\n-\t\t\tString shortName = event.substring(2);\n-\t\t\t// TODO Wicket 8 Change this to throw an error in the milestone/RC versions and remove it for the final version\n-\t\t\tLOGGER.warn(\"Since version 6.0.0 Wicket uses JavaScript event registration so there is no need of the leading \" +\n-\t\t\t\t\t\"'on' in the event name '{}'. Please use just '{}'. Wicket 8.x won't manipulate the provided event \" +\n-\t\t\t\t\t\"names so the leading 'on' may break your application.\"\n-\t\t\t\t\t, event, shortName);\n-\t\t\tevent = shortName;\n-\t\t}\n-\n \t\tthis.event = event;\n \t}\n \n@@ -102,7 +102,9 @@ protected void updateAjaxAttributes(AjaxRequestAttributes attributes)\n \t{\n \t\tsuper.updateAjaxAttributes(attributes);\n \n-\t\tattributes.setEventNames(event);\n+\t\tString evt = getEvent();\n+\t\tChecks.notEmpty(evt, \"getEvent() should return non-empty event name(s)\");\n+\t\tattributes.setEventNames(evt);\n \t}\n \n \t/**\n@@ -115,13 +117,33 @@ protected void onCheckEvent(final String event)\n \t}\n \n \t/**\n-\t * \n \t * @return event\n \t *      the event this behavior is attached to\n \t */\n-\tpublic final String getEvent()\n+\tpublic String getEvent()\n \t{\n-\t\treturn event;\n+\t\tString events = event.toLowerCase();\n+\t\tString[] splitEvents = events.split(\"\\\\s+\");\n+\t\tList<String> cleanedEvents = new ArrayList<>(splitEvents.length);\n+\t\tfor (String evt : splitEvents)\n+\t\t{\n+\t\t\tif (Strings.isEmpty(evt) == false)\n+\t\t\t{\n+\t\t\t\tif (evt.startsWith(\"on\"))\n+\t\t\t\t{\n+\t\t\t\t\tString shortName = evt.substring(2);\n+\t\t\t\t\t// TODO Wicket 8 Change this to throw an error in the milestone/RC versions and remove it for the final version\n+\t\t\t\t\tLOGGER.warn(\"Since version 6.0.0 Wicket uses JavaScript event registration so there is no need of the leading \" +\n+\t\t\t\t\t\t\t\"'on' in the event name '{}'. Please use just '{}'. Wicket 8.x won't manipulate the provided event \" +\n+\t\t\t\t\t\t\t\"names so the leading 'on' may break your application.\"\n+\t\t\t\t\t\t\t, evt, shortName);\n+\t\t\t\t\tevt = shortName;\n+\t\t\t\t}\n+\t\t\t\tcleanedEvents.add(evt);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn Strings.join(\" \", cleanedEvents);\n \t}\n \n \t/**\n",
        "project": "wicket",
        "linesAdd": 30,
        "jira_id": "5783",
        "nb_skipped": 1,
        "commit": "7b8b6767",
        "nb_failure": 1,
        "linesRem": 14,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1170,
        "nb_error": 2,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.wicket.protocol.http.servlet.ServletWebResponseTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\nindex a1d03122d2..c5bc8c73e6 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/ServletWebResponse.java\n@@ -241,7 +241,6 @@ public void sendRedirect(String url)\n \t\ttry\n \t\t{\n \t\t\tredirect = true;\n-\t\t\turl = getAbsoluteURL(url);\n \t\t\turl = encodeRedirectURL(url);\n \n \t\t\t// wicket redirects should never be cached\n",
        "project": "wicket",
        "linesAdd": 0,
        "jira_id": "3885",
        "nb_skipped": 2,
        "commit": "beb9086d",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": true
    },
    {
        "files": 1,
        "nb_test": 992,
        "nb_error": 6,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.versioning.PageVersioningTest",
            "org.apache.wicket.ComponentConfigurationTest",
            "org.apache.wicket.markup.html.internal.EnclosureTest",
            "org.apache.wicket.markup.html.border.ComponentBorderTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/Component.java b/wicket/src/main/java/org/apache/wicket/Component.java\nindex c9d7bdeed7..fa7e85a78a 100644\n--- a/wicket/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket/src/main/java/org/apache/wicket/Component.java\n@@ -429,16 +429,6 @@ public boolean compare(Component component, Object b)\n \t\tprivate static final long serialVersionUID = 1L;\n \t};\n \n-\t/**\n-\t * Keeps metadata about the visibility state of the component\n-\t * \n-\t * The states are: null - not calculated, true and false\n-\t */\n-\tprivate static final MetaDataKey<Boolean> VISIBLE_IN_HIERARCHY_CACHE_KEY = new MetaDataKey<Boolean>()\n-\t{\n-\t\tprivate static final long serialVersionUID = 1L;\n-\t};\n-\n \t/**\n \t * Keeps metadata about the enabled state of the component\n \t * \n@@ -2147,22 +2137,16 @@ public boolean isVisible()\n \t * @return true if the component and all its parents are visible.\n \t */\n \tpublic final boolean isVisibleInHierarchy()\n-\t{\n-\t\tBoolean state = getMetaData(VISIBLE_IN_HIERARCHY_CACHE_KEY);\n-\t\tif (state == null)\n \t{\n \t\tComponent parent = getParent();\n \t\tif (parent != null && !parent.isVisibleInHierarchy())\n \t\t{\n-\t\t\t\tstate = false;\n+\t\t\treturn false;\n \t\t}\n \t\telse\n \t\t{\n-\t\t\t\tstate = determineVisibility();\n-\t\t\t}\n-\t\t\tsetMetaData(VISIBLE_IN_HIERARCHY_CACHE_KEY, state);\n+\t\t\treturn determineVisibility();\n \t\t}\n-\t\treturn state;\n \t}\n \n \t/**\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "3166",
        "nb_skipped": 0,
        "commit": "4d7f7359",
        "nb_failure": 0,
        "linesRem": 13,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1616,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.form.CollectionFormComponentTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\nindex fdeb8c638f..cb4ad0573c 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/FormComponent.java\n@@ -1610,8 +1610,8 @@ public final void updateAutoLabels(AjaxRequestTarget target)\n \t * @param formComponent\n \t *            the form component to update\n \t * @see FormComponent#updateModel()\n-\t * @throws UnsupportedOperationException\n-\t *             if the existing model object Collection cannot be modified\n+\t * @throws WicketRuntimeException\n+\t *             if the existing model object collection is unmodifiable and no setter exists\n \t */\n \tpublic static <S> void updateCollectionModel(FormComponent<Collection<S>> formComponent)\n \t{\n@@ -1625,23 +1625,42 @@ public final void updateAutoLabels(AjaxRequestTarget target)\n \t\t}\n \t\telse\n \t\t{\n+\t\t\tException failure;\n+\n \t\t\tformComponent.modelChanging();\n+\t\t\t\n+\t\t\ttry {\n \t\t\t\tcollection.clear();\n \t\t\t\tif (convertedInput != null)\n \t\t\t\t{\n \t\t\t\t\tcollection.addAll(convertedInput);\n \t\t\t\t}\n-\t\t\tformComponent.modelChanged();\n+\t\t\t\tfailure = null;\n+\t\t\t} catch (UnsupportedOperationException unmodifiable) {\n+\t\t\t\tlogger.debug(\"An error occurred while trying to change the collection attached to \" + formComponent, unmodifiable);\n+\n+\t\t\t\tfailure = unmodifiable;\n+\t\t\t\tcollection = new ArrayList<>(convertedInput); \n+\t\t\t}\n \t\t\t\n \t\t\ttry\n \t\t\t{\n \t\t\t\tformComponent.getModel().setObject(collection);\n+\t\t\t\tfailure = null;\n \t\t\t}\n-\t\t\tcatch (Exception e)\n+\t\t\tcatch (Exception noSetter)\n \t\t\t{\n-\t\t\t\t// ignore this exception because it could be that there\n-\t\t\t\t// is not setter for this collection.\n-\t\t\t\tlogger.info(\"An error occurred while trying to set the new value for the property attached to \" + formComponent, e);\n+\t\t\t\tlogger.debug(\"An error occurred while trying to set the collection attached to \" + formComponent, noSetter);\n+\t\t\t\t\n+\t\t\t\tif (failure != null) {\n+\t\t\t\t\tfailure = noSetter;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n+\t\t\tif (failure == null) {\n+\t\t\t\tformComponent.modelChanged();\n+\t\t\t} else {\n+\t\t\t\tthrow new WicketRuntimeException(\"Unable to update the collection attached to \" + formComponent); \n \t\t\t}\n \t\t}\n \t}\n",
        "project": "wicket",
        "linesAdd": 24,
        "jira_id": "5518",
        "nb_skipped": 2,
        "commit": "c2e12216",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1458,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.protocol.http.mock.CookiesTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/Cookies.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/Cookies.java\nindex 68f3083918..d3a8a6e17e 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/Cookies.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/mock/Cookies.java\n@@ -19,6 +19,7 @@\n import javax.servlet.http.Cookie;\n \n import org.apache.wicket.util.lang.Args;\n+import org.apache.wicket.util.lang.Objects;\n \n /**\n  * A helper class for dealing with cookies\n@@ -59,7 +60,7 @@ public static boolean isEqual(Cookie c1, Cookie c2)\n \t\tArgs.notNull(c2, \"c2\");\n \n \t\treturn c1.getName().equals(c2.getName()) &&\n-\t\t\t\t((c1.getPath() == null && c2.getPath() == null) || (c1.getPath().equals(c2.getPath()))) &&\n-\t\t\t\t((c1.getDomain() == null && c2.getDomain() == null) || (c1.getDomain().equals(c2.getDomain())));\n+\t\t\t\tObjects.isEqual(c1.getPath(), c2.getPath()) &&\n+\t\t\t\tObjects.isEqual(c1.getDomain(), c2.getDomain());\n \t}\n }\n",
        "project": "wicket",
        "linesAdd": 3,
        "jira_id": "5072",
        "nb_skipped": 3,
        "commit": "381b90fd",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 77,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.UrlTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex d387a13c2b..acb42875d2 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -989,18 +989,29 @@ public void resolveRelative(final Url relative)\n \t\t\t// strip the first non-folder segment\n \t\t\tgetSegments().remove(getSegments().size() - 1);\n \t\t}\n-\t\t// remove all './' (current folder) from the relative url\n-\t\tif (!relative.getSegments().isEmpty() && \".\".equals(relative.getSegments().get(0)))\n+\n+\t\t// remove leading './' (current folder) and empty segments, process any ../ segments from the\n+\t\t// relative url\n+\t\twhile (!relative.getSegments().isEmpty())\n+\t\t{\n+\t\t\tif (\".\".equals(relative.getSegments().get(0)))\n \t\t\t{\n \t\t\t\trelative.getSegments().remove(0);\n \t\t\t}\n-\n-\t\t// process any ../ segments in the relative url\n-\t\twhile (!relative.getSegments().isEmpty() && \"..\".equals(relative.getSegments().get(0)))\n+\t\t\telse if (\"\".equals(relative.getSegments().get(0)))\n+\t\t\t{\n+\t\t\t\trelative.getSegments().remove(0);\n+\t\t\t}\n+\t\t\telse if (\"..\".equals(relative.getSegments().get(0)))\n \t\t\t{\n \t\t\t\trelative.getSegments().remove(0);\n \t\t\t\tgetSegments().remove(getSegments().size() - 1);\n \t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n \n \t\t// append the remaining relative segments\n \t\tgetSegments().addAll(relative.getSegments());\n",
        "project": "wicket",
        "linesAdd": 14,
        "jira_id": "4518",
        "nb_skipped": 0,
        "commit": "a88882f7",
        "nb_failure": 2,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1546,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.stateless.StatelessDynmicLinksTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 62f1eba75c..e139f997ae 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -4200,15 +4200,10 @@ public Component get(final String path)\n \t */\n \tvoid internalMarkRendering(boolean setRenderingFlag)\n \t{\n-\t\tif (setRenderingFlag)\n-\t\t{\n+\t\t// WICKET-5460 no longer prepared for render\n \t\tsetFlag(FLAG_PREPARED_FOR_RENDER, false);\n-\t\t\tsetFlag(FLAG_RENDERING, true);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tsetFlag(FLAG_RENDERING, false);\n-\t\t}\n+\n+\t\tsetFlag(FLAG_RENDERING, setRenderingFlag);\n \t}\n \n \t/**\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "5460",
        "nb_skipped": 2,
        "commit": "a3a5a40f",
        "nb_failure": 1,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 384,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "wicket.versioning.ReattachVersioningTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/wicket/MarkupContainer.java b/wicket/src/main/java/wicket/MarkupContainer.java\nindex 3234316ff4..395943cb6c 100644\n--- a/wicket/src/main/java/wicket/MarkupContainer.java\n+++ b/wicket/src/main/java/wicket/MarkupContainer.java\n@@ -90,7 +90,7 @@\n  * @see MarkupStream\n  * @author Jonathan Locke\n  */\n-public abstract class MarkupContainer<T> extends Component<T> implements Iterable<Component>\n+public abstract class MarkupContainer<T> extends Component<T> implements Iterable<Component<?>>\n {\n \tprivate static final long serialVersionUID = 1L;\n \n@@ -124,7 +124,7 @@\n \t/**\n \t * @see wicket.Component#Component(MarkupContainer,String)\n \t */\n-\tpublic MarkupContainer(MarkupContainer parent, final String id)\n+\tpublic MarkupContainer(MarkupContainer<?> parent, final String id)\n \t{\n \t\tsuper(parent, id);\n \t}\n@@ -132,7 +132,7 @@ public MarkupContainer(MarkupContainer parent, final String id)\n \t/**\n \t * @see wicket.Component#Component(MarkupContainer,String, IModel)\n \t */\n-\tpublic MarkupContainer(MarkupContainer parent, final String id, IModel<T> model)\n+\tpublic MarkupContainer(MarkupContainer<?> parent, final String id, IModel<T> model)\n \t{\n \t\tsuper(parent, id, model);\n \t}\n@@ -166,7 +166,7 @@ public MarkupFragment getMarkupFragment(final String id)\n \t *             operation.\n \t * @return This\n \t */\n-\tfinal MarkupContainer add(final Component<?> child)\n+\tfinal MarkupContainer<?> add(final Component<?> child)\n \t{\n \t\tif (child == null)\n \t\t{\n@@ -180,8 +180,7 @@ final MarkupContainer add(final Component<?> child)\n \t\t}\n \n \t\t// Add to map\n-\t\taddedComponent(child);\n-\t\tComponent replaced = put(child);\n+\t\tComponent<?> replaced = put(child);\n \t\tchild.setFlag(FLAG_REMOVED_FROM_PARENT, false);\n \t\tif (replaced != null)\n \t\t{\n@@ -195,6 +194,8 @@ final MarkupContainer add(final Component<?> child)\n \t\t\tString replacedId = (replaced.hasMarkupIdMetaData()) ? replaced.getMarkupId() : null;\n \t\t\tchild.setMarkupIdMetaData(replacedId);\n \t\t}\n+\t\t// now call addedComponent (after removedComponent)\n+\t\taddedComponent(child);\n \n \t\treturn this;\n \t}\n@@ -229,7 +230,7 @@ final MarkupContainer add(final Component<?> child)\n \t *            True if all descendents should be considered\n \t * @return True if the component is contained in this container\n \t */\n-\tpublic final boolean contains(final Component component, final boolean recurse)\n+\tpublic final boolean contains(final Component<?> component, final boolean recurse)\n \t{\n \t\tif (component == null)\n \t\t{\n@@ -239,10 +240,10 @@ public final boolean contains(final Component component, final boolean recurse)\n \t\tif (recurse)\n \t\t{\n \t\t\t// Start at component and continue while we're not out of parents\n-\t\t\tfor (Component current = component; current != null;)\n+\t\t\tfor (Component<?> current = component; current != null;)\n \t\t\t{\n \t\t\t\t// Get parent\n-\t\t\t\tfinal MarkupContainer parent = current.getParent();\n+\t\t\t\tfinal MarkupContainer<?> parent = current.getParent();\n \n \t\t\t\t// If this container is the parent, then the component is\n \t\t\t\t// recursively contained by this container\n@@ -274,7 +275,7 @@ public final boolean contains(final Component component, final boolean recurse)\n \t * @return The component at the path\n \t */\n \t@Override\n-\tpublic final Component get(final String path)\n+\tpublic final Component<?> get(final String path)\n \t{\n \t\t// Reference to this container\n \t\tif (path == null || path.trim().equals(\"\"))\n@@ -286,7 +287,7 @@ public final Component get(final String path)\n \t\tfinal String id = Strings.firstPathComponent(path, Component.PATH_SEPARATOR);\n \n \t\t// Get child by id\n-\t\tComponent child = children_get(id);\n+\t\tComponent<?> child = children_get(id);\n \n \t\t// If the container is transparent, than ask its parent.\n \t\t// ParentResolver does something quite similar, but because of <head>,\n@@ -341,7 +342,7 @@ public String getMarkupType()\n \t *             Thrown if a child with the same id is replaced by the add\n \t *             operation.\n \t */\n-\tpublic void internalAdd(final Component child)\n+\tpublic void internalAdd(final Component<?> child)\n \t{\n \t\tif (log.isDebugEnabled())\n \t\t{\n@@ -372,7 +373,7 @@ public void internalAttach()\n \t\t\tfor (int i = 0; i < size; i++)\n \t\t\t{\n \t\t\t\t// Get next child\n-\t\t\t\tfinal Component child = children_get(i);\n+\t\t\t\tfinal Component<?> child = children_get(i);\n \n \t\t\t\t// Ignore feedback as that was done in Page\n \t\t\t\tif (!(child instanceof IFeedback))\n@@ -409,7 +410,7 @@ public void internalDetach()\n \t\tsuper.internalDetach();\n \n \t\t// Loop through child components\n-\t\tfor (Component child : this)\n+\t\tfor (Component<?> child : this)\n \t\t{\n \t\t\t// Call end request on the child\n \t\t\tchild.internalDetach();\n@@ -420,9 +421,9 @@ public void internalDetach()\n \t * @return Iterator that iterates through children in the order they were\n \t *         added\n \t */\n-\tpublic final Iterator<Component> iterator()\n+\tpublic final Iterator<Component<?>> iterator()\n \t{\n-\t\treturn new Iterator<Component>()\n+\t\treturn new Iterator<Component<?>>()\n \t\t{\n \t\t\tint index = 0;\n \n@@ -431,7 +432,7 @@ public boolean hasNext()\n \t\t\t\treturn index < children_size();\n \t\t\t}\n \n-\t\t\tpublic Component next()\n+\t\t\tpublic Component<?> next()\n \t\t\t{\n \t\t\t\treturn children_get(index++);\n \t\t\t}\n@@ -449,9 +450,9 @@ public void remove()\n \t * @return Iterator that iterates over children in the order specified by\n \t *         comparator\n \t */\n-\tpublic final Iterator<Component> iterator(Comparator<Component> comparator)\n+\tpublic final Iterator<Component<?>> iterator(Comparator<Component<?>> comparator)\n \t{\n-\t\tfinal List<Component> sorted;\n+\t\tfinal List<Component<?>> sorted;\n \t\tif (children == null)\n \t\t{\n \t\t\tsorted = Collections.emptyList();\n@@ -460,12 +461,12 @@ public void remove()\n \t\t{\n \t\t\tif (children instanceof Component)\n \t\t\t{\n-\t\t\t\tsorted = new ArrayList<Component>(1);\n-\t\t\t\tsorted.add((Component)children);\n+\t\t\t\tsorted = new ArrayList<Component<?>>(1);\n+\t\t\t\tsorted.add((Component<?>)children);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n-\t\t\t\tsorted = Arrays.asList((Component[])children);\n+\t\t\t\tsorted = Arrays.asList((Component<?>[])children);\n \t\t\t}\n \t\t}\n \t\tCollections.sort(sorted, comparator);\n@@ -476,7 +477,7 @@ public void remove()\n \t * @param component\n \t *            Component to remove from this container\n \t */\n-\tpublic void remove(final Component component)\n+\tpublic void remove(final Component<?> component)\n \t{\n \t\tif (component == null)\n \t\t{\n@@ -503,7 +504,7 @@ public final void remove(final String id)\n \t\t\tthrow new IllegalArgumentException(\"argument id may not be null\");\n \t\t}\n \n-\t\tfinal Component component = get(id);\n+\t\tfinal Component<?> component = get(id);\n \t\tif (component != null)\n \t\t{\n \t\t\tremove(component);\n@@ -685,7 +686,7 @@ public String toString(final boolean detailed)\n \t\t\t\tfor (int i = 0; i < size; i++)\n \t\t\t\t{\n \t\t\t\t\t// Get next child\n-\t\t\t\t\tfinal Component child = children_get(i);\n+\t\t\t\t\tfinal Component<?> child = children_get(i);\n \t\t\t\t\tif (i != 0)\n \t\t\t\t\t{\n \t\t\t\t\t\tbuffer.append(' ');\n@@ -709,7 +710,7 @@ public String toString(final boolean detailed)\n \t * @return The return value from a visitor which halted the traversal, or\n \t *         null if the entire traversal occurred\n \t */\n-\tpublic final Object visitChildren(final Class clazz, final IVisitor visitor)\n+\tpublic final Object visitChildren(final Class<?> clazz, final IVisitor visitor)\n \t{\n \t\tif (visitor == null)\n \t\t{\n@@ -720,7 +721,7 @@ public final Object visitChildren(final Class clazz, final IVisitor visitor)\n \t\tfor (int i = 0; i < children_size(); i++)\n \t\t{\n \t\t\t// Get next child component\n-\t\t\tfinal Component child = children_get(i);\n+\t\t\tfinal Component<?> child = children_get(i);\n \t\t\tObject value = null;\n \n \t\t\t// Is the child of the correct class (or was no class specified)?\n@@ -780,7 +781,7 @@ public final Object visitChildren(final IVisitor visitor)\n \tprotected final MarkupStream findMarkupStream()\n \t{\n \t\t// Start here\n-\t\tMarkupContainer c = this;\n+\t\tMarkupContainer<?> c = this;\n \n \t\t// Walk up hierarchy until markup found\n \t\twhile (c.getMarkupStream() == null)\n@@ -1025,7 +1026,7 @@ private final void addedComponent(final Component component)\n \t * @param child\n \t *            Child to add\n \t */\n-\tprivate final void children_add(final Component child)\n+\tprivate final void children_add(final Component<?> child)\n \t{\n \t\tif (this.children == null)\n \t\t{\n@@ -1037,7 +1038,7 @@ private final void children_add(final Component child)\n \t\t\tfinal int size = children_size();\n \n \t\t\t// Create array that holds size + 1 elements\n-\t\t\tfinal Component[] children = new Component[size + 1];\n+\t\t\tfinal Component<?>[] children = new Component[size + 1];\n \n \t\t\t// Loop through existing children copying them\n \t\t\tfor (int i = 0; i < size; i++)\n@@ -1059,7 +1060,7 @@ private final void children_add(final Component child)\n \t\t{\n \t\t\tif (children instanceof Component)\n \t\t\t{\n-\t\t\t\treturn (Component)children;\n+\t\t\t\treturn (Component<?>)children;\n \t\t\t}\n \t\t\telse\n \t\t\t{\n@@ -1072,11 +1073,11 @@ private final void children_add(final Component child)\n \t\t}\n \t}\n \n-\tprivate final Component children_get(final String id)\n+\tprivate final Component<?> children_get(final String id)\n \t{\n \t\tif (children instanceof Component)\n \t\t{\n-\t\t\tfinal Component component = (Component)children;\n+\t\t\tfinal Component<?> component = (Component<?>)children;\n \t\t\tif (component.getId().equals(id))\n \t\t\t{\n \t\t\t\treturn component;\n@@ -1086,8 +1087,8 @@ private final Component children_get(final String id)\n \t\t{\n \t\t\tif (children != null)\n \t\t\t{\n-\t\t\t\tfinal Component[] components = (Component[])children;\n-\t\t\t\tfor (Component element : components)\n+\t\t\t\tfinal Component<?>[] components = (Component[])children;\n+\t\t\t\tfor (Component<?> element : components)\n \t\t\t\t{\n \t\t\t\t\tif (element.getId().equals(id))\n \t\t\t\t\t{\n@@ -1099,11 +1100,49 @@ private final Component children_get(final String id)\n \t\treturn null;\n \t}\n \n+\t/**\n+\t * Will search for this specific child instance in the current\n+\t * children. So it will do a identity check, it will not look if the\n+\t * id is already present in the children. Use indexOf(String) for that. \n+\t * @param child\n+\t * @return The index of this child.\n+\t */\n \tprivate final int children_indexOf(Component<?> child)\n \t{\n \t\tif (children instanceof Component)\n \t\t{\n-\t\t\tif (((Component)children).getId().equals(child.getId()))\n+\t\t\tif (children == child)\n+\t\t\t{\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tif (children != null)\n+\t\t\t{\n+\t\t\t\tfinal Component<?>[] components = (Component[])children;\n+\t\t\t\tfor (int i = 0; i < components.length; i++)\n+\t\t\t\t{\n+\t\t\t\t\tif (components[i] == child)\n+\t\t\t\t\t{\n+\t\t\t\t\t\treturn i;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn -1;\n+\t}\n+\n+\t/**\n+\t * Will search for the id if it is found in the current children.\n+\t * @param id The id to search for.\n+\t * @return The index of this child.\n+\t */\n+\tprivate final int children_indexOf(String id)\n+\t{\n+\t\tif (children instanceof Component)\n+\t\t{\n+\t\t\tif (((Component<?>)children).getId().equals(id))\n \t\t\t{\n \t\t\t\treturn 0;\n \t\t\t}\n@@ -1112,10 +1151,10 @@ private final int children_indexOf(Component<?> child)\n \t\t{\n \t\t\tif (children != null)\n \t\t\t{\n-\t\t\t\tfinal Component[] components = (Component[])children;\n+\t\t\t\tfinal Component<?>[] components = (Component[])children;\n \t\t\t\tfor (int i = 0; i < components.length; i++)\n \t\t\t\t{\n-\t\t\t\t\tif (components[i].getId().equals(child.getId()))\n+\t\t\t\t\tif (components[i].getId().equals(id))\n \t\t\t\t\t{\n \t\t\t\t\t\treturn i;\n \t\t\t\t\t}\n@@ -1125,7 +1164,7 @@ private final int children_indexOf(Component<?> child)\n \t\treturn -1;\n \t}\n \n-\tprivate final Component children_remove(Component<?> component)\n+\tprivate final Component<?> children_remove(Component<?> component)\n \t{\n \t\tint index = children_indexOf(component);\n \t\tif (index != -1)\n@@ -1135,13 +1174,13 @@ private final Component children_remove(Component<?> component)\n \t\treturn null;\n \t}\n \n-\tprivate final Component children_remove(int index)\n+\tprivate final Component<?> children_remove(int index)\n \t{\n \t\tif (children instanceof Component)\n \t\t{\n \t\t\tif (index == 0)\n \t\t\t{\n-\t\t\t\tfinal Component removed = (Component)children;\n+\t\t\t\tfinal Component<?> removed = (Component<?>)children;\n \t\t\t\tthis.children = null;\n \t\t\t\treturn removed;\n \t\t\t}\n@@ -1152,8 +1191,8 @@ private final Component children_remove(int index)\n \t\t}\n \t\telse\n \t\t{\n-\t\t\tComponent[] c = ((Component[])children);\n-\t\t\tfinal Component removed = c[index];\n+\t\t\tComponent<?>[] c = ((Component[])children);\n+\t\t\tfinal Component<?> removed = c[index];\n \t\t\tif (c.length == 2)\n \t\t\t{\n \t\t\t\tif (index == 0)\n@@ -1171,7 +1210,7 @@ else if (index == 1)\n \t\t\t}\n \t\t\telse\n \t\t\t{\n-\t\t\t\tComponent[] newChildren = new Component[c.length - 1];\n+\t\t\t\tComponent<?>[] newChildren = new Component[c.length - 1];\n \t\t\t\tint j = 0;\n \t\t\t\tfor (int i = 0; i < c.length; i++)\n \t\t\t\t{\n@@ -1186,19 +1225,19 @@ else if (index == 1)\n \t\t}\n \t}\n \n-\tprivate final Component children_set(int index, Component child)\n+\tprivate final Component<?> children_set(int index, Component<?> child)\n \t{\n-\t\tfinal Component replaced;\n+\t\tfinal Component<?> replaced;\n \t\tif (index < children_size())\n \t\t{\n \t\t\tif (children == null || children instanceof Component)\n \t\t\t{\n-\t\t\t\treplaced = (Component)children;\n+\t\t\t\treplaced = (Component<?>)children;\n \t\t\t\tchildren = child;\n \t\t\t}\n \t\t\telse\n \t\t\t{\n-\t\t\t\tfinal Component[] children = (Component[])this.children;\n+\t\t\t\tfinal Component<?>[] children = (Component[])this.children;\n \t\t\t\treplaced = children[index];\n \t\t\t\tchildren[index] = child;\n \t\t\t}\n@@ -1234,9 +1273,12 @@ private final int children_size()\n \t *            The child to put into the map\n \t * @return Any component that was replaced\n \t */\n-\tprivate final Component put(final Component<?> child)\n+\tprivate final Component<?> put(final Component<?> child)\n \t{\n-\t\tint index = children_indexOf(child);\n+\t\t// search for the child by id. So that it will\n+\t\t// find the right index for the id instead of looking\n+\t\t// if the component itself is already children.\n+\t\tint index = children_indexOf(child.getId());\n \t\tif (index == -1)\n \t\t{\n \t\t\tchildren_add(child);\n@@ -1410,7 +1452,7 @@ public void renderHead(final IHeaderResponse response)\n \t\t{\n \t\t\tsuper.renderHead(response);\n \n-\t\t\tfor (Component child : this)\n+\t\t\tfor (Component<?> child : this)\n \t\t\t{\n \t\t\t\tchild.renderHead(response);\n \t\t\t}\ndiff --git a/wicket/src/main/java/wicket/markup/repeater/RefreshingView.java b/wicket/src/main/java/wicket/markup/repeater/RefreshingView.java\nindex 87d61fe04f..29fe8c487f 100644\n--- a/wicket/src/main/java/wicket/markup/repeater/RefreshingView.java\n+++ b/wicket/src/main/java/wicket/markup/repeater/RefreshingView.java\n@@ -170,7 +170,7 @@ protected void internalOnAttach()\n \t */\r\n \tpublic Iterator<Item<T>> getItems()\r\n \t{\r\n-\t\tfinal Iterator<Component> iterator = iterator();\r\n+\t\tfinal Iterator<Component<?>> iterator = iterator();\r\n \t\treturn new Iterator<Item<T>>()\r\n \t\t{\r\n \t\t\tpublic boolean hasNext()\r\ndiff --git a/wicket/src/main/java/wicket/markup/repeater/data/GridView.java b/wicket/src/main/java/wicket/markup/repeater/data/GridView.java\nindex 1f306fc110..d1984e8b47 100644\n--- a/wicket/src/main/java/wicket/markup/repeater/data/GridView.java\n+++ b/wicket/src/main/java/wicket/markup/repeater/data/GridView.java\n@@ -303,7 +303,7 @@ protected void addItems(Iterator<Item<T>> items)\n \t */\r\n \tprivate static class ItemsIterator<T> implements Iterator<Item<T>>\r\n \t{\r\n-\t\tprivate Iterator<Component> rows;\r\n+\t\tprivate Iterator<Component<?>> rows;\r\n \t\tprivate Iterator<Item<T>> cells;\r\n \r\n \t\tprivate Item<T> next;\r\n@@ -312,7 +312,7 @@ protected void addItems(Iterator<Item<T>> items)\n \t\t * @param rows\r\n \t\t *            iterator over child row views\r\n \t\t */\r\n-\t\tpublic ItemsIterator(Iterator<Component> rows)\r\n+\t\tpublic ItemsIterator(Iterator<Component<?>> rows)\r\n \t\t{\r\n \t\t\tthis.rows = rows;\r\n \t\t\tfindNext();\r\n",
        "project": "wicket",
        "linesAdd": 80,
        "jira_id": "172",
        "nb_skipped": 0,
        "commit": "99e22ce4",
        "nb_failure": 1,
        "linesRem": 54,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 940,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.lang.PropertyResolverTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/util/convert/ConverterLocator.java b/wicket/src/main/java/org/apache/wicket/util/convert/ConverterLocator.java\nindex fc09b994ab..0b9b093a03 100644\n--- a/wicket/src/main/java/org/apache/wicket/util/convert/ConverterLocator.java\n+++ b/wicket/src/main/java/org/apache/wicket/util/convert/ConverterLocator.java\n@@ -101,7 +101,7 @@ public Object convertToObject(String value, Locale locale)\n \t\t\t\telse\n \t\t\t\t{\n \t\t\t\t\tthrow new ConversionException(\"Could not convert value: \" + value +\n-\t\t\t\t\t\t\" to type: \" + theType.getName() + \"(Could not find compatible converter).\").setSourceValue(value);\n+\t\t\t\t\t\t\" to type: \" + theType.getName() + \". Could not find compatible converter.\").setSourceValue(value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (Exception e)\ndiff --git a/wicket/src/main/java/org/apache/wicket/util/lang/PropertyResolver.java b/wicket/src/main/java/org/apache/wicket/util/lang/PropertyResolver.java\nindex d83ba146a3..64a717bf3a 100644\n--- a/wicket/src/main/java/org/apache/wicket/util/lang/PropertyResolver.java\n+++ b/wicket/src/main/java/org/apache/wicket/util/lang/PropertyResolver.java\n@@ -1094,6 +1094,9 @@ public final void setValue(final Object object, final Object value,\n \t\t\tClass type = null;\n \t\t\tif (setMethod != null)\n \t\t\t{\n+\t\t\t\t// getMethod is always there and if the value will be set through a setMethod then\n+\t\t\t\t// the getMethod return type will be its type. Else we have to look at the\n+\t\t\t\t// parameters if the setter but getting the return type is quicker\n \t\t\t\ttype = getMethod.getReturnType();\n \t\t\t}\n \t\t\telse if (field != null)\n@@ -1104,7 +1107,7 @@ else if (field != null)\n \t\t\tObject converted = null;\n \t\t\tif (type != null)\n \t\t\t{\n-\t\t\t\tconverted = converter.convert(value, getMethod.getReturnType());\n+\t\t\t\tconverted = converter.convert(value, type);\n \t\t\t\tif (converted == null)\n \t\t\t\t{\n \t\t\t\t\tif (value != null)\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "2624",
        "nb_skipped": 0,
        "commit": "ef880545",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1066,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.resolver.border.WicketMessageResolverTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/resolver/WicketMessageResolver.java b/wicket-core/src/main/java/org/apache/wicket/markup/resolver/WicketMessageResolver.java\nindex 03d7acdfd0..fa4122a825 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/resolver/WicketMessageResolver.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/resolver/WicketMessageResolver.java\n@@ -347,7 +348,8 @@ protected String getValue(final String variableName)\n \t\t\t\t\t// If it a tag like <wicket..> or <span wicket:id=\"...\" >\n \t\t\t\t\tif ((element instanceof ComponentTag) && !markupStream.atCloseTag())\n \t\t\t\t\t{\n-\t\t\t\t\t\tString id = ((ComponentTag)element).getId();\n+\t\t\t\t\t\tComponentTag currentTag = (ComponentTag)element;\n+\t\t\t\t\t\tString id = currentTag.getId();\n \n \t\t\t\t\t\t// Temporarily replace the web response with a String response\n \t\t\t\t\t\tfinal Response webResponse = getResponse();\n@@ -358,6 +360,18 @@ protected String getValue(final String variableName)\n \t\t\t\t\t\t\tgetRequestCycle().setResponse(response);\n \n \t\t\t\t\t\t\tComponent component = getParent().get(id);\n+\t\t\t\t\t\t\tif (component == null)\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tcomponent = ComponentResolvers.resolve(getParent(), markupStream,\n+\t\t\t\t\t\t\t\t\tcurrentTag, null);\n+\n+\t\t\t\t\t\t\t\t// Must not be a Page and it must be connected to a parent.\n+\t\t\t\t\t\t\t\tif (component.getParent() == null)\n+\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\tcomponent = null;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\n \t\t\t\t\t\t\tif (component != null)\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tcomponent.render();\n",
        "project": "wicket",
        "linesAdd": 13,
        "jira_id": "3454",
        "nb_skipped": 0,
        "commit": "f1e854b3",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1406,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.resource.aggregator.ResourceAggregatorTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/head/ResourceAggregator.java b/wicket-core/src/main/java/org/apache/wicket/markup/head/ResourceAggregator.java\nindex bce6a11305..02221e7997 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/head/ResourceAggregator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/head/ResourceAggregator.java\n@@ -126,7 +126,7 @@ public String toString()\n \t\tpublic RecordedHeaderItem(HeaderItem item)\n \t\t{\n \t\t\tthis.item = item;\n-\t\t\tthis.locations = new ArrayList<RecordedHeaderItemLocation>();\n+\t\t\tlocations = new ArrayList<RecordedHeaderItemLocation>();\n \t\t}\n \n \t\t/**\n@@ -186,9 +186,9 @@ public ResourceAggregator(IHeaderResponse real)\n \t{\n \t\tsuper(real);\n \n-\t\tthis.itemsToBeRendered = new LinkedHashMap<HeaderItem, RecordedHeaderItem>();\n-\t\tthis.domReadyItemsToBeRendered = new ArrayList<OnDomReadyHeaderItem>();\n-\t\tthis.loadItemsToBeRendered = new ArrayList<OnLoadHeaderItem>();\n+\t\titemsToBeRendered = new LinkedHashMap<HeaderItem, RecordedHeaderItem>();\n+\t\tdomReadyItemsToBeRendered = new ArrayList<OnDomReadyHeaderItem>();\n+\t\tloadItemsToBeRendered = new ArrayList<OnLoadHeaderItem>();\n \t}\n \n \t@Override\n@@ -375,6 +375,10 @@ private void renderSeperateEventScripts()\n \t */\n \tprivate HeaderItem getItemToBeRendered(HeaderItem item)\n \t{\n+\t\twhile (item instanceof IWrappedHeaderItem)\n+\t\t{\n+\t\t\titem = ((IWrappedHeaderItem)item).getWrapped();\n+\t\t}\n \t\tif (getRealResponse().wasRendered(item))\n \t\t{\n \t\t\treturn NoHeaderItem.get();\n",
        "project": "wicket",
        "linesAdd": 8,
        "jira_id": "4753",
        "nb_skipped": 5,
        "commit": "21a47387",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 9,
        "nb_test": 409,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "wicket.util.tester.apps_4.FormTesterTest",
            "wicket.util.tester.WicketTesterTest"
        ],
        "patch": "diff --git a/jdk-1.4/wicket/src/main/java/wicket/Component.java b/jdk-1.4/wicket/src/main/java/wicket/Component.java\nindex cd199158fb..a360e4f575 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/Component.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/Component.java\n@@ -662,7 +662,7 @@ public final boolean continueToOriginalDestination()\n \t */\n \tpublic final void debug(final String message)\n \t{\n-\t\tgetPage().getFeedbackMessages().debug(this, message);\n+\t\tSession.get().getFeedbackMessages().debug(this, message);\n \t}\n \n \t/**\n@@ -685,7 +685,7 @@ public void detachModels()\n \t */\n \tpublic final void error(final Serializable message)\n \t{\n-\t\tgetPage().getFeedbackMessages().error(this, message);\n+\t\tSession.get().getFeedbackMessages().error(this, message);\n \t}\n \n \t/**\n@@ -696,7 +696,7 @@ public final void error(final Serializable message)\n \t */\n \tpublic final void fatal(final String message)\n \t{\n-\t\tgetPage().getFeedbackMessages().fatal(this, message);\n+\t\tSession.get().getFeedbackMessages().fatal(this, message);\n \t}\n \n \t/**\n@@ -825,7 +825,7 @@ public final boolean getEscapeModelStrings()\n \t */\n \tpublic final FeedbackMessage getFeedbackMessage()\n \t{\n-\t\treturn getPage().getFeedbackMessages().messageForComponent(this);\n+\t\treturn Session.get().getFeedbackMessages().messageForComponent(this);\n \t}\n \n \t/**\n@@ -1216,7 +1216,7 @@ public String getVariation()\n \t */\n \tpublic final boolean hasErrorMessage()\n \t{\n-\t\treturn getPage().getFeedbackMessages().hasErrorMessageFor(this);\n+\t\treturn Session.get().getFeedbackMessages().hasErrorMessageFor(this);\n \t}\n \n \t/**\n@@ -1224,7 +1224,7 @@ public final boolean hasErrorMessage()\n \t */\n \tpublic final boolean hasFeedbackMessage()\n \t{\n-\t\treturn getPage().getFeedbackMessages().hasMessageFor(this);\n+\t\treturn Session.get().getFeedbackMessages().hasMessageFor(this);\n \t}\n \n \t/**\n@@ -1235,7 +1235,7 @@ public final boolean hasFeedbackMessage()\n \t */\n \tpublic final void info(final String message)\n \t{\n-\t\tgetPage().getFeedbackMessages().info(this, message);\n+\t\tSession.get().getFeedbackMessages().info(this, message);\n \t}\n \n \t/**\n@@ -2376,7 +2376,7 @@ public final CharSequence urlFor(final ResourceReference resourceReference)\n \t */\n \tpublic final void warn(final String message)\n \t{\n-\t\tgetPage().getFeedbackMessages().warn(this, message);\n+\t\tSession.get().getFeedbackMessages().warn(this, message);\n \t}\n \n \t/**\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/Page.java b/jdk-1.4/wicket/src/main/java/wicket/Page.java\nindex c67365cf4d..24c9a2cfa7 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/Page.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/Page.java\n@@ -25,7 +25,6 @@\n import org.apache.commons.logging.LogFactory;\n \n import wicket.authorization.UnauthorizedActionException;\n-import wicket.feedback.FeedbackMessages;\n import wicket.feedback.IFeedback;\n import wicket.markup.MarkupException;\n import wicket.markup.MarkupStream;\n@@ -134,6 +133,12 @@\n  */\n public abstract class Page extends MarkupContainer implements IRedirectListener, IPageMapEntry\n {\n+\t/**\n+\t * When passed to {@link Page#getVersion(int)} the latest page version is\n+\t * returned.\n+\t */\n+\tpublic static final int LATEST_VERSION = -1;\n+\n \tprivate static final long serialVersionUID = 1L;\n \n \t/**\n@@ -141,12 +146,6 @@\n \t */\n \tprivate static final ConcurrentHashMap pageClassToBookmarkableCache = new ConcurrentHashMap();\n \n-\t/**\n-\t * When passed to {@link Page#getVersion(int)} the latest page version is\n-\t * returned.\n-\t */\n-\tpublic static final int LATEST_VERSION = -1;\n-\n \t/** True if this page is currently rendering. */\n \tprivate static final short FLAG_IS_RENDERING = FLAG_RESERVED2;\n \n@@ -165,9 +164,6 @@\n \t/** Used to create page-unique numbers */\n \tprivate short autoIndex;\n \n-\t/** Feedback messages for this page */\n-\tprivate FeedbackMessages feedbackMessages;\n-\n \t/** Numeric version of this page's id */\n \tprivate short numericId;\n \n@@ -283,6 +279,35 @@ public void beforeCallComponent(final Component component,\n \t}\n \n \n+\t/**\n+\t * Adds a component to the set of rendered components.\n+\t * \n+\t * @param component\n+\t *            The component that was rendered\n+\t */\n+\tpublic final void componentRendered(final Component component)\n+\t{\n+\t\t// Inform the page that this component rendered\n+\t\tif (Application.get().getDebugSettings().getComponentUseCheck())\n+\t\t{\n+\t\t\tif (renderedComponents == null)\n+\t\t\t{\n+\t\t\t\trenderedComponents = new HashSet();\n+\t\t\t}\n+\t\t\tif (renderedComponents.add(component) == false)\n+\t\t\t{\n+\t\t\t\tthrow new MarkupException(\n+\t\t\t\t\t\t\"The component \"\n+\t\t\t\t\t\t\t\t+ component\n+\t\t\t\t\t\t\t\t+ \" has the same wicket:id as another component already added at the same level\");\n+\t\t\t}\n+\t\t\tif (log.isDebugEnabled())\n+\t\t\t{\n+\t\t\t\tlog.debug(\"Rendered \" + component);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \t/**\n \t * Detaches any attached models referenced by this page.\n \t */\n@@ -300,7 +325,8 @@ public void detachModels()\n \t\t// }\n \t\t// catch (Exception e) // catch anything; we MUST detach all models\n \t\t// {\n-//\t\t\t\t\tlog.error(\"detaching models of component \" + component + \" failed:\", e);\n+\t\t// log.error(\"detaching models of component \" + component + \" failed:\",\n+\t\t// e);\n \t\t// }\n \t\t// return IVisitor.CONTINUE_TRAVERSAL;\n \t\t// }\n@@ -317,88 +343,6 @@ public final void dirty()\n \t\tSession.get().dirtyPage(this);\n \t}\n \n-\t/**\n-\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL IT.\n-\t */\n-\tpublic final void renderPage()\n-\t{\n-\t\t// first try to check if the page can be rendered:\n-\t\tif (!isActionAuthorized(RENDER))\n-\t\t{\n-\t\t\tif (log.isDebugEnabled())\n-\t\t\t{\n-\t\t\t\tlog.debug(\"Page not allowed to render: \" + this);\n-\t\t\t}\n-\t\t\tthrow new UnauthorizedActionException(this, Component.RENDER);\n-\t\t}\n-\n-\t\t// Make sure it is really empty\n-\t\trenderedComponents = null;\n-\n-\t\t// Reset it to stateless so that it can be tested again\n-\t\tthis.stateless = null;\n-\n-\t\t// Set form component values from cookies\n-\t\tsetFormComponentValuesFromCookies();\n-\n-\t\t// First, give priority to IFeedback instances, as they have to\n-\t\t// collect their messages before components like ListViews\n-\t\t// remove any child components\n-\t\tvisitChildren(IFeedback.class, new IVisitor()\n-\t\t{\n-\t\t\tpublic Object component(Component component)\n-\t\t\t{\n-\t\t\t\t((IFeedback)component).updateFeedback();\n-\t\t\t\tcomponent.attach();\n-\t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL;\n-\t\t\t}\n-\t\t});\n-\n-\t\tif (this instanceof IFeedback)\n-\t\t{\n-\t\t\t((IFeedback)this).updateFeedback();\n-\t\t}\n-\n-\t\t// Now, do the initialization for the other components\n-\t\tattach();\n-\n-\t\t// Visit all this page's children to reset markup streams and check\n-\t\t// rendering authorization, as appropriate. We set any result; positive\n-\t\t// or negative as a temporary boolean in the components, and when a\n-\t\t// authorization exception is thrown it will block the rendering of this\n-\t\t// page\n-\n-\t\t// first the page itself\n-\t\tsetRenderAllowed(isActionAuthorized(RENDER));\n-\t\t// children of the page\n-\t\tvisitChildren(new IVisitor()\n-\t\t{\n-\t\t\tpublic Object component(final Component component)\n-\t\t\t{\n-\t\t\t\t// Find out if this component can be rendered\n-\t\t\t\tfinal boolean renderAllowed = component.isActionAuthorized(RENDER);\n-\n-\t\t\t\t// Authorize rendering\n-\t\t\t\tcomponent.setRenderAllowed(renderAllowed);\n-\t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL;\n-\t\t\t}\n-\t\t});\n-\n-\t\t// Handle request by rendering page\n-\t\trender(null);\n-\n-\t\t// Check rendering if it happened fully\n-\t\tcheckRendering(this);\n-\n-\t\tif (!isPageStateless())\n-\t\t{\n-\t\t\t// trigger creation of the actual session in case it was deferred\n-\t\t\tSession.get().getSessionStore().getSessionId(RequestCycle.get().getRequest(), true);\n-\t\t\t// Add/touch the response page in the session (its pagemap).\n-\t\t\tgetSession().touch(this);\n-\t\t}\n-\t}\n-\n \t/**\n \t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL.\n \t * \n@@ -431,6 +375,14 @@ public final void expireOldestVersion()\n \t\t}\n \t}\n \n+\t/**\n+\t * @return The current ajax version number of this page.\n+\t */\n+\tpublic final int getAjaxVersionNumber()\n+\t{\n+\t\treturn versionManager == null ? 0 : versionManager.getAjaxVersionNumber();\n+\t}\n+\n \t/**\n \t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL IT.\n \t * \n@@ -454,42 +406,6 @@ public final int getCurrentVersionNumber()\n \t\treturn versionManager == null ? 0 : versionManager.getCurrentVersionNumber();\n \t}\n \n-\t/**\n-\t * @return The current ajax version number of this page. \n-\t */\n-\tpublic final int getAjaxVersionNumber()\n-\t{\n-\t\treturn versionManager == null ? 0 : versionManager.getAjaxVersionNumber();\n-\t}\n-\t\n-\t/**\n-\t * This returns a page instance that is rollbacked the number of versions\n-\t * that is specified compared to the current page.\n-\t * \n-\t * This is a rollback including ajax versions. \n-\t * \n-\t * @param numberOfVersions to rollback\n-\t * @return\n-\t */\n-\tpublic final Page rollbackPage(int numberOfVersions)\n-\t{\n-\t\tPage page =  versionManager == null? this : versionManager.rollbackPage(numberOfVersions);\n-\t\tgetSession().touch(page);\n-\t\treturn page;\n-\t}\n-\t/**\n-\t * @return Returns feedback messages from all components in this page\n-\t *         (including the page itself).\n-\t */\n-\tpublic final FeedbackMessages getFeedbackMessages()\n-\t{\n-\t\tif (feedbackMessages == null)\n-\t\t{\n-\t\t\tfeedbackMessages = new FeedbackMessages();\n-\t\t}\n-\t\treturn feedbackMessages;\n-\t}\n-\n \t/**\n \t * @see wicket.Component#getId()\n \t */\n@@ -610,7 +526,8 @@ public Page getVersion(final int versionNumber)\n \t\t\t\t}\n \n \t\t\t\t// If we went all the way back to the original page\n-\t\t\t\tif (page != null && page.getCurrentVersionNumber() == 0 && page.getAjaxVersionNumber() == 0)\n+\t\t\t\tif (page != null && page.getCurrentVersionNumber() == 0\n+\t\t\t\t\t\t&& page.getAjaxVersionNumber() == 0)\n \t\t\t\t{\n \t\t\t\t\t// remove version info\n \t\t\t\t\tpage.versionManager = null;\n@@ -658,6 +575,28 @@ public Object component(Component component)\n \t\treturn buffer.toString();\n \t}\n \n+\t/**\n+\t * Call this method when the current (ajax) request shouldn't merge the\n+\t * changes that are happening to the page with the previous version.\n+\t * \n+\t * This is for example needed when you want to redirect to this page in an\n+\t * ajax request and then you do want to version normally..\n+\t * \n+\t * This method doesn't do anything if the getRequest().mergeVersion doesn't\n+\t * return true.\n+\t */\n+\tpublic final void ignoreVersionMerge()\n+\t{\n+\t\tif (getRequest().mergeVersion())\n+\t\t{\n+\t\t\tmayTrackChangesFor(this, null);\n+\t\t\tif (versionManager != null)\n+\t\t\t{\n+\t\t\t\tversionManager.ignoreVersionMerge();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \t/**\n \t * Bookmarkable page can be instantiated using a bookmarkable URL.\n \t * \n@@ -713,16 +652,6 @@ public boolean isErrorPage()\n \t\treturn false;\n \t}\n \n-\t/**\n-\t * Set page stateless\n-\t * \n-\t * @param stateless\n-\t */\n-\tvoid setPageStateless(Boolean stateless)\n-\t{\n-\t\tthis.stateless = stateless;\n-\t}\n-\n \t/**\n \t * Gets whether the page is stateless. Components on stateless page must not\n \t * render any statefull urls, and components on statefull page must not\n@@ -827,288 +756,117 @@ public Object component(final Component component)\n \t}\n \n \t/**\n-\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL.\n-\t * \n-\t * Set the id for this Page. This method is called by PageMap when a Page is\n-\t * added because the id, which is assigned by PageMap, is not known until\n-\t * this time.\n-\t * \n-\t * @param id\n-\t *            The id\n-\t */\n-\tpublic final void setNumericId(final int id)\n-\t{\n-\t\tthis.numericId = (short)id;\n-\t}\n-\n-\t/**\n-\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL.\n-\t * \n-\t * This method is called when a component will be rendered standalone.\n-\t * \n-\t * @param component\n-\t * \n-\t */\n-\tpublic final void startComponentRender(Component component)\n-\t{\n-\t\trenderedComponents = null;\n-\t}\n-\n-\t/**\n-\t * Get the string representation of this container.\n-\t * \n-\t * @return String representation of this container\n+\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL IT.\n \t */\n-\tpublic String toString()\n+\tpublic final void renderPage()\n \t{\n-\t\tif(versionManager != null)\n+\t\t// first try to check if the page can be rendered:\n+\t\tif (!isActionAuthorized(RENDER))\n \t\t{\n-\t\t\treturn \"[Page class = \" + getClass().getName() + \", id = \" + getId() + \n-\t\t\t\t\", version = \" + versionManager.getCurrentVersionNumber()  + \", ajax = \" + \n-\t\t\t\tversionManager.getAjaxVersionNumber() + \"]\";\t\n-\t\t}\n-\t\telse\n+\t\t\tif (log.isDebugEnabled())\n \t\t\t{\n-\t\t\treturn \"[Page class = \" + getClass().getName() + \", id = \" + getId() + \", version = \" + 0 + \"]\";\n+\t\t\t\tlog.debug(\"Page not allowed to render: \" + this);\n \t\t\t}\n+\t\t\tthrow new UnauthorizedActionException(this, Component.RENDER);\n \t\t}\n \n-\t/**\n-\t * Set-up response with appropriate content type, locale and encoding. The\n-\t * locale is set equal to the session's locale. The content type header\n-\t * contains information about the markup type (@see #getMarkupType()) and\n-\t * the encoding. The response (and request) encoding is determined by an\n-\t * application setting (@see\n-\t * ApplicationSettings#getResponseRequestEncoding()). In addition, if the\n-\t * page's markup contains a xml declaration like &lt?xml ... ?&gt; an xml\n-\t * declaration with proper encoding information is written to the output as\n-\t * well, provided it is not disabled by an applicaton setting (@see\n-\t * ApplicationSettings#getStripXmlDeclarationFromOutput()).\n-\t * <p>\n-\t * Note: Prior to Wicket 1.1 the output encoding was determined by the\n-\t * page's markup encoding. Because this caused uncertainties about the\n-\t * /request/ encoding, it has been changed in favour of the new, much safer,\n-\t * approach. Please see the Wiki for more details.\n-\t */\n-\tprotected void configureResponse()\n-\t{\n-\t\t// Get the response and application\n-\t\tfinal RequestCycle cycle = getRequestCycle();\n-\t\tfinal Application application = cycle.getApplication();\n-\t\tfinal Response response = cycle.getResponse();\n+\t\t// Make sure it is really empty\n+\t\trenderedComponents = null;\n \n-\t\t// Determine encoding\n-\t\tfinal String encoding = application.getRequestCycleSettings().getResponseRequestEncoding();\n+\t\t// Reset it to stateless so that it can be tested again\n+\t\tthis.stateless = null;\n \n-\t\t// Set content type based on markup type for page\n-\t\tresponse.setContentType(\"text/\" + getMarkupType() + \"; charset=\" + encoding);\n+\t\t// Set form component values from cookies\n+\t\tsetFormComponentValuesFromCookies();\n \n-\t\t// Write out an xml declaration if the markup stream and settings allow\n-\t\tfinal MarkupStream markupStream = findMarkupStream();\n-\t\tif ((markupStream != null) && (markupStream.getXmlDeclaration() != null)\n-\t\t\t\t&& (application.getMarkupSettings().getStripXmlDeclarationFromOutput() == false))\n+\t\t// First, give priority to IFeedback instances, as they have to\n+\t\t// collect their messages before components like ListViews\n+\t\t// remove any child components\n+\t\tvisitChildren(IFeedback.class, new IVisitor()\n \t\t{\n-\t\t\tresponse.write(\"<?xml version='1.0' encoding='\");\n-\t\t\tresponse.write(encoding);\n-\t\t\tresponse.write(\"'?>\");\n-\t\t}\n-\n-\t\t// Set response locale from session locale\n-\t\tresponse.setLocale(getSession().getLocale());\n+\t\t\tpublic Object component(Component component)\n+\t\t\t{\n+\t\t\t\t((IFeedback)component).updateFeedback();\n+\t\t\t\tcomponent.attach();\n+\t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL;\n \t\t\t}\n+\t\t});\n \n-\t/**\n-\t * @see wicket.Component#onDetach()\n-\t */\n-\tprotected void onDetach()\n-\t{\n-\t\tif (log.isDebugEnabled())\n+\t\tif (this instanceof IFeedback)\n \t\t{\n-\t\t\tlog.debug(\"ending request for page \" + this + \", request \" + getRequest());\n+\t\t\t((IFeedback)this).updateFeedback();\n \t\t}\n \n-\t\tendVersion();\n+\t\t// Now, do the initialization for the other components\n+\t\tattach();\n \n-\t\tsuper.onDetach();\n-\t}\n+\t\t// Visit all this page's children to reset markup streams and check\n+\t\t// rendering authorization, as appropriate. We set any result; positive\n+\t\t// or negative as a temporary boolean in the components, and when a\n+\t\t// authorization exception is thrown it will block the rendering of this\n+\t\t// page\n \n-\t/**\n-\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\n-\t * OVERRIDE.\n-\t * \n-\t * @see wicket.Component#internalOnModelChanged()\n-\t */\n-\tprotected final void internalOnModelChanged()\n-\t{\n-\t\tvisitChildren(new Component.IVisitor()\n+\t\t// first the page itself\n+\t\tsetRenderAllowed(isActionAuthorized(RENDER));\n+\t\t// children of the page\n+\t\tvisitChildren(new IVisitor()\n \t\t{\n \t\t\tpublic Object component(final Component component)\n \t\t\t{\n-\t\t\t\t// If form component is using form model\n-\t\t\t\tif (component.sameRootModel(Page.this))\n-\t\t\t\t{\n-\t\t\t\t\tcomponent.modelChanged();\n-\t\t\t\t}\n+\t\t\t\t// Find out if this component can be rendered\n+\t\t\t\tfinal boolean renderAllowed = component.isActionAuthorized(RENDER);\n+\n+\t\t\t\t// Authorize rendering\n+\t\t\t\tcomponent.setRenderAllowed(renderAllowed);\n \t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL;\n \t\t\t}\n \t\t});\n-\t}\n \n-\t/**\n-\t * @return Factory method that creates a version manager for this Page\n-\t */\n-\tprotected final IPageVersionManager newVersionManager()\n-\t{\n-\t\treturn null;\n-\t}\n-\n-\t/**\n-\t * Renders this container to the given response object.\n-\t * \n-\t * @param markupStream\n-\t */\n-\tprotected void onRender(final MarkupStream markupStream)\n-\t{\n-\t\t// Set page's associated markup stream\n-\t\tfinal MarkupStream associatedMarkupStream = getAssociatedMarkupStream(true);\n-\t\tsetMarkupStream(associatedMarkupStream);\n-\n-\t\t// Configure response object with locale and content type\n-\t\tconfigureResponse();\n-\n-\t\t// Render all the page's markup\n-\t\tsetFlag(FLAG_IS_RENDERING, true);\n-\t\ttry\n-\t\t{\n-\t\t\trenderAll(associatedMarkupStream);\n-\t\t}\n-\t\tfinally\n-\t\t{\n-\t\t\tsetFlag(FLAG_IS_RENDERING, false);\n-\t\t}\n-\t}\n+\t\t// Handle request by rendering page\n+\t\trender(null);\n \n-\t/**\n-\t * A component was added.\n-\t * \n-\t * @param component\n-\t *            The component that was added\n-\t */\n-\tfinal void componentAdded(final Component component)\n-\t{\n-\t\tcheckHierarchyChange(component);\n+\t\t// Check rendering if it happened fully\n+\t\tcheckRendering(this);\n \n-\t\tdirty();\n-\t\tif (mayTrackChangesFor(component, component.getParent()))\n+\t\tif (!isPageStateless())\n \t\t{\n-\t\t\tversionManager.componentAdded(component);\n+\t\t\t// trigger creation of the actual session in case it was deferred\n+\t\t\tSession.get().getSessionStore().getSessionId(RequestCycle.get().getRequest(), true);\n+\t\t\t// Add/touch the response page in the session (its pagemap).\n+\t\t\tgetSession().touch(this);\n \t\t}\n \t}\n \n \t/**\n-\t * A component's model changed.\n+\t * This returns a page instance that is rollbacked the number of versions\n+\t * that is specified compared to the current page.\n \t * \n-\t * @param component\n-\t *            The component whose model is about to change\n-\t */\n-\tfinal void componentModelChanging(final Component component)\n-\t{\n-\t\tcheckHierarchyChange(component);\n-\n-\t\tdirty();\n-\t\tif (mayTrackChangesFor(component, null))\n-\t\t{\n-\t\t\tversionManager.componentModelChanging(component);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * A component was removed.\n+\t * This is a rollback including ajax versions.\n \t * \n-\t * @param component\n-\t *            The component that was removed\n+\t * @param numberOfVersions\n+\t *            to rollback\n+\t * @return\n \t */\n-\tfinal void componentRemoved(final Component component)\n-\t{\n-\t\tcheckHierarchyChange(component);\n-\n-\t\tdirty();\n-\t\tif (mayTrackChangesFor(component, component.getParent()))\n+\tpublic final Page rollbackPage(int numberOfVersions)\n \t{\n-\t\t\tversionManager.componentRemoved(component);\n-\t\t}\n+\t\tPage page = versionManager == null ? this : versionManager.rollbackPage(numberOfVersions);\n+\t\tgetSession().touch(page);\n+\t\treturn page;\n \t}\n \n \t/**\n-\t * Adds a component to the set of rendered components.\n+\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL.\n \t * \n-\t * @param component\n-\t *            The component that was rendered\n-\t */\n-\tpublic final void componentRendered(final Component component)\n-\t{\n-\t\t// Inform the page that this component rendered\n-\t\tif (Application.get().getDebugSettings().getComponentUseCheck())\n-\t\t{\n-\t\t\tif (renderedComponents == null)\n-\t\t\t{\n-\t\t\t\trenderedComponents = new HashSet();\n-\t\t\t}\n-\t\t\tif (renderedComponents.add(component) == false)\n-\t\t\t{\n-\t\t\t\tthrow new MarkupException(\n-\t\t\t\t\t\t\"The component \"\n-\t\t\t\t\t\t\t\t+ component\n-\t\t\t\t\t\t\t\t+ \" has the same wicket:id as another component already added at the same level\");\n-\t\t\t}\n-\t\t\tif (log.isDebugEnabled())\n-\t\t\t{\n-\t\t\t\tlog.debug(\"Rendered \" + component);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tfinal void componentStateChanging(final Component component, Change change)\n-\t{\n-\t\tcheckHierarchyChange(component);\n-\n-\t\tdirty();\n-\t\tif (mayTrackChangesFor(component, null))\n-\t\t{\n-\t\t\tversionManager.componentStateChanging(change);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Sets values for form components based on cookie values in the request.\n+\t * Set the id for this Page. This method is called by PageMap when a Page is\n+\t * added because the id, which is assigned by PageMap, is not known until\n+\t * this time.\n \t * \n+\t * @param id\n+\t *            The id\n \t */\n-\tfinal void setFormComponentValuesFromCookies()\n-\t{\n-\t\t// Visit all Forms contained in the page\n-\t\tvisitChildren(Form.class, new Component.IVisitor()\n-\t\t{\n-\t\t\t// For each FormComponent found on the Page (not Form)\n-\t\t\tpublic Object component(final Component component)\n-\t\t\t{\n-\t\t\t\t((Form)component).loadPersistentFormComponentValues();\n-\t\t\t\treturn CONTINUE_TRAVERSAL;\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t/**\n-\t * @param pageMap\n-\t *            Sets this page into the page map with the given name. If the\n-\t *            page map does not yet exist, it is automatically created.\n-\t */\n-\tfinal void setPageMap(final IPageMap pageMap)\n+\tpublic final void setNumericId(final int id)\n \t{\n-\t\t// Save transient reference to pagemap\n-\t\tthis.pageMap = pageMap;\n-\n-\t\t// Save name for restoring transient\n-\t\tthis.pageMapName = pageMap.getName();\n+\t\tthis.numericId = (short)id;\n \t}\n \n \t/**\n@@ -1131,21 +889,37 @@ public final void setStatelessHint(boolean value)\n \t}\n \n \t/**\n-\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\n-\t * OVERRIDE.\n+\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL.\n+\t * \n+\t * This method is called when a component will be rendered standalone.\n+\t * \n+\t * @param component\n \t * \n-\t * @param map\n \t */\n-\tprotected final void moveToPageMap(IPageMap map)\n+\tpublic final void startComponentRender(Component component)\n \t{\n-\t\t// TODO post 1.2 shouldn't we remove this page from the pagemap/session\n-\t\t// if it would be in there?\n-\t\t// This should be done if the page was not cloned first, but shouldn't\n-\t\t// be done if it was cloned..\n-\t\tsetPageMap(map);\n-\t\tnumericId = (short)map.nextId();\n+\t\trenderedComponents = null;\n \t}\n \n+\t/**\n+\t * Get the string representation of this container.\n+\t * \n+\t * @return String representation of this container\n+\t */\n+\tpublic String toString()\n+\t{\n+\t\tif (versionManager != null)\n+\t\t{\n+\t\t\treturn \"[Page class = \" + getClass().getName() + \", id = \" + getId() + \", version = \"\n+\t\t\t\t\t+ versionManager.getCurrentVersionNumber() + \", ajax = \"\n+\t\t\t\t\t+ versionManager.getAjaxVersionNumber() + \"]\";\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\treturn \"[Page class = \" + getClass().getName() + \", id = \" + getId() + \", version = \"\n+\t\t\t\t\t+ 0 + \"]\";\n+\t\t}\n+\t}\n \n \t/**\n \t * Checks whether the hierarchy may be changed at all, and throws an\n@@ -1362,24 +1136,238 @@ private final boolean mayTrackChangesFor(final Component component, MarkupContai\n \t}\n \n \t/**\n-\t * Call this method when the current (ajax) request shouldn't merge \n-\t * the changes that are happening to the page with the previous version. \n+\t * Set-up response with appropriate content type, locale and encoding. The\n+\t * locale is set equal to the session's locale. The content type header\n+\t * contains information about the markup type (@see #getMarkupType()) and\n+\t * the encoding. The response (and request) encoding is determined by an\n+\t * application setting (@see\n+\t * ApplicationSettings#getResponseRequestEncoding()). In addition, if the\n+\t * page's markup contains a xml declaration like &lt?xml ... ?&gt; an xml\n+\t * declaration with proper encoding information is written to the output as\n+\t * well, provided it is not disabled by an applicaton setting (@see\n+\t * ApplicationSettings#getStripXmlDeclarationFromOutput()).\n+\t * <p>\n+\t * Note: Prior to Wicket 1.1 the output encoding was determined by the\n+\t * page's markup encoding. Because this caused uncertainties about the\n+\t * /request/ encoding, it has been changed in favour of the new, much safer,\n+\t * approach. Please see the Wiki for more details.\n+\t */\n+\tprotected void configureResponse()\n+\t{\n+\t\t// Get the response and application\n+\t\tfinal RequestCycle cycle = getRequestCycle();\n+\t\tfinal Application application = cycle.getApplication();\n+\t\tfinal Response response = cycle.getResponse();\n+\n+\t\t// Determine encoding\n+\t\tfinal String encoding = application.getRequestCycleSettings().getResponseRequestEncoding();\n+\n+\t\t// Set content type based on markup type for page\n+\t\tresponse.setContentType(\"text/\" + getMarkupType() + \"; charset=\" + encoding);\n+\n+\t\t// Write out an xml declaration if the markup stream and settings allow\n+\t\tfinal MarkupStream markupStream = findMarkupStream();\n+\t\tif ((markupStream != null) && (markupStream.getXmlDeclaration() != null)\n+\t\t\t\t&& (application.getMarkupSettings().getStripXmlDeclarationFromOutput() == false))\n+\t\t{\n+\t\t\tresponse.write(\"<?xml version='1.0' encoding='\");\n+\t\t\tresponse.write(encoding);\n+\t\t\tresponse.write(\"'?>\");\n+\t\t}\n+\n+\t\t// Set response locale from session locale\n+\t\tresponse.setLocale(getSession().getLocale());\n+\t}\n+\n+\t/**\n+\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\n+\t * OVERRIDE.\n+\t * \n+\t * @see wicket.Component#internalOnModelChanged()\n+\t */\n+\tprotected final void internalOnModelChanged()\n+\t{\n+\t\tvisitChildren(new Component.IVisitor()\n+\t\t{\n+\t\t\tpublic Object component(final Component component)\n+\t\t\t{\n+\t\t\t\t// If form component is using form model\n+\t\t\t\tif (component.sameRootModel(Page.this))\n+\t\t\t\t{\n+\t\t\t\t\tcomponent.modelChanged();\n+\t\t\t\t}\n+\t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL;\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\n+\t * OVERRIDE.\n \t * \n-\t * This is for example needed when you want to redirect to this \n-\t * page in an ajax request and then you do want to version normally.. \n+\t * @param map\n+\t */\n+\tprotected final void moveToPageMap(IPageMap map)\n+\t{\n+\t\t// TODO post 1.2 shouldn't we remove this page from the pagemap/session\n+\t\t// if it would be in there?\n+\t\t// This should be done if the page was not cloned first, but shouldn't\n+\t\t// be done if it was cloned..\n+\t\tsetPageMap(map);\n+\t\tnumericId = (short)map.nextId();\n+\t}\n+\n+\t/**\n+\t * @return Factory method that creates a version manager for this Page\n+\t */\n+\tprotected final IPageVersionManager newVersionManager()\n+\t{\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * @see wicket.Component#onDetach()\n+\t */\n+\tprotected void onDetach()\n+\t{\n+\t\tif (log.isDebugEnabled())\n+\t\t{\n+\t\t\tlog.debug(\"ending request for page \" + this + \", request \" + getRequest());\n+\t\t}\n+\n+\t\tendVersion();\n+\n+\t\tsuper.onDetach();\n+\t}\n+\n+\t/**\n+\t * Renders this container to the given response object.\n \t * \n-\t * This method doesn't do anything if the getRequest().mergeVersion\n-\t * doesn't return true.\n+\t * @param markupStream\n \t */\n-\tpublic final void ignoreVersionMerge()\n+\tprotected void onRender(final MarkupStream markupStream)\n \t{\n-\t\tif (getRequest().mergeVersion())\n+\t\t// Set page's associated markup stream\n+\t\tfinal MarkupStream associatedMarkupStream = getAssociatedMarkupStream(true);\n+\t\tsetMarkupStream(associatedMarkupStream);\n+\n+\t\t// Configure response object with locale and content type\n+\t\tconfigureResponse();\n+\n+\t\t// Render all the page's markup\n+\t\tsetFlag(FLAG_IS_RENDERING, true);\n+\t\ttry\n \t\t{\n-\t\t\tmayTrackChangesFor(this, null);\n-\t\t\tif (versionManager != null)\n+\t\t\trenderAll(associatedMarkupStream);\n+\t\t}\n+\t\tfinally\n \t\t{\n-\t\t\t\tversionManager.ignoreVersionMerge();\n+\t\t\tsetFlag(FLAG_IS_RENDERING, false);\n \t\t}\n \t}\n+\n+\n+\t/**\n+\t * A component was added.\n+\t * \n+\t * @param component\n+\t *            The component that was added\n+\t */\n+\tfinal void componentAdded(final Component component)\n+\t{\n+\t\tcheckHierarchyChange(component);\n+\n+\t\tdirty();\n+\t\tif (mayTrackChangesFor(component, component.getParent()))\n+\t\t{\n+\t\t\tversionManager.componentAdded(component);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A component's model changed.\n+\t * \n+\t * @param component\n+\t *            The component whose model is about to change\n+\t */\n+\tfinal void componentModelChanging(final Component component)\n+\t{\n+\t\tcheckHierarchyChange(component);\n+\n+\t\tdirty();\n+\t\tif (mayTrackChangesFor(component, null))\n+\t\t{\n+\t\t\tversionManager.componentModelChanging(component);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A component was removed.\n+\t * \n+\t * @param component\n+\t *            The component that was removed\n+\t */\n+\tfinal void componentRemoved(final Component component)\n+\t{\n+\t\tcheckHierarchyChange(component);\n+\n+\t\tdirty();\n+\t\tif (mayTrackChangesFor(component, component.getParent()))\n+\t\t{\n+\t\t\tversionManager.componentRemoved(component);\n+\t\t}\n+\t}\n+\n+\tfinal void componentStateChanging(final Component component, Change change)\n+\t{\n+\t\tcheckHierarchyChange(component);\n+\n+\t\tdirty();\n+\t\tif (mayTrackChangesFor(component, null))\n+\t\t{\n+\t\t\tversionManager.componentStateChanging(change);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets values for form components based on cookie values in the request.\n+\t * \n+\t */\n+\tfinal void setFormComponentValuesFromCookies()\n+\t{\n+\t\t// Visit all Forms contained in the page\n+\t\tvisitChildren(Form.class, new Component.IVisitor()\n+\t\t{\n+\t\t\t// For each FormComponent found on the Page (not Form)\n+\t\t\tpublic Object component(final Component component)\n+\t\t\t{\n+\t\t\t\t((Form)component).loadPersistentFormComponentValues();\n+\t\t\t\treturn CONTINUE_TRAVERSAL;\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * @param pageMap\n+\t *            Sets this page into the page map with the given name. If the\n+\t *            page map does not yet exist, it is automatically created.\n+\t */\n+\tfinal void setPageMap(final IPageMap pageMap)\n+\t{\n+\t\t// Save transient reference to pagemap\n+\t\tthis.pageMap = pageMap;\n+\n+\t\t// Save name for restoring transient\n+\t\tthis.pageMapName = pageMap.getName();\n+\t}\n+\n+\t/**\n+\t * Set page stateless\n+\t * \n+\t * @param stateless\n+\t */\n+\tvoid setPageStateless(Boolean stateless)\n+\t{\n+\t\tthis.stateless = stateless;\n \t}\n }\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/RequestCycle.java b/jdk-1.4/wicket/src/main/java/wicket/RequestCycle.java\nindex 9db2282ea3..b8e00a5dd4 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/RequestCycle.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/RequestCycle.java\n@@ -886,7 +886,7 @@ private void detach()\n \t\t// remove any rendered feedback messages from the session\n \t\ttry\n \t\t{\n-\t\t\tsession.cleanupFeedbackMessages();\n+\t\t\tsession.cleanupRenderedFeedbackMessages();\n \t\t}\n \t\tcatch (RuntimeException re)\n \t\t{\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/Session.java b/jdk-1.4/wicket/src/main/java/wicket/Session.java\nindex ae82d317c2..0e88aeda05 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/Session.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/Session.java\n@@ -37,7 +37,6 @@\n import wicket.feedback.FeedbackMessages;\n import wicket.request.ClientInfo;\n import wicket.session.ISessionStore;\n-import wicket.util.concurrent.CopyOnWriteArrayList;\n import wicket.util.convert.IConverter;\n import wicket.util.lang.Objects;\n import wicket.util.string.Strings;\n@@ -199,7 +198,7 @@ public boolean add(IPageMap pagemap)\n \tprivate String style;\n \n \t/** feedback messages */\n-\tprivate FeedbackMessages feedbackMessages = new FeedbackMessages(new CopyOnWriteArrayList());\n+\tprivate FeedbackMessages feedbackMessages = new FeedbackMessages();\n \n \tprivate transient Map pageMapsUsedInRequest;\n \n@@ -1133,7 +1132,7 @@ else if (object instanceof IPageMap)\n \t * Removes any rendered feedback messages as well as compacts memory. This\n \t * method is usually called at the end of the request cycle processing.\n \t */\n-\tfinal void cleanupFeedbackMessages()\n+\tfinal void cleanupRenderedFeedbackMessages()\n \t{\n \t\tint size = feedbackMessages.size();\n \t\tfeedbackMessages.clearRendered();\n@@ -1145,6 +1144,26 @@ final void cleanupFeedbackMessages()\n \t\t}\n \t}\n \n+\t/**\n+\t * Cleans up any unrendered, dangling feedback messages there may be. This\n+\t * implementation calls {@link FeedbackMessages#clearComponentSpecific()} to\n+\t * aggresively ensure there won't be memory leaks. Clients can override this\n+\t * method to e.g. call {@link FeedbackMessages#clearPageSpecific(Page)}.\n+\t * <p>\n+\t * This method should be called from by the framework right before a even\n+\t * handler is called. There is no need for clients to call this method\n+\t * directly\n+\t * </p>\n+\t * \n+\t * @param page\n+\t *            any current page (the page on which the event handler is that\n+\t *            is about to be processed)\n+\t */\n+\tpublic void cleanupFeedbackMessages(Page page)\n+\t{\n+\t\tfeedbackMessages.clearComponentSpecific();\n+\t}\n+\n \t/**\n \t * @param page\n \t *            The page to add to dirty objects list\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessages.java b/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessages.java\nindex 7da26624b4..719e1773e0 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessages.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessages.java\n@@ -27,6 +27,7 @@\n \n import wicket.Component;\n import wicket.IClusterable;\n+import wicket.Page;\n import wicket.util.concurrent.CopyOnWriteArrayList;\n import wicket.util.string.StringList;\n \n@@ -58,24 +59,37 @@\n \t */\n \tpublic FeedbackMessages()\n \t{\n-\t\tmessages = new ArrayList();\n+\t\tmessages = new CopyOnWriteArrayList();\n \t}\n \n \t/**\n-\t * Call this constructor if you want to replace the internal\n-\t * store with another implemention then the default (ArrayList). \n-\t * This could be a {@link CopyOnWriteArrayList} if this feedbackmessages \n-\t * instance is used by multiply threads.\n+\t * Call this constructor if you want to replace the internal store with\n+\t * another implemention then the default (ArrayList). This could be a\n+\t * {@link CopyOnWriteArrayList} if this feedbackmessages instance is used by\n+\t * multiply threads.\n \t * \n \t * @param messagesList\n \t * \n \t */\n \tpublic FeedbackMessages(List messagesList)\n \t{\n-\t\tif(messagesList == null) throw new IllegalArgumentException(\"messages list can't be null\");\n+\t\tif (messagesList == null)\n+\t\t\tthrow new IllegalArgumentException(\"messages list can't be null\");\n \t\tmessages = messagesList;\n \t}\n \n+\t/**\n+\t * Adds a message\n+\t * \n+\t * @param reporter\n+\t * @param message\n+\t * @param level\n+\t */\n+\tpublic final void add(Component reporter, String message, int level)\n+\t{\n+\t\tadd(new FeedbackMessage(reporter, message, level));\n+\t}\n+\n \t/**\n \t * Clears any existing messages\n \t */\n@@ -85,13 +99,50 @@ public final void clear()\n \t}\n \n \t/**\n-\t * Gets the number of messages\n+\t * Clears any messages specifically for components. This is an aggressive\n+\t * cleanup to ensure there won't be a memory leak in session.\n+\t */\n+\tpublic final void clearComponentSpecific()\n+\t{\n+\t\tfor (int i = messages.size() - 1; i >= 0; i--)\n+\t\t{\n+\t\t\tfinal FeedbackMessage msg = (FeedbackMessage)messages.get(i);\n+\t\t\tComponent reporter = msg.getReporter();\n+\t\t\tif (reporter != null)\n+\t\t\t{\n+\t\t\t\tmessages.remove(i);\n+\t\t\t}\n+\t\t}\n+\t\ttrimToSize();\n+\t}\n+\n+\t/**\n+\t * Clears any messages specifically for components on the provided page.\n \t * \n-\t * @return the number of messages\n+\t * @param page\n+\t *            The page to clear messages for\n \t */\n-\tpublic final int size()\n+\tpublic final void clearPageSpecific(Page page)\n \t{\n-\t\treturn messages.size();\n+\t\tif (page == null)\n+\t\t{\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfor (int i = messages.size() - 1; i >= 0; i--)\n+\t\t{\n+\t\t\tfinal FeedbackMessage msg = (FeedbackMessage)messages.get(i);\n+\t\t\tComponent reporter = msg.getReporter();\n+\t\t\tif (reporter != null)\n+\t\t\t{\n+\t\t\t\tPage reporterPage = (Page)reporter.findParent(Page.class);\n+\t\t\t\tif (reporterPage != null && reporterPage.equals(page))\n+\t\t\t\t{\n+\t\t\t\t\tmessages.remove(i);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\ttrimToSize();\n \t}\n \n \t/**\n@@ -225,6 +276,16 @@ public final boolean isEmpty()\n \t\treturn messages.isEmpty();\n \t}\n \n+\t/**\n+\t * Gets an iterator over stored messages\n+\t * \n+\t * @return iterator over stored messages\n+\t */\n+\tpublic final Iterator iterator()\n+\t{\n+\t\treturn messages.iterator();\n+\t}\n+\n \t/**\n \t * Looks up a message for the given component.\n \t * \n@@ -274,6 +335,16 @@ public final List messages(final IFeedbackMessageFilter filter)\n \t\t}\n \t}\n \n+\t/**\n+\t * Gets the number of messages\n+\t * \n+\t * @return the number of messages\n+\t */\n+\tpublic final int size()\n+\t{\n+\t\treturn messages.size();\n+\t}\n+\n \t/**\n \t * @see java.lang.Object#toString()\n \t */\n@@ -282,6 +353,17 @@ public String toString()\n \t\treturn \"[feedbackMessages = \" + StringList.valueOf(messages) + \"]\";\n \t}\n \n+\t/**\n+\t * Frees any unnecessary internal storage\n+\t */\n+\tpublic final void trimToSize()\n+\t{\n+\t\tif (messages instanceof ArrayList)\n+\t\t{\n+\t\t\t((ArrayList)messages).trimToSize();\n+\t\t}\n+\t}\n+\n \t/**\n \t * Adds a new ui message with level WARNING to the current messages.\n \t * \n@@ -295,16 +377,6 @@ public final void warn(Component reporter, String message)\n \t\tadd(new FeedbackMessage(reporter, message, FeedbackMessage.WARNING));\n \t}\n \n-\t/**\n-\t * Adds a message\n-\t * @param reporter\n-\t * @param message\n-\t * @param level\n-\t */\n-\tpublic final void add(Component reporter, String message, int level) {\n-\t\tadd(new FeedbackMessage(reporter, message, level));\n-\t}\n-\t\n \t/**\n \t * Adds a message.\n \t * \n@@ -319,25 +391,4 @@ final void add(FeedbackMessage message)\n \t\t}\n \t\tmessages.add(message);\n \t}\n-\n-\t/**\n-\t * Gets an iterator over stored messages\n-\t * \n-\t * @return iterator over stored messages\n-\t */\n-\tpublic final Iterator iterator()\n-\t{\n-\t\treturn messages.iterator();\n-\t}\n-\n-\t/**\n-\t * Frees any unnecessary internal storage\n-\t */\n-\tpublic final void trimToSize()\n-\t{\n-\t\tif(messages instanceof ArrayList)\n-\t\t{\n-\t\t\t((ArrayList)messages).trimToSize();\n-\t\t}\n-\t}\n }\n\\ No newline at end of file\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessagesModel.java b/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessagesModel.java\nindex 7b5230021d..82f39b27c9 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessagesModel.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessagesModel.java\n@@ -17,13 +17,13 @@\n package wicket.feedback;\n \n import java.io.Serializable;\n-import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.List;\n \n import wicket.Component;\n import wicket.Page;\n+import wicket.Session;\n import wicket.model.IModel;\n \n /**\n@@ -51,8 +51,9 @@\n \t * Constructor. Creates a model for all feedback messages on the page.\n \t * \n \t * @param component\n-\t *            The component where the page will be get from for which messages will be displayed \n-\t *            usually the same page as the one feedbackpanel is attached to\n+\t *            The component where the page will be get from for which\n+\t *            messages will be displayed usually the same page as the one\n+\t *            feedbackpanel is attached to\n \t */\n \tpublic FeedbackMessagesModel(Component component)\n \t{\n@@ -104,13 +105,7 @@ public final Object getObject()\n \t\tif (messages == null)\n \t\t{\n \t\t\t// Get filtered messages from page where component lives\n-\t\t\tList pageMessages = component.getPage().getFeedbackMessages().messages(filter);\n-\n-\t\t\tList sessionMessages = component.getSession().getFeedbackMessages().messages(filter);\n-\n-\t\t\tmessages = new ArrayList(pageMessages.size() + sessionMessages.size());\n-\t\t\tmessages.addAll(pageMessages);\n-\t\t\tmessages.addAll(sessionMessages);\n+\t\t\tmessages = Session.get().getFeedbackMessages().messages(filter);\n \n \t\t\t// Sort the list before returning it\n \t\t\tif (sortingComparator != null)\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackBorder.java b/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackBorder.java\nindex 2198c9e197..5d4f34a3e9 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackBorder.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackBorder.java\n@@ -16,6 +16,7 @@\n  */\n package wicket.markup.html.form.validation;\n \n+import wicket.Session;\n import wicket.feedback.ContainerFeedbackMessageFilter;\n import wicket.feedback.IFeedback;\n import wicket.feedback.IFeedbackMessageFilter;\n@@ -87,7 +88,7 @@ public FormComponentFeedbackBorder(final String id)\n \tpublic void updateFeedback()\n \t{\n \t\t// Get the messages for the current page\n-\t\tvisible = getPage().getFeedbackMessages().messages(getMessagesFilter()).size() != 0;\n+\t\tvisible = Session.get().getFeedbackMessages().messages(getMessagesFilter()).size() != 0;\n \t}\n \n \t/**\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackIndicator.java b/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackIndicator.java\nindex 06531811d2..bb76fee177 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackIndicator.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackIndicator.java\n@@ -17,6 +17,7 @@\n package wicket.markup.html.form.validation;\n \n import wicket.Component;\n+import wicket.Session;\n import wicket.feedback.ComponentFeedbackMessageFilter;\n import wicket.feedback.IFeedback;\n import wicket.feedback.IFeedbackMessageFilter;\n@@ -74,7 +75,7 @@ public void setIndicatorFor(final Component component)\n \tpublic void updateFeedback()\n \t{\n \t\t// Get the messages for the current page\n-\t\tsetVisible(getPage().getFeedbackMessages().hasMessage(getFeedbackMessageFilter()));\n+\t\tsetVisible(Session.get().getFeedbackMessages().hasMessage(getFeedbackMessageFilter()));\n \t}\n \n \t/**\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/request/target/component/listener/AbstractListenerInterfaceRequestTarget.java b/jdk-1.4/wicket/src/main/java/wicket/request/target/component/listener/AbstractListenerInterfaceRequestTarget.java\nindex 7d8fb92767..ed88751140 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/request/target/component/listener/AbstractListenerInterfaceRequestTarget.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/request/target/component/listener/AbstractListenerInterfaceRequestTarget.java\n@@ -21,6 +21,7 @@\n import wicket.Page;\n import wicket.RequestCycle;\n import wicket.RequestListenerInterface;\n+import wicket.Session;\n import wicket.request.RequestParameters;\n import wicket.request.target.IEventProcessor;\n import wicket.request.target.component.PageRequestTarget;\n@@ -189,7 +190,7 @@ protected void onProcessEvents(final RequestCycle requestCycle)\n \t\trequestCycle.setUpdateSession(true);\n \n \t\t// Clear all feedback messages if it isn't a redirect\n-\t\tgetPage().getFeedbackMessages().clear();\n+\t\tSession.get().cleanupFeedbackMessages(getPage());\n \n \t\tgetPage().startComponentRender(getTarget());\n \n",
        "project": "wicket",
        "linesAdd": 318,
        "jira_id": "442",
        "nb_skipped": 0,
        "commit": "246d53c5",
        "nb_failure": 3,
        "linesRem": 286,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 50,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.extensions.markup.html.tabs.TabbedPanelVisibilityTest"
        ],
        "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/tabs/TabbedPanel.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/tabs/TabbedPanel.java\nindex 10be55dc91..f70ef2bb3c 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/tabs/TabbedPanel.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/tabs/TabbedPanel.java\n@@ -84,7 +84,7 @@\n \t/** the current tab */\n \tprivate int currentTab = -1;\n \n-\tprivate transient Boolean[] tabsVisibilityCache;\n+\tprivate transient VisibilityCache visibilityCache;\n \n \t/**\n \t * Constructor\n@@ -203,6 +203,14 @@ protected LoopItem newTabContainer(final int tabIndex)\n \t\t{\n \t\t\tprivate static final long serialVersionUID = 1L;\n \n+\t\t\t@Override\n+\t\t\tprotected void onConfigure()\n+\t\t\t{\n+\t\t\t\tsuper.onConfigure();\n+\n+\t\t\t\tsetVisible(getVisiblityCache().isVisible(tabIndex));\n+\t\t\t}\n+\n \t\t\t@Override\n \t\t\tprotected void onComponentTag(final ComponentTag tag)\n \t\t\t{\n@@ -218,18 +227,12 @@ protected void onComponentTag(final ComponentTag tag)\n \t\t\t\t{\n \t\t\t\t\tcssClass += ' ' + getSelectedTabCssClass();\n \t\t\t\t}\n-\t\t\t\tif (getIndex() == getTabs().size() - 1)\n+\t\t\t\tif (getVisiblityCache().getLastVisible() == getIndex())\n \t\t\t\t{\n \t\t\t\t\tcssClass += ' ' + getLastTabCssClass();\n \t\t\t\t}\n \t\t\t\ttag.put(\"class\", cssClass.trim());\n \t\t\t}\n-\n-\t\t\t@Override\n-\t\t\tpublic boolean isVisible()\n-\t\t\t{\n-\t\t\t\treturn getTabs().get(tabIndex).isVisible();\n-\t\t\t}\n \t\t};\n \t}\n \n@@ -238,13 +241,13 @@ protected void onBeforeRender()\n \t{\n \t\tint index = getSelectedTab();\n \n-\t\tif ((index == -1) || (isTabVisible(index) == false))\n+\t\tif ((index == -1) || (getVisiblityCache().isVisible(index) == false))\n \t\t{\n \t\t\t// find first visible tab\n \t\t\tindex = -1;\n \t\t\tfor (int i = 0; i < tabs.size(); i++)\n \t\t\t{\n-\t\t\t\tif (isTabVisible(i))\n+\t\t\t\tif (getVisiblityCache().isVisible(i))\n \t\t\t\t{\n \t\t\t\t\tindex = i;\n \t\t\t\t\tbreak;\n@@ -253,9 +256,7 @@ protected void onBeforeRender()\n \n \t\t\tif (index != -1)\n \t\t\t{\n-\t\t\t\t/*\n-\t\t\t\t * found a visible tab, so select it\n-\t\t\t\t */\n+\t\t\t\t// found a visible tab, so select it\n \t\t\t\tsetSelectedTab(index);\n \t\t\t}\n \t\t}\n@@ -401,7 +402,7 @@ private void setCurrentTab(int index)\n \n \t\tfinal Component component;\n \n-\t\tif (currentTab == -1 || (tabs.size() == 0) || !isTabVisible(currentTab))\n+\t\tif (currentTab == -1 || (tabs.size() == 0) || !getVisiblityCache().isVisible(currentTab))\n \t\t{\n \t\t\t// no tabs or the current tab is not visible\n \t\t\tcomponent = newPanel();\n@@ -443,32 +444,77 @@ public final int getSelectedTab()\n \t\treturn (Integer)getDefaultModelObject();\n \t}\n \n+\t@Override\n+\tprotected void onDetach()\n+\t{\n+\t\tvisibilityCache = null;\n+\n+\t\tsuper.onDetach();\n+\t}\n+\n+\tprivate VisibilityCache getVisiblityCache()\n+\t{\n+\t\tif (visibilityCache == null)\n+\t\t{\n+\t\t\tvisibilityCache = new VisibilityCache();\n+\t\t}\n+\n+\t\treturn visibilityCache;\n+\t}\n+\n \t/**\n-\t * \n-\t * @param tabIndex\n-\t * @return visible\n+\t * A cache for visibilities of {@link ITab}s.\n \t */\n-\tprivate boolean isTabVisible(final int tabIndex)\n+\tprivate class VisibilityCache\n \t{\n-\t\tif (tabsVisibilityCache == null)\n+\n+\t\t/**\n+\t\t * Visibility for each tab.\n+\t\t */\n+\t\tprivate Boolean[] visibilities;\n+\n+\t\t/**\n+\t\t * Last visible tab.\n+\t\t */\n+\t\tprivate int lastVisible = -1;\n+\n+\t\tpublic VisibilityCache()\n \t\t{\n-\t\t\ttabsVisibilityCache = new Boolean[tabs.size()];\n+\t\t\tvisibilities = new Boolean[tabs.size()];\n \t\t}\n \n-\t\tif (tabsVisibilityCache.length < tabIndex + 1)\n+\t\tpublic int getLastVisible()\n+\t\t{\n+\t\t\tif (lastVisible == -1)\n \t\t\t{\n-\t\t\tBoolean[] resized = new Boolean[tabIndex + 1];\n-\t\t\tSystem.arraycopy(tabsVisibilityCache, 0, resized, 0, tabsVisibilityCache.length);\n-\t\t\ttabsVisibilityCache = resized;\n+\t\t\t\tfor (int t = 0; t < tabs.size(); t++)\n+\t\t\t\t{\n+\t\t\t\t\tif (isVisible(t))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tlastVisible = t;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn lastVisible;\n+\t\t}\n+\n+\t\tpublic boolean isVisible(int index)\n+\t\t{\n+\t\t\tif (visibilities.length < index + 1)\n+\t\t\t{\n+\t\t\t\tBoolean[] resized = new Boolean[index + 1];\n+\t\t\t\tSystem.arraycopy(visibilities, 0, resized, 0, visibilities.length);\n+\t\t\t\tvisibilities = resized;\n \t\t\t}\n \n-\t\tif (tabsVisibilityCache.length > 0)\n+\t\t\tif (visibilities.length > 0)\n \t\t\t{\n-\t\t\tBoolean visible = tabsVisibilityCache[tabIndex];\n+\t\t\t\tBoolean visible = visibilities[index];\n \t\t\t\tif (visible == null)\n \t\t\t\t{\n-\t\t\t\tvisible = tabs.get(tabIndex).isVisible();\n-\t\t\t\ttabsVisibilityCache[tabIndex] = visible;\n+\t\t\t\t\tvisible = tabs.get(index).isVisible();\n+\t\t\t\t\tvisibilities[index] = visible;\n \t\t\t\t}\n \t\t\t\treturn visible;\n \t\t\t}\n@@ -477,11 +523,5 @@ private boolean isTabVisible(final int tabIndex)\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n-\n-\t@Override\n-\tprotected void onDetach()\n-\t{\n-\t\ttabsVisibilityCache = null;\n-\t\tsuper.onDetach();\n \t}\n }\n\\ No newline at end of file\n",
        "project": "wicket",
        "linesAdd": 65,
        "jira_id": "4658",
        "nb_skipped": 0,
        "commit": "ef3adb12",
        "nb_failure": 1,
        "linesRem": 28,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1038,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.mapper.MountedMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractComponentMapper.java b/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractComponentMapper.java\nindex 0512fadee0..57573323c5 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractComponentMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/mapper/AbstractComponentMapper.java\n@@ -80,18 +80,24 @@ protected RequestListenerInterface requestListenerInterfaceFromString(String int\n \t * \n \t * @return PageComponentInfo instance if one was encoded in URL, <code>null</code> otherwise.\n \t */\n-\tprotected PageComponentInfo getPageComponentInfo(Url url)\n+\tprotected PageComponentInfo getPageComponentInfo(final Url url)\n \t{\n \t\tif (url == null)\n \t\t{\n \t\t\tthrow new IllegalStateException(\"Argument 'url' may not be null.\");\n \t\t}\n-\t\tif (url.getQueryParameters().size() > 0)\n+\t\telse\n \t\t{\n-\t\t\tQueryParameter param = url.getQueryParameters().get(0);\n-\t\t\tif (Strings.isEmpty(param.getValue()))\n+\t\t\tfor (QueryParameter queryParameter : url.getQueryParameters())\n \t\t\t{\n-\t\t\t\treturn PageComponentInfo.parse(param.getName());\n+\t\t\t\tif (Strings.isEmpty(queryParameter.getValue()))\n+\t\t\t\t{\n+\t\t\t\t\tPageComponentInfo pageComponentInfo = PageComponentInfo.parse(queryParameter.getName());\n+\t\t\t\t\tif (pageComponentInfo != null)\n+\t\t\t\t\t{\n+\t\t\t\t\t\treturn pageComponentInfo;\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn null;\n",
        "project": "wicket",
        "linesAdd": 11,
        "jira_id": "3272",
        "nb_skipped": 0,
        "commit": "c86b972a",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 96,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.UrlTest"
        ],
        "patch": "diff --git a/wicket-request/src/main/java/org/apache/wicket/request/Url.java b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\nindex 6aa6e2565d..5297857c17 100755\n--- a/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n+++ b/wicket-request/src/main/java/org/apache/wicket/request/Url.java\n@@ -337,15 +337,16 @@ public static Url parse(CharSequence _url, Charset charset)\n \t */\n \tprivate static QueryParameter parseQueryParameter(final String qp, final Charset charset)\n \t{\n-\t\tif (qp.indexOf('=') == -1)\n+\t\tint idxOfEquals = qp.indexOf('=');\n+\t\tif (idxOfEquals == -1)\n \t\t{\n \t\t\t// name => empty value\n \t\t\treturn new QueryParameter(decodeParameter(qp, charset), \"\");\n \t\t}\n \n-\t\tString parts[] = Strings.split(qp, '=');\n-\t\treturn new QueryParameter(decodeParameter(parts[0], charset), decodeParameter(parts[1],\n-\t\t\tcharset));\n+\t\tString parameterName = qp.substring(0, idxOfEquals);\n+\t\tString parameterValue = qp.substring(idxOfEquals + 1);\n+\t\treturn new QueryParameter(decodeParameter(parameterName, charset), decodeParameter(parameterValue, charset));\n \t}\n \n \t/**\n",
        "project": "wicket",
        "linesAdd": 5,
        "jira_id": "5157",
        "nb_skipped": 0,
        "commit": "961f2477",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1859,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.resource.locator.CachingResourceStreamLocatorTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/util/resource/locator/caching/CachingResourceStreamLocator.java b/wicket-core/src/main/java/org/apache/wicket/core/util/resource/locator/caching/CachingResourceStreamLocator.java\nindex ceeb59fec6..f9b3624320 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/util/resource/locator/caching/CachingResourceStreamLocator.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/util/resource/locator/caching/CachingResourceStreamLocator.java\n@@ -73,7 +73,7 @@ public CachingResourceStreamLocator(final IResourceStreamLocator resourceStreamL\n \t@Override\n \tpublic IResourceStream locate(Class<?> clazz, String path)\n \t{\n-\t\tCacheKey key = new CacheKey(clazz.getName(), path, null, null, null, null);\n+\t\tCacheKey key = new CacheKey(clazz.getName(), path, null, null, null, null, true);\n \t\tIResourceStreamReference resourceStreamReference = cache.get(key);\n \n \t\tfinal IResourceStream result;\n@@ -113,7 +113,7 @@ else if (stream instanceof UrlResourceStream)\n \tpublic IResourceStream locate(Class<?> scope, String path, String style, String variation,\n \t\tLocale locale, String extension, boolean strict)\n \t{\n-\t\tCacheKey key = new CacheKey(scope.getName(), path, extension, locale, style, variation);\n+\t\tCacheKey key = new CacheKey(scope.getName(), path, extension, locale, style, variation, strict);\n \t\tIResourceStreamReference resourceStreamReference = cache.get(key);\n \n \t\tfinal IResourceStream result;\n@@ -154,37 +154,54 @@ public void clearCache()\n \t */\n \tprivate static class CacheKey extends Key\n \t{\n+\t\tprivate static final long serialVersionUID = 1L;\n+\n \t\t/**\n \t\t * The file extension\n \t\t */\n \t\tprivate final String extension;\n \n-\t\tprivate CacheKey(String scope, String name, String extension, Locale locale, String style, String variation)\n+\t\t/** Whether the key was looked up using a strict matching search */\n+\t\tprivate final boolean strict;\n+\n+\t\tprivate CacheKey(String scope, String name, String extension, Locale locale, String style, String variation, boolean strict)\n \t\t{\n \t\t\tsuper(scope, name, locale, style, variation);\n \n \t\t\tthis.extension = extension;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic boolean equals(Object o)\n-\t\t{\n-\t\t\tif (this == o) return true;\n-\t\t\tif (o == null || getClass() != o.getClass()) return false;\n-\t\t\tif (!super.equals(o)) return false;\n-\n-\t\t\tCacheKey cacheKey = (CacheKey) o;\n-\n-\t\t\treturn !(extension != null ? !extension.equals(cacheKey.extension) : cacheKey.extension != null);\n-\n+\t\t\tthis.strict = strict;\n \t\t}\n \n \t\t@Override\n \t\tpublic int hashCode()\n \t\t{\n+\t\t\tfinal int prime = 31;\n \t\t\tint result = super.hashCode();\n-\t\t\tresult = 31 * result + (extension != null ? extension.hashCode() : 0);\n+\t\t\tresult = prime * result + ((extension == null) ? 0 : extension.hashCode());\n+\t\t\tresult = prime * result + (strict ? 1231 : 1237);\n \t\t\treturn result;\n \t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj)\n+\t\t{\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (!super.equals(obj))\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tCacheKey other = (CacheKey)obj;\n+\t\t\tif (extension == null)\n+\t\t\t{\n+\t\t\t\tif (other.extension != null)\n+\t\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\telse if (!extension.equals(other.extension))\n+\t\t\t\treturn false;\n+\t\t\tif (strict != other.strict)\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n \t}\n }\n",
        "project": "wicket",
        "linesAdd": 33,
        "jira_id": "5968",
        "nb_skipped": 1,
        "commit": "8b7946d8",
        "nb_failure": 2,
        "linesRem": 17,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1408,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.form.FormValidationTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\nindex 9d46baf7cc..d3c9b8bacc 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/form/Form.java\n@@ -170,8 +170,7 @@ public void component(final FormComponent<?> formComponent, final IVisit<Void> v\n \t\t\t\treturn;\n \t\t\t}\n \n-\t\t\tif (formComponent.isVisibleInHierarchy() && formComponent.isValid() &&\n-\t\t\t\tformComponent.isEnabledInHierarchy())\n+\t\t\tif (formComponent.isVisibleInHierarchy() && formComponent.isEnabledInHierarchy())\n \t\t\t{\n \t\t\t\tvalidate(formComponent);\n \t\t\t}\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "4757",
        "nb_skipped": 5,
        "commit": "fd910746",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 799,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.markup.html.border.BoxBorderTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/Page.java b/wicket/src/main/java/org/apache/wicket/Page.java\nindex 756036f98e..7ec9bc2a16 100644\n--- a/wicket/src/main/java/org/apache/wicket/Page.java\n+++ b/wicket/src/main/java/org/apache/wicket/Page.java\n@@ -1067,7 +1067,7 @@ public Object component(final Component component)\n \t\t\t\t\t// If component never rendered\n \t\t\t\t\tif (renderedComponents == null || !renderedComponents.contains(component))\n \t\t\t\t\t{\n-\t\t\t\t\t\t// If auto component ...\n+\t\t\t\t\t\t// If not an auto component ...\n \t\t\t\t\t\tif (!component.isAuto() && component.isVisibleInHierarchy())\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\t// Increase number of unrendered components\n@@ -1106,8 +1106,7 @@ public Object component(final Component component)\n \t\t\t\trenderedComponents = null;\n \n \t\t\t\tIterator<Component> iterator = unrenderedComponents.iterator();\n-\n-\t\t\t\twhile (iterator.hasNext())\n+\t\t\t\touterWhile : while (iterator.hasNext())\n \t\t\t\t{\n \t\t\t\t\tComponent component = iterator.next();\n \t\t\t\t\t// Now first test if the component has a sibling that is a transparent resolver.\n@@ -1129,7 +1128,7 @@ public Object component(final Component component)\n \t\t\t\t\t\t\t\t\t\"Component {} wasn't rendered but most likely it has a transparent parent: {}\",\n \t\t\t\t\t\t\t\t\tcomponent, sibling);\n \t\t\t\t\t\t\t\titerator.remove();\n-\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t\tcontinue outerWhile;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n",
        "project": "wicket",
        "linesAdd": 2,
        "jira_id": "2368",
        "nb_skipped": 0,
        "commit": "fae1601b",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 1180,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.MarkupContainerTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/Component.java b/wicket-core/src/main/java/org/apache/wicket/Component.java\nindex 13b32cb054..5f0a97d4a1 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/Component.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/Component.java\n@@ -3207,23 +3207,22 @@ public String toString(final boolean detailed)\n \t{\n \t\ttry\n \t\t{\n+\t\t\tfinal StringBuilder buffer = new StringBuilder();\n+\t\t\tbuffer.append(\"[Component id = \").append(getId());\n+\n \t\t\tif (detailed)\n \t\t\t{\n \t\t\t\tfinal Page page = findPage();\n \t\t\t\tif (page == null)\n \t\t\t\t{\n-\t\t\t\t\treturn new StringBuilder(\"[Component id = \").append(getId())\n-\t\t\t\t\t\t.append(\", page = <No Page>, path = \")\n+\t\t\t\t\tbuffer.append(\", page = <No Page>, path = \")\n \t\t\t\t\t\t.append(getPath())\n \t\t\t\t\t\t.append('.')\n-\t\t\t\t\t\t.append(Classes.simpleName(getClass()))\n-\t\t\t\t\t\t.append(']')\n-\t\t\t\t\t\t.toString();\n+\t\t\t\t\t\t.append(Classes.simpleName(getClass()));\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n-\t\t\t\t\treturn new StringBuilder(\"[Component id = \").append(getId())\n-\t\t\t\t\t\t.append(\", page = \")\n+\t\t\t\t\tbuffer.append(\", page = \")\n \t\t\t\t\t\t.append(getPage().getClass().getName())\n \t\t\t\t\t\t.append(\", path = \")\n \t\t\t\t\t\t.append(getPath())\n@@ -3232,15 +3231,18 @@ public String toString(final boolean detailed)\n \t\t\t\t\t\t.append(\", isVisible = \")\n \t\t\t\t\t\t.append((determineVisibility()))\n \t\t\t\t\t\t.append(\", isVersioned = \")\n-\t\t\t\t\t\t.append(isVersioned())\n-\t\t\t\t\t\t.append(']')\n-\t\t\t\t\t\t.toString();\n-\t\t\t\t}\n+\t\t\t\t\t\t.append(isVersioned());\n \t\t\t\t}\n-\t\t\telse\n+\n+\t\t\t\tif (markup != null)\n \t\t\t\t{\n-\t\t\t\treturn \"[Component id = \" + getId() + ']';\n+\t\t\t\t\tbuffer.append(\", markup = \").append(new MarkupStream(getMarkup()).toString());\n+\t\t\t\t}\n \t\t\t}\n+\n+\t\t\tbuffer.append(']');\n+\n+\t\t\treturn buffer.toString();\n \t\t}\n \t\tcatch (Exception e)\n \t\t{\ndiff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\nindex 056d48365d..f9922640ee 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java\n@@ -860,17 +860,11 @@ public String toString()\n \tpublic String toString(final boolean detailed)\n \t{\n \t\tfinal StringBuilder buffer = new StringBuilder();\n-\t\tbuffer.append(\"[\").append(this.getClass().getSimpleName()).append(\" \");\n+\t\tbuffer.append('[').append(this.getClass().getSimpleName()).append(' ');\n \t\tbuffer.append(super.toString(detailed));\n-\t\tif (detailed)\n+\t\tif (detailed && children_size() != 0)\n \t\t{\n-\t\t\tif (getMarkup() != null)\n-\t\t\t{\n-\t\t\t\tbuffer.append(\", markup = \").append(new MarkupStream(getMarkup()).toString());\n-\t\t\t}\n \n-\t\t\tif (children_size() != 0)\n-\t\t\t{\n \t\t\tbuffer.append(\", children = \");\n \n \t\t\t// Loop through child components\n@@ -885,7 +879,7 @@ public String toString(final boolean detailed)\n \t\t\t\t}\n \t\t\t\tbuffer.append(child.toString());\n \t\t\t}\n-\t\t\t}\n+\n \t\t}\n \t\tbuffer.append(']');\n \t\treturn buffer.toString();\n",
        "project": "wicket",
        "linesAdd": 18,
        "jira_id": "4016",
        "nb_skipped": 2,
        "commit": "f1c9cef2",
        "nb_failure": 0,
        "linesRem": 22,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 16,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.extensions.markup.html.basic.DefaultLinkParserTest"
        ],
        "patch": "diff --git a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/LinkParser.java b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/LinkParser.java\nindex ff1aa1bb17..8cf4356592 100644\n--- a/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/LinkParser.java\n+++ b/wicket-extensions/src/main/java/org/apache/wicket/extensions/markup/html/basic/LinkParser.java\n@@ -62,6 +62,10 @@ public String parse(final String text)\n \t\t}\n \n \t\tString work = text;\n+\n+\t\t// don't try to parse markup. just plain text. WICKET-4099\n+\t\tif (work.indexOf('<') == -1)\n+\t\t{\n \t\t\tfor (String pattern : renderStrategies.keySet())\n \t\t\t{\n \t\t\t\tILinkRenderStrategy strategy = renderStrategies.get(pattern);\n@@ -76,6 +80,7 @@ public String parse(final String text)\n \t\t\t\tmatcher.appendTail(buffer);\n \t\t\t\twork = buffer.toString();\n \t\t\t}\n+\t\t}\n \t\treturn work;\n \t}\n }\n",
        "project": "wicket",
        "linesAdd": 4,
        "jira_id": "4099",
        "nb_skipped": 0,
        "commit": "1dcaec98",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1385,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.DefaultExceptionMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java b/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\nindex 1a787ead4f..eea361d6d5 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/DefaultExceptionMapper.java\n@@ -17,21 +17,23 @@\n package org.apache.wicket;\n \n import org.apache.wicket.authorization.AuthorizationException;\n+import org.apache.wicket.core.request.handler.IPageRequestHandler;\n+import org.apache.wicket.core.request.handler.ListenerInvocationNotAllowedException;\n+import org.apache.wicket.core.request.handler.PageProvider;\n+import org.apache.wicket.core.request.handler.RenderPageRequestHandler;\n+import org.apache.wicket.core.request.mapper.StalePageException;\n import org.apache.wicket.markup.html.pages.ExceptionErrorPage;\n import org.apache.wicket.protocol.http.PageExpiredException;\n import org.apache.wicket.protocol.http.servlet.ResponseIOException;\n import org.apache.wicket.request.IExceptionMapper;\n import org.apache.wicket.request.IRequestHandler;\n import org.apache.wicket.request.Request;\n+import org.apache.wicket.request.Response;\n import org.apache.wicket.request.cycle.RequestCycle;\n import org.apache.wicket.request.handler.EmptyRequestHandler;\n-import org.apache.wicket.core.request.handler.IPageRequestHandler;\n-import org.apache.wicket.core.request.handler.ListenerInvocationNotAllowedException;\n-import org.apache.wicket.core.request.handler.PageProvider;\n-import org.apache.wicket.core.request.handler.RenderPageRequestHandler;\n import org.apache.wicket.request.http.WebRequest;\n+import org.apache.wicket.request.http.WebResponse;\n import org.apache.wicket.request.http.handler.ErrorCodeRequestHandler;\n-import org.apache.wicket.core.request.mapper.StalePageException;\n import org.apache.wicket.settings.IExceptionSettings;\n import org.apache.wicket.settings.IExceptionSettings.UnexpectedExceptionDisplay;\n import org.slf4j.Logger;\n@@ -51,6 +53,12 @@ public IRequestHandler map(Exception e)\n \t{\n \t\ttry\n \t\t{\n+\t\t\tResponse response = RequestCycle.get().getResponse();\n+\t\t\tif (response instanceof WebResponse)\n+\t\t\t{\n+\t\t\t\t// we don't wan't to cache an exceptional reply in the browser\n+\t\t\t\t((WebResponse)response).disableCaching();\n+\t\t\t}\n \t\t\treturn internalMap(e);\n \t\t}\n \t\tcatch (RuntimeException e2)\n",
        "project": "wicket",
        "linesAdd": 12,
        "jira_id": "4659",
        "nb_skipped": 5,
        "commit": "ccd74641",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 798,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.lang.PropertyResolverTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/util/lang/PropertyResolver.java b/wicket/src/main/java/org/apache/wicket/util/lang/PropertyResolver.java\nindex ae38446b57..d83ba146a3 100644\n--- a/wicket/src/main/java/org/apache/wicket/util/lang/PropertyResolver.java\n+++ b/wicket/src/main/java/org/apache/wicket/util/lang/PropertyResolver.java\n@@ -217,6 +217,12 @@ private static ObjectAndGetSetter getObjectAndGetSetter(final String expression,\n \t\twhile (index != -1)\n \t\t{\n \t\t\texp = expressionBracketsSeperated.substring(lastIndex, index);\n+\t\t\tif (exp.length() == 0)\n+\t\t\t{\n+\t\t\t\texp = expressionBracketsSeperated.substring(index + 1);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n \t\t\tIGetAndSet getAndSetter = null;\n \t\t\ttry\n \t\t\t{\n@@ -762,6 +768,8 @@ public Object newValue(Object object)\n \t\t */\n \t\tpublic Object getValue(Object object)\n \t\t{\n+\t\t\tif (((List<?>)object).size() <= index)\n+\t\t\t\treturn null;\n \t\t\treturn ((List<?>)object).get(index);\n \t\t}\n \n@@ -818,9 +826,13 @@ public Object newValue(Object object)\n \t\t * @see org.apache.wicket.util.lang.PropertyResolver.IGetAndSet#getValue(java.lang.Object)\n \t\t */\n \t\tpublic Object getValue(Object object)\n+\t\t{\n+\t\t\tif (Array.getLength(object) > index)\n \t\t\t{\n \t\t\t\treturn Array.get(object, index);\n \t\t\t}\n+\t\t\treturn null;\n+\t\t}\n \n \t\t/**\n \t\t * @see org.apache.wicket.util.lang.PropertyResolver.IGetAndSet#setValue(Object, Object,\n",
        "project": "wicket",
        "linesAdd": 12,
        "jira_id": "2337",
        "nb_skipped": 0,
        "commit": "36a41358",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 377,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "wicket.FormDispatchEventTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/wicket/Session.java b/wicket/src/main/java/wicket/Session.java\nindex 0a64238b46..1de82b76ce 100644\n--- a/wicket/src/main/java/wicket/Session.java\n+++ b/wicket/src/main/java/wicket/Session.java\n@@ -16,8 +16,6 @@\n  */\n package wicket;\n \n-import java.io.ByteArrayOutputStream;\n-import java.io.ObjectOutputStream;\n import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.HashMap;\n@@ -41,7 +39,6 @@\n import wicket.request.ClientInfo;\n import wicket.session.ISessionStore;\n import wicket.util.convert.IConverter;\n-import wicket.util.lang.Bytes;\n import wicket.util.lang.Objects;\n import wicket.util.string.Strings;\n import wicket.util.time.Duration;\n@@ -1036,20 +1033,6 @@ protected final void setAttribute(String name, Object value)\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tString valueTypeName = (value != null ? value.getClass().getName() : \"null\");\n-\t\ttry\n-\t\t{\n-\t\t\tfinal ByteArrayOutputStream out = new ByteArrayOutputStream();\n-\t\t\tnew ObjectOutputStream(out).writeObject(value);\n-\t\t\tlog.debug(\"Stored attribute \" + name + \"{ \" + valueTypeName + \"} with size: \"\n-\t\t\t\t\t+ Bytes.bytes(out.size()));\n-\t\t}\n-\t\tcatch (Exception e)\n-\t\t{\n-\t\t\tthrow new WicketRuntimeException(\n-\t\t\t\t\t\"Internal error cloning object. Make sure all dependent objects implement Serializable. Class: \"\n-\t\t\t\t\t\t\t+ valueTypeName, e);\n-\t\t}\n \n \t\t// Set the actual attribute\n \t\tstore.setAttribute(request, name, value);\n",
        "project": "wicket",
        "linesAdd": 0,
        "jira_id": "128",
        "nb_skipped": 0,
        "commit": "7e1000dd",
        "nb_failure": 0,
        "linesRem": 17,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1476,
        "nb_error": 1,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.wicket.core.util.string.ComponentRendererTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/util/string/ComponentRenderer.java b/wicket-core/src/main/java/org/apache/wicket/core/util/string/ComponentRenderer.java\nindex 308b5487b1..41704a65c8 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/core/util/string/ComponentRenderer.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/util/string/ComponentRenderer.java\n@@ -100,6 +100,7 @@ public static CharSequence renderComponent(final Component component)\n \n \t\t\tRenderPage page = new RenderPage();\n \t\t\tpage.add(component);\n+\t\t\tpage.internalInitialize();\n \n \t\t\tcomponent.render();\n \t\t}\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "5209",
        "nb_skipped": 4,
        "commit": "55eb5212",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 3,
        "nb_test": 784,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.PageParametersTest",
            "org.apache.wicket.util.value.ValueMapTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/PageParameters.java b/wicket/src/main/java/org/apache/wicket/PageParameters.java\nindex 95d1a48100..0a865f2c1f 100644\n--- a/wicket/src/main/java/org/apache/wicket/PageParameters.java\n+++ b/wicket/src/main/java/org/apache/wicket/PageParameters.java\n@@ -123,14 +123,14 @@ else if (pos != -1)\n \t\t\t\tfinal String key = pair.substring(0, pos).trim();\n \t\t\t\tfinal String value = pair.substring(pos + 1).trim();\n \n-\t\t\t\tput(key, value);\n+\t\t\t\tadd(key, value);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\tfinal String key = pair.trim();\n \t\t\t\tfinal String value = null;\n \n-\t\t\t\tput(key, value);\n+\t\t\t\tadd(key, value);\n \t\t\t}\n \t\t}\n \t}\ndiff --git a/wicket/src/main/java/org/apache/wicket/Resource.java b/wicket/src/main/java/org/apache/wicket/Resource.java\nindex 85c39aaeaf..78e62b058d 100644\n--- a/wicket/src/main/java/org/apache/wicket/Resource.java\n+++ b/wicket/src/main/java/org/apache/wicket/Resource.java\n@@ -149,7 +149,7 @@ public final Resource setCacheable(boolean cacheable)\n \t * @param parameters\n \t *            Map of query parameters that parameterize this resource\n \t */\n-\tpublic final void setParameters(final Map<?, ?> parameters)\n+\tpublic final void setParameters(final Map<String, ?> parameters)\n \t{\n \t\tif (parameters == null)\n \t\t{\ndiff --git a/wicket/src/main/java/org/apache/wicket/util/value/ValueMap.java b/wicket/src/main/java/org/apache/wicket/util/value/ValueMap.java\nindex 3e72e8f7ba..5b5062ba5a 100644\n--- a/wicket/src/main/java/org/apache/wicket/util/value/ValueMap.java\n+++ b/wicket/src/main/java/org/apache/wicket/util/value/ValueMap.java\n@@ -20,7 +20,6 @@\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.util.Arrays;\n-import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.Map;\n \n@@ -91,7 +90,7 @@ public ValueMap()\n \t * @param map\n \t *            the <code>ValueMap</code> to copy\n \t */\n-\tpublic ValueMap(final Map map)\n+\tpublic ValueMap(final Map<? extends String, ? extends Object> map)\n \t{\n \t\tsuper();\n \n@@ -152,7 +151,7 @@ public ValueMap(final String keyValuePairs, final String delimiter)\n \t\t\t}\n \t\t\tString key = keyValuePairs.substring(start, equalsIndex);\n \t\t\tString value = keyValuePairs.substring(equalsIndex + 1, delimiterIndex);\n-\t\t\tput(key, value);\n+\t\t\tadd(key, value);\n \t\t\tif (delimiterIndex < keyValuePairs.length())\n \t\t\t{\n \t\t\t\tstart = delimiterIndex + 1;\n@@ -490,7 +489,7 @@ else if (o.getClass().isArray())\n \t * @see java.util.Map#putAll(java.util.Map)\n \t */\n \t@Override\n-\tpublic void putAll(final Map map)\n+\tpublic void putAll(final Map<? extends String, ? extends Object> map)\n \t{\n \t\tcheckMutability();\n \t\tsuper.putAll(map);\n@@ -535,9 +534,15 @@ public String getKey(final String key)\n \tpublic String toString()\n \t{\n \t\tfinal StringBuffer buffer = new StringBuffer();\n-\t\tfor (final Iterator iterator = entrySet().iterator(); iterator.hasNext();)\n+\t\tboolean first = true;\n+\t\tfor (Map.Entry<String, Object> entry : entrySet())\n \t\t{\n-\t\t\tfinal Map.Entry entry = (Map.Entry)iterator.next();\n+\t\t\tif (first == false)\n+\t\t\t{\n+\t\t\t\tbuffer.append(' ');\n+\t\t\t}\n+\t\t\tfirst = false;\n+\n \t\t\tbuffer.append(entry.getKey());\n \t\t\tbuffer.append(\" = \\\"\");\n \t\t\tfinal Object value = entry.getValue();\n@@ -555,10 +560,6 @@ else if (value.getClass().isArray())\n \t\t\t}\n \n \t\t\tbuffer.append('\\\"');\n-\t\t\tif (iterator.hasNext())\n-\t\t\t{\n-\t\t\t\tbuffer.append(' ');\n-\t\t\t}\n \t\t}\n \t\treturn buffer.toString();\n \t}\n@@ -585,7 +586,9 @@ private void checkMutability()\n \tpublic Boolean getAsBoolean(String key)\n \t{\n \t\tif (!containsKey(key))\n+\t\t{\n \t\t\treturn null;\n+\t\t}\n \n \t\ttry\n \t\t{\n@@ -619,7 +622,9 @@ public boolean getAsBoolean(String key, boolean defaultValue)\n \tpublic Integer getAsInteger(String key)\n \t{\n \t\tif (!containsKey(key))\n+\t\t{\n \t\t\treturn null;\n+\t\t}\n \n \t\ttry\n \t\t{\n@@ -652,7 +657,9 @@ public int getAsInteger(String key, int defaultValue)\n \tpublic Long getAsLong(String key)\n \t{\n \t\tif (!containsKey(key))\n+\t\t{\n \t\t\treturn null;\n+\t\t}\n \n \t\ttry\n \t\t{\n@@ -685,7 +692,9 @@ public long getAsLong(String key, long defaultValue)\n \tpublic Double getAsDouble(String key)\n \t{\n \t\tif (!containsKey(key))\n+\t\t{\n \t\t\treturn null;\n+\t\t}\n \n \t\ttry\n \t\t{\n@@ -700,7 +709,7 @@ public Double getAsDouble(String key)\n \t/**\n \t * @see IValueMap#getAsDouble(String, double)\n \t */\n-\tpublic double getAsDouble(String key, double defaultValue)\n+\tpublic double getAsDouble(final String key, final double defaultValue)\n \t{\n \t\ttry\n \t\t{\n@@ -715,7 +724,7 @@ public double getAsDouble(String key, double defaultValue)\n \t/**\n \t * @see IValueMap#getAsDuration(String)\n \t */\n-\tpublic Duration getAsDuration(String key)\n+\tpublic Duration getAsDuration(final String key)\n \t{\n \t\treturn getAsDuration(key, null);\n \t}\n@@ -723,10 +732,12 @@ public Duration getAsDuration(String key)\n \t/**\n \t * @see IValueMap#getAsDuration(String, Duration)\n \t */\n-\tpublic Duration getAsDuration(String key, Duration defaultValue)\n+\tpublic Duration getAsDuration(final String key, final Duration defaultValue)\n \t{\n \t\tif (!containsKey(key))\n+\t\t{\n \t\t\treturn defaultValue;\n+\t\t}\n \n \t\ttry\n \t\t{\n@@ -741,7 +752,7 @@ public Duration getAsDuration(String key, Duration defaultValue)\n \t/**\n \t * @see IValueMap#getAsTime(String)\n \t */\n-\tpublic Time getAsTime(String key)\n+\tpublic Time getAsTime(final String key)\n \t{\n \t\treturn getAsTime(key, null);\n \t}\n@@ -749,10 +760,12 @@ public Time getAsTime(String key)\n \t/**\n \t * @see IValueMap#getAsTime(String, Time)\n \t */\n-\tpublic Time getAsTime(String key, Time defaultValue)\n+\tpublic Time getAsTime(final String key, final Time defaultValue)\n \t{\n \t\tif (!containsKey(key))\n+\t\t{\n \t\t\treturn defaultValue;\n+\t\t}\n \n \t\ttry\n \t\t{\n@@ -765,43 +778,59 @@ public Time getAsTime(String key, Time defaultValue)\n \t}\n \n \t/**\n-\t * @see IValueMap#getAsEnum(String, Class<T>)\n+\t * @see org.apache.wicket.util.value.IValueMap#getAsEnum(java.lang.String, java.lang.Class)\n \t */\n-\tpublic <T extends Enum<T>> T getAsEnum(String key, Class<T> eClass)\n+\tpublic <T extends Enum<T>> T getAsEnum(final String key, final Class<T> eClass)\n \t{\n \t\treturn getEnumImpl(key, eClass, null);\n \t}\n \n \t/**\n-\t * @see IValueMap#getAsEnum\n+\t * @see org.apache.wicket.util.value.IValueMap#getAsEnum(java.lang.String, java.lang.Enum)\n \t */\n-\tpublic <T extends Enum<T>> T getAsEnum(String key, T defaultValue)\n+\tpublic <T extends Enum<T>> T getAsEnum(final String key, final T defaultValue)\n \t{\n \t\tif (defaultValue == null)\n+\t\t{\n \t\t\tthrow new IllegalArgumentException(\"Default value cannot be null\");\n+\t\t}\n+\n \t\treturn getEnumImpl(key, defaultValue.getClass(), defaultValue);\n \t}\n \n \t/**\n-\t * @see IValueMap#getAsEnum(String, Class<T>, T)\n+\t * @see org.apache.wicket.util.value.IValueMap#getAsEnum(java.lang.String, java.lang.Class,\n+\t *      java.lang.Enum)\n \t */\n-\tpublic <T extends Enum<T>> T getAsEnum(String key, Class<T> eClass, T defaultValue)\n+\tpublic <T extends Enum<T>> T getAsEnum(final String key, final Class<T> eClass,\n+\t\tfinal T defaultValue)\n \t{\n \t\treturn getEnumImpl(key, eClass, defaultValue);\n \t}\n \n \t/**\n \t * get enum implementation\n+\t * \n+\t * @param key\n+\t * @param eClass\n+\t * @param defaultValue\n+\t * @param <T>\n+\t * @return Enum\n \t */\n \t@SuppressWarnings( { \"unchecked\" })\n-\tprivate <T extends Enum<T>> T getEnumImpl(String key, Class<?> eClass, T defaultValue)\n+\tprivate <T extends Enum<T>> T getEnumImpl(final String key, final Class<?> eClass,\n+\t\tfinal T defaultValue)\n \t{\n \t\tif (eClass == null)\n+\t\t{\n \t\t\tthrow new IllegalArgumentException(\"eClass value cannot be null\");\n+\t\t}\n \n \t\tString value = getString(key);\n \t\tif (value == null)\n+\t\t{\n \t\t\treturn defaultValue;\n+\t\t}\n \n \t\tMethod valueOf = null;\n \t\ttry\n",
        "project": "wicket",
        "linesAdd": 44,
        "jira_id": "2172",
        "nb_skipped": 0,
        "commit": "ea4a3f8a",
        "nb_failure": 2,
        "linesRem": 22,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 181,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.string.StringsTest"
        ],
        "patch": "diff --git a/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java b/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java\nindex f3ebe1bca1..fdb75a471c 100755\n--- a/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java\n+++ b/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java\n@@ -677,7 +677,7 @@ else if (fragments.length < 2)\n \t\t\t\t{\r\n \t\t\t\t\tboolean lhsClosed = fragments[i - 1].endsWith(separator);\r\n \t\t\t\t\tboolean rhsClosed = fragment.startsWith(separator);\r\n-\t\t\t\t\tif (lhsClosed && rhsClosed)\r\n+\t\t\t\t\tif (!Strings.isEmpty(separator) && lhsClosed && rhsClosed)\r\n \t\t\t\t\t{\r\n \t\t\t\t\t\tbuff.append(fragment.substring(1));\r\n \t\t\t\t\t}\r\n",
        "project": "wicket",
        "linesAdd": 1,
        "jira_id": "5720",
        "nb_skipped": 2,
        "commit": "2fc6a395",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 723,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.util.tester.FormTesterTest"
        ],
        "patch": "diff --git a/wicket/src/main/java/org/apache/wicket/protocol/http/MockHttpServletRequest.java b/wicket/src/main/java/org/apache/wicket/protocol/http/MockHttpServletRequest.java\nindex e282be1ad6..c521441f7f 100644\n--- a/wicket/src/main/java/org/apache/wicket/protocol/http/MockHttpServletRequest.java\n+++ b/wicket/src/main/java/org/apache/wicket/protocol/http/MockHttpServletRequest.java\n@@ -486,8 +486,6 @@ public String getHeader(final String name)\n \t *             If an I/O related problem occurs\n \t */\n \tpublic ServletInputStream getInputStream() throws IOException\n-\t{\n-\t\tif (uploadedFiles != null && uploadedFiles.size() > 0)\n \t{\n \t\tbyte[] request = buildRequest();\n \n@@ -503,18 +501,6 @@ public int read()\n \t\t\t}\n \t\t};\n \t}\n-\t\telse\n-\t\t{\n-\t\t\treturn new ServletInputStream()\n-\t\t\t{\n-\t\t\t\t@Override\n-\t\t\t\tpublic int read()\n-\t\t\t\t{\n-\t\t\t\t\treturn -1;\n-\t\t\t\t}\n-\t\t\t};\n-\t\t}\n-\t}\n \n \t/**\n \t * Get the given header as an int.\n",
        "project": "wicket",
        "linesAdd": 0,
        "jira_id": "1931",
        "nb_skipped": 0,
        "commit": "986848f7",
        "nb_failure": 1,
        "linesRem": 14,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 1201,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.wicket.request.mapper.BookmarkableMapperTest",
            "org.apache.wicket.request.mapper.PackageMapperTest",
            "org.apache.wicket.request.mapper.MountedMapperTest"
        ],
        "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\nindex ed01ddb28b..f000badad4 100644\n--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java\n@@ -292,12 +292,6 @@ private IRequestablePage getStoredPage(final int pageId)\n \t\t\t(pageClass == null || pageClass.equals(storedPageInstance.getClass())))\n \t\t{\n \t\t\tpageInstance = storedPageInstance;\n-\n-\t\t\tif (pageParameters != null)\n-\t\t\t{\n-\t\t\t\tstoredPageInstance.getPageParameters().overwriteWith(pageParameters);\n-\t\t\t}\n-\n \t\t}\n \t\treturn storedPageInstance;\n \t}\n",
        "project": "wicket",
        "linesAdd": 0,
        "jira_id": "4109",
        "nb_skipped": 2,
        "commit": "8f7805f8",
        "nb_failure": 6,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 5907,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.random.Well1024aTest",
            "org.apache.commons.math4.random.Well44497bTest",
            "org.apache.commons.math4.random.ISAACTest",
            "org.apache.commons.math4.random.AbstractRandomGeneratorTest",
            "org.apache.commons.math4.random.BitsStreamGeneratorTest",
            "org.apache.commons.math4.random.Well512aTest",
            "org.apache.commons.math4.random.Well19937aTest",
            "org.apache.commons.math4.random.Well44497aTest",
            "org.apache.commons.math4.random.MersenneTwisterTest",
            "org.apache.commons.math4.random.Well19937cTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/random/AbstractRandomGenerator.java b/src/main/java/org/apache/commons/math4/random/AbstractRandomGenerator.java\nindex 1b9cead20..173f4ee05 100644\n--- a/src/main/java/org/apache/commons/math4/random/AbstractRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math4/random/AbstractRandomGenerator.java\n@@ -114,6 +114,8 @@ public void nextBytes(byte[] bytes) {\n                 if (i > 0) {\n                     randInt >>= 8;\n                 }\n+            }\n+            if (bytesOut < bytes.length) {\n                 bytes[bytesOut++] = (byte) randInt;\n                 if (bytesOut == bytes.length) {\n                     return;\ndiff --git a/src/main/java/org/apache/commons/math4/random/BitsStreamGenerator.java b/src/main/java/org/apache/commons/math4/random/BitsStreamGenerator.java\nindex 81968e244..7c89b60cc 100644\n--- a/src/main/java/org/apache/commons/math4/random/BitsStreamGenerator.java\n+++ b/src/main/java/org/apache/commons/math4/random/BitsStreamGenerator.java\n@@ -82,12 +82,14 @@ public void nextBytes(byte[] bytes) {\n             bytes[i + 3] = (byte) ((random >> 24) & 0xff);\n             i += 4;\n         }\n+        if (i < bytes.length) {\n             int random = next(32);\n             while (i < bytes.length) {\n                 bytes[i++] = (byte) (random & 0xff);\n                 random >>= 8;\n             }\n         }\n+    }\n \n     /** {@inheritDoc} */\n     @Override\n",
        "project": "commons-math",
        "linesAdd": 4,
        "jira_id": "1300",
        "nb_skipped": 4,
        "commit": "1d635088",
        "nb_failure": 10,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5859,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.stat.correlation.KendallsCorrelationTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/stat/correlation/KendallsCorrelation.java b/src/main/java/org/apache/commons/math4/stat/correlation/KendallsCorrelation.java\nindex 77b7d2297..125083e91 100644\n--- a/src/main/java/org/apache/commons/math4/stat/correlation/KendallsCorrelation.java\n+++ b/src/main/java/org/apache/commons/math4/stat/correlation/KendallsCorrelation.java\n@@ -201,7 +201,7 @@ public int compare(Pair<Double, Double> pair1, Pair<Double, Double> pair2) {\n         tiedXPairs += sum(consecutiveXTies - 1);\n         tiedXYPairs += sum(consecutiveXYTies - 1);\n \n-        int swaps = 0;\n+        long swaps = 0;\n         @SuppressWarnings(\"unchecked\")\n         Pair<Double, Double>[] pairsDestination = new Pair[n];\n         for (int segmentSize = 1; segmentSize < n; segmentSize <<= 1) {\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "1277",
        "nb_skipped": 3,
        "commit": "fb007815",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 2226,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.util.FastMathTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/util/FastMath.java b/src/main/java/org/apache/commons/math/util/FastMath.java\nindex 8cba4d484..4f7d447df 100644\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n@@ -3479,7 +3479,7 @@ public static long max(final long a, final long b) {\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n     }\n \n     /** Compute the maximum of two values\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "482",
        "nb_skipped": 1,
        "commit": "6d6649ef",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 3,
        "nb_test": 5909,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizerTest",
            "org.apache.commons.math3.fitting.leastsquares.EvaluationTest",
            "org.apache.commons.math3.fitting.leastsquares.GaussNewtonOptimizerWithCholeskyTest",
            "org.apache.commons.math3.fitting.leastsquares.GaussNewtonOptimizerWithQRTest",
            "org.apache.commons.math3.fitting.leastsquares.GaussNewtonOptimizerWithLUTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/fitting/leastsquares/GaussNewtonOptimizer.java b/src/main/java/org/apache/commons/math3/fitting/leastsquares/GaussNewtonOptimizer.java\nindex 924085687..c17c870c4 100644\n--- a/src/main/java/org/apache/commons/math3/fitting/leastsquares/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/fitting/leastsquares/GaussNewtonOptimizer.java\n@@ -197,9 +197,7 @@ public Optimum optimize(final LeastSquaresProblem lsp) {\n             throw new NullArgumentException();\n         }\n \n-        final int nC = lsp.getParameterSize();\n-\n-        final RealVector currentPoint = lsp.getStart();\n+        RealVector currentPoint = lsp.getStart();\n \n         // iterate until convergence is reached\n         Evaluation current = null;\n@@ -227,9 +225,7 @@ public Optimum optimize(final LeastSquaresProblem lsp) {\n             // solve the linearized least squares problem\n             final RealVector dX = this.decomposition.solve(weightedJacobian, currentResiduals);\n             // update the estimated parameters\n-            for (int i = 0; i < nC; ++i) {\n-                currentPoint.setEntry(i, currentPoint.getEntry(i) + dX.getEntry(i));\n-            }\n+            currentPoint = currentPoint.add(dX);\n         }\n     }\n \ndiff --git a/src/main/java/org/apache/commons/math3/fitting/leastsquares/LeastSquaresFactory.java b/src/main/java/org/apache/commons/math3/fitting/leastsquares/LeastSquaresFactory.java\nindex 0853d0355..16ac659c5 100644\n--- a/src/main/java/org/apache/commons/math3/fitting/leastsquares/LeastSquaresFactory.java\n+++ b/src/main/java/org/apache/commons/math3/fitting/leastsquares/LeastSquaresFactory.java\n@@ -332,7 +332,8 @@ public Evaluation evaluate(final RealVector point) {\n                     value.getFirst(),\n                     value.getSecond(),\n                     this.target,\n-                    point);\n+                    // copy so optimizer can change point without changing our instance\n+                    point.copy());\n         }\n \n         /**\ndiff --git a/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java b/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java\nindex 1cd4e51f7..5f0527c33 100644\n--- a/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java\n@@ -328,7 +328,7 @@ public Optimum optimize(final LeastSquaresProblem problem) {\n         // Evaluate the function at the starting point and calculate its norm.\n         evaluationCounter.incrementCount();\n         //value will be reassigned in the loop\n-        Evaluation current = problem.evaluate(new ArrayRealVector(currentPoint, false));\n+        Evaluation current = problem.evaluate(new ArrayRealVector(currentPoint));\n         double[] currentResiduals = current.getResiduals().toArray();\n         double currentCost = current.getCost();\n \n@@ -445,7 +445,7 @@ public Optimum optimize(final LeastSquaresProblem problem) {\n \n                 // Evaluate the function at x + p and calculate its norm.\n                 evaluationCounter.incrementCount();\n-                current = problem.evaluate(new ArrayRealVector(currentPoint,false));\n+                current = problem.evaluate(new ArrayRealVector(currentPoint));\n                 currentResiduals = current.getResiduals().toArray();\n                 currentCost = current.getCost();\n \n",
        "project": "commons-math",
        "linesAdd": 5,
        "jira_id": "1103",
        "nb_skipped": 3,
        "commit": "a6f96306",
        "nb_failure": 5,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 4106,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.distribution.UniformRealDistributionTest",
            "org.apache.commons.math3.distribution.FDistributionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/distribution/FDistribution.java b/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\nindex 8b0993c4d..e301e2ef5 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/FDistribution.java\n@@ -272,7 +272,7 @@ public double getSupportUpperBound() {\n \n     /** {@inheritDoc} */\n     public boolean isSupportLowerBoundInclusive() {\n-        return true;\n+        return false;\n     }\n \n     /** {@inheritDoc} */\ndiff --git a/src/main/java/org/apache/commons/math3/distribution/RealDistribution.java b/src/main/java/org/apache/commons/math3/distribution/RealDistribution.java\nindex f09c5acbe..90dc8fdeb 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/RealDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/RealDistribution.java\n@@ -137,18 +137,26 @@\n     double getSupportUpperBound();\n \n     /**\n-     * Use this method to get information about whether the lower bound\n-     * of the support is inclusive or not.\n+     * Whether or not the lower bound of support is in the domain of the density\n+     * function.  Returns true iff {@code getSupporLowerBound()} is finite and\n+     * {@code density(getSupportLowerBound())} returns a non-NaN, non-infinite\n+     * value.\n      *\n-     * @return whether the lower bound of the support is inclusive or not\n+     * @return true if the lower bound of support is finite and the density \n+     * function returns a non-NaN, non-infinite value there\n+     * @deprecated to be removed in 4.0\n      */\n     boolean isSupportLowerBoundInclusive();\n \n     /**\n-     * Use this method to get information about whether the upper bound\n-     * of the support is inclusive or not.\n+     * Whether or not the upper bound of support is in the domain of the density\n+     * function.  Returns true iff {@code getSupportUpperBound()} is finite and\n+     * {@code density(getSupportUpperBound())} returns a non-NaN, non-infinite\n+     * value.\n      *\n-     * @return whether the upper bound of the support is inclusive or not\n+     * @return true if the upper bound of support is finite and the density \n+     * function returns a non-NaN, non-infinite value there\n+     * @deprecated to be removed in 4.0\n      */\n     boolean isSupportUpperBoundInclusive();\n \ndiff --git a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\nindex 5d32f6ebf..0d279de1f 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n@@ -181,7 +181,7 @@ public boolean isSupportLowerBoundInclusive() {\n \n     /** {@inheritDoc} */\n     public boolean isSupportUpperBoundInclusive() {\n-        return false;\n+        return true;\n     }\n \n     /**\n",
        "project": "commons-math",
        "linesAdd": 2,
        "jira_id": "859",
        "nb_skipped": 4,
        "commit": "66dece12",
        "nb_failure": 2,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4934,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.distribution.UniformRealDistributionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\nindex 0d279de1f..62ccb0c51 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java\n@@ -18,6 +18,7 @@\n package org.apache.commons.math3.distribution;\n \n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.random.RandomGenerator;\n import org.apache.commons.math3.random.Well19937c;\n@@ -32,7 +33,10 @@\n  * @since 3.0\n  */\n public class UniformRealDistribution extends AbstractRealDistribution {\n-    /** Default inverse cumulative probability accuracy. */\n+    /** Default inverse cumulative probability accuracy.\n+     * @deprecated as of 3.2 not used anymore, will be removed in 4.0\n+     */\n+    @Deprecated\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 20120109L;\n@@ -40,8 +44,6 @@\n     private final double lower;\n     /** Upper bound of this distribution (exclusive). */\n     private final double upper;\n-    /** Inverse cumulative probability accuracy. */\n-    private final double solverAbsoluteAccuracy;\n \n     /**\n      * Create a standard uniform real distribution with lower bound (inclusive)\n@@ -61,7 +63,7 @@ public UniformRealDistribution() {\n      */\n     public UniformRealDistribution(double lower, double upper)\n         throws NumberIsTooLargeException {\n-        this(lower, upper, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+        this(new  Well19937c(), lower, upper);\n     }\n \n     /**\n@@ -71,10 +73,13 @@ public UniformRealDistribution(double lower, double upper)\n      * @param upper Upper bound of this distribution (exclusive).\n      * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n      * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     * @deprecated as of 3.2, inverse CDF is now calculated analytically, use\n+     *             {@link #UniformRealDistribution(double, double)} instead.\n      */\n+    @Deprecated\n     public UniformRealDistribution(double lower, double upper, double inverseCumAccuracy)\n         throws NumberIsTooLargeException {\n-        this(new  Well19937c(), lower, upper, inverseCumAccuracy);\n+        this(new  Well19937c(), lower, upper);\n     }\n \n     /**\n@@ -86,11 +91,30 @@ public UniformRealDistribution(double lower, double upper, double inverseCumAccu\n      * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n      * @throws NumberIsTooLargeException if {@code lower >= upper}.\n      * @since 3.1\n+     * @deprecated as of 3.2, inverse CDF is now calculated analytically, use\n+     *             {@link #UniformRealDistribution(RandomGenerator, double, double)}\n+     *             instead.\n      */\n+    @Deprecated\n     public UniformRealDistribution(RandomGenerator rng,\n                                    double lower,\n                                    double upper,\n-                                   double inverseCumAccuracy)\n+                                   double inverseCumAccuracy){\n+        this(rng, lower, upper);\n+    }\n+\n+    /**\n+     * Creates a uniform distribution.\n+     *\n+     * @param rng Random number generator.\n+     * @param lower Lower bound of this distribution (inclusive).\n+     * @param upper Upper bound of this distribution (exclusive).\n+     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     * @since 3.1\n+     */\n+    public UniformRealDistribution(RandomGenerator rng,\n+                                   double lower,\n+                                   double upper)\n         throws NumberIsTooLargeException {\n         super(rng);\n         if (lower >= upper) {\n@@ -101,7 +125,6 @@ public UniformRealDistribution(RandomGenerator rng,\n \n         this.lower = lower;\n         this.upper = upper;\n-        solverAbsoluteAccuracy = inverseCumAccuracy;\n     }\n \n     /** {@inheritDoc} */\n@@ -123,10 +146,13 @@ public double cumulativeProbability(double x)  {\n         return (x - lower) / (upper - lower);\n     }\n \n-    /** {@inheritDoc} */\n     @Override\n-    protected double getSolverAbsoluteAccuracy() {\n-        return solverAbsoluteAccuracy;\n+    public double inverseCumulativeProbability(final double p)\n+            throws OutOfRangeException {\n+        if (p < 0.0 || p > 1.0) {\n+            throw new OutOfRangeException(p, 0, 1);\n+        }\n+        return p * (upper - lower) + lower;\n     }\n \n     /**\n",
        "project": "commons-math",
        "linesAdd": 19,
        "jira_id": "957",
        "nb_skipped": 4,
        "commit": "9aabf587",
        "nb_failure": 1,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5968,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.stat.descriptive.DescriptiveStatisticsTest",
            "org.apache.commons.math3.stat.descriptive.SynchronizedDescriptiveStatisticsTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/stat/descriptive/rank/Percentile.java b/src/main/java/org/apache/commons/math3/stat/descriptive/rank/Percentile.java\nindex db447aa8e..15631cf9e 100644\n--- a/src/main/java/org/apache/commons/math3/stat/descriptive/rank/Percentile.java\n+++ b/src/main/java/org/apache/commons/math3/stat/descriptive/rank/Percentile.java\n@@ -440,12 +440,18 @@ private int partition(final double[] work, final int begin, final int end, final\n      * @param end index after the last element of the slice to sort\n      */\n     private void insertionSort(final double[] work, final int begin, final int end) {\n+        // Arrays.sort(work, begin, end); // Would also fix MATH-1129\n         for (int j = begin + 1; j < end; j++) {\n             final double saved = work[j];\n             int i = j - 1;\n-            while ((i >= begin) && (saved < work[i])) {\n-                work[i + 1] = work[i];\n+            while (i >= begin) {\n+                final double wi = work[i];\n+                if (saved < wi || Double.isNaN(wi)) {\n+                    work[i + 1] = wi;\n                     i--;\n+                } else {\n+                    break;\n+                }\n             }\n             work[i + 1] = saved;\n         }\n",
        "project": "commons-math",
        "linesAdd": 7,
        "jira_id": "1129",
        "nb_skipped": 3,
        "commit": "d4f978dd",
        "nb_failure": 2,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5964,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.geometry.euclidean.twod.hull.AklToussaintHeuristicTest",
            "org.apache.commons.math3.geometry.euclidean.twod.hull.MonotoneChainTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java b/src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java\nindex c81832b07..5aec175fc 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/partitioning/BSPTree.java\n@@ -294,7 +294,7 @@ public void visit(final BSPTreeVisitor<S> visitor) {\n      */\n     private SubHyperplane<S> fitToCell(final SubHyperplane<S> sub) {\n         SubHyperplane<S> s = sub;\n-        for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {\n+        for (BSPTree<S> tree = this; tree.parent != null && s != null; tree = tree.parent) {\n             if (tree == tree.parent.plus) {\n                 s = s.split(tree.parent.cut.getHyperplane()).getPlus();\n             } else {\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "1123",
        "nb_skipped": 3,
        "commit": "a197ba85",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3611,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.geometry.euclidean.threed.RotationTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java\nindex d5cfb9b5d..51ffce25c 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java\n@@ -22,6 +22,7 @@\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathArrays;\n \n /**\n  * This class implements rotations in a three-dimensional space.\n@@ -241,6 +242,22 @@ public Rotation(double[][] m, double threshold)\n               det);\n     }\n \n+    double[] quat = mat2quat(ort);\n+    q0 = quat[0];\n+    q1 = quat[1];\n+    q2 = quat[2];\n+    q3 = quat[3];\n+\n+  }\n+\n+  /** Convert an orthogonal rotation matrix to a quaternion.\n+   * @param ort orthogonal rotation matrix\n+   * @return quaternion corresponding to the matrix\n+   */\n+  private static double[] mat2quat(final double[][] ort) {\n+\n+      final double[] quat = new double[4];\n+\n       // There are different ways to compute the quaternions elements\n       // from the matrix. They all involve computing one element from\n       // the diagonal of the matrix, and computing the three other ones\n@@ -255,41 +272,43 @@ public Rotation(double[][] m, double threshold)\n       double s = ort[0][0] + ort[1][1] + ort[2][2];\n       if (s > -0.19) {\n           // compute q0 and deduce q1, q2 and q3\n-      q0 = 0.5 * FastMath.sqrt(s + 1.0);\n-      double inv = 0.25 / q0;\n-      q1 = inv * (ort[1][2] - ort[2][1]);\n-      q2 = inv * (ort[2][0] - ort[0][2]);\n-      q3 = inv * (ort[0][1] - ort[1][0]);\n+          quat[0] = 0.5 * FastMath.sqrt(s + 1.0);\n+          double inv = 0.25 / quat[0];\n+          quat[1] = inv * (ort[1][2] - ort[2][1]);\n+          quat[2] = inv * (ort[2][0] - ort[0][2]);\n+          quat[3] = inv * (ort[0][1] - ort[1][0]);\n       } else {\n           s = ort[0][0] - ort[1][1] - ort[2][2];\n           if (s > -0.19) {\n               // compute q1 and deduce q0, q2 and q3\n-        q1 = 0.5 * FastMath.sqrt(s + 1.0);\n-        double inv = 0.25 / q1;\n-        q0 = inv * (ort[1][2] - ort[2][1]);\n-        q2 = inv * (ort[0][1] + ort[1][0]);\n-        q3 = inv * (ort[0][2] + ort[2][0]);\n+              quat[1] = 0.5 * FastMath.sqrt(s + 1.0);\n+              double inv = 0.25 / quat[1];\n+              quat[0] = inv * (ort[1][2] - ort[2][1]);\n+              quat[2] = inv * (ort[0][1] + ort[1][0]);\n+              quat[3] = inv * (ort[0][2] + ort[2][0]);\n           } else {\n               s = ort[1][1] - ort[0][0] - ort[2][2];\n               if (s > -0.19) {\n                   // compute q2 and deduce q0, q1 and q3\n-          q2 = 0.5 * FastMath.sqrt(s + 1.0);\n-          double inv = 0.25 / q2;\n-          q0 = inv * (ort[2][0] - ort[0][2]);\n-          q1 = inv * (ort[0][1] + ort[1][0]);\n-          q3 = inv * (ort[2][1] + ort[1][2]);\n+                  quat[2] = 0.5 * FastMath.sqrt(s + 1.0);\n+                  double inv = 0.25 / quat[2];\n+                  quat[0] = inv * (ort[2][0] - ort[0][2]);\n+                  quat[1] = inv * (ort[0][1] + ort[1][0]);\n+                  quat[3] = inv * (ort[2][1] + ort[1][2]);\n               } else {\n                   // compute q3 and deduce q0, q1 and q2\n                   s = ort[2][2] - ort[0][0] - ort[1][1];\n-          q3 = 0.5 * FastMath.sqrt(s + 1.0);\n-          double inv = 0.25 / q3;\n-          q0 = inv * (ort[0][1] - ort[1][0]);\n-          q1 = inv * (ort[0][2] + ort[2][0]);\n-          q2 = inv * (ort[2][1] + ort[1][2]);\n+                  quat[3] = 0.5 * FastMath.sqrt(s + 1.0);\n+                  double inv = 0.25 / quat[3];\n+                  quat[0] = inv * (ort[0][1] - ort[1][0]);\n+                  quat[1] = inv * (ort[0][2] + ort[2][0]);\n+                  quat[2] = inv * (ort[2][1] + ort[1][2]);\n               }\n           }\n       }\n \n+      return quat;\n+\n   }\n \n   /** Build the rotation that transforms a pair of vector into another pair.\n@@ -308,85 +327,48 @@ public Rotation(double[][] m, double threshold)\n    * @param u2 second vector of the origin pair\n    * @param v1 desired image of u1 by the rotation\n    * @param v2 desired image of u2 by the rotation\n-   * @exception MathIllegalArgumentException if the norm of one of the vectors is zero\n+   * @exception MathIllegalArgumentException if the norm of one of the vectors is zero,\n+   * or if one of the pair is degenerated (i.e. the vectors of the pair are colinear)\n    */\n-  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n-\n-  // norms computation\n-  double u1u1 = u1.getNormSq();\n-  double u2u2 = u2.getNormSq();\n-  double v1v1 = v1.getNormSq();\n-  double v2v2 = v2.getNormSq();\n-  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n-    throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n-  }\n-\n-  // normalize v1 in order to have (v1'|v1') = (u1|u1)\n-  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n-\n-  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\n-  double u1u2   = u1.dotProduct(u2);\n-  double v1v2   = v1.dotProduct(v2);\n-  double coeffU = u1u2 / u1u1;\n-  double coeffV = v1v2 / u1u1;\n-  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n-  double alpha  = coeffU - beta * coeffV;\n-  v2 = new Vector3D(alpha, v1, beta, v2);\n-\n-  // preliminary computation\n-  Vector3D uRef  = u1;\n-  Vector3D vRef  = v1;\n-  Vector3D v1Su1 = v1.subtract(u1);\n-  Vector3D v2Su2 = v2.subtract(u2);\n-  Vector3D k     = v1Su1.crossProduct(v2Su2);\n-  Vector3D u3    = u1.crossProduct(u2);\n-  double c       = k.dotProduct(u3);\n-  final double inPlaneThreshold = 0.001;\n-  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);\n-      c = k.dotProduct(u2.crossProduct(u3));\n-\n-      if (c <= 0) {\n-        // the (q1, q2, q3) vector is aligned with everything\n-        // this is really the identity rotation\n-        q0 = 1.0;\n-        q1 = 0.0;\n-        q2 = 0.0;\n-        q3 = 0.0;\n-        return;\n-      }\n-\n-      // we will have to use u2 and v2 to compute the scalar part\n-      uRef = u2;\n-      vRef = v2;\n-\n-    }\n-\n+  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2)\n+      throws MathIllegalArgumentException {\n+\n+      // build orthonormalized base from u1, u2\n+      // this fails when vectors are null or colinear, which is forbidden to define a rotation\n+      final Vector3D u3 = u1.crossProduct(u2).normalize();\n+      u2 = u3.crossProduct(u1).normalize();\n+      u1 = u1.normalize();\n+\n+      // build an orthonormalized base from v1, v2\n+      // this fails when vectors are null or colinear, which is forbidden to define a rotation\n+      final Vector3D v3 = v1.crossProduct(v2).normalize();\n+      v2 = v3.crossProduct(v1).normalize();\n+      v1 = v1.normalize();\n+\n+      // buid a matrix transforming the first base into the second one\n+      final double[][] m = new double[][] {\n+          {\n+              MathArrays.linearCombination(u1.getX(), v1.getX(), u2.getX(), v2.getX(), u3.getX(), v3.getX()),\n+              MathArrays.linearCombination(u1.getY(), v1.getX(), u2.getY(), v2.getX(), u3.getY(), v3.getX()),\n+              MathArrays.linearCombination(u1.getZ(), v1.getX(), u2.getZ(), v2.getX(), u3.getZ(), v3.getX())\n+          },\n+          {\n+              MathArrays.linearCombination(u1.getX(), v1.getY(), u2.getX(), v2.getY(), u3.getX(), v3.getY()),\n+              MathArrays.linearCombination(u1.getY(), v1.getY(), u2.getY(), v2.getY(), u3.getY(), v3.getY()),\n+              MathArrays.linearCombination(u1.getZ(), v1.getY(), u2.getZ(), v2.getY(), u3.getZ(), v3.getY())\n+          },\n+          {\n+              MathArrays.linearCombination(u1.getX(), v1.getZ(), u2.getX(), v2.getZ(), u3.getX(), v3.getZ()),\n+              MathArrays.linearCombination(u1.getY(), v1.getZ(), u2.getY(), v2.getZ(), u3.getY(), v3.getZ()),\n+              MathArrays.linearCombination(u1.getZ(), v1.getZ(), u2.getZ(), v2.getZ(), u3.getZ(), v3.getZ())\n           }\n+      };\n \n-  // compute the vectorial part\n-  c = FastMath.sqrt(c);\n-  double inv = 1.0 / (c + c);\n-  q1 = inv * k.getX();\n-  q2 = inv * k.getY();\n-  q3 = inv * k.getZ();\n-\n-  // compute the scalar part\n-   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n-                    uRef.getZ() * q1 - uRef.getX() * q3,\n-                    uRef.getX() * q2 - uRef.getY() * q1);\n-  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n+      double[] quat = mat2quat(m);\n+      q0 = quat[0];\n+      q1 = quat[1];\n+      q2 = quat[2];\n+      q3 = quat[3];\n \n   }\n \n",
        "project": "commons-math",
        "linesAdd": 67,
        "jira_id": "801",
        "nb_skipped": 1,
        "commit": "118e94b5",
        "nb_failure": 1,
        "linesRem": 82,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4224,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.random.SynchronizedRandomGeneratorTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/random/SynchronizedRandomGenerator.java b/src/main/java/org/apache/commons/math3/random/SynchronizedRandomGenerator.java\nindex 54c006dee..d28f74bf6 100644\n--- a/src/main/java/org/apache/commons/math3/random/SynchronizedRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/random/SynchronizedRandomGenerator.java\n@@ -82,7 +82,7 @@ public synchronized int nextInt() {\n      * {@inheritDoc}\n      */\n     public synchronized int nextInt(int n) {\n-        return wrapped.nextInt();\n+        return wrapped.nextInt(n);\n     }\n \n     /**\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "899",
        "nb_skipped": 4,
        "commit": "ce126bdb",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 5400,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.linear.EigenDecompositionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java b/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\nindex a2ea88ee4..b566de766 100644\n--- a/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\n+++ b/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\n@@ -364,15 +364,13 @@ private void performDoubleQRStep(final int il, final int im, final int iu,\n                 q = matrixT[k + 1][k - 1];\n                 r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                 shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n-                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n+                if (Precision.equals(shift.x, 0.0, epsilon)) {\n+                    continue;\n+                }\n                 p = p / shift.x;\n                 q = q / shift.x;\n                 r = r / shift.x;\n             }\n-            }\n-            if (shift.x == 0.0) {\n-                break;\n-            }\n             double s = FastMath.sqrt(p * p + q * q + r * r);\n             if (p < 0.0) {\n                 s = -s;\n",
        "project": "commons-math",
        "linesAdd": 3,
        "jira_id": "1051",
        "nb_skipped": 4,
        "commit": "bda25b40",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5850,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.random.CorrelatedRandomVectorGeneratorTest",
            "org.apache.commons.math4.util.ResizableDoubleArrayTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java b/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java\nindex b0dd132d2..09fd7482b 100644\n--- a/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java\n@@ -21,21 +21,15 @@\n \n import org.apache.commons.math4.exception.MathIllegalArgumentException;\n import org.apache.commons.math4.exception.MathIllegalStateException;\n-import org.apache.commons.math4.exception.MathInternalError;\n import org.apache.commons.math4.exception.NotStrictlyPositiveException;\n import org.apache.commons.math4.exception.NullArgumentException;\n import org.apache.commons.math4.exception.NumberIsTooSmallException;\n import org.apache.commons.math4.exception.util.LocalizedFormats;\n \n /**\n- * <p>\n  * A variable length {@link DoubleArray} implementation that automatically\n  * handles expanding and contracting its internal storage array as elements\n  * are added and removed.\n- * </p>\n- * <h3>Important note: Usage should not assume that this class is thread-safe\n- * even though some of the methods are {@code synchronized}.\n- * This qualifier will be dropped in the next major release (4.0).</h3>\n  * <p>\n  * The internal storage array starts with capacity determined by the\n  * {@code initialCapacity} property, which can be set by the constructor.\n@@ -51,7 +45,6 @@\n  * locations added).\n  * The default {@code expansionMode} is {@code MULTIPLICATIVE} and the default\n  * {@code expansionFactor} is 2.\n- * </p>\n  * <p>\n  * The {@link #addElementRolling(double)} method adds a new element to the end\n  * of the internal storage array and adjusts the \"usable window\" of the\n@@ -71,26 +64,16 @@\n  * {@code contractionFactor.}  If the {@code expansionMode}\n  * is {@code ADDITIVE}, the number of excess storage locations\n  * is compared to {@code contractionFactor}.\n- * </p>\n  * <p>\n  * To avoid cycles of expansions and contractions, the\n  * {@code expansionFactor} must not exceed the {@code contractionFactor}.\n  * Constructors and mutators for both of these properties enforce this\n  * requirement, throwing a {@code MathIllegalArgumentException} if it is\n  * violated.\n- * </p>\n+ * <p>\n+ * <b>Note:</b> this class is <b>NOT</b> thread-safe.\n  */\n public class ResizableDoubleArray implements DoubleArray, Serializable {\n-    /** Additive expansion mode.\n-     * @deprecated As of 3.1. Please use {@link ExpansionMode#ADDITIVE} instead.\n-     */\n-    @Deprecated\n-    public static final int ADDITIVE_MODE = 1;\n-    /** Multiplicative expansion mode.\n-     * @deprecated As of 3.1. Please use {@link ExpansionMode#MULTIPLICATIVE} instead.\n-     */\n-    @Deprecated\n-    public static final int MULTIPLICATIVE_MODE = 0;\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -3485529955529426875L;\n \n@@ -98,6 +81,8 @@\n     private static final int DEFAULT_INITIAL_CAPACITY = 16;\n     /** Default value for array size modifier. */\n     private static final double DEFAULT_EXPANSION_FACTOR = 2.0;\n+    /** Default value for expansion mode. */\n+    private static final ExpansionMode DEFAULT_EXPANSION_MODE = ExpansionMode.MULTIPLICATIVE;\n     /**\n      * Default value for the difference between {@link #contractionCriterion}\n      * and {@link #expansionFactor}.\n@@ -109,23 +94,22 @@\n      * contracted to fit the number of elements contained in the element\n      *  array + 1.\n      */\n-    private double contractionCriterion = 2.5;\n+    private final double contractionCriterion;\n \n     /**\n      * The expansion factor of the array.  When the array needs to be expanded,\n-     * the new array size will be\n-     * {@code internalArray.length * expansionFactor}\n-     * if {@code expansionMode} is set to MULTIPLICATIVE_MODE, or\n+     * the new array size will be {@code internalArray.length * expansionFactor}\n+     * if {@code expansionMode} is set to MULTIPLICATIVE, or\n      * {@code internalArray.length + expansionFactor} if\n-     * {@code expansionMode} is set to ADDITIVE_MODE.\n+     * {@code expansionMode} is set to ADDITIVE.\n      */\n-    private double expansionFactor = 2.0;\n+    private final double expansionFactor;\n \n     /**\n      * Determines whether array expansion by {@code expansionFactor}\n      * is additive or multiplicative.\n      */\n-    private ExpansionMode expansionMode = ExpansionMode.MULTIPLICATIVE;\n+    private final ExpansionMode expansionMode;\n \n     /**\n      * The internal storage array.\n@@ -171,6 +155,7 @@ public ResizableDoubleArray() {\n \n     /**\n      * Creates an instance with the specified initial capacity.\n+     * <p>\n      * Other properties take default values:\n      * <ul>\n      *  <li>{@code expansionMode = MULTIPLICATIVE}</li>\n@@ -180,8 +165,7 @@ public ResizableDoubleArray() {\n      * @param initialCapacity Initial size of the internal storage array.\n      * @throws MathIllegalArgumentException if {@code initialCapacity <= 0}.\n      */\n-    public ResizableDoubleArray(int initialCapacity)\n-        throws MathIllegalArgumentException {\n+    public ResizableDoubleArray(int initialCapacity) throws MathIllegalArgumentException {\n         this(initialCapacity, DEFAULT_EXPANSION_FACTOR);\n     }\n \n@@ -189,6 +173,7 @@ public ResizableDoubleArray(int initialCapacity)\n      * Creates an instance from an existing {@code double[]} with the\n      * initial capacity and numElements corresponding to the size of\n      * the supplied {@code double[]} array.\n+     * <p>\n      * If the supplied array is null, a new empty array with the default\n      * initial capacity will be created.\n      * The input array is copied, not referenced.\n@@ -207,177 +192,66 @@ public ResizableDoubleArray(double[] initialArray) {\n         this(DEFAULT_INITIAL_CAPACITY,\n              DEFAULT_EXPANSION_FACTOR,\n              DEFAULT_CONTRACTION_DELTA + DEFAULT_EXPANSION_FACTOR,\n-             ExpansionMode.MULTIPLICATIVE,\n+             DEFAULT_EXPANSION_MODE,\n              initialArray);\n     }\n \n     /**\n      * Creates an instance with the specified initial capacity\n      * and expansion factor.\n+     * <p>\n      * The remaining properties take default values:\n      * <ul>\n      *  <li>{@code expansionMode = MULTIPLICATIVE}</li>\n      *  <li>{@code contractionCriterion = 0.5 + expansionFactor}</li>\n      * </ul>\n-     * <br/>\n-     * Throws IllegalArgumentException if the following conditions are\n-     * not met:\n-     * <ul>\n-     *  <li>{@code initialCapacity > 0}</li>\n-     *  <li>{@code expansionFactor > 1}</li>\n-     * </ul>\n-     *\n-     * @param initialCapacity Initial size of the internal storage array.\n-     * @param expansionFactor The array will be expanded based on this\n-     * parameter.\n-     * @throws MathIllegalArgumentException if parameters are not valid.\n-     * @deprecated As of 3.1. Please use\n-     * {@link #ResizableDoubleArray(int,double)} instead.\n-     */\n-    @Deprecated\n-    public ResizableDoubleArray(int initialCapacity,\n-                                float expansionFactor)\n-        throws MathIllegalArgumentException {\n-        this(initialCapacity,\n-             (double) expansionFactor);\n-    }\n-\n-    /**\n-     * Creates an instance with the specified initial capacity\n-     * and expansion factor.\n-     * The remaining properties take default values:\n-     * <ul>\n-     *  <li>{@code expansionMode = MULTIPLICATIVE}</li>\n-     *  <li>{@code contractionCriterion = 0.5 + expansionFactor}</li>\n-     * </ul>\n-     * <br/>\n-     * Throws IllegalArgumentException if the following conditions are\n-     * not met:\n+     * <p>\n+     * Throws MathIllegalArgumentException if the following conditions\n+     * are not met:\n      * <ul>\n      *  <li>{@code initialCapacity > 0}</li>\n      *  <li>{@code expansionFactor > 1}</li>\n      * </ul>\n      *\n      * @param initialCapacity Initial size of the internal storage array.\n-     * @param expansionFactor The array will be expanded based on this\n-     * parameter.\n+     * @param expansionFactor The array will be expanded based on this parameter.\n      * @throws MathIllegalArgumentException if parameters are not valid.\n      * @since 3.1\n      */\n-    public ResizableDoubleArray(int initialCapacity,\n-                                double expansionFactor)\n-        throws MathIllegalArgumentException {\n-        this(initialCapacity,\n-             expansionFactor,\n-             DEFAULT_CONTRACTION_DELTA + expansionFactor);\n-    }\n-\n-    /**\n-     * Creates an instance with the specified initialCapacity,\n-     * expansionFactor, and contractionCriterion.\n-     * The expansion mode will default to {@code MULTIPLICATIVE}.\n-     * <br/>\n-     * Throws IllegalArgumentException if the following conditions are\n-     * not met:\n-     * <ul>\n-     *  <li>{@code initialCapacity > 0}</li>\n-     *  <li>{@code expansionFactor > 1}</li>\n-     *  <li>{@code contractionCriterion >= expansionFactor}</li>\n-     * </ul>\n-     *\n-     * @param initialCapacity Initial size of the internal storage array..\n-     * @param expansionFactor The array will be expanded based on this\n-     * parameter.\n-     * @param contractionCriteria Contraction criteria.\n-     * @throws MathIllegalArgumentException if parameters are not valid.\n-     * @deprecated As of 3.1. Please use\n-     * {@link #ResizableDoubleArray(int,double,double)} instead.\n-     */\n-    @Deprecated\n-    public ResizableDoubleArray(int initialCapacity,\n-                                float expansionFactor,\n-                                float contractionCriteria)\n-        throws MathIllegalArgumentException {\n-        this(initialCapacity,\n-             (double) expansionFactor,\n-             (double) contractionCriteria);\n+    public ResizableDoubleArray(int initialCapacity, double expansionFactor) throws MathIllegalArgumentException {\n+        this(initialCapacity, expansionFactor, DEFAULT_CONTRACTION_DELTA + expansionFactor);\n     }\n \n     /**\n      * Creates an instance with the specified initial capacity,\n      * expansion factor, and contraction criteria.\n+     * <p>\n      * The expansion mode will default to {@code MULTIPLICATIVE}.\n-     * <br/>\n-     * Throws IllegalArgumentException if the following conditions are\n-     * not met:\n+     * <p>\n+     * Throws MathIllegalArgumentException if the following conditions\n+     * are not met:\n      * <ul>\n      *  <li>{@code initialCapacity > 0}</li>\n      *  <li>{@code expansionFactor > 1}</li>\n      *  <li>{@code contractionCriterion >= expansionFactor}</li>\n      * </ul>\n      *\n-     * @param initialCapacity Initial size of the internal storage array..\n-     * @param expansionFactor The array will be expanded based on this\n-     * parameter.\n+     * @param initialCapacity Initial size of the internal storage array.\n+     * @param expansionFactor The array will be expanded based on this parameter.\n      * @param contractionCriterion Contraction criterion.\n      * @throws MathIllegalArgumentException if the parameters are not valid.\n      * @since 3.1\n      */\n-    public ResizableDoubleArray(int initialCapacity,\n-                                double expansionFactor,\n-                                double contractionCriterion)\n+    public ResizableDoubleArray(int initialCapacity, double expansionFactor, double contractionCriterion)\n         throws MathIllegalArgumentException {\n-        this(initialCapacity,\n-             expansionFactor,\n-             contractionCriterion,\n-             ExpansionMode.MULTIPLICATIVE,\n-             null);\n-    }\n-\n-    /**\n-     * <p>\n-     * Create a ResizableArray with the specified properties.</p>\n-     * <p>\n-     * Throws IllegalArgumentException if the following conditions are\n-     * not met:\n-     * <ul>\n-     * <li><code>initialCapacity > 0</code></li>\n-     * <li><code>expansionFactor > 1</code></li>\n-     * <li><code>contractionFactor >= expansionFactor</code></li>\n-     * <li><code>expansionMode in {MULTIPLICATIVE_MODE, ADDITIVE_MODE}</code>\n-     * </li>\n-     * </ul></p>\n-     *\n-     * @param initialCapacity the initial size of the internal storage array\n-     * @param expansionFactor the array will be expanded based on this\n-     *                        parameter\n-     * @param contractionCriteria the contraction Criteria\n-     * @param expansionMode  the expansion mode\n-     * @throws MathIllegalArgumentException if parameters are not valid\n-     * @deprecated As of 3.1. Please use\n-     * {@link #ResizableDoubleArray(int,double,double,ExpansionMode,double[])}\n-     * instead.\n-     */\n-    @Deprecated\n-    public ResizableDoubleArray(int initialCapacity, float expansionFactor,\n-            float contractionCriteria, int expansionMode) throws MathIllegalArgumentException {\n-        this(initialCapacity,\n-             expansionFactor,\n-             contractionCriteria,\n-             expansionMode == ADDITIVE_MODE ?\n-             ExpansionMode.ADDITIVE :\n-             ExpansionMode.MULTIPLICATIVE,\n-             null);\n-        // XXX Just ot retain the expected failure in a unit test.\n-        // With the new \"enum\", that test will become obsolete.\n-        setExpansionMode(expansionMode);\n+        this(initialCapacity, expansionFactor, contractionCriterion, DEFAULT_EXPANSION_MODE, null);\n     }\n \n     /**\n      * Creates an instance with the specified properties.\n      * <br/>\n-     * Throws MathIllegalArgumentException if the following conditions are\n-     * not met:\n+     * Throws MathIllegalArgumentException if the following conditions\n+     * are not met:\n      * <ul>\n      *  <li>{@code initialCapacity > 0}</li>\n      *  <li>{@code expansionFactor > 1}</li>\n@@ -385,12 +259,12 @@ public ResizableDoubleArray(int initialCapacity, float expansionFactor,\n      * </ul>\n      *\n      * @param initialCapacity Initial size of the internal storage array.\n-     * @param expansionFactor The array will be expanded based on this\n-     * parameter.\n+     * @param expansionFactor The array will be expanded based on this parameter.\n      * @param contractionCriterion Contraction criteria.\n      * @param expansionMode Expansion mode.\n      * @param data Initial contents of the array.\n      * @throws MathIllegalArgumentException if the parameters are not valid.\n+     * @throws NullArgumentException if expansionMode is null\n      */\n     public ResizableDoubleArray(int initialCapacity,\n                                 double expansionFactor,\n@@ -403,6 +277,7 @@ public ResizableDoubleArray(int initialCapacity,\n                                                    initialCapacity);\n         }\n         checkContractExpand(contractionCriterion, expansionFactor);\n+        MathUtils.checkNotNull(expansionMode);\n \n         this.expansionFactor = expansionFactor;\n         this.contractionCriterion = contractionCriterion;\n@@ -417,19 +292,25 @@ public ResizableDoubleArray(int initialCapacity,\n     }\n \n     /**\n-     * Copy constructor.  Creates a new ResizableDoubleArray that is a deep,\n-     * fresh copy of the original. Needs to acquire synchronization lock\n-     * on original.  Original may not be null; otherwise a {@link NullArgumentException}\n-     * is thrown.\n+     * Copy constructor.\n+     * <p>\n+     * Creates a new ResizableDoubleArray that is a deep, fresh copy of the original.\n+     * Original may not be null; otherwise a {@link NullArgumentException} is thrown.\n      *\n      * @param original array to copy\n      * @exception NullArgumentException if original is null\n      * @since 2.0\n      */\n-    public ResizableDoubleArray(ResizableDoubleArray original)\n+    public ResizableDoubleArray(final ResizableDoubleArray original)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(original);\n-        copy(original, this);\n+        this.contractionCriterion = original.contractionCriterion;\n+        this.expansionFactor = original.expansionFactor;\n+        this.expansionMode = original.expansionMode;\n+        this.internalArray = new double[original.internalArray.length];\n+        System.arraycopy(original.internalArray, 0, this.internalArray, 0, this.internalArray.length);\n+        this.numElements = original.numElements;\n+        this.startIndex = original.startIndex;\n     }\n \n     /**\n@@ -438,7 +319,7 @@ public ResizableDoubleArray(ResizableDoubleArray original)\n      * @param value Value to be added to end of array.\n      */\n     @Override\n-    public synchronized void addElement(double value) {\n+    public void addElement(final double value) {\n         if (internalArray.length <= startIndex + numElements) {\n             expand();\n         }\n@@ -452,7 +333,7 @@ public synchronized void addElement(double value) {\n      * @since 2.2\n      */\n     @Override\n-    public synchronized void addElements(double[] values) {\n+    public void addElements(final double[] values) {\n         final double[] tempArray = new double[numElements + values.length + 1];\n         System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);\n         System.arraycopy(values, 0, tempArray, numElements, values.length);\n@@ -462,23 +343,21 @@ public synchronized void addElements(double[] values) {\n     }\n \n     /**\n-     * <p>\n      * Adds an element to the end of the array and removes the first\n      * element in the array.  Returns the discarded first element.\n+     * <p>\n      * The effect is similar to a push operation in a FIFO queue.\n-     * </p>\n      * <p>\n      * Example: If the array contains the elements 1, 2, 3, 4 (in that order)\n      * and addElementRolling(5) is invoked, the result is an array containing\n      * the entries 2, 3, 4, 5 and the value returned is 1.\n-     * </p>\n      *\n      * @param value Value to be added to the array.\n      * @return the value which has been discarded or \"pushed\" out of the array\n      * by this rolling insert.\n      */\n     @Override\n-    public synchronized double addElementRolling(double value) {\n+    public double addElementRolling(double value) {\n         double discarded = internalArray[startIndex];\n \n         if ((startIndex + (numElements + 1)) > internalArray.length) {\n@@ -498,20 +377,19 @@ public synchronized double addElementRolling(double value) {\n     }\n \n     /**\n-     * Substitutes <code>value</code> for the most recently added value.\n+     * Substitutes {@code value} for the most recently added value.\n+     * <p>\n      * Returns the value that has been replaced. If the array is empty (i.e.\n-     * if {@link #numElements} is zero), an IllegalStateException is thrown.\n+     * if {@link #numElements} is zero), an MathIllegalStateException is thrown.\n      *\n      * @param value New value to substitute for the most recently added value\n      * @return the value that has been replaced in the array.\n      * @throws MathIllegalStateException if the array is empty\n      * @since 2.0\n      */\n-    public synchronized double substituteMostRecentElement(double value)\n-        throws MathIllegalStateException {\n+    public double substituteMostRecentElement(double value) throws MathIllegalStateException {\n         if (numElements < 1) {\n-            throw new MathIllegalStateException(\n-                    LocalizedFormats.CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY);\n+            throw new MathIllegalStateException(LocalizedFormats.CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY);\n         }\n \n         final int substIndex = startIndex + (numElements - 1);\n@@ -522,25 +400,6 @@ public synchronized double substituteMostRecentElement(double value)\n         return discarded;\n     }\n \n-    /**\n-     * Checks the expansion factor and the contraction criterion and throws an\n-     * IllegalArgumentException if the contractionCriteria is less than the\n-     * expansionCriteria\n-     *\n-     * @param expansion factor to be checked\n-     * @param contraction criteria to be checked\n-     * @throws MathIllegalArgumentException if the contractionCriteria is less than\n-     * the expansionCriteria.\n-     * @deprecated As of 3.1. Please use\n-     * {@link #checkContractExpand(double,double)} instead.\n-     */\n-    @Deprecated\n-    protected void checkContractExpand(float contraction, float expansion)\n-        throws MathIllegalArgumentException {\n-        checkContractExpand((double) contraction,\n-                            (double) expansion);\n-    }\n-\n     /**\n      * Checks the expansion factor and the contraction criterion and raises\n      * an exception if the contraction criterion is smaller than the\n@@ -553,9 +412,7 @@ protected void checkContractExpand(float contraction, float expansion)\n      * @throws NumberIsTooSmallException if {@code expansion <= 1 }.\n      * @since 3.1\n      */\n-    protected void checkContractExpand(double contraction,\n-                                       double expansion)\n-        throws NumberIsTooSmallException {\n+    protected void checkContractExpand(double contraction, double expansion) throws NumberIsTooSmallException {\n         if (contraction < expansion) {\n             final NumberIsTooSmallException e = new NumberIsTooSmallException(contraction, 1, true);\n             e.getContext().addMessage(LocalizedFormats.CONTRACTION_CRITERIA_SMALLER_THAN_EXPANSION_FACTOR,\n@@ -582,17 +439,16 @@ protected void checkContractExpand(double contraction,\n      * Clear the array contents, resetting the number of elements to zero.\n      */\n     @Override\n-    public synchronized void clear() {\n+    public void clear() {\n         numElements = 0;\n         startIndex = 0;\n     }\n \n     /**\n-     * Contracts the storage array to the (size of the element set) + 1 - to\n-     * avoid a zero length array. This function also resets the startIndex to\n-     * zero.\n+     * Contracts the storage array to the (size of the element set) + 1 - to avoid\n+     * a zero length array. This function also resets the startIndex to zero.\n      */\n-    public synchronized void contract() {\n+    public void contract() {\n         final double[] tempArray = new double[numElements + 1];\n \n         // Copy and swap - copy only the element array from the src array.\n@@ -604,48 +460,45 @@ public synchronized void contract() {\n     }\n \n     /**\n-     * Discards the <code>i</code> initial elements of the array.  For example,\n-     * if the array contains the elements 1,2,3,4, invoking\n-     * <code>discardFrontElements(2)</code> will cause the first two elements\n-     * to be discarded, leaving 3,4 in the array.  Throws illegalArgumentException\n-     * if i exceeds numElements.\n+     * Discards the {@code i} initial elements of the array.\n+     * <p>\n+     * For example, if the array contains the elements 1,2,3,4, invoking\n+     * {@code discardFrontElements(2)} will cause the first two elements\n+     * to be discarded, leaving 3,4 in the array.\n      *\n      * @param i  the number of elements to discard from the front of the array\n      * @throws MathIllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n      */\n-    public synchronized void discardFrontElements(int i)\n-        throws MathIllegalArgumentException {\n+    public void discardFrontElements(int i) throws MathIllegalArgumentException {\n         discardExtremeElements(i,true);\n     }\n \n     /**\n-     * Discards the <code>i</code> last elements of the array.  For example,\n-     * if the array contains the elements 1,2,3,4, invoking\n-     * <code>discardMostRecentElements(2)</code> will cause the last two elements\n-     * to be discarded, leaving 1,2 in the array.  Throws illegalArgumentException\n-     * if i exceeds numElements.\n+     * Discards the {@code i} last elements of the array.\n+     * <p>\n+     * For example, if the array contains the elements 1,2,3,4, invoking\n+     * {@code discardMostRecentElements(2)} will cause the last two elements\n+     * to be discarded, leaving 1,2 in the array.\n      *\n      * @param i  the number of elements to discard from the end of the array\n      * @throws MathIllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n      */\n-    public synchronized void discardMostRecentElements(int i)\n-        throws MathIllegalArgumentException {\n+    public void discardMostRecentElements(int i) throws MathIllegalArgumentException {\n         discardExtremeElements(i,false);\n     }\n \n     /**\n-     * Discards the <code>i</code> first or last elements of the array,\n-     * depending on the value of <code>front</code>.\n+     * Discards the {@code i} first or last elements of the array,\n+     * depending on the value of {@code front}.\n+     * <p>\n      * For example, if the array contains the elements 1,2,3,4, invoking\n-     * <code>discardExtremeElements(2,false)</code> will cause the last two elements\n+     * {@code discardExtremeElements(2,false)} will cause the last two elements\n      * to be discarded, leaving 1,2 in the array.\n      * For example, if the array contains the elements 1,2,3,4, invoking\n-     * <code>discardExtremeElements(2,true)</code> will cause the first two elements\n+     * {@code discardExtremeElements(2,true)} will cause the first two elements\n      * to be discarded, leaving 3,4 in the array.\n-     * Throws illegalArgumentException\n-     * if i exceeds numElements.\n      *\n      * @param i  the number of elements to discard from the front/end of the array\n      * @param front true if elements are to be discarded from the front\n@@ -654,9 +507,7 @@ public synchronized void discardMostRecentElements(int i)\n      * @throws MathIllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n      */\n-    private synchronized void discardExtremeElements(int i,\n-                                                     boolean front)\n-        throws MathIllegalArgumentException {\n+    private void discardExtremeElements(int i, boolean front) throws MathIllegalArgumentException {\n         if (i > numElements) {\n             throw new MathIllegalArgumentException(\n                     LocalizedFormats.TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY,\n@@ -680,13 +531,12 @@ private synchronized void discardExtremeElements(int i,\n     /**\n      * Expands the internal storage array using the expansion factor.\n      * <p>\n-     * if <code>expansionMode</code> is set to MULTIPLICATIVE_MODE,\n-     * the new array size will be <code>internalArray.length * expansionFactor.</code>\n-     * If <code>expansionMode</code> is set to ADDITIVE_MODE,  the length\n-     * after expansion will be <code>internalArray.length + expansionFactor</code>\n-     * </p>\n+     * If {@code expansionMode} is set to MULTIPLICATIVE,\n+     * the new array size will be {@code internalArray.length * expansionFactor}.\n+     * If {@code expansionMode} is set to ADDITIVE, the length\n+     * after expansion will be {@code internalArray.length + expansionFactor}.\n      */\n-    protected synchronized void expand() {\n+    protected void expand() {\n         // notice the use of FastMath.ceil(), this guarantees that we will always\n         // have an array of at least currentSize + 1.   Assume that the\n         // current initial capacity is 1 and the expansion factor\n@@ -710,41 +560,22 @@ protected synchronized void expand() {\n      *\n      * @param size Size of the new internal storage array.\n      */\n-    private synchronized void expandTo(int size) {\n+    private void expandTo(int size) {\n         final double[] tempArray = new double[size];\n         // Copy and swap\n         System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n         internalArray = tempArray;\n     }\n \n-    /**\n-     * The contraction criteria defines when the internal array will contract\n-     * to store only the number of elements in the element array.\n-     * If  the <code>expansionMode</code> is <code>MULTIPLICATIVE_MODE</code>,\n-     * contraction is triggered when the ratio between storage array length\n-     * and <code>numElements</code> exceeds <code>contractionFactor</code>.\n-     * If the <code>expansionMode</code> is <code>ADDITIVE_MODE</code>, the\n-     * number of excess storage locations is compared to\n-     * <code>contractionFactor.</code>\n-     *\n-     * @return the contraction criteria used to reclaim memory.\n-     * @deprecated As of 3.1. Please use {@link #getContractionCriterion()}\n-     * instead.\n-     */\n-    @Deprecated\n-    public float getContractionCriteria() {\n-        return (float) getContractionCriterion();\n-    }\n-\n     /**\n      * The contraction criterion defines when the internal array will contract\n      * to store only the number of elements in the element array.\n-     * If  the <code>expansionMode</code> is <code>MULTIPLICATIVE_MODE</code>,\n+     * <p>\n+     * If the {@code expansionMode} is {@code MULTIPLICATIVE},\n      * contraction is triggered when the ratio between storage array length\n-     * and <code>numElements</code> exceeds <code>contractionFactor</code>.\n-     * If the <code>expansionMode</code> is <code>ADDITIVE_MODE</code>, the\n-     * number of excess storage locations is compared to\n-     * <code>contractionFactor.</code>\n+     * and {@code numElements} exceeds {@code contractionFactor}.\n+     * If the {@code expansionMode} is {@code ADDITIVE}, the\n+     * number of excess storage locations is compared to {@code contractionFactor}.\n      *\n      * @return the contraction criterion used to reclaim memory.\n      * @since 3.1\n@@ -754,15 +585,15 @@ public double getContractionCriterion() {\n     }\n \n     /**\n-     * Returns the element at the specified index\n+     * Returns the element at the specified index.\n      *\n      * @param index index to fetch a value from\n      * @return value stored at the specified index\n-     * @throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n-     * zero or is greater than <code>getNumElements() - 1</code>.\n+     * @throws ArrayIndexOutOfBoundsException if {@code index} is less than\n+     * zero or is greater than {@code getNumElements() - 1}.\n      */\n     @Override\n-    public synchronized double getElement(int index) {\n+    public double getElement(int index) {\n         if (index >= numElements) {\n             throw new ArrayIndexOutOfBoundsException(index);\n         } else if (index >= 0) {\n@@ -773,14 +604,15 @@ public synchronized double getElement(int index) {\n     }\n \n      /**\n-     * Returns a double array containing the elements of this\n-     * <code>ResizableArray</code>.  This method returns a copy, not a\n-     * reference to the underlying array, so that changes made to the returned\n-     *  array have no effect on this <code>ResizableArray.</code>\n+     * Returns a double array containing the elements of this ResizableArray.\n+     * <p>\n+     * This method returns a copy, not a reference to the underlying array,\n+     * so that changes made to the returned array have no effect on this ResizableArray.\n+     *\n      * @return the double array.\n      */\n     @Override\n-    public synchronized double[] getElements() {\n+    public double[] getElements() {\n         final double[] elementArray = new double[numElements];\n         System.arraycopy(internalArray, startIndex, elementArray, 0, numElements);\n         return elementArray;\n@@ -788,20 +620,18 @@ public synchronized double getElement(int index) {\n \n     /**\n      * The expansion factor controls the size of a new array when an array\n-     * needs to be expanded.  The <code>expansionMode</code>\n-     * determines whether the size of the array is multiplied by the\n-     * <code>expansionFactor</code> (MULTIPLICATIVE_MODE) or if\n-     * the expansion is additive (ADDITIVE_MODE -- <code>expansionFactor</code>\n-     * storage locations added).  The default <code>expansionMode</code> is\n-     * MULTIPLICATIVE_MODE and the default <code>expansionFactor</code>\n-     * is 2.0.\n+     * needs to be expanded.\n+     * <p>\n+     * The {@code expansionMode} determines whether the size of the array\n+     * is multiplied by the {@code expansionFactor} (MULTIPLICATIVE) or if\n+     * the expansion is additive (ADDITIVE -- {@code expansionFactor}\n+     * storage locations added).  The default {@code expansionMode} is\n+     * MULTIPLICATIVE and the default {@code expansionFactor} is 2.0.\n      *\n      * @return the expansion factor of this expandable double array\n-     * @deprecated As of 3.1. Return type will be changed to \"double\" in 4.0.\n      */\n-    @Deprecated\n-    public float getExpansionFactor() {\n-        return (float) expansionFactor;\n+    public double getExpansionFactor() {\n+        return expansionFactor;\n     }\n \n     /**\n@@ -809,33 +639,9 @@ public float getExpansionFactor() {\n      * array grows additively or multiplicatively when it is expanded.\n      *\n      * @return the expansion mode.\n-     * @deprecated As of 3.1. Return value to be changed to\n-     * {@link ExpansionMode} in 4.0.\n-     */\n-    @Deprecated\n-    public int getExpansionMode() {\n-        switch (expansionMode) {\n-        case MULTIPLICATIVE:\n-            return MULTIPLICATIVE_MODE;\n-        case ADDITIVE:\n-            return ADDITIVE_MODE;\n-        default:\n-            throw new MathInternalError(); // Should never happen.\n-        }\n-    }\n-\n-    /**\n-     * Notice the package scope on this method.   This method is simply here\n-     * for the JUnit test, it allows us check if the expansion is working\n-     * properly after a number of expansions.  This is not meant to be a part\n-     * of the public interface of this class.\n-     *\n-     * @return the length of the internal storage array.\n-     * @deprecated As of 3.1. Please use {@link #getCapacity()} instead.\n      */\n-    @Deprecated\n-    synchronized int getInternalLength() {\n-        return internalArray.length;\n+    public ExpansionMode getExpansionMode() {\n+        return expansionMode;\n     }\n \n     /**\n@@ -858,41 +664,23 @@ public int getCapacity() {\n      * @return the number of elements.\n      */\n     @Override\n-    public synchronized int getNumElements() {\n+    public int getNumElements() {\n         return numElements;\n     }\n \n-    /**\n-     * Returns the internal storage array.  Note that this method returns\n-     * a reference to the internal storage array, not a copy, and to correctly\n-     * address elements of the array, the <code>startIndex</code> is\n-     * required (available via the {@link #start} method).  This method should\n-     * only be used in cases where copying the internal array is not practical.\n-     * The {@link #getElements} method should be used in all other cases.\n-     *\n-     *\n-     * @return the internal storage array used by this object\n-     * @since 2.0\n-     * @deprecated As of 3.1.\n-     */\n-    @Deprecated\n-    public synchronized double[] getInternalValues() {\n-        return internalArray;\n-    }\n-\n     /**\n      * Provides <em>direct</em> access to the internal storage array.\n      * Please note that this method returns a reference to this object's\n      * storage array, not a copy.\n-     * <br/>\n+     * <p>\n      * To correctly address elements of the array, the \"start index\" is\n      * required (available via the {@link #getStartIndex() getStartIndex}\n      * method.\n-     * <br/>\n+     * <p>\n      * This method should only be used to avoid copying the internal array.\n      * The returned value <em>must</em> be used for reading only; other\n      * uses could lead to this object becoming inconsistent.\n-     * <br/>\n+     * <p>\n      * The {@link #getElements} method has no such limitation since it\n      * returns a copy of this array's addressable elements.\n      *\n@@ -907,6 +695,7 @@ public synchronized int getNumElements() {\n      * Returns the \"start index\" of the internal array.\n      * This index is the position of the first addressable element in the\n      * internal storage array.\n+     * <p>\n      * The addressable elements in the array are at indices contained in\n      * the interval [{@link #getStartIndex()},\n      *               {@link #getStartIndex()} + {@link #getNumElements()} - 1].\n@@ -918,23 +707,6 @@ protected int getStartIndex() {\n         return startIndex;\n     }\n \n-    /**\n-     * Sets the contraction criteria.\n-     *\n-     * @param contractionCriteria contraction criteria\n-     * @throws MathIllegalArgumentException if the contractionCriteria is less than\n-     *         the expansionCriteria.\n-     * @deprecated As of 3.1 (to be removed in 4.0 as field will become \"final\").\n-     */\n-    @Deprecated\n-    public void setContractionCriteria(float contractionCriteria)\n-        throws MathIllegalArgumentException {\n-        checkContractExpand(contractionCriteria, getExpansionFactor());\n-        synchronized(this) {\n-            this.contractionCriterion = contractionCriteria;\n-        }\n-    }\n-\n     /**\n      * Performs an operation on the addressable elements of the array.\n      *\n@@ -943,30 +715,24 @@ public void setContractionCriteria(float contractionCriteria)\n      * @since 3.1\n      */\n     public double compute(MathArrays.Function f) {\n-        final double[] array;\n-        final int start;\n-        final int num;\n-        synchronized(this) {\n-            array = internalArray;\n-            start = startIndex;\n-            num   = numElements;\n-        }\n-        return f.evaluate(array, start, num);\n+        return f.evaluate(internalArray, startIndex, numElements);\n     }\n \n     /**\n-     * Sets the element at the specified index.  If the specified index is greater than\n-     * <code>getNumElements() - 1</code>, the <code>numElements</code> property\n-     * is increased to <code>index +1</code> and additional storage is allocated\n-     * (if necessary) for the new element and all  (uninitialized) elements\n-     * between the new element and the previous end of the array).\n+     * Sets the element at the specified index.\n+     * <p>\n+     * If the specified index is greater than {@code getNumElements() - 1},\n+     * the {@code numElements} property is increased to {@code index +1}\n+     * and additional storage is allocated (if necessary) for the new element and\n+     * all (uninitialized) elements between the new element and the previous end\n+     * of the array).\n      *\n      * @param index index to store a value in\n      * @param value value to store at the specified index\n      * @throws ArrayIndexOutOfBoundsException if {@code index < 0}.\n      */\n     @Override\n-    public synchronized void setElement(int index, double value) {\n+    public void setElement(int index, double value) {\n         if (index < 0) {\n             throw new ArrayIndexOutOfBoundsException(index);\n         }\n@@ -979,93 +745,18 @@ public synchronized void setElement(int index, double value) {\n         internalArray[startIndex + index] = value;\n     }\n \n-    /**\n-     * Sets the expansionFactor.  Throws IllegalArgumentException if the\n-     * the following conditions are not met:\n-     * <ul>\n-     * <li><code>expansionFactor > 1</code></li>\n-     * <li><code>contractionFactor >= expansionFactor</code></li>\n-     * </ul>\n-     * @param expansionFactor the new expansion factor value.\n-     * @throws MathIllegalArgumentException if expansionFactor is <= 1 or greater\n-     * than contractionFactor\n-     * @deprecated As of 3.1 (to be removed in 4.0 as field will become \"final\").\n-     */\n-    @Deprecated\n-    public void setExpansionFactor(float expansionFactor) throws MathIllegalArgumentException {\n-        checkContractExpand(getContractionCriterion(), expansionFactor);\n-        // The check above verifies that the expansion factor is > 1.0;\n-        synchronized(this) {\n-            this.expansionFactor = expansionFactor;\n-        }\n-    }\n-\n-    /**\n-     * Sets the <code>expansionMode</code>. The specified value must be one of\n-     * ADDITIVE_MODE, MULTIPLICATIVE_MODE.\n-     *\n-     * @param expansionMode The expansionMode to set.\n-     * @throws MathIllegalArgumentException if the specified mode value is not valid.\n-     * @deprecated As of 3.1. Please use {@link #setExpansionMode(ExpansionMode)} instead.\n-     */\n-    @Deprecated\n-    public void setExpansionMode(int expansionMode)\n-        throws MathIllegalArgumentException {\n-        if (expansionMode != MULTIPLICATIVE_MODE &&\n-            expansionMode != ADDITIVE_MODE) {\n-            throw new MathIllegalArgumentException(LocalizedFormats.UNSUPPORTED_EXPANSION_MODE, expansionMode,\n-                                                   MULTIPLICATIVE_MODE, \"MULTIPLICATIVE_MODE\",\n-                                                   ADDITIVE_MODE, \"ADDITIVE_MODE\");\n-        }\n-        synchronized(this) {\n-            if (expansionMode == MULTIPLICATIVE_MODE) {\n-                setExpansionMode(ExpansionMode.MULTIPLICATIVE);\n-            } else if (expansionMode == ADDITIVE_MODE) {\n-                setExpansionMode(ExpansionMode.ADDITIVE);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Sets the {@link ExpansionMode expansion mode}.\n-     *\n-     * @param expansionMode Expansion mode to use for resizing the array.\n-     * @deprecated As of 3.1 (to be removed in 4.0 as field will become \"final\").\n-     */\n-    @Deprecated\n-    public void setExpansionMode(ExpansionMode expansionMode) {\n-        this.expansionMode = expansionMode;\n-    }\n-\n-    /**\n-     * Sets the initial capacity.  Should only be invoked by constructors.\n-     *\n-     * @param initialCapacity of the array\n-     * @throws MathIllegalArgumentException if <code>initialCapacity</code> is not\n-     * positive.\n-     * @deprecated As of 3.1, this is a no-op.\n-     */\n-    @Deprecated\n-    protected void setInitialCapacity(int initialCapacity)\n-        throws MathIllegalArgumentException {\n-        // Body removed in 3.1.\n-    }\n-\n     /**\n      * This function allows you to control the number of elements contained\n      * in this array, and can be used to \"throw out\" the last n values in an\n      * array. This function will also expand the internal array as needed.\n      *\n      * @param i a new number of elements\n-     * @throws MathIllegalArgumentException if <code>i</code> is negative.\n+     * @throws MathIllegalArgumentException if {@code i} is negative.\n      */\n-    public synchronized void setNumElements(int i)\n-        throws MathIllegalArgumentException {\n+    public void setNumElements(int i) throws MathIllegalArgumentException {\n         // If index is negative thrown an error.\n         if (i < 0) {\n-            throw new MathIllegalArgumentException(\n-                    LocalizedFormats.INDEX_NOT_POSITIVE,\n-                    i);\n+            throw new MathIllegalArgumentException(LocalizedFormats.INDEX_NOT_POSITIVE, i);\n         }\n \n         // Test the new num elements, check to see if the array needs to be\n@@ -1085,7 +776,7 @@ public synchronized void setNumElements(int i)\n      *\n      * @return true if array satisfies the contraction criteria\n      */\n-    private synchronized boolean shouldContract() {\n+    private boolean shouldContract() {\n         if (expansionMode == ExpansionMode.MULTIPLICATIVE) {\n             return (internalArray.length / ((float) numElements)) > contractionCriterion;\n         } else {\n@@ -1093,57 +784,6 @@ private synchronized boolean shouldContract() {\n         }\n     }\n \n-    /**\n-     * Returns the starting index of the internal array.  The starting index is\n-     * the position of the first addressable element in the internal storage\n-     * array.  The addressable elements in the array are <code>\n-     * internalArray[startIndex],...,internalArray[startIndex + numElements -1]\n-     * </code>\n-     *\n-     * @return the starting index.\n-     * @deprecated As of 3.1.\n-     */\n-    @Deprecated\n-    public synchronized int start() {\n-        return startIndex;\n-    }\n-\n-    /**\n-     * <p>Copies source to dest, copying the underlying data, so dest is\n-     * a new, independent copy of source.  Does not contract before\n-     * the copy.</p>\n-     *\n-     * <p>Obtains synchronization locks on both source and dest\n-     * (in that order) before performing the copy.</p>\n-     *\n-     * <p>Neither source nor dest may be null; otherwise a {@link NullArgumentException}\n-     * is thrown</p>\n-     *\n-     * @param source ResizableDoubleArray to copy\n-     * @param dest ResizableArray to replace with a copy of the source array\n-     * @exception NullArgumentException if either source or dest is null\n-     * @since 2.0\n-     *\n-     */\n-    public static void copy(ResizableDoubleArray source,\n-                            ResizableDoubleArray dest)\n-        throws NullArgumentException {\n-        MathUtils.checkNotNull(source);\n-        MathUtils.checkNotNull(dest);\n-        synchronized(source) {\n-           synchronized(dest) {\n-               dest.contractionCriterion = source.contractionCriterion;\n-               dest.expansionFactor = source.expansionFactor;\n-               dest.expansionMode = source.expansionMode;\n-               dest.internalArray = new double[source.internalArray.length];\n-               System.arraycopy(source.internalArray, 0, dest.internalArray,\n-                       0, dest.internalArray.length);\n-               dest.numElements = source.numElements;\n-               dest.startIndex = source.startIndex;\n-           }\n-       }\n-    }\n-\n     /**\n      * Returns a copy of the ResizableDoubleArray.  Does not contract before\n      * the copy, so the returned object is an exact copy of this.\n@@ -1152,10 +792,8 @@ public static void copy(ResizableDoubleArray source,\n      * properties as this\n      * @since 2.0\n      */\n-    public synchronized ResizableDoubleArray copy() {\n-        final ResizableDoubleArray result = new ResizableDoubleArray();\n-        copy(this, result);\n-        return result;\n+    public ResizableDoubleArray copy() {\n+        return new ResizableDoubleArray(this);\n     }\n \n     /**\n@@ -1175,8 +813,6 @@ public boolean equals(Object object) {\n         if (object instanceof ResizableDoubleArray == false) {\n             return false;\n         }\n-        synchronized(this) {\n-            synchronized(object) {\n         boolean result = true;\n         final ResizableDoubleArray other = (ResizableDoubleArray) object;\n         result = result && (other.contractionCriterion == contractionCriterion);\n@@ -1190,8 +826,6 @@ public boolean equals(Object object) {\n             return Arrays.equals(internalArray, other.internalArray);\n         }\n     }\n-        }\n-    }\n \n     /**\n      * Returns a hash code consistent with equals.\n@@ -1200,7 +834,7 @@ public boolean equals(Object object) {\n      * @since 2.0\n      */\n     @Override\n-    public synchronized int hashCode() {\n+    public int hashCode() {\n         final int[] hashData = new int[6];\n         hashData[0] = Double.valueOf(expansionFactor).hashCode();\n         hashData[1] = Double.valueOf(contractionCriterion).hashCode();\n",
        "project": "commons-math",
        "linesAdd": 47,
        "jira_id": "757",
        "nb_skipped": 3,
        "commit": "76b7413d",
        "nb_failure": 2,
        "linesRem": 211,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3967,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.optimization.linear.SimplexSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\nindex c2fa14dad..dec310beb 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -116,6 +116,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n+            if (tableau.getNumArtificialVariables() > 0) {\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n@@ -125,16 +126,23 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                         }\n                     }\n                 }\n+            }\n \n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n             //\n             // see http://www.stanford.edu/class/msande310/blandrule.pdf\n             // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n+            //\n+            // Additional heuristic: if we did not get a solution after half of maxIterations\n+            //                       revert to the simple case of just returning the top-most row\n+            // This heuristic is based on empirical data gathered while investigating MATH-828.\n+            if (getIterations() < getMaxIterations() / 2) {\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n                 for (Integer row : minRatioPositions) {\n-                for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1 && minRow != row; i++) {\n+                    int i = tableau.getNumObjectiveFunctions();\n+                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n                                 minIndex = i;\n@@ -143,9 +151,9 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {\n                         }\n                     }\n                 }\n-\n                 return minRow;\n             }\n+        }\n         return minRatioPositions.get(0);\n     }\n \n",
        "project": "commons-math",
        "linesAdd": 6,
        "jira_id": "828",
        "nb_skipped": 4,
        "commit": "a49e443c",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2883,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.random.AbstractRandomGeneratorTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/random/AbstractRandomGenerator.java b/src/main/java/org/apache/commons/math/random/AbstractRandomGenerator.java\nindex 85768473d..10c8f3881 100644\n--- a/src/main/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n@@ -134,7 +134,7 @@ public void nextBytes(byte[] bytes) {\n      *  value from this random number generator's sequence\n      */\n     public int nextInt() {\n-        return (int) (nextDouble() * Integer.MAX_VALUE);\n+        return (int) ((2d * nextDouble() - 1d) * Integer.MAX_VALUE);\n     }\n \n     /**\n@@ -176,7 +176,7 @@ public int nextInt(int n) {\n      *value from this random number generator's sequence\n      */\n     public long nextLong() {\n-        return (long) (nextDouble() * Long.MAX_VALUE);\n+        return (long) ((2d * nextDouble() - 1d) * Long.MAX_VALUE);\n     }\n \n     /**\n",
        "project": "commons-math",
        "linesAdd": 2,
        "jira_id": "640",
        "nb_skipped": 1,
        "commit": "98556fed",
        "nb_failure": 2,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3104,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.stat.descriptive.SynchronizedSummaryStatisticsTest",
            "org.apache.commons.math.stat.descriptive.SummaryStatisticsTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\nindex 1203d516c..da987cd3c 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n@@ -155,13 +155,13 @@ public void addValue(double value) {\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n+        if (meanImpl != mean) {\n             meanImpl.increment(value);\n         }\n-        if (!(varianceImpl instanceof Variance)) {\n+        if (varianceImpl != variance) {\n             varianceImpl.increment(value);\n         }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+        if (geoMeanImpl != geoMean) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n",
        "project": "commons-math",
        "linesAdd": 3,
        "jira_id": "691",
        "nb_skipped": 1,
        "commit": "118f0cc0",
        "nb_failure": 6,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2516,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.linear.SingularValueDecompositionImplTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\nindex 5e27413e4..c2c655e52 100644\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n@@ -35,23 +34,38 @@\n  * @since 2.0\n  */\n public class SingularValueDecompositionImpl implements SingularValueDecomposition {\n-    /** Number of rows of the initial matrix. */\n+\n+    /** Relative threshold for small singular values. */\n+    private static final double EPS = 0x1.0p-52;\n+\n+    /** Absolute threshold for small singular values. */\n+    private static final double TINY = 0x1.0p-966;\n+\n+    /** Computed singular values. */\n+    private double[] singularValues;\n+\n+    /** Row dimension. */\n     private int m;\n-    /** Number of columns of the initial matrix. */\n+\n+    /** Column dimension. */\n     private int n;\n-    /** Eigen decomposition of the tridiagonal matrix. */\n-    private EigenDecomposition eigenDecomposition;\n-    /** Singular values. */\n-    private double[] singularValues;\n-    /** Cached value of U. */\n+\n+    /** Indicator for transposed matrix. */\n+    private boolean transposed;\n+\n+    /** Cached value of U matrix. */\n     private RealMatrix cachedU;\n-    /** Cached value of U<sup>T</sup>. */\n+\n+    /** Cached value of transposed U matrix. */\n     private RealMatrix cachedUt;\n-    /** Cached value of S. */\n+\n+    /** Cached value of S (diagonal) matrix. */\n     private RealMatrix cachedS;\n-    /** Cached value of V. */\n+\n+    /** Cached value of V matrix. */\n     private RealMatrix cachedV;\n-    /** Cached value of V<sup>T</sup>. */\n+\n+    /** Cached value of transposed V matrix. */\n     private RealMatrix cachedVt;\n \n     /**\n@@ -60,80 +74,397 @@\n      * @param matrix Matrix to decompose.\n      */\n     public SingularValueDecompositionImpl(final RealMatrix matrix) {\n+\n+        // Derived from LINPACK code.\n+        // Initialize.\n+        double[][] A;\n+        m = matrix.getRowDimension();\n+        n = matrix.getColumnDimension();\n+        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n+            transposed = true;\n+            A = matrix.transpose().getData();\n+            m = matrix.getColumnDimension();\n+            n = matrix.getRowDimension();\n+        } else {\n+            transposed = false;\n+            A = matrix.getData();\n             m = matrix.getRowDimension();\n             n = matrix.getColumnDimension();\n-\n-        cachedU = null;\n-        cachedS = null;\n-        cachedV = null;\n-        cachedVt = null;\n-\n-        double[][] localcopy = matrix.getData();\n-        double[][] matATA = new double[n][n];\n-        //\n-        // create A^T*A\n-        //\n-        for (int i = 0; i < n; i++) {\n-            for (int j = i; j < n; j++) {\n-                matATA[i][j] = 0.0;\n-                for (int k = 0; k < m; k++) {\n-                    matATA[i][j] += localcopy[k][i] * localcopy[k][j];\n         }\n-                matATA[j][i] = matATA[i][j];\n+        int nu = FastMath.min(m, n);\n+        singularValues = new double[FastMath.min(m + 1, n)];\n+        double[][] U = new double[m][nu];\n+        double[][] V = new double[n][n];\n+        double[] e = new double[n];\n+        double[] work = new double[m];\n+        boolean wantu = true;\n+        boolean wantv = true;\n+        // Reduce A to bidiagonal form, storing the diagonal elements\n+        // in s and the super-diagonal elements in e.\n+        int nct = FastMath.min(m - 1, n);\n+        int nrt = FastMath.max(0, FastMath.min(n - 2, m));\n+        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n+            if (k < nct) {\n+                // Compute the transformation for the k-th column and\n+                // place the k-th diagonal in s[k].\n+                // Compute 2-norm of k-th column without under/overflow.\n+                singularValues[k] = 0;\n+                for (int i = k; i < m; i++) {\n+                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n                 }\n+                if (singularValues[k] != 0.0) {\n+                    if (A[k][k] < 0.0) {\n+                        singularValues[k] = -singularValues[k];\n                     }\n-\n-        double[][] matAAT = new double[m][m];\n-        //\n-        // create A*A^T\n-        //\n+                    for (int i = k; i < m; i++) {\n+                        A[i][k] /= singularValues[k];\n+                    }\n+                    A[k][k] += 1.0;\n+                }\n+                singularValues[k] = -singularValues[k];\n+            }\n+            for (int j = k + 1; j < n; j++) {\n+                if ((k < nct) & (singularValues[k] != 0.0)) {\n+                    // Apply the transformation.\n+                    double t = 0;\n+                    for (int i = k; i < m; i++) {\n+                        t += A[i][k] * A[i][j];\n+                    }\n+                    t = -t / A[k][k];\n+                    for (int i = k; i < m; i++) {\n+                        A[i][j] += t * A[i][k];\n+                    }\n+                }\n+                // Place the k-th row of A into e for the\n+                // subsequent calculation of the row transformation.\n+                e[j] = A[k][j];\n+            }\n+            if (wantu & (k < nct)) {\n+                // Place the transformation in U for subsequent back\n+                // multiplication.\n+                for (int i = k; i < m; i++) {\n+                    U[i][k] = A[i][k];\n+                }\n+            }\n+            if (k < nrt) {\n+                // Compute the k-th row transformation and place the\n+                // k-th super-diagonal in e[k].\n+                // Compute 2-norm without under/overflow.\n+                e[k] = 0;\n+                for (int i = k + 1; i < n; i++) {\n+                    e[k] = FastMath.hypot(e[k], e[i]);\n+                }\n+                if (e[k] != 0.0) {\n+                    if (e[k + 1] < 0.0) {\n+                        e[k] = -e[k];\n+                    }\n+                    for (int i = k + 1; i < n; i++) {\n+                        e[i] /= e[k];\n+                    }\n+                    e[k + 1] += 1.0;\n+                }\n+                e[k] = -e[k];\n+                if ((k + 1 < m) & (e[k] != 0.0)) {\n+                    // Apply the transformation.\n+                    for (int i = k + 1; i < m; i++) {\n+                        work[i] = 0.0;\n+                    }\n+                    for (int j = k + 1; j < n; j++) {\n+                        for (int i = k + 1; i < m; i++) {\n+                            work[i] += e[j] * A[i][j];\n+                        }\n+                    }\n+                    for (int j = k + 1; j < n; j++) {\n+                        double t = -e[j] / e[k + 1];\n+                        for (int i = k + 1; i < m; i++) {\n+                            A[i][j] += t * work[i];\n+                        }\n+                    }\n+                }\n+                if (wantv) {\n+                    // Place the transformation in V for subsequent\n+                    // back multiplication.\n+                    for (int i = k + 1; i < n; i++) {\n+                        V[i][k] = e[i];\n+                    }\n+                }\n+            }\n+        }\n+        // Set up the final bidiagonal matrix or order p.\n+        int p = FastMath.min(n, m + 1);\n+        if (nct < n) {\n+            singularValues[nct] = A[nct][nct];\n+        }\n+        if (m < p) {\n+            singularValues[p - 1] = 0.0;\n+        }\n+        if (nrt + 1 < p) {\n+            e[nrt] = A[nrt][p - 1];\n+        }\n+        e[p - 1] = 0.0;\n+        // If required, generate U.\n+        if (wantu) {\n+            for (int j = nct; j < nu; j++) {\n                 for (int i = 0; i < m; i++) {\n-            for (int j = i; j < m; j++) {\n-                matAAT[i][j] = 0.0;\n-                for (int k = 0; k < n; k++) {\n-                    matAAT[i][j] += localcopy[i][k] * localcopy[j][k];\n-                }\n-                 matAAT[j][i] = matAAT[i][j];\n-            }\n-        }\n-        int p;\n-        if (m >= n) {\n-            p = n;\n-            // compute eigen decomposition of A^T*A\n-            eigenDecomposition\n-                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matATA), 1);\n-            singularValues = eigenDecomposition.getRealEigenvalues();\n-            cachedV = eigenDecomposition.getV();\n-            // compute eigen decomposition of A*A^T\n-            eigenDecomposition\n-                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matAAT), 1);\n-            cachedU = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n+                    U[i][j] = 0.0;\n+                }\n+                U[j][j] = 1.0;\n+            }\n+            for (int k = nct - 1; k >= 0; k--) {\n+                if (singularValues[k] != 0.0) {\n+                    for (int j = k + 1; j < nu; j++) {\n+                        double t = 0;\n+                        for (int i = k; i < m; i++) {\n+                            t += U[i][k] * U[i][j];\n+                        }\n+                        t = -t / U[k][k];\n+                        for (int i = k; i < m; i++) {\n+                            U[i][j] += t * U[i][k];\n+                        }\n+                    }\n+                    for (int i = k; i < m; i++) {\n+                        U[i][k] = -U[i][k];\n+                    }\n+                    U[k][k] = 1.0 + U[k][k];\n+                    for (int i = 0; i < k - 1; i++) {\n+                        U[i][k] = 0.0;\n+                    }\n                 } else {\n-            p = m;\n-            // compute eigen decomposition of A*A^T\n-            eigenDecomposition\n-                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matAAT), 1);\n-            singularValues = eigenDecomposition.getRealEigenvalues();\n-            cachedU = eigenDecomposition.getV();\n-\n-            // compute eigen decomposition of A^T*A\n-            eigenDecomposition\n-                = new EigenDecompositionImpl(new Array2DRowRealMatrix(matATA), 1);\n-            cachedV = eigenDecomposition.getV().getSubMatrix(0, n - 1 , 0, p - 1);\n+                    for (int i = 0; i < m; i++) {\n+                        U[i][k] = 0.0;\n+                    }\n+                    U[k][k] = 1.0;\n                 }\n-        for (int i = 0; i < p; i++) {\n-            singularValues[i] = FastMath.sqrt(FastMath.abs(singularValues[i]));\n             }\n-        // Up to this point, U and V are computed independently of each other.\n-        // There still a sign indetermination of each column of, say, U.\n-        // The sign is set such that A.V_i=sigma_i.U_i (i<=p)\n-        // The right sign corresponds to a positive dot product of A.V_i and U_i\n-        for (int i = 0; i < p; i++) {\n-            RealVector tmp = cachedU.getColumnVector(i);\n-            double product=matrix.operate(cachedV.getColumnVector(i)).dotProduct(tmp);\n-            if (product < 0) {\n-                cachedU.setColumnVector(i, tmp.mapMultiply(-1));\n         }\n+        // If required, generate V.\n+        if (wantv) {\n+            for (int k = n - 1; k >= 0; k--) {\n+                if ((k < nrt) & (e[k] != 0.0)) {\n+                    for (int j = k + 1; j < nu; j++) {\n+                        double t = 0;\n+                        for (int i = k + 1; i < n; i++) {\n+                            t += V[i][k] * V[i][j];\n+                        }\n+                        t = -t / V[k + 1][k];\n+                        for (int i = k + 1; i < n; i++) {\n+                            V[i][j] += t * V[i][k];\n+                        }\n+                    }\n+                }\n+                for (int i = 0; i < n; i++) {\n+                    V[i][k] = 0.0;\n+                }\n+                V[k][k] = 1.0;\n+            }\n+        }\n+        // Main iteration loop for the singular values.\n+        int pp = p - 1;\n+        int iter = 0;\n+        while (p > 0) {\n+            int k, kase;\n+            // Here is where a test for too many iterations would go.\n+            // This section of the program inspects for\n+            // negligible elements in the s and e arrays.  On\n+            // completion the variables kase and k are set as follows.\n+            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n+            // kase = 2     if s(k) is negligible and k<p\n+            // kase = 3     if e[k-1] is negligible, k<p, and\n+            //              s(k), ..., s(p) are not negligible (qr step).\n+            // kase = 4     if e(p-1) is negligible (convergence).\n+            for (k = p - 2; k >= -1; k--) {\n+                if (k == -1) {\n+                    break;\n+                }\n+                final double threshold =\n+                        TINY + EPS * (FastMath.abs(singularValues[k]) + FastMath.abs(singularValues[k + 1]));\n+                if (FastMath.abs(e[k]) <= threshold) {\n+                    e[k] = 0.0;\n+                    break;\n+                }\n+            }\n+            if (k == p - 2) {\n+                kase = 4;\n+            } else {\n+                int ks;\n+                for (ks = p - 1; ks >= k; ks--) {\n+                    if (ks == k) {\n+                        break;\n+                    }\n+                    double t = (ks != p ? FastMath.abs(e[ks]) : 0.0) +\n+                               (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0.0);\n+                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n+                        singularValues[ks] = 0.0;\n+                        break;\n+                    }\n+                }\n+                if (ks == k) {\n+                    kase = 3;\n+                } else if (ks == p - 1) {\n+                    kase = 1;\n+                } else {\n+                    kase = 2;\n+                    k = ks;\n+                }\n+            }\n+            k++;\n+            // Perform the task indicated by kase.\n+            switch (kase) {\n+                // Deflate negligible s(p).\n+                case 1: {\n+                    double f = e[p - 2];\n+                    e[p - 2] = 0.0;\n+                    for (int j = p - 2; j >= k; j--) {\n+                        double t = FastMath.hypot(singularValues[j], f);\n+                        double cs = singularValues[j] / t;\n+                        double sn = f / t;\n+                        singularValues[j] = t;\n+                        if (j != k) {\n+                            f = -sn * e[j - 1];\n+                            e[j - 1] = cs * e[j - 1];\n+                        }\n+                        if (wantv) {\n+                            for (int i = 0; i < n; i++) {\n+                                t = cs * V[i][j] + sn * V[i][p - 1];\n+                                V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n+                                V[i][j] = t;\n+                            }\n+                        }\n+                    }\n+                }\n+                break;\n+                // Split at negligible s(k).\n+                case 2: {\n+                    double f = e[k - 1];\n+                    e[k - 1] = 0.0;\n+                    for (int j = k; j < p; j++) {\n+                        double t = FastMath.hypot(singularValues[j], f);\n+                        double cs = singularValues[j] / t;\n+                        double sn = f / t;\n+                        singularValues[j] = t;\n+                        f = -sn * e[j];\n+                        e[j] = cs * e[j];\n+                        if (wantu) {\n+                            for (int i = 0; i < m; i++) {\n+                                t = cs * U[i][j] + sn * U[i][k - 1];\n+                                U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n+                                U[i][j] = t;\n+                            }\n+                        }\n+                    }\n+                }\n+                break;\n+                // Perform one qr step.\n+                case 3: {\n+                    // Calculate the shift.\n+                    double scale = FastMath.max(FastMath.max(FastMath.max(FastMath.max(\n+                            FastMath.abs(singularValues[p - 1]), FastMath.abs(singularValues[p - 2])), FastMath.abs(e[p - 2])),\n+                            FastMath.abs(singularValues[k])), FastMath.abs(e[k]));\n+                    double sp = singularValues[p - 1] / scale;\n+                    double spm1 = singularValues[p - 2] / scale;\n+                    double epm1 = e[p - 2] / scale;\n+                    double sk = singularValues[k] / scale;\n+                    double ek = e[k] / scale;\n+                    double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n+                    double c = (sp * epm1) * (sp * epm1);\n+                    double shift = 0.0;\n+                    if ((b != 0.0) | (c != 0.0)) {\n+                        shift = FastMath.sqrt(b * b + c);\n+                        if (b < 0.0) {\n+                            shift = -shift;\n+                        }\n+                        shift = c / (b + shift);\n+                    }\n+                    double f = (sk + sp) * (sk - sp) + shift;\n+                    double g = sk * ek;\n+                    // Chase zeros.\n+                    for (int j = k; j < p - 1; j++) {\n+                        double t = FastMath.hypot(f, g);\n+                        double cs = f / t;\n+                        double sn = g / t;\n+                        if (j != k) {\n+                            e[j - 1] = t;\n+                        }\n+                        f = cs * singularValues[j] + sn * e[j];\n+                        e[j] = cs * e[j] - sn * singularValues[j];\n+                        g = sn * singularValues[j + 1];\n+                        singularValues[j + 1] = cs * singularValues[j + 1];\n+                        if (wantv) {\n+                            for (int i = 0; i < n; i++) {\n+                                t = cs * V[i][j] + sn * V[i][j + 1];\n+                                V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n+                                V[i][j] = t;\n+                            }\n+                        }\n+                        t = FastMath.hypot(f, g);\n+                        cs = f / t;\n+                        sn = g / t;\n+                        singularValues[j] = t;\n+                        f = cs * e[j] + sn * singularValues[j + 1];\n+                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n+                        g = sn * e[j + 1];\n+                        e[j + 1] = cs * e[j + 1];\n+                        if (wantu && (j < m - 1)) {\n+                            for (int i = 0; i < m; i++) {\n+                                t = cs * U[i][j] + sn * U[i][j + 1];\n+                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n+                                U[i][j] = t;\n+                            }\n+                        }\n+                    }\n+                    e[p - 2] = f;\n+                    iter = iter + 1;\n+                }\n+                break;\n+                // Convergence.\n+                default: {\n+                    // Make the singular values positive.\n+                    if (singularValues[k] <= 0.0) {\n+                        singularValues[k] = singularValues[k] < 0.0 ? -singularValues[k] : 0.0;\n+                        if (wantv) {\n+                            for (int i = 0; i <= pp; i++) {\n+                                V[i][k] = -V[i][k];\n+                            }\n+                        }\n+                    }\n+                    // Order the singular values.\n+                    while (k < pp) {\n+                        if (singularValues[k] >= singularValues[k + 1]) {\n+                            break;\n+                        }\n+                        double t = singularValues[k];\n+                        singularValues[k] = singularValues[k + 1];\n+                        singularValues[k + 1] = t;\n+                        if (wantv && (k < n - 1)) {\n+                            for (int i = 0; i < n; i++) {\n+                                t = V[i][k + 1];\n+                                V[i][k + 1] = V[i][k];\n+                                V[i][k] = t;\n+                            }\n+                        }\n+                        if (wantu && (k < m - 1)) {\n+                            for (int i = 0; i < m; i++) {\n+                                t = U[i][k + 1];\n+                                U[i][k + 1] = U[i][k];\n+                                U[i][k] = t;\n+                            }\n+                        }\n+                        k++;\n+                    }\n+                    iter = 0;\n+                    p--;\n+                }\n+                break;\n+            }\n+        }\n+\n+        if (!transposed) {\n+            cachedU = MatrixUtils.createRealMatrix(U);\n+            cachedV = MatrixUtils.createRealMatrix(V);\n+        } else {\n+            cachedU = MatrixUtils.createRealMatrix(V);\n+            cachedV = MatrixUtils.createRealMatrix(U);\n+\n         }\n     }\n \n@@ -217,19 +548,19 @@ public double getNorm() {\n \n     /** {@inheritDoc} */\n     public double getConditionNumber() {\n-        return singularValues[0] / singularValues[singularValues.length - 1];\n+        return singularValues[0] / singularValues[FastMath.min(m, n) - 1];\n     }\n \n     /** {@inheritDoc} */\n     public int getRank() {\n-        final double threshold = FastMath.max(m, n) * FastMath.ulp(singularValues[0]);\n-\n-        for (int i = singularValues.length - 1; i >= 0; --i) {\n-            if (singularValues[i] > threshold) {\n-                return i + 1;\n+        double tol = FastMath.max(m, n) * singularValues[0] * EPS;\n+        int r = 0;\n+        for (int i = 0; i < singularValues.length; i++) {\n+            if (singularValues[i] > tol) {\n+                r++;\n             }\n         }\n-        return 0;\n+        return r;\n     }\n \n     /** {@inheritDoc} */\n",
        "project": "commons-math",
        "linesAdd": 363,
        "jira_id": "327",
        "nb_skipped": 1,
        "commit": "262fe4c0",
        "nb_failure": 2,
        "linesRem": 59,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2091,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 46368dc9f..ad77a56eb 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -1621,9 +1621,9 @@ public static double distance(double[] p1, double[] p2) {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n+      double sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+          final double dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n",
        "project": "commons-math",
        "linesAdd": 2,
        "jira_id": "305",
        "nb_skipped": 0,
        "commit": "ef9b639a",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4550,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.analysis.differentiation.DerivativeStructureTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\nindex 9d0855530..d5a3c18b8 100644\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n@@ -1415,6 +1415,9 @@ public void atan2(final double[] y, final int yOffset,\n \n         }\n \n+        // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly\n+        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);\n+\n     }\n \n     /** Compute hyperbolic cosine of a derivative structure.\n",
        "project": "commons-math",
        "linesAdd": 2,
        "jira_id": "935",
        "nb_skipped": 4,
        "commit": "48dde378",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5035,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.util.MathArraysTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/util/MathArrays.java b/src/main/java/org/apache/commons/math3/util/MathArrays.java\nindex 1aa56cc7d..8f83d96a5 100644\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n@@ -818,6 +818,11 @@ public static double linearCombination(final double[] a, final double[] b)\n             throw new DimensionMismatchException(len, b.length);\n         }\n \n+        if (len == 1) {\n+            // Revert to scalar multiplication.\n+            return a[0] * b[0];\n+        }\n+\n         final double[] prodHigh = new double[len];\n         double prodLowSum = 0;\n \n",
        "project": "commons-math",
        "linesAdd": 4,
        "jira_id": "1005",
        "nb_skipped": 4,
        "commit": "91d280b7",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3026,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.linear.OpenMapRealMatrixTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java b/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\nindex 4369db778..f05c8783a 100644\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n@@ -19,6 +19,7 @@\n \n import java.io.Serializable;\n \n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.util.OpenIntToDoubleHashMap;\n \n /**\n@@ -46,6 +47,11 @@\n      */\n     public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n         super(rowDimension, columnDimension);\n+        long lRow = (long) rowDimension;\n+        long lCol = (long) columnDimension;\n+        if (lRow * lCol >= (long) Integer.MAX_VALUE) {\n+            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);\n+        }\n         this.rows = rowDimension;\n         this.columns = columnDimension;\n         this.entries = new OpenIntToDoubleHashMap(0.0);\n",
        "project": "commons-math",
        "linesAdd": 6,
        "jira_id": "679",
        "nb_skipped": 1,
        "commit": "5e638976",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2081,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.random.RandomDataTest",
            "org.apache.commons.math.random.AbstractRandomGeneratorTest",
            "org.apache.commons.math.random.RandomAdaptorTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\nindex 18097bcca..d5d2474f7 100644\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n@@ -322,30 +322,17 @@ public long nextSecureLong(long lower, long upper) {\n     /**\n      * {@inheritDoc}\n      * <p>\n-     * <strong>Algorithm Description</strong>: For small means, uses simulation\n-     * of a Poisson process using Uniform deviates, as described <a\n-     * href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n-     * </p>\n-     * <p>\n-     * The Poisson process (and hence value returned) is bounded by 1000 * mean.\n-     * </p>\n-     *\n-     * <p>\n-     * For large means, uses a reject method as described in <a\n-     * href=\"http://cg.scs.carleton.ca/~luc/rnbookindex.html\">Non-Uniform Random\n-     * Variate Generation</a>\n-     * </p>\n+     * <strong>Algorithm Description</strong>:\n+     * <ul><li> For small means, uses simulation of a Poisson process\n+     * using Uniform deviates, as described\n+     * <a href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n+     * The Poisson process (and hence value returned) is bounded by 1000 * mean.</li>\n      *\n-     * <p>\n-     * References:\n-     * <ul>\n-     * <li>Devroye, Luc. (1986). <i>Non-Uniform Random Variate Generation</i>.\n-     * New York, NY. Springer-Verlag</li>\n-     * </ul>\n-     * </p>\n+     * <li> For large means, uses the rejection algorithm described in <br/>\n+     * Devroye, Luc. (1981).<i>The Computer Generation of Poisson Random Variables</i>\n+     * <strong>Computing</strong> vol. 26 pp. 197-207.</li></ul></p>\n      *\n-     * @param mean\n-     *            mean of the Poisson distribution.\n+     * @param mean mean of the Poisson distribution.\n      * @return the random Poisson value.\n      */\n     public long nextPoisson(double mean) {\n@@ -356,7 +343,7 @@ public long nextPoisson(double mean) {\n \n         final RandomGenerator generator = getRan();\n \n-        double pivot = 6.0;\n+        final double pivot = 40.0d;\n         if (mean < pivot) {\n             double p = Math.exp(-mean);\n             long n = 0;\n@@ -374,68 +361,70 @@ public long nextPoisson(double mean) {\n             }\n             return n;\n         } else {\n-            double mu = Math.floor(mean);\n-            double delta = Math.floor(pivot + (mu - pivot) / 2.0); // integer\n-            // between 6\n-            // and mean\n-            double mu2delta = 2.0 * mu + delta;\n-            double muDeltaHalf = mu + delta / 2.0;\n-            double logMeanMu = Math.log(mean / mu);\n-\n-            double muFactorialLog = MathUtils.factorialLog((int) mu);\n-\n-            double c1 = Math.sqrt(Math.PI * mu / 2.0);\n-            double c2 = c1 +\n-                        Math.sqrt(Math.PI * muDeltaHalf /\n-                                  (2.0 * Math.exp(1.0 / mu2delta)));\n-            double c3 = c2 + 2.0;\n-            double c4 = c3 + Math.exp(1.0 / 78.0);\n-            double c = c4 + 2.0 / delta * mu2delta *\n-                       Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));\n-\n-            double y = 0.0;\n-            double x = 0.0;\n-            double w = Double.POSITIVE_INFINITY;\n-\n-            boolean accept = false;\n-            while (!accept) {\n-                double u = nextUniform(0.0, c);\n-                double e = nextExponential(mean);\n-\n-                if (u <= c1) {\n-                    double z = nextGaussian(0.0, 1.0);\n-                    y = -Math.abs(z) * Math.sqrt(mu) - 1.0;\n-                    x = Math.floor(y);\n-                    w = -z * z / 2.0 - e - x * logMeanMu;\n-                    if (x < -mu) {\n-                        w = Double.POSITIVE_INFINITY;\n-                    }\n-                } else if (c1 < u && u <= c2) {\n-                    double z = nextGaussian(0.0, 1.0);\n-                    y = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);\n-                    x = Math.ceil(y);\n-                    w = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;\n-                    if (x > delta) {\n-                        w = Double.POSITIVE_INFINITY;\n-                    }\n-                } else if (c2 < u && u <= c3) {\n-                    x = 0.0;\n-                    w = -e;\n-                } else if (c3 < u && u <= c4) {\n-                    x = 1.0;\n-                    w = -e - logMeanMu;\n-                } else if (c4 < u) {\n-                    double v = nextExponential(mean);\n-                    y = delta + v * 2.0 / delta * mu2delta;\n-                    x = Math.ceil(y);\n-                    w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;\n-                }\n-                accept = w <= x * Math.log(mu) -\n-                         MathUtils.factorialLog((int) (mu + x)) / muFactorialLog;\n-            }\n-            // cast to long is acceptable because both x and mu are whole\n-            // numbers.\n-            return (long) (x + mu);\n+            final double lambda = Math.floor(mean);\n+            final double lambdaFractional = mean - lambda;\n+            final double logLambda = Math.log(lambda);\n+            final double logLambdaFactorial = MathUtils.factorialLog((int) lambda);\n+            final long y2 = lambdaFractional < Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional);\n+            final double delta = Math.sqrt(lambda * Math.log(32 * lambda / Math.PI + 1));\n+            final double halfDelta = delta / 2;\n+            final double twolpd = 2 * lambda + delta;\n+            final double a1 = Math.sqrt(Math.PI * twolpd) * Math.exp(1 / 8 * lambda);\n+            final double a2 = (twolpd / delta) * Math.exp(-delta * (1 + delta) / twolpd);\n+            final double aSum = a1 + a2 + 1;\n+            final double p1 = a1 / aSum;\n+            final double p2 = a2 / aSum;\n+            final double c1 = 1 / (8 * lambda);\n+\n+            double x = 0;\n+            double y = 0;\n+            double v = 0;\n+            int a = 0;\n+            double t = 0;\n+            double qr = 0;\n+            double qa = 0;\n+            for (;;) {\n+                final double u = nextUniform(0.0, 1);\n+                if (u <= p1) {\n+                    final double n = nextGaussian(0d, 1d);\n+                    x = n * Math.sqrt(lambda + halfDelta) - 0.5d;\n+                    if (x > delta || x < -lambda) {\n+                        continue;\n+                    }\n+                    y = x < 0 ? Math.floor(x) : Math.ceil(x);\n+                    final double e = nextExponential(1d);\n+                    v = -e - (n * n / 2) + c1;\n+                } else {\n+                    if (u > p1 + p2) {\n+                        y = lambda;\n+                        break;\n+                    } else {\n+                        x = delta + (twolpd / delta) * nextExponential(1d);\n+                        y = Math.ceil(x);\n+                        v = -nextExponential(1d) - delta * (x + 1) / twolpd;\n+                    }\n+                }\n+                a = x < 0 ? 1 : 0;\n+                t = y * (y + 1) / (2 * lambda);\n+                if (v < -t && a == 0) {\n+                    y = lambda + y;\n+                    break;\n+                }\n+                qr = t * ((2 * y + 1) / (6 * lambda) - 1);\n+                qa = qr - (t * t) / (3 * (lambda + a * (y + 1)));\n+                if (v < qa) {\n+                    y = lambda + y;\n+                    break;\n+                }\n+                if (v > qr) {\n+                    continue;\n+                }\n+                if (v < y * logLambda - MathUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {\n+                    y = lambda + y;\n+                    break;\n+                }\n+            }\n+            return y2 + (long) y;\n         }\n     }\n \n",
        "project": "commons-math",
        "linesAdd": 65,
        "jira_id": "294",
        "nb_skipped": 0,
        "commit": "2c8a114f",
        "nb_failure": 0,
        "linesRem": 59,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3968,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.fraction.FractionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/fraction/Fraction.java b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\nindex f81ff0a94..08d3b9556 100644\n--- a/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n@@ -178,7 +178,7 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n         long overflow = Integer.MAX_VALUE;\n         double r0 = value;\n         long a0 = (long)FastMath.floor(r0);\n-        if (a0 > overflow) {\n+        if (FastMath.abs(a0) > overflow) {\n             throw new FractionConversionException(value, a0, 1l);\n         }\n \n@@ -206,7 +206,7 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             long a1 = (long)FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n-            if ((p2 > overflow) || (q2 > overflow)) {\n+            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                 throw new FractionConversionException(value, p2, q2);\n             }\n \n",
        "project": "commons-math",
        "linesAdd": 2,
        "jira_id": "836",
        "nb_skipped": 4,
        "commit": "d7c0f27e",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5960,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java\nindex 31b78a61a..0c5a9a7e3 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java\n@@ -59,6 +59,16 @@ public PolyhedronsSet(final double tolerance) {\n      * cells). In order to avoid building too many small objects, it is\n      * recommended to use the predefined constants\n      * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n+     * <p>\n+     * This constructor is aimed at expert use, as building the tree may\n+     * be a difficult taks. It is not intended for general use and for\n+     * performances reasons does not check thoroughly its input, as this would\n+     * require walking the full tree each time. Failing to provide a tree with\n+     * the proper attributes, <em>will</em> therefore generate problems like\n+     * {@link NullPointerException} or {@link ClassCastException} only later on.\n+     * This limitation is known and explains why this constructor is for expert\n+     * use only. The caller does have the responsibility to provided correct arguments.\n+     * </p>\n      * @param tree inside/outside BSP tree representing the region\n      * @param tolerance tolerance below which points are considered identical\n      * @since 3.3\n@@ -190,6 +200,10 @@ public PolyhedronsSet(final double xMin, final double xMax,\n                                                       final double yMin, final double yMax,\n                                                       final double zMin, final double zMax,\n                                                       final double tolerance) {\n+        if ((xMin >= xMax - tolerance) || (yMin >= yMax - tolerance) || (zMin >= zMax - tolerance)) {\n+            // too thin box, build an empty polygons set\n+            return new BSPTree<Euclidean3D>(Boolean.FALSE);\n+        }\n         final Plane pxMin = new Plane(new Vector3D(xMin, 0,    0),   Vector3D.MINUS_I, tolerance);\n         final Plane pxMax = new Plane(new Vector3D(xMax, 0,    0),   Vector3D.PLUS_I,  tolerance);\n         final Plane pyMin = new Plane(new Vector3D(0,    yMin, 0),   Vector3D.MINUS_J, tolerance);\n",
        "project": "commons-math",
        "linesAdd": 3,
        "jira_id": "1115",
        "nb_skipped": 3,
        "commit": "2a6c6409",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5826,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.fraction.FractionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/fraction/Fraction.java b/src/main/java/org/apache/commons/math4/fraction/Fraction.java\nindex 0713b8596..39eba8dff 100644\n--- a/src/main/java/org/apache/commons/math4/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math4/fraction/Fraction.java\n@@ -566,7 +566,7 @@ public Fraction multiply(Fraction fraction) {\n      */\n     @Override\n     public Fraction multiply(final int i) {\n-        return new Fraction(numerator * i, denominator);\n+        return multiply(new Fraction(i));\n     }\n \n     /**\n@@ -597,7 +597,7 @@ public Fraction divide(Fraction fraction) {\n      * @return this * i\n      */\n     public Fraction divide(final int i) {\n-        return new Fraction(numerator, denominator * i);\n+        return divide(new Fraction(i));\n     }\n \n     /**\n",
        "project": "commons-math",
        "linesAdd": 2,
        "jira_id": "1261",
        "nb_skipped": 3,
        "commit": "4c4b3e2e",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5851,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.random.EmpiricalDistributionTest",
            "org.apache.commons.math4.ml.neuralnet.sofm.KohonenTrainingTaskTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java b/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\nindex 9458289fd..3b3a8642d 100644\n--- a/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\n+++ b/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\n@@ -799,7 +799,7 @@ private double cumBinP(int binIndex) {\n      * @return within-bin kernel parameterized by bStats\n      */\n     protected RealDistribution getKernel(SummaryStatistics bStats) {\n-        if (bStats.getN() == 1) {\n+        if (bStats.getN() == 1 || bStats.getVariance() == 0) {\n             return new ConstantRealDistribution(bStats.getMean());\n         } else {\n             return new NormalDistribution(randomData.getRandomGenerator(),\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "1203",
        "nb_skipped": 3,
        "commit": "4aa4c6d3",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 6185,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.analysis.solvers.UnivariateSolverUtilsTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/analysis/solvers/UnivariateSolverUtils.java b/src/main/java/org/apache/commons/math4/analysis/solvers/UnivariateSolverUtils.java\nindex 2521c9b5a..49742d84b 100644\n--- a/src/main/java/org/apache/commons/math4/analysis/solvers/UnivariateSolverUtils.java\n+++ b/src/main/java/org/apache/commons/math4/analysis/solvers/UnivariateSolverUtils.java\n@@ -314,7 +314,7 @@ public static double forceSide(final int maxEval, final UnivariateFunction f,\n         double delta = 0;\n \n         for (int numIterations = 0;\n-             (numIterations < maximumIterations) && (a > lowerBound || b > upperBound);\n+             (numIterations < maximumIterations) && (a > lowerBound || b < upperBound);\n              ++numIterations) {\n \n             final double previousA  = a;\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "1204",
        "nb_skipped": 3,
        "commit": "a56d4998",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 2125,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.stat.FrequencyTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/stat/Frequency.java b/src/main/java/org/apache/commons/math/stat/Frequency.java\nindex c45d72883..68c8bf2de 100644\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n@@ -300,7 +300,7 @@ public long getCount(char v) {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+        return getPct((Comparable<?>) v);\n     }\n \n     /**\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "329",
        "nb_skipped": 0,
        "commit": "6dd3724b",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 5864,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.special.GammaTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/special/Gamma.java b/src/main/java/org/apache/commons/math4/special/Gamma.java\nindex aa0e90c23..f390f7c2b 100644\n--- a/src/main/java/org/apache/commons/math4/special/Gamma.java\n+++ b/src/main/java/org/apache/commons/math4/special/Gamma.java\n@@ -695,7 +695,7 @@ public static double gamma(final double x) {\n             }\n         } else {\n             final double y = absX + LANCZOS_G + 0.5;\n-            final double gammaAbs = SQRT_TWO_PI / x *\n+            final double gammaAbs = SQRT_TWO_PI / absX *\n                                     FastMath.pow(y, absX + 0.5) *\n                                     FastMath.exp(-y) * lanczos(absX);\n             if (x > 0.0) {\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "1283",
        "nb_skipped": 3,
        "commit": "9e0c5ad4",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2042,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.optimization.linear.SimplexSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex b38776718..97d80619d 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -69,7 +69,7 @@\n     private final LinearObjectiveFunction f;\n \n     /** Linear constraints. */\n-    private final Collection<LinearConstraint> constraints;\n+    private final List<LinearConstraint> constraints;\n \n     /** Whether to restrict the variables to non-negative values. */\n     private final boolean restrictToNonNegative;\n@@ -103,7 +103,7 @@\n                    final GoalType goalType, final boolean restrictToNonNegative,\n                    final double epsilon) {\n         this.f                      = f;\n-        this.constraints            = constraints;\n+        this.constraints            = normalizeConstraints(constraints);\n         this.restrictToNonNegative  = restrictToNonNegative;\n         this.epsilon                = epsilon;\n         this.numDecisionVariables   = getNumVariables() + (restrictToNonNegative ? 0 : 1);\n@@ -123,7 +123,6 @@\n     protected double[][] createTableau(final boolean maximize) {\n \n         // create a matrix of the correct size\n-        List<LinearConstraint> constraints = getNormalizedConstraints();\n         int width = numDecisionVariables + numSlackVariables +\n         numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS\n         int height = constraints.size() + getNumObjectiveFunctions();\n@@ -192,9 +191,10 @@ public int getNumVariables() {\n \n     /**\n      * Get new versions of the constraints which have positive right hand sides.\n+     * @param constraints original (not normalized) constraints\n      * @return new versions of the constraints\n      */\n-    public List<LinearConstraint> getNormalizedConstraints() {\n+    public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> constraints) {\n         List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();\n         for (LinearConstraint constraint : constraints) {\n             normalized.add(normalize(constraint));\n",
        "project": "commons-math",
        "linesAdd": 3,
        "jira_id": "290",
        "nb_skipped": 0,
        "commit": "b01fcc31",
        "nb_failure": 0,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5392,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.linear.EigenSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java b/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\nindex 4652f618b..b5e93ce2b 100644\n--- a/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n@@ -513,15 +513,32 @@ public RealMatrix solve(RealMatrix b) {\n          * @return true if the decomposed matrix is non-singular.\n          */\n         public boolean isNonSingular() {\n+            // The eigenvalues are sorted by size, descending\n+            double largestEigenvalueNorm = eigenvalueNorm(0);\n+            // Corner case: zero matrix, all exactly 0 eigenvalues\n+            if (largestEigenvalueNorm == 0.0) {\n+                return false;\n+            }\n             for (int i = 0; i < realEigenvalues.length; ++i) {\n-                if (realEigenvalues[i] == 0 &&\n-                    imagEigenvalues[i] == 0) {\n+                // Looking for eigenvalues that are 0, where we consider anything much much smaller\n+                // than the largest eigenvalue to be effectively 0.\n+                if (Precision.equals(eigenvalueNorm(i) / largestEigenvalueNorm, 0, EPSILON)) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n \n+        /**\n+         * @param i which eigenvalue to find the norm of\n+         * @return the norm of ith (complex) eigenvalue.\n+         */\n+        private double eigenvalueNorm(int i) {\n+            final double re = realEigenvalues[i];\n+            final double im = imagEigenvalues[i];\n+            return FastMath.sqrt(re * re + im * im);\n+        }\n+\n         /**\n          * Get the inverse of the decomposed matrix.\n          *\n",
        "project": "commons-math",
        "linesAdd": 11,
        "jira_id": "1045",
        "nb_skipped": 4,
        "commit": "a4ffd393",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2130,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.analysis.solvers.BrentSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 4e95ed5eb..e0cb42714 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -32,6 +32,11 @@\n  */\n public class BrentSolver extends UnivariateRealSolverImpl {\n \n+    /** Error message for non-bracketing interval. */\n+    private static final String NON_BRACKETING_MESSAGE =\n+        \"function values at endpoints do not have different signs.  \" +\n+        \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\";\n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 7694577816772532779L;\n \n@@ -128,6 +133,11 @@ public double solve(final UnivariateRealFunction f,\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        if (yMin * yMax > 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+        }\n+\n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n@@ -176,9 +186,7 @@ public double solve(final UnivariateRealFunction f,\n             } else {\n                 // neither value is close to zero and min and max do not bracket root.\n                 throw MathRuntimeException.createIllegalArgumentException(\n-                        \"function values at endpoints do not have different signs.  \" +\n-                        \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\n-                        min, max, yMin, yMax);\n+                        NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n             }\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n",
        "project": "commons-math",
        "linesAdd": 10,
        "jira_id": "343",
        "nb_skipped": 0,
        "commit": "f6dd42b4",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2888,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.geometry.euclidean.threed.RotationTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\nindex bfa7f2692..ada0a8fb0 100644\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\n@@ -313,92 +313,51 @@ public Rotation(double[][] m, double threshold)\n   public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n \n   // norms computation\n-  double u1u1 = Vector3D.dotProduct(u1, u1);\n-  double u2u2 = Vector3D.dotProduct(u2, u2);\n-  double v1v1 = Vector3D.dotProduct(v1, v1);\n-  double v2v2 = Vector3D.dotProduct(v2, v2);\n+  double u1u1 = u1.getNormSq();\n+  double u2u2 = u2.getNormSq();\n+  double v1v1 = v1.getNormSq();\n+  double v2v2 = v2.getNormSq();\n   if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n     throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n   }\n \n-  double u1x = u1.getX();\n-  double u1y = u1.getY();\n-  double u1z = u1.getZ();\n-\n-  double u2x = u2.getX();\n-  double u2y = u2.getY();\n-  double u2z = u2.getZ();\n-\n   // normalize v1 in order to have (v1'|v1') = (u1|u1)\n-  double coeff = FastMath.sqrt (u1u1 / v1v1);\n-  double v1x   = coeff * v1.getX();\n-  double v1y   = coeff * v1.getY();\n-  double v1z   = coeff * v1.getZ();\n-  v1 = new Vector3D(v1x, v1y, v1z);\n-\n-  // adjust v2 in order to have (u1|u2) = (v1|v2) and (v2'|v2') = (u2|u2)\n-  double u1u2   = Vector3D.dotProduct(u1, u2);\n-  double v1v2   = Vector3D.dotProduct(v1, v2);\n+  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n+\n+  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\n+  double u1u2   = u1.dotProduct(u2);\n+  double v1v2   = v1.dotProduct(v2);\n   double coeffU = u1u2 / u1u1;\n   double coeffV = v1v2 / u1u1;\n   double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n   double alpha  = coeffU - beta * coeffV;\n-  double v2x    = alpha * v1x + beta * v2.getX();\n-  double v2y    = alpha * v1y + beta * v2.getY();\n-  double v2z    = alpha * v1z + beta * v2.getZ();\n-  v2 = new Vector3D(v2x, v2y, v2z);\n-\n-  // preliminary computation (we use explicit formulation instead\n-  // of relying on the Vector3D class in order to avoid building lots\n-  // of temporary objects)\n+  v2 = new Vector3D(alpha, v1, beta, v2);\n+\n+  // preliminary computation\n   Vector3D uRef  = u1;\n   Vector3D vRef  = v1;\n-  double dx1 = v1x - u1.getX();\n-  double dy1 = v1y - u1.getY();\n-  double dz1 = v1z - u1.getZ();\n-  double dx2 = v2x - u2.getX();\n-  double dy2 = v2y - u2.getY();\n-  double dz2 = v2z - u2.getZ();\n-  Vector3D k = new Vector3D(dy1 * dz2 - dz1 * dy2,\n-                            dz1 * dx2 - dx1 * dz2,\n-                            dx1 * dy2 - dy1 * dx2);\n-  double c = k.getX() * (u1y * u2z - u1z * u2y) +\n-             k.getY() * (u1z * u2x - u1x * u2z) +\n-             k.getZ() * (u1x * u2y - u1y * u2x);\n-\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is in the (u1, u2) plane\n+  Vector3D v1Su1 = v1.subtract(u1);\n+  Vector3D v2Su2 = v2.subtract(u2);\n+  Vector3D k     = v1Su1.crossProduct(v2Su2);\n+  Vector3D u3    = u1.crossProduct(u2);\n+  double c       = k.dotProduct(u3);\n+  final double inPlaneThreshold = 0.001;\n+  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n+    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n     // we try other vectors\n-    Vector3D u3 = Vector3D.crossProduct(u1, u2);\n     Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    double u3x  = u3.getX();\n-    double u3y  = u3.getY();\n-    double u3z  = u3.getZ();\n-    double v3x  = v3.getX();\n-    double v3y  = v3.getY();\n-    double v3z  = v3.getZ();\n-\n-    double dx3 = v3x - u3x;\n-    double dy3 = v3y - u3y;\n-    double dz3 = v3z - u3z;\n-    k = new Vector3D(dy1 * dz3 - dz1 * dy3,\n-                     dz1 * dx3 - dx1 * dz3,\n-                     dx1 * dy3 - dy1 * dx3);\n-    c = k.getX() * (u1y * u3z - u1z * u3y) +\n-        k.getY() * (u1z * u3x - u1x * u3z) +\n-        k.getZ() * (u1x * u3y - u1y * u3x);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is aligned with u1:\n-      // we try (u2, u3) and (v2, v3)\n-      k = new Vector3D(dy2 * dz3 - dz2 * dy3,\n-                       dz2 * dx3 - dx2 * dz3,\n-                       dx2 * dy3 - dy2 * dx3);\n-      c = k.getX() * (u2y * u3z - u2z * u3y) +\n-          k.getY() * (u2z * u3x - u2x * u3z) +\n-          k.getZ() * (u2x * u3y - u2y * u3x);\n-\n-      if (c == 0) {\n+    Vector3D v3Su3 = v3.subtract(u3);\n+    k = v1Su1.crossProduct(v3Su3);\n+    Vector3D u2Prime = u1.crossProduct(u3);\n+    c = k.dotProduct(u2Prime);\n+\n+    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {\n+      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n+      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n+      k = v2Su2.crossProduct(v3Su3);;\n+      c = k.dotProduct(u2.crossProduct(u3));;\n+\n+      if (c <= 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n@@ -427,8 +386,7 @@ public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n                     uRef.getZ() * q1 - uRef.getX() * q3,\n                     uRef.getX() * q2 - uRef.getY() * q1);\n-   c = Vector3D.dotProduct(k, k);\n-  q0 = Vector3D.dotProduct(vRef, k) / (c + c);\n+  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n \n   }\n \n@@ -452,7 +410,7 @@ public Rotation(Vector3D u, Vector3D v) {\n         throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n     }\n \n-    double dot = Vector3D.dotProduct(u, v);\n+    double dot = u.dotProduct(v);\n \n     if (dot < ((2.0e-15 - 1.0) * normProduct)) {\n       // special case u = -v: we select a PI angle rotation around\n@@ -467,9 +425,10 @@ public Rotation(Vector3D u, Vector3D v) {\n       // the shortest possible rotation: axis orthogonal to this plane\n       q0 = FastMath.sqrt(0.5 * (1.0 + dot / normProduct));\n       double coeff = 1.0 / (2.0 * q0 * normProduct);\n-      q1 = coeff * (v.getY() * u.getZ() - v.getZ() * u.getY());\n-      q2 = coeff * (v.getZ() * u.getX() - v.getX() * u.getZ());\n-      q3 = coeff * (v.getX() * u.getY() - v.getY() * u.getX());\n+      Vector3D q = v.crossProduct(u);\n+      q1 = coeff * q.getX();\n+      q2 = coeff * q.getY();\n+      q3 = coeff * q.getZ();\n     }\n \n   }\n",
        "project": "commons-math",
        "linesAdd": 33,
        "jira_id": "639",
        "nb_skipped": 1,
        "commit": "8b418000",
        "nb_failure": 1,
        "linesRem": 72,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5627,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.geometry.spherical.oned.ArcsSetTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/spherical/oned/ArcsSet.java b/src/main/java/org/apache/commons/math3/geometry/spherical/oned/ArcsSet.java\nindex 06a8bb2ec..08ec3adcc 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/spherical/oned/ArcsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/spherical/oned/ArcsSet.java\n@@ -717,10 +717,10 @@ public Side side(final Arc arc) {\n             final double syncedStart = MathUtils.normalizeAngle(a[0], reference) - arc.getInf();\n             final double arcOffset   = a[0] - syncedStart;\n             final double syncedEnd   = a[1] - arcOffset;\n-            if (syncedStart < arcLength || syncedEnd > MathUtils.TWO_PI) {\n+            if (syncedStart <= arcLength - getTolerance() || syncedEnd >= MathUtils.TWO_PI + getTolerance()) {\n                 inMinus = true;\n             }\n-            if (syncedEnd > arcLength) {\n+            if (syncedEnd >= arcLength + getTolerance()) {\n                 inPlus = true;\n             }\n         }\n@@ -749,10 +749,8 @@ public Side side(final Arc arc) {\n      */\n     public Split split(final Arc arc) {\n \n-        final BSPTree<Sphere1D> minus = new BSPTree<Sphere1D>();\n-        minus.setAttribute(Boolean.FALSE);\n-        final BSPTree<Sphere1D> plus  = new BSPTree<Sphere1D>();\n-        plus.setAttribute(Boolean.FALSE);\n+        final List<Double> minus = new ArrayList<Double>();\n+        final List<Double>  plus = new ArrayList<Double>();\n \n         final double reference = FastMath.PI + arc.getInf();\n         final double arcLength = arc.getSup() - arc.getInf();\n@@ -763,51 +761,51 @@ public Split split(final Arc arc) {\n             final double syncedEnd   = a[1] - arcOffset;\n             if (syncedStart < arcLength) {\n                 // the start point a[0] is in the minus part of the arc\n-                addArcLimit(minus, a[0], true);\n+                minus.add(a[0]);\n                 if (syncedEnd > arcLength) {\n                     // the end point a[1] is past the end of the arc\n                     // so we leave the minus part and enter the plus part\n                     final double minusToPlus = arcLength + arcOffset;\n-                    addArcLimit(minus, minusToPlus, false);\n-                    addArcLimit(plus, minusToPlus, true);\n+                    minus.add(minusToPlus);\n+                    plus.add(minusToPlus);\n                     if (syncedEnd > MathUtils.TWO_PI) {\n                         // in fact the end point a[1] goes far enough that we\n                         // leave the plus part of the arc and enter the minus part again\n                         final double plusToMinus = MathUtils.TWO_PI + arcOffset;\n-                        addArcLimit(plus, plusToMinus, false);\n-                        addArcLimit(minus, plusToMinus, true);\n-                        addArcLimit(minus, a[1], false);\n+                        plus.add(plusToMinus);\n+                        minus.add(plusToMinus);\n+                        minus.add(a[1]);\n                     } else {\n                         // the end point a[1] is in the plus part of the arc\n-                        addArcLimit(plus, a[1], false);\n+                        plus.add(a[1]);\n                     }\n                 } else {\n                     // the end point a[1] is in the minus part of the arc\n-                    addArcLimit(minus, a[1], false);\n+                    minus.add(a[1]);\n                 }\n             } else {\n                 // the start point a[0] is in the plus part of the arc\n-                addArcLimit(plus, a[0], true);\n+                plus.add(a[0]);\n                 if (syncedEnd > MathUtils.TWO_PI) {\n                     // the end point a[1] wraps around to the start of the arc\n                     // so we leave the plus part and enter the minus part\n                     final double plusToMinus = MathUtils.TWO_PI + arcOffset;\n-                    addArcLimit(plus, plusToMinus, false);\n-                    addArcLimit(minus, plusToMinus, true);\n+                    plus.add(plusToMinus);\n+                    minus.add(plusToMinus);\n                     if (syncedEnd > MathUtils.TWO_PI + arcLength) {\n                         // in fact the end point a[1] goes far enough that we\n                         // leave the minus part of the arc and enter the plus part again\n                         final double minusToPlus = MathUtils.TWO_PI + arcLength + arcOffset;\n-                        addArcLimit(minus, minusToPlus, false);\n-                        addArcLimit(plus, minusToPlus, true);\n-                        addArcLimit(plus, a[1], false);\n+                        minus.add(minusToPlus);\n+                        plus.add(minusToPlus);\n+                        plus.add(a[1]);\n                     } else {\n                         // the end point a[1] is in the minus part of the arc\n-                        addArcLimit(minus, a[1], false);\n+                        minus.add(a[1]);\n                     }\n                 } else {\n                     // the end point a[1] is in the plus part of the arc\n-                    addArcLimit(plus, a[1], false);\n+                    plus.add(a[1]);\n                 }\n             }\n         }\n@@ -825,27 +824,81 @@ private void addArcLimit(final BSPTree<Sphere1D> tree, final double alpha, final\n         final LimitAngle limit = new LimitAngle(new S1Point(alpha), !isStart, getTolerance());\n         final BSPTree<Sphere1D> node = tree.getCell(limit.getLocation(), getTolerance());\n         if (node.getCut() != null) {\n-            // we find again an already added limit,\n-            // this means we have done a full turn around the circle\n-            leafBefore(node).setAttribute(Boolean.valueOf(!isStart));\n-        } else {\n-            // it's a new node\n+            // this should never happen\n+            throw new MathInternalError();\n+        }\n+\n         node.insertCut(limit);\n         node.setAttribute(null);\n         node.getPlus().setAttribute(Boolean.FALSE);\n         node.getMinus().setAttribute(Boolean.TRUE);\n-        }\n+\n     }\n \n     /** Create a split part.\n-     * @param tree BSP tree containing the limit angles of the split part\n+     * <p>\n+     * As per construction, the list of limit angles is known to have\n+     * an even number of entries, with start angles at even indices and\n+     * end angles at odd indices.\n+     * </p>\n+     * @param limits limit angles of the split part\n      * @return split part (may be null)\n      */\n-    private ArcsSet createSplitPart(final BSPTree<Sphere1D> tree) {\n-        if (tree.getCut() == null && !(Boolean) tree.getAttribute()) {\n+    private ArcsSet createSplitPart(final List<Double> limits) {\n+        if (limits.isEmpty()) {\n+            return null;\n+        } else {\n+\n+            // collapse close limit angles\n+            for (int i = 0; i < limits.size(); ++i) {\n+                final int    j  = (i + 1) % limits.size();\n+                final double lA = limits.get(i);\n+                final double lB = MathUtils.normalizeAngle(limits.get(j), lA);\n+                if (FastMath.abs(lB - lA) <= getTolerance()) {\n+                    // the two limits are too close to each other, we remove both of them\n+                    if (j > 0) {\n+                        // regular case, the two entries are consecutive ones\n+                        limits.remove(j);\n+                        limits.remove(i);\n+                        i = i - 1;\n+                    } else {\n+                        // special case, i the the last entry and j is the first entry\n+                        // we have wrapped around list end\n+                        final double lEnd   = limits.remove(limits.size() - 1);\n+                        final double lStart = limits.remove(0);\n+                        if (limits.isEmpty()) {\n+                            // the ends were the only limits, is it a full circle or an empty circle?\n+                            if (lEnd - lStart > FastMath.PI) {\n+                                // it was full circle\n+                                return new ArcsSet(new BSPTree<Sphere1D>(Boolean.TRUE), getTolerance());\n+                            } else {\n+                                // it was an empty circle\n                                 return null;\n+                            }\n                         } else {\n+                            // we have removed the first interval start, so our list\n+                            // currently starts with an interval end, which is wrong\n+                            // we need to move this interval end to the end of the list\n+                            limits.add(limits.remove(0) + MathUtils.TWO_PI);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // build the tree by adding all angular sectors\n+            BSPTree<Sphere1D> tree = new BSPTree<Sphere1D>(Boolean.FALSE);\n+            for (int i = 0; i < limits.size() - 1; i += 2) {\n+                addArcLimit(tree, limits.get(i),     true);\n+                addArcLimit(tree, limits.get(i + 1), false);\n+            }\n+\n+            if (tree.getCut() == null) {\n+                // we did not insert anything\n+                return null;\n+            }\n+\n             return new ArcsSet(tree, getTolerance());\n+\n         }\n     }\n \n",
        "project": "commons-math",
        "linesAdd": 63,
        "jira_id": "1093",
        "nb_skipped": 5,
        "commit": "7cfbc0da",
        "nb_failure": 1,
        "linesRem": 27,
        "singleLine": false
    },
    {
        "files": 7,
        "nb_test": 4903,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizerTest",
            "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest",
            "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizerTest",
            "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizerTest",
            "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizerTest",
            "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizerTest",
            "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerNelderMeadTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\nindex 75c9757ae..927e17f5b 100644\n--- a/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n@@ -48,7 +48,7 @@ protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\n         this.checker = checker;\n \n         evaluations = new Incrementor(0, new MaxEvalCallback());\n-        iterations = new Incrementor(0, new MaxIterCallback());\n+        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\nindex e010781af..bd12b54fc 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\n@@ -211,16 +211,15 @@ protected PointValuePair doOptimize() {\n         }\n \n         PointValuePair current = null;\n-        int iter = 0;\n         int maxEval = getMaxEvaluations();\n         while (true) {\n-            ++iter;\n+            incrementIterationCount();\n \n             final double objective = computeObjectiveValue(point);\n             PointValuePair previous = current;\n             current = new PointValuePair(point, objective);\n             if (previous != null) {\n-                if (checker.converged(iter, previous, current)) {\n+                if (checker.converged(getIterations(), previous, current)) {\n                     // We have found an optimum.\n                     return current;\n                 }\n@@ -274,7 +273,7 @@ protected PointValuePair doOptimize() {\n             steepestDescent = newSteepestDescent;\n \n             // Compute conjugate search direction.\n-            if (iter % n == 0 ||\n+            if (getIterations() % n == 0 ||\n                 beta < 0) {\n                 // Break conjugation: reset search direction.\n                 searchDirection = steepestDescent.clone();\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java\nindex c7216f9e0..fed67b119 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java\n@@ -385,6 +385,8 @@ protected PointValuePair doOptimize() {\n \n         generationLoop:\n         for (iterations = 1; iterations <= maxIterations; iterations++) {\n+            incrementIterationCount();\n+\n             // Generate and evaluate lambda offspring\n             final RealMatrix arz = randn1(dimension, lambda);\n             final RealMatrix arx = zeros(dimension, lambda);\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java\nindex 9572820b2..afe8d2f5d 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java\n@@ -188,9 +188,8 @@ protected PointValuePair doOptimize() {\n         double[] x = guess;\n         double fVal = computeObjectiveValue(x);\n         double[] x1 = x.clone();\n-        int iter = 0;\n         while (true) {\n-            ++iter;\n+            incrementIterationCount();\n \n             double fX = fVal;\n             double fX2 = 0;\n@@ -224,7 +223,7 @@ protected PointValuePair doOptimize() {\n             final PointValuePair current = new PointValuePair(x, fVal);\n             if (!stop) { // User-defined stopping criteria.\n                 if (checker != null) {\n-                    stop = checker.converged(iter, previous, current);\n+                    stop = checker.converged(getIterations(), previous, current);\n                 }\n             }\n             if (stop) {\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java\nindex 3d16aa8a7..0dd644e22 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java\n@@ -155,7 +155,7 @@ public int compare(final PointValuePair o1,\n         int iteration = 0;\n         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n         while (true) {\n-            if (iteration > 0) {\n+            if (getIterations() > 0) {\n                 boolean converged = true;\n                 for (int i = 0; i < simplex.getSize(); i++) {\n                     PointValuePair prev = previous[i];\n@@ -171,7 +171,8 @@ public int compare(final PointValuePair o1,\n             // We still need to search.\n             previous = simplex.getPoints();\n             simplex.iterate(evalFunc, comparator);\n-            ++iteration;\n+\n+            incrementIterationCount();\n         }\n     }\n \ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java\nindex a2834f227..844ed2208 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java\n@@ -103,9 +103,8 @@ public PointVectorValuePair doOptimize() {\n \n         // iterate until convergence is reached\n         PointVectorValuePair current = null;\n-        int iter = 0;\n         for (boolean converged = false; !converged;) {\n-            ++iter;\n+            incrementIterationCount();\n \n             // evaluate the objective function and its jacobian\n             PointVectorValuePair previous = current;\n@@ -157,7 +156,7 @@ public PointVectorValuePair doOptimize() {\n \n             // Check convergence.\n             if (previous != null) {\n-                converged = checker.converged(iter, previous, current);\n+                converged = checker.converged(getIterations(), previous, current);\n                 if (converged) {\n                     setCost(computeCost(currentResiduals));\n                     return current;\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java\nindex ca2d1381b..4016131e1 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java\n@@ -319,10 +319,10 @@ protected PointVectorValuePair doOptimize() {\n         // Outer loop.\n         lmPar = 0;\n         boolean firstIteration = true;\n-        int iter = 0;\n         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n         while (true) {\n-            ++iter;\n+            incrementIterationCount();\n+\n             final PointVectorValuePair previous = current;\n \n             // QR decomposition of the jacobian matrix\n@@ -486,7 +486,7 @@ protected PointVectorValuePair doOptimize() {\n                     // tests for convergence.\n                     if (checker != null) {\n                         // we use the vectorial convergence checker\n-                        if (checker.converged(iter, previous, current)) {\n+                        if (checker.converged(getIterations(), previous, current)) {\n                             setCost(currentCost);\n                             return current;\n                         }\n",
        "project": "commons-math",
        "linesAdd": 16,
        "jira_id": "949",
        "nb_skipped": 4,
        "commit": "f83bbc1d",
        "nb_failure": 28,
        "linesRem": 16,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2225,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.util.MathUtilsTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex bd6852389..f015cdb70 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -82,6 +82,9 @@\n     /** Offset to order signed double numbers lexicographically. */\n     private static final long SGN_MASK = 0x8000000000000000L;\n \n+    /** Offset to order signed double numbers lexicographically. */\n+    private static final int SGN_MASK_FLOAT = 0x80000000;\n+\n     /** All long-representable factorials */\n     private static final long[] FACTORIALS = new long[] {\n                        1l,                  1l,                   2l,\n@@ -414,6 +417,160 @@ public static double cosh(double x) {\n         return (FastMath.exp(x) + FastMath.exp(-x)) / 2.0;\n     }\n \n+    /**\n+     * Returns true iff they are equal as defined by\n+     * {@link #equals(float,float,int) equals(x, y, 1)}.\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @return {@code true} if the values are equal.\n+     */\n+    public static boolean equals(float x, float y) {\n+        return equals(x, y, 1);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are NaN or neither is NaN and they are\n+     * equal as defined by {@link #equals(float,float) this method}.\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @return {@code true} if the values are equal or both are NaN.\n+     */\n+    public static boolean equalsIncludingNaN(float x, float y) {\n+        return (Float.isNaN(x) && Float.isNaN(y)) || equals(x, y, 1);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are equal or within the range of allowed\n+     * error (inclusive).\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param eps the amount of absolute error to allow.\n+     * @return {@code true} if the values are equal or within range of each other.\n+     */\n+    public static boolean equals(float x, float y, float eps) {\n+        return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n+    }\n+\n+    /**\n+     * Returns true if both arguments are NaN or are equal or within the range\n+     * of allowed error (inclusive).\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param eps the amount of absolute error to allow.\n+     * @return {@code true} if the values are equal or within range of each other,\n+     * or both are NaN.\n+     */\n+    public static boolean equalsIncludingNaN(float x, float y, float eps) {\n+        return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are equal or within the range of allowed\n+     * error (inclusive).\n+     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n+     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n+     * point numbers are considered equal.\n+     * Adapted from <a\n+     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n+     * Bruce Dawson</a>\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n+     * values between {@code x} and {@code y}.\n+     * @return {@code true} if there are fewer than {@code maxUlps} floating\n+     * point values between {@code x} and {@code y}.\n+     */\n+    public static boolean equals(float x, float y, int maxUlps) {\n+        // Check that \"maxUlps\" is non-negative and small enough so that\n+        // NaN won't compare as equal to anything (except another NaN).\n+        assert maxUlps > 0 && maxUlps < NAN_GAP;\n+\n+        int xInt = Float.floatToIntBits(x);\n+        int yInt = Float.floatToIntBits(y);\n+\n+        // Make lexicographically ordered as a two's-complement integer.\n+        if (xInt < 0) {\n+            xInt = SGN_MASK_FLOAT - xInt;\n+        }\n+        if (yInt < 0) {\n+            yInt = SGN_MASK_FLOAT - yInt;\n+        }\n+\n+        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n+\n+        return isEqual && !Float.isNaN(x) && !Float.isNaN(y);\n+    }\n+\n+    /**\n+     * Returns true if both arguments are NaN or if they are equal as defined\n+     * by {@link #equals(float,float,int) this method}.\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n+     * values between {@code x} and {@code y}.\n+     * @return {@code true} if both arguments are NaN or if there are less than\n+     * {@code maxUlps} floating point values between {@code x} and {@code y}.\n+     */\n+    public static boolean equalsIncludingNaN(float x, float y, int maxUlps) {\n+        return (Float.isNaN(x) && Float.isNaN(y)) || equals(x, y, maxUlps);\n+    }\n+\n+    /**\n+     * Returns true iff both arguments are null or have same dimensions and all\n+     * their elements are equal as defined by\n+     * {@link #equals(float,float) this method}.\n+     *\n+     * @param x first array\n+     * @param y second array\n+     * @return true if the values are both null or have same dimension\n+     * and equal elements.\n+     */\n+    public static boolean equals(float[] x, float[] y) {\n+        if ((x == null) || (y == null)) {\n+            return !((x == null) ^ (y == null));\n+        }\n+        if (x.length != y.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < x.length; ++i) {\n+            if (!equals(x[i], y[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true iff both arguments are null or have same dimensions and all\n+     * their elements are equal as defined by\n+     * {@link #equalsIncludingNaN(double,double) this method}.\n+     *\n+     * @param x first array\n+     * @param y second array\n+     * @return true if the values are both null or have same dimension and\n+     * equal elements\n+     */\n+    public static boolean equalsIncludingNaN(float[] x, float[] y) {\n+        if ((x == null) || (y == null)) {\n+            return !((x == null) ^ (y == null));\n+        }\n+        if (x.length != y.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < x.length; ++i) {\n+            if (!equalsIncludingNaN(x[i], y[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n     /**\n      * Returns true iff they are equal as defined by\n      * {@link #equals(double,double,int) equals(x, y, 1)}.\n",
        "project": "commons-math",
        "linesAdd": 70,
        "jira_id": "471",
        "nb_skipped": 1,
        "commit": "a4b1948b",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 11,
        "nb_test": 3095,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.ode.nonstiff.HighamHall54StepInterpolatorTest",
            "org.apache.commons.math.ode.nonstiff.GillStepInterpolatorTest",
            "org.apache.commons.math.ode.nonstiff.MidpointStepInterpolatorTest",
            "org.apache.commons.math.ode.events.ReappearingEventTest",
            "org.apache.commons.math.ode.nonstiff.DormandPrince54StepInterpolatorTest",
            "org.apache.commons.math.ode.nonstiff.ThreeEighthesStepInterpolatorTest",
            "org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaStepInterpolatorTest",
            "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolatorTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\nindex 42796c755..baf236a52 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\n@@ -48,7 +48,7 @@\n     extends RungeKuttaStepInterpolator {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 20110928L;\n+    private static final long serialVersionUID = 20111120L;\n \n     /** Simple constructor.\n      * This constructor builds an instance that is not usable yet, the\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\nindex af32c4c01..1dac8ab30 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n@@ -72,7 +72,7 @@\n     private static final double D6 =      69997945.0 /     29380423.0;\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 20110928L;\n+    private static final long serialVersionUID = 20111120L;\n \n     /** First vector for interpolation. */\n     private double[] v1;\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\nindex 91442bbf2..64dd7d77b 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n@@ -39,7 +39,7 @@\n   extends RungeKuttaStepInterpolator {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 20110928L;\n+    private static final long serialVersionUID = 20111120L;\n \n     /** Propagation weights, element 1. */\n     private static final double B_01 =         104257.0 / 1920240.0;\n@@ -368,6 +368,21 @@ protected void computeInterpolatedStateAndDerivatives(final double theta,\n     final double dot5 = theta2 * (3 + theta * (-12 + theta * (15 - 6 * theta)));\n     final double dot6 = theta2 * theta * (4 + theta * (-15 + theta * (18 - 7 * theta)));\n \n+    if ((previousState != null) && (theta <= 0.5)) {\n+        for (int i = 0; i < interpolatedState.length; ++i) {\n+            interpolatedState[i] = previousState[i] +\n+                    theta * h * (v[0][i] +\n+                            eta * (v[1][i] +\n+                                    theta * (v[2][i] +\n+                                            eta * (v[3][i] +\n+                                                    theta * (v[4][i] +\n+                                                            eta * (v[5][i] +\n+                                                                    theta * (v[6][i])))))));\n+            interpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +\n+                    dot3 * v[3][i] + dot4 * v[4][i] +\n+                    dot5 * v[5][i] + dot6 * v[6][i];\n+        }\n+    } else {\n         for (int i = 0; i < interpolatedState.length; ++i) {\n             interpolatedState[i] = currentState[i] -\n                     oneMinusThetaH * (v[0][i] -\n@@ -381,6 +396,7 @@ protected void computeInterpolatedStateAndDerivatives(final double theta,\n                     dot3 * v[3][i] + dot4 * v[4][i] +\n                     dot5 * v[5][i] + dot6 * v[6][i];\n         }\n+    }\n \n   }\n \ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 87fd71602..34d2c0073 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -202,7 +202,7 @@ public void integrate(final ExpandableStatefulODE equations, final double t)\n     final double[] y = y0.clone();\n     final int stages = c.length + 1;\n     final double[][] yDotK = new double[stages][y.length];\n-    final double[] yTmp    = new double[y.length];\n+    final double[] yTmp    = y0.clone();\n     final double[] yDotTmp = new double[y.length];\n \n     // set up an interpolator sharing the integrator arrays\n@@ -294,6 +294,7 @@ public void integrate(final ExpandableStatefulODE equations, final double t)\n       System.arraycopy(yTmp, 0, y, 0, y0.length);\n       System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n       stepStart = acceptStep(interpolator, y, yDotTmp, t);\n+      System.arraycopy(y, 0, yTmp, 0, y.length);\n \n       if (!isLastStep) {\n \ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\nindex 99a604f3b..d2807a465 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\n@@ -42,7 +42,7 @@\n   extends RungeKuttaStepInterpolator {\n \n   /** Serializable version identifier. */\n-  private static final long serialVersionUID = 20110928L;\n+  private static final long serialVersionUID = 20111120L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\nindex e956b200e..537775556 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n@@ -54,7 +54,7 @@\n     private static final double TWO_PLUS_SQRT_2 = 2 + FastMath.sqrt(2.0);\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = 20110928L;\n+    private static final long serialVersionUID = 20111120L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\nindex ba112d449..b928b53ab 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n@@ -33,7 +33,7 @@\n   extends RungeKuttaStepInterpolator {\n \n   /** Serializable version identifier */\n-  private static final long serialVersionUID = 20110928L;\n+  private static final long serialVersionUID = 20111120L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\nindex 1c7648365..25f77c543 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n@@ -44,7 +44,7 @@\n   extends RungeKuttaStepInterpolator {\n \n   /** Serializable version identifier */\n-  private static final long serialVersionUID = 20110928L;\n+  private static final long serialVersionUID = 20111120L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\nindex fb82d0c9e..c51620c17 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n@@ -107,7 +107,7 @@ public void integrate(final ExpandableStatefulODE equations, final double t)\n     for (int i = 0; i < stages; ++i) {\n       yDotK [i] = new double[y0.length];\n     }\n-    final double[] yTmp    = new double[y0.length];\n+    final double[] yTmp    = y0.clone();\n     final double[] yDotTmp = new double[y0.length];\n \n     // set up an interpolator sharing the integrator arrays\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\nindex 987dfb1f3..55146c32c 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n@@ -38,6 +38,9 @@\n abstract class RungeKuttaStepInterpolator\n   extends AbstractStepInterpolator {\n \n+    /** Previous state. */\n+    protected double[] previousState;\n+\n     /** Slopes at the intermediate points */\n     protected double[][] yDotK;\n \n@@ -55,7 +58,7 @@\n    * uninitialized model and latter initializing the copy.\n    */\n   protected RungeKuttaStepInterpolator() {\n-    super();\n+    previousState = null;\n     yDotK         = null;\n     integrator    = null;\n   }\n@@ -82,16 +85,16 @@ public RungeKuttaStepInterpolator(final RungeKuttaStepInterpolator interpolator)\n     super(interpolator);\n \n     if (interpolator.currentState != null) {\n-      final int dimension = currentState.length;\n+\n+      previousState = interpolator.previousState.clone();\n \n       yDotK = new double[interpolator.yDotK.length][];\n       for (int k = 0; k < interpolator.yDotK.length; ++k) {\n-        yDotK[k] = new double[dimension];\n-        System.arraycopy(interpolator.yDotK[k], 0,\n-                         yDotK[k], 0, dimension);\n+        yDotK[k] = interpolator.yDotK[k].clone();\n       }\n \n     } else {\n+      previousState = null;\n       yDotK = null;\n     }\n \n@@ -129,10 +132,18 @@ public void reinitialize(final AbstractIntegrator rkIntegrator,\n                            final EquationsMapper primaryMapper,\n                            final EquationsMapper[] secondaryMappers) {\n     reinitialize(y, forward, primaryMapper, secondaryMappers);\n+    this.previousState = null;\n     this.yDotK = yDotArray;\n     this.integrator = rkIntegrator;\n   }\n \n+  /** {@inheritDoc} */\n+  @Override\n+  public void shift() {\n+    previousState = currentState.clone();\n+    super.shift();\n+  }\n+\n   /** {@inheritDoc} */\n   @Override\n   public void writeExternal(final ObjectOutput out)\n@@ -143,6 +154,10 @@ public void writeExternal(final ObjectOutput out)\n \n     // save the local attributes\n     final int n = (currentState == null) ? -1 : currentState.length;\n+    for (int i = 0; i < n; ++i) {\n+      out.writeDouble(previousState[i]);\n+    }\n+\n     final int kMax = (yDotK == null) ? -1 : yDotK.length;\n     out.writeInt(kMax);\n     for (int k = 0; k < kMax; ++k) {\n@@ -165,6 +180,15 @@ public void readExternal(final ObjectInput in)\n \n     // read the local attributes\n     final int n = (currentState == null) ? -1 : currentState.length;\n+    if (n < 0) {\n+      previousState = null;\n+    } else {\n+      previousState = new double[n];\n+      for (int i = 0; i < n; ++i) {\n+        previousState[i] = in.readDouble();\n+      }\n+    }\n+\n     final int kMax = in.readInt();\n     yDotK = (kMax < 0) ? null : new double[kMax][];\n     for (int k = 0; k < kMax; ++k) {\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\nindex 731ec444c..fdc9d757c 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n@@ -49,7 +49,7 @@\n   extends RungeKuttaStepInterpolator {\n \n   /** Serializable version identifier */\n-  private static final long serialVersionUID = 20110928L;\n+  private static final long serialVersionUID = 20111120L;\n \n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n",
        "project": "commons-math",
        "linesAdd": 54,
        "jira_id": "705",
        "nb_skipped": 1,
        "commit": "645d642b",
        "nb_failure": 8,
        "linesRem": 15,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3549,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.distribution.BinomialDistributionTest",
            "org.apache.commons.math3.distribution.FDistributionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java b/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\nindex 35fe9160b..253f3c59e 100644\n--- a/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\n+++ b/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java\n@@ -101,19 +101,18 @@ public double evaluate(double x, int maxIterations) {\n      * </p>\n      *\n      * <p>\n-     * The implementation of this method is based on equations 14-17 of:\n+     * The implementation of this method is based on the modified Lentz algorithm as described\n+     * on page 18 ff. in:\n      * <ul>\n      * <li>\n-     *   Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n-     *   Resource. <a target=\"_blank\"\n-     *   href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n-     *   http://mathworld.wolfram.com/ContinuedFraction.html</a>\n+     *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n+     *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n+     *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n      * </li>\n      * </ul>\n-     * The recurrence relationship defined in those equations can result in\n-     * very large intermediate results which can result in numerical overflow.\n-     * As a means to combat these overflow conditions, the intermediate results\n-     * are scaled whenever they threaten to become numerically unstable.</p>\n+     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n+     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n+     * </p>\n      *\n      * @param x the evaluation point.\n      * @param epsilon maximum error allowed.\n@@ -122,72 +121,53 @@ public double evaluate(double x, int maxIterations) {\n      * @throws ConvergenceException if the algorithm fails to converge.\n      */\n     public double evaluate(double x, double epsilon, int maxIterations) {\n-        double p0 = 1.0;\n-        double p1 = getA(0, x);\n-        double q0 = 0.0;\n-        double q1 = 1.0;\n-        double c = p1 / q1;\n-        int n = 0;\n-        double relativeError = Double.MAX_VALUE;\n-        while (n < maxIterations && relativeError > epsilon) {\n-            ++n;\n-            double a = getA(n, x);\n-            double b = getB(n, x);\n-            double p2 = a * p1 + b * p0;\n-            double q2 = a * q1 + b * q0;\n-            boolean infinite = false;\n-            if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n-                /*\n-                 * Need to scale. Try successive powers of the larger of a or b\n-                 * up to 5th power. Throw ConvergenceException if one or both\n-                 * of p2, q2 still overflow.\n-                 */\n-                double scaleFactor = 1d;\n-                double lastScaleFactor = 1d;\n-                final int maxPower = 5;\n-                final double scale = FastMath.max(a,b);\n-                if (scale <= 0) {  // Can't scale\n-                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n-                                                   x);\n-                }\n-                infinite = true;\n-                for (int i = 0; i < maxPower; i++) {\n-                    lastScaleFactor = scaleFactor;\n-                    scaleFactor *= scale;\n-                    if (a != 0.0 && a > b) {\n-                        p2 = p1 / lastScaleFactor + (b / scaleFactor * p0);\n-                        q2 = q1 / lastScaleFactor + (b / scaleFactor * q0);\n-                    } else if (b != 0) {\n-                        p2 = (a / scaleFactor * p1) + p0 / lastScaleFactor;\n-                        q2 = (a / scaleFactor * q1) + q0 / lastScaleFactor;\n-                    }\n-                    infinite = Double.isInfinite(p2) || Double.isInfinite(q2);\n-                    if (!infinite) {\n-                        break;\n+        final double small = 1e-50;\n+        double hPrev = getA(0, x);\n+\n+        // use the value of small as epsilon criteria for zero checks\n+        if (Precision.equals(hPrev, 0.0, small)) {\n+            hPrev = small;\n         }\n+\n+        int n = 1;\n+        double dPrev = 0.0;\n+        double cPrev = hPrev;\n+        double hN = hPrev;\n+\n+        while (n < maxIterations) {\n+            final double a = getA(n, x);\n+            final double b = getB(n, x);\n+\n+            double dN = a + b * dPrev;\n+            if (Precision.equals(dN, 0.0, small)) {\n+                dN = small;\n             }\n+            double cN = a + b / cPrev;\n+            if (Precision.equals(cN, 0.0, small)) {\n+                cN = small;\n             }\n \n-            if (infinite) {\n-               // Scaling failed\n+            dN = 1 / dN;\n+            final double deltaN = cN * dN;\n+            hN = hPrev * deltaN;\n+\n+            if (Double.isInfinite(hN)) {\n                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                                x);\n             }\n-\n-            double r = p2 / q2;\n-\n-            if (Double.isNaN(r)) {\n+            if (Double.isNaN(hN)) {\n                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                                x);\n             }\n-            relativeError = FastMath.abs(r / c - 1.0);\n-\n-            // prepare for next iteration\n-            c = p2 / q2;\n-            p0 = p1;\n-            p1 = p2;\n-            q0 = q1;\n-            q1 = q2;\n+\n+            if (FastMath.abs(deltaN - 1.0) < epsilon) {\n+                break;\n+            }\n+\n+            dPrev = dN;\n+            cPrev = cN;\n+            hPrev = hN;\n+            n++;\n         }\n \n         if (n >= maxIterations) {\n@@ -195,6 +175,7 @@ public double evaluate(double x, double epsilon, int maxIterations) {\n                                                 maxIterations, x);\n         }\n \n-        return c;\n+        return hN;\n     }\n+\n }\n",
        "project": "commons-math",
        "linesAdd": 38,
        "jira_id": "718",
        "nb_skipped": 1,
        "commit": "3a08bfa6",
        "nb_failure": 2,
        "linesRem": 50,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2167,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.linear.AbstractRealVectorTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\nindex 023648de1..e17254367 100644\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n@@ -18,6 +18,7 @@\n package org.apache.commons.math.linear;\n \n import java.util.Iterator;\n+import java.util.NoSuchElementException;\n \n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n@@ -875,34 +876,23 @@ public void setValue(double newValue) {\n         /** Dimension of the vector. */\n         private final int dim;\n \n-        /** Temporary entry (reused on each call to {@link #next()}. */\n-        private EntryImpl tmp = new EntryImpl();\n-\n-        /** Current entry. */\n+        /** last entry returned by {@link #next()} */\n         private EntryImpl current;\n \n-        /** Next entry. */\n+        /** Next entry for {@link #next()} to return. */\n         private EntryImpl next;\n \n         /** Simple constructor. */\n         protected SparseEntryIterator() {\n             dim = getDimension();\n             current = new EntryImpl();\n-            if (current.getValue() == 0) {\n-                advance(current);\n-            }\n-            if(current.getIndex() >= 0){\n-                // There is at least one non-zero entry\n             next = new EntryImpl();\n-                next.setIndex(current.getIndex());\n+            if(next.getValue() == 0){\n             \tadvance(next);\n-            } else {\n-                // The vector consists of only zero entries, so deny having a next\n-                current = null;\n             }\n         }\n \n-        /** Advance an entry up to the next non null one.\n+        /** Advance an entry up to the next nonzero one.\n          * @param e entry to advance\n          */\n         protected void advance(EntryImpl e) {\n@@ -919,22 +909,18 @@ protected void advance(EntryImpl e) {\n \n         /** {@inheritDoc} */\n         public boolean hasNext() {\n-            return current != null;\n+            return next.getIndex() >= 0;\n         }\n \n         /** {@inheritDoc} */\n         public Entry next() {\n-            tmp.setIndex(current.getIndex());\n-            if (next != null) {\n-                current.setIndex(next.getIndex());\n-                advance(next);\n-                if (next.getIndex() < 0) {\n-                    next = null;\n-                }\n-            } else {\n-                current = null;\n+        \tint index = next.getIndex();\n+        \tif(index < 0){\n+        \t\tthrow new NoSuchElementException();\n         \t}\n-            return tmp;\n+        \tcurrent.setIndex(index);\n+        \tadvance(next);\n+        \treturn current;\n         }\n \n         /** {@inheritDoc} */\n",
        "project": "commons-math",
        "linesAdd": 9,
        "jira_id": "367",
        "nb_skipped": 0,
        "commit": "3a15d8ce",
        "nb_failure": 0,
        "linesRem": 20,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5966,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.util.PrecisionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/util/Precision.java b/src/main/java/org/apache/commons/math3/util/Precision.java\nindex d08947617..fa938c008 100644\n--- a/src/main/java/org/apache/commons/math3/util/Precision.java\n+++ b/src/main/java/org/apache/commons/math3/util/Precision.java\n@@ -62,6 +62,14 @@\n     private static final int SGN_MASK_FLOAT = 0x80000000;\n     /** Positive zero. */\n     private static final double POSITIVE_ZERO = 0d;\n+    /** Positive zero bits. */\n+    private static final long POSITIVE_ZERO_DOUBLE_BITS = Double.doubleToRawLongBits(+0.0);\n+    /** Negative zero bits. */\n+    private static final long NEGATIVE_ZERO_DOUBLE_BITS = Double.doubleToRawLongBits(-0.0);\n+    /** Positive zero bits. */\n+    private static final int POSITIVE_ZERO_FLOAT_BITS   = Float.floatToRawIntBits(+0.0f);\n+    /** Negative zero bits. */\n+    private static final int NEGATIVE_ZERO_FLOAT_BITS   = Float.floatToRawIntBits(-0.0f);\n \n     static {\n         /*\n@@ -109,7 +117,7 @@ public static int compareTo(double x, double y, double eps) {\n      * (or fewer) floating point numbers between them, i.e. two adjacent floating\n      * point numbers are considered equal.\n      * Adapted from <a\n-     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n+     * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n      * Bruce Dawson</a>\n      *\n      * @param x first value\n@@ -190,7 +198,7 @@ public static boolean equalsIncludingNaN(float x, float y, float eps) {\n      * (or fewer) floating point numbers between them, i.e. two adjacent floating\n      * point numbers are considered equal.\n      * Adapted from <a\n-     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n+     * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n      * Bruce Dawson</a>\n      *\n      * @param x first value\n@@ -201,21 +209,37 @@ public static boolean equalsIncludingNaN(float x, float y, float eps) {\n      * point values between {@code x} and {@code y}.\n      * @since 2.2\n      */\n-    public static boolean equals(float x, float y, int maxUlps) {\n-        int xInt = Float.floatToIntBits(x);\n-        int yInt = Float.floatToIntBits(y);\n+    public static boolean equals(final float x, final float y, final int maxUlps) {\n \n-        // Make lexicographically ordered as a two's-complement integer.\n-        if (xInt < 0) {\n-            xInt = SGN_MASK_FLOAT - xInt;\n+        final int xInt = Float.floatToRawIntBits(x);\n+        final int yInt = Float.floatToRawIntBits(y);\n+\n+        final boolean isEqual;\n+        if (((xInt ^ yInt) & SGN_MASK_FLOAT) == 0) {\n+            // number have same sign, there is no risk of overflow\n+            isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n+        } else {\n+            // number have opposite signs, take care of overflow\n+            final int deltaPlus;\n+            final int deltaMinus;\n+            if (xInt < yInt) {\n+                deltaPlus  = yInt - POSITIVE_ZERO_FLOAT_BITS;\n+                deltaMinus = xInt - NEGATIVE_ZERO_FLOAT_BITS;\n+            } else {\n+                deltaPlus  = xInt - POSITIVE_ZERO_FLOAT_BITS;\n+                deltaMinus = yInt - NEGATIVE_ZERO_FLOAT_BITS;\n             }\n-        if (yInt < 0) {\n-            yInt = SGN_MASK_FLOAT - yInt;\n+\n+            if (deltaPlus > maxUlps) {\n+                isEqual = false;\n+            } else {\n+                isEqual = deltaMinus <= (maxUlps - deltaPlus);\n             }\n \n-        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n+        }\n \n         return isEqual && !Float.isNaN(x) && !Float.isNaN(y);\n+\n     }\n \n     /**\n@@ -315,12 +339,16 @@ public static boolean equalsIncludingNaN(double x, double y, double eps) {\n     /**\n      * Returns true if both arguments are equal or within the range of allowed\n      * error (inclusive).\n+     * <p>\n      * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n-     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n-     * point numbers are considered equal.\n+     * (or fewer) floating point numbers between them, i.e. two adjacent\n+     * floating point numbers are considered equal.\n+     * </p>\n+     * <p>\n      * Adapted from <a\n-     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n+     * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n      * Bruce Dawson</a>\n+     * </p>\n      *\n      * @param x first value\n      * @param y second value\n@@ -329,21 +357,37 @@ public static boolean equalsIncludingNaN(double x, double y, double eps) {\n      * @return {@code true} if there are fewer than {@code maxUlps} floating\n      * point values between {@code x} and {@code y}.\n      */\n-    public static boolean equals(double x, double y, int maxUlps) {\n-        long xInt = Double.doubleToLongBits(x);\n-        long yInt = Double.doubleToLongBits(y);\n+    public static boolean equals(final double x, final double y, final int maxUlps) {\n \n-        // Make lexicographically ordered as a two's-complement integer.\n-        if (xInt < 0) {\n-            xInt = SGN_MASK - xInt;\n+        final long xInt = Double.doubleToRawLongBits(x);\n+        final long yInt = Double.doubleToRawLongBits(y);\n+\n+        final boolean isEqual;\n+        if (((xInt ^ yInt) & SGN_MASK) == 0l) {\n+            // number have same sign, there is no risk of overflow\n+            isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n+        } else {\n+            // number have opposite signs, take care of overflow\n+            final long deltaPlus;\n+            final long deltaMinus;\n+            if (xInt < yInt) {\n+                deltaPlus  = yInt - POSITIVE_ZERO_DOUBLE_BITS;\n+                deltaMinus = xInt - NEGATIVE_ZERO_DOUBLE_BITS;\n+            } else {\n+                deltaPlus  = xInt - POSITIVE_ZERO_DOUBLE_BITS;\n+                deltaMinus = yInt - NEGATIVE_ZERO_DOUBLE_BITS;\n             }\n-        if (yInt < 0) {\n-            yInt = SGN_MASK - yInt;\n+\n+            if (deltaPlus > maxUlps) {\n+                isEqual = false;\n+            } else {\n+                isEqual = deltaMinus <= (maxUlps - deltaPlus);\n             }\n \n-        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n+        }\n \n         return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n+\n     }\n \n     /**\n",
        "project": "commons-math",
        "linesAdd": 50,
        "jira_id": "1127",
        "nb_skipped": 3,
        "commit": "ba62c59d",
        "nb_failure": 1,
        "linesRem": 16,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 5656,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.geometry.enclosing.WelzlEncloser2DTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/enclosing/Encloser.java b/src/main/java/org/apache/commons/math3/geometry/enclosing/Encloser.java\nindex 4e9270430..a2e168455 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/enclosing/Encloser.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/enclosing/Encloser.java\n@@ -16,8 +16,6 @@\n  */\n package org.apache.commons.math3.geometry.enclosing;\n \n-import java.util.List;\n-\n import org.apache.commons.math3.geometry.Point;\n import org.apache.commons.math3.geometry.Space;\n \n@@ -34,6 +32,6 @@\n      * @param points points to enclose\n      * @return enclosing ball\n      */\n-    EnclosingBall<S, P> enclose(List<P> points);\n+    EnclosingBall<S, P> enclose(Iterable<P> points);\n \n }\ndiff --git a/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java b/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\nindex ce5c58cb5..b8ea5d6bb 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\n@@ -65,9 +65,9 @@ protected WelzlEncloser(final double tolerance, final int dimension,\n     }\n \n     /** {@inheritDoc} */\n-    public EnclosingBall<S, P> enclose(final List<P> points) {\n+    public EnclosingBall<S, P> enclose(final Iterable<P> points) {\n \n-        if (points == null || points.isEmpty()) {\n+        if (points == null || !points.iterator().hasNext()) {\n             // return an empty ball\n             return generator.ballOnSupport(new ArrayList<P>());\n         }\n@@ -81,14 +81,14 @@ protected WelzlEncloser(final double tolerance, final int dimension,\n      * @param points points to be enclosed\n      * @return enclosing ball\n      */\n-    private EnclosingBall<S, P> pivotingBall(final List<P> points) {\n+    private EnclosingBall<S, P> pivotingBall(final Iterable<P> points) {\n \n         List<P> extreme = new ArrayList<P>(max);\n         List<P> support = new ArrayList<P>(max);\n \n         // start with only first point selected as a candidate support\n-        extreme.add(points.get(0));\n-        EnclosingBall<S, P> ball = moveToFrontBall(extreme, support);\n+        extreme.add(points.iterator().next());\n+        EnclosingBall<S, P> ball = moveToFrontBall(extreme, extreme.size(), support);\n \n         while (true) {\n \n@@ -103,7 +103,7 @@ protected WelzlEncloser(final double tolerance, final int dimension,\n             support.clear();\n             support.add(farthest);\n             EnclosingBall<S, P> savedBall = ball;\n-            ball = moveToFrontBall(extreme, support);\n+            ball = moveToFrontBall(extreme, extreme.size(), support);\n             if (ball.getRadius() < savedBall.getRadius()) {\n                 // TODO: fix this, it should never happen but it does!\n                 throw new MathInternalError();\n@@ -122,28 +122,31 @@ protected WelzlEncloser(final double tolerance, final int dimension,\n \n     /** Compute enclosing ball using Welzl's move to front heuristic.\n      * @param extreme subset of extreme points\n+     * @param nbExtreme number of extreme points to consider\n      * @param support points that must belong to the ball support\n      * @return enclosing ball, for the extreme subset only\n      */\n-    private EnclosingBall<S, P> moveToFrontBall(final List<P> extreme, final List<P> support) {\n+    private EnclosingBall<S, P> moveToFrontBall(final List<P> extreme, final int nbExtreme,\n+                                                final List<P> support) {\n \n         // create a new ball on the prescribed support\n         EnclosingBall<S, P> ball = generator.ballOnSupport(support);\n \n         if (ball.getSupportSize() < max) {\n \n-            for (int i = 0; i < extreme.size(); ++i) {\n+            for (int i = 0; i < nbExtreme; ++i) {\n                 final P pi = extreme.get(i);\n                 if (!ball.contains(pi, tolerance)) {\n \n                     // we have found an outside point,\n                     // enlarge the ball by adding it to the support\n                     support.add(pi);\n-                    ball = moveToFrontBall(extreme.subList(i + 1, extreme.size()), support);\n+                    ball = moveToFrontBall(extreme, i, support);\n+                    support.remove(support.size() - 1);\n \n                     // it was an interesting point, move it to the front\n                     // according to Welzl's heuristic\n-                    for (int j = i; j > 1; --j) {\n+                    for (int j = i; j > 0; --j) {\n                         extreme.set(j, extreme.get(j - 1));\n                     }\n                     extreme.set(0, pi);\n@@ -162,7 +165,7 @@ protected WelzlEncloser(final double tolerance, final int dimension,\n      * @param ball current ball\n      * @return farthest point\n      */\n-    public P selectFarthest(final List<P> points, final EnclosingBall<S, P> ball) {\n+    public P selectFarthest(final Iterable<P> points, final EnclosingBall<S, P> ball) {\n \n         final P center = ball.getCenter();\n         P farthest   = null;\n",
        "project": "commons-math",
        "linesAdd": 14,
        "jira_id": "1096",
        "nb_skipped": 5,
        "commit": "faf99727",
        "nb_failure": 0,
        "linesRem": 14,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3531,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.complex.ComplexTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex 3822a89e6..ed76a2950 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -993,8 +993,8 @@ public Complex sqrt1z() {\n      *  </code>\n      * </pre>\n      * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n-     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n+     * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n+     * {@link FastMath#sinh}.\n      * <br/>\n      * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is {@code NaN}.\n@@ -1004,8 +1004,8 @@ public Complex sqrt1z() {\n      * <pre>\n      *  Examples:\n      *  <code>\n-     *   tan(1 &plusmn; INFINITY i) = 0 + NaN i\n-     *   tan(&plusmn;INFINITY + i) = NaN + NaN i\n+     *   tan(a &plusmn; INFINITY i) = 0 &plusmn; i\n+     *   tan(&plusmn;INFINITY + bi) = NaN + NaN i\n      *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n      *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i\n      *  </code>\n@@ -1015,9 +1015,15 @@ public Complex sqrt1z() {\n      * @since 1.2\n      */\n     public Complex tan() {\n-        if (isNaN) {\n+        if (isNaN || Double.isInfinite(real)) {\n             return NaN;\n         }\n+        if (imaginary > 20.0) {\n+            return createComplex(0.0, 1.0);\n+        }\n+        if (imaginary < -20.0) {\n+            return createComplex(0.0, -1.0);\n+        }\n \n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n@@ -1038,8 +1044,8 @@ public Complex tan() {\n      *  </code>\n      * </pre>\n      * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n-     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n+     * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n+     * {@link FastMath#sinh}.\n      * <br/>\n      * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is {@code NaN}.\n@@ -1049,8 +1055,8 @@ public Complex tan() {\n      * <pre>\n      *  Examples:\n      *  <code>\n-     *   tanh(1 &plusmn; INFINITY i) = NaN + NaN i\n-     *   tanh(&plusmn;INFINITY + i) = NaN + 0 i\n+     *   tanh(a &plusmn; INFINITY i) = NaN + NaN i\n+     *   tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i\n      *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n      *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i\n      *  </code>\n@@ -1060,10 +1066,15 @@ public Complex tan() {\n      * @since 1.2\n      */\n     public Complex tanh() {\n-        if (isNaN) {\n+        if (isNaN || Double.isInfinite(imaginary)) {\n             return NaN;\n         }\n-\n+        if (real > 20.0) {\n+            return createComplex(1.0, 0.0);\n+        }\n+        if (real < -20.0) {\n+            return createComplex(-1.0, 0.0);\n+        }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\n",
        "project": "commons-math",
        "linesAdd": 14,
        "jira_id": "722",
        "nb_skipped": 1,
        "commit": "95d15eff",
        "nb_failure": 4,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5714,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.distribution.EnumeratedRealDistributionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/distribution/EnumeratedRealDistribution.java b/src/main/java/org/apache/commons/math3/distribution/EnumeratedRealDistribution.java\nindex d4574342e..270764fd4 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/EnumeratedRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/EnumeratedRealDistribution.java\n@@ -23,6 +24,7 @@\n import org.apache.commons.math3.exception.NotANumberException;\n import org.apache.commons.math3.exception.NotFiniteNumberException;\n import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.random.RandomGenerator;\n import org.apache.commons.math3.random.Well19937c;\n import org.apache.commons.math3.util.Pair;\n@@ -136,6 +138,33 @@ public double cumulativeProbability(final double x) {\n         return probability;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(final double p) throws OutOfRangeException {\n+        if (p < 0.0 || p > 1.0) {\n+            throw new OutOfRangeException(p, 0, 1);\n+        }\n+\n+        double probability = 0;\n+        double x = getSupportLowerBound();\n+        for (final Pair<Double, Double> sample : innerDistribution.getPmf()) {\n+            if (sample.getValue() == 0.0) {\n+                continue;\n+            }\n+\n+            probability += sample.getValue();\n+            x = sample.getKey();\n+\n+            if (probability >= p) {\n+                break;\n+            }\n+        }\n+\n+        return x;\n+    }\n+\n     /**\n      * {@inheritDoc}\n      *\n",
        "project": "commons-math",
        "linesAdd": 25,
        "jira_id": "1065",
        "nb_skipped": 5,
        "commit": "996c0c16",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5962,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.optim.univariate.BrentOptimizerTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/optim/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optim/univariate/BrentOptimizer.java\nindex a5fca86f3..b788c2c78 100644\n--- a/src/main/java/org/apache/commons/math3/optim/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/univariate/BrentOptimizer.java\n@@ -150,7 +150,6 @@ protected UnivariatePointValuePair doOptimize() {\n         // Best point encountered so far (which is the initial guess).\n         UnivariatePointValuePair best = current;\n \n-        int iter = 0;\n         while (true) {\n             final double m = 0.5 * (a + b);\n             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n@@ -238,7 +237,7 @@ protected UnivariatePointValuePair doOptimize() {\n                                  isMinim),\n                             isMinim);\n \n-                if (checker != null && checker.converged(iter, previous, current)) {\n+                if (checker != null && checker.converged(getIterations(), previous, current)) {\n                     return best;\n                 }\n \n@@ -281,7 +280,8 @@ protected UnivariatePointValuePair doOptimize() {\n                                  isMinim),\n                             isMinim);\n             }\n-            ++iter;\n+\n+            incrementIterationCount();\n         }\n     }\n \n",
        "project": "commons-math",
        "linesAdd": 3,
        "jira_id": "1121",
        "nb_skipped": 3,
        "commit": "5a6ccd58",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 6153,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.ode.nonstiff.ClassicalRungeKuttaIntegratorTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/ode/nonstiff/RungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math3/ode/nonstiff/RungeKuttaIntegrator.java\nindex 68bd8b029..5f7d5d88a 100644\n--- a/src/main/java/org/apache/commons/math3/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/nonstiff/RungeKuttaIntegrator.java\n@@ -119,7 +119,19 @@ public void integrate(final ExpandableStatefulODE equations, final double t)\n \n     // set up integration control objects\n     stepStart = equations.getTime();\n-    stepSize  = forward ? step : -step;\n+    if (forward) {\n+        if (stepStart + step >= t) {\n+            stepSize = t - stepStart;\n+        } else {\n+            stepSize = step;\n+        }\n+    } else {\n+        if (stepStart - step <= t) {\n+            stepSize = t - stepStart;\n+        } else {\n+            stepSize = -step;\n+        }\n+    }\n     initIntegration(equations.getTime(), y0, t);\n \n     // main integration loop\n",
        "project": "commons-math",
        "linesAdd": 13,
        "jira_id": "727",
        "nb_skipped": 3,
        "commit": "69273dca",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 4990,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.geometry.euclidean.threed.SubLineTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\nindex a146cb661..aad7b65a5 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java\n@@ -111,6 +111,9 @@ public Vector3D intersection(final SubLine subLine, final boolean includeEndPoin\n \n         // compute the intersection on infinite line\n         Vector3D v1D = line.intersection(subLine.line);\n+        if (v1D == null) {\n+            return null;\n+        }\n \n         // check location of point with respect to first sub-line\n         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\ndiff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\nindex a9d621a44..ea9e96a49 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java\n@@ -115,6 +115,9 @@ public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin\n \n         // compute the intersection on infinite line\n         Vector2D v2D = line1.intersection(line2);\n+        if (v2D == null) {\n+            return null;\n+        }\n \n         // check location of point with respect to first sub-line\n         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n",
        "project": "commons-math",
        "linesAdd": 6,
        "jira_id": "988",
        "nb_skipped": 4,
        "commit": "d270055e",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2902,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.analysis.solvers.RegulaFalsiSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex b3a23a1d4..c781a9011 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -183,14 +183,7 @@ protected final double doSolve() {\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n-                    if (x == x1) {\n-                        final double delta = FastMath.max(rtol * FastMath.abs(x1),\n-                                                          atol);\n-                        // Update formula cannot make any progress: Update the\n-                        // search interval.\n-                        x0 = 0.5 * (x0 + x1 - delta);\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+                    // Nothing.\n                     break;\n                 default:\n                     // Should never happen.\n",
        "project": "commons-math",
        "linesAdd": 0,
        "jira_id": "631",
        "nb_skipped": 1,
        "commit": "ebc61de9",
        "nb_failure": 1,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2121,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 70b2a2b52..1bbad3ec3 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -17,8 +17,6 @@\n \n package org.apache.commons.math.ode.nonstiff;\n \n-import java.util.Arrays;\n-\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.IntegratorException;\n@@ -244,12 +242,15 @@ public double integrate(final FirstOrderDifferentialEquations equations,\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance != null) {\n-            scale = vecAbsoluteTolerance;\n+          final double[] scale = new double[y0.length];\n+          if (vecAbsoluteTolerance == null) {\n+              for (int i = 0; i < scale.length; ++i) {\n+                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n+              }\n             } else {\n-            scale = new double[y0.length];\n-            Arrays.fill(scale, scalAbsoluteTolerance);\n+              for (int i = 0; i < scale.length; ++i) {\n+                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n+              }\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n",
        "project": "commons-math",
        "linesAdd": 8,
        "jira_id": "338",
        "nb_skipped": 0,
        "commit": "8dd22390",
        "nb_failure": 1,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 2264,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.optimization.general.MinpackTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 152c30c3a..c4b19855a 100644\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -247,12 +247,7 @@ public double getRMS() {\n      * @return chi-square value\n      */\n     public double getChiSquare() {\n-        double chiSquare = 0;\n-        for (int i = 0; i < rows; ++i) {\n-            final double residual = residuals[i];\n-            chiSquare += residual * residual * residualsWeights[i];\n-        }\n-        return chiSquare;\n+        return cost*cost;\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\nindex 4cf4ee006..b41456eff 100644\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n@@ -255,6 +255,8 @@ protected VectorialPointValuePair doOptimize()\n         double[] diag    = new double[cols];\n         double[] oldX    = new double[cols];\n         double[] oldRes  = new double[rows];\n+        double[] oldObj  = new double[rows];\n+        double[] qtf     = new double[rows];\n         double[] work1   = new double[cols];\n         double[] work2   = new double[cols];\n         double[] work3   = new double[cols];\n@@ -267,7 +269,9 @@ protected VectorialPointValuePair doOptimize()\n         boolean firstIteration = true;\n         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n         while (true) {\n-\n+            for (int i=0;i<rows;i++) {\n+                qtf[i]=residuals[i];\n+            }\n             incrementIterationsCounter();\n \n             // compute the Q.R. decomposition of the jacobian matrix\n@@ -276,8 +280,7 @@ protected VectorialPointValuePair doOptimize()\n             qrDecomposition();\n \n             // compute Qt.res\n-            qTy(residuals);\n-\n+            qTy(qtf);\n             // now we don't need Q anymore,\n             // so let jacobian contain the R matrix with its diagonal elements\n             for (int k = 0; k < solvedCols; ++k) {\n@@ -315,7 +318,7 @@ protected VectorialPointValuePair doOptimize()\n                     if (s != 0) {\n                         double sum = 0;\n                         for (int i = 0; i <= j; ++i) {\n-                            sum += jacobian[i][pj] * residuals[i];\n+                            sum += jacobian[i][pj] * qtf[i];\n                         }\n                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                     }\n@@ -323,6 +326,8 @@ protected VectorialPointValuePair doOptimize()\n             }\n             if (maxCosine <= orthoTolerance) {\n                 // convergence has been reached\n+            \tupdateResidualsAndCost();\n+            \tcurrent = new VectorialPointValuePair(point, objective);\n                 return current;\n             }\n \n@@ -343,9 +348,12 @@ protected VectorialPointValuePair doOptimize()\n                 double[] tmpVec = residuals;\n                 residuals = oldRes;\n                 oldRes    = tmpVec;\n+                tmpVec    = objective;\n+                objective = oldObj;\n+                oldObj    = tmpVec;\n \n                 // determine the Levenberg-Marquardt parameter\n-                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n+                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n \n                 // compute the new point and the norm of the evolution direction\n                 double lmNorm = 0;\n@@ -365,7 +372,6 @@ protected VectorialPointValuePair doOptimize()\n \n                 // evaluate the function at x + p and calculate its norm\n                 updateResidualsAndCost();\n-                current = new VectorialPointValuePair(point, objective);\n \n                 // compute the scaled actual reduction\n                 double actRed = -1.0;\n@@ -421,6 +427,15 @@ protected VectorialPointValuePair doOptimize()\n                         xNorm    += xK * xK;\n                     }\n                     xNorm = Math.sqrt(xNorm);\n+                    current = new VectorialPointValuePair(point, objective);\n+\n+                    // tests for convergence.\n+                    if (checker != null) {\n+                    // we use the vectorial convergence checker\n+                    \tif (checker.converged(getIterations(), previous, current)) {\n+                    \t\treturn current;\n+                    \t}\n+                    }\n                 } else {\n                     // failed iteration, reset the previous values\n                     cost = previousCost;\n@@ -431,16 +446,11 @@ protected VectorialPointValuePair doOptimize()\n                     tmpVec    = residuals;\n                     residuals = oldRes;\n                     oldRes    = tmpVec;\n+                    tmpVec    = objective;\n+                    objective = oldObj;\n+                    oldObj    = tmpVec;\n                 }\n-\n-                // tests for convergence.\n-                if (checker != null) {\n-                    // we use the vectorial convergence checker\n-                    if (checker.converged(getIterations(), previous, current)) {\n-                        return current;\n-                    }\n-                } else {\n-                    // we use the Levenberg-Marquardt specific convergence parameters\n+                if (checker==null) {\n                 \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                         (preRed <= costRelativeTolerance) &&\n                         (ratio <= 2.0)) ||\n",
        "project": "commons-math",
        "linesAdd": 25,
        "jira_id": "405",
        "nb_skipped": 0,
        "commit": "784e4f69",
        "nb_failure": 2,
        "linesRem": 18,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5476,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.special.BetaTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/special/Beta.java b/src/main/java/org/apache/commons/math3/special/Beta.java\nindex c6091b48c..04696f971 100644\n--- a/src/main/java/org/apache/commons/math3/special/Beta.java\n+++ b/src/main/java/org/apache/commons/math3/special/Beta.java\n@@ -189,11 +189,12 @@ public static double regularizedBeta(double x,\n             Double.isNaN(b) ||\n             x < 0 ||\n             x > 1 ||\n-            a <= 0.0 ||\n-            b <= 0.0) {\n+            a <= 0 ||\n+            b <= 0) {\n             ret = Double.NaN;\n-        } else if (x > (a + 1.0) / (a + b + 2.0)) {\n-            ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n+        } else if (x > (a + 1) / (2 + b + a) &&\n+                   1 - x <= (b + 1) / (2 + b + a)) {\n+            ret = 1 - regularizedBeta(1 - x, b, a, epsilon, maxIterations);\n         } else {\n             ContinuedFraction fraction = new ContinuedFraction() {\n \n",
        "project": "commons-math",
        "linesAdd": 5,
        "jira_id": "1067",
        "nb_skipped": 5,
        "commit": "aff82362",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4114,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.random.CorrelatedRandomVectorGeneratorTest",
            "org.apache.commons.math3.linear.RectangularCholeskyDecompositionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\nindex 38584d420..aba7b9806 100644\n--- a/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java\n@@ -62,11 +62,10 @@\n     public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n         throws NonPositiveDefiniteMatrixException {\n \n-        int order = matrix.getRowDimension();\n-        double[][] c = matrix.getData();\n-        double[][] b = new double[order][order];\n+        final int order = matrix.getRowDimension();\n+        final double[][] c = matrix.getData();\n+        final double[][] b = new double[order][order];\n \n-        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;\n@@ -76,21 +75,24 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n         for (boolean loop = true; loop;) {\n \n             // find maximal diagonal element\n-            swap[r] = r;\n+            int swapR = r;\n             for (int i = r + 1; i < order; ++i) {\n                 int ii  = index[i];\n-                int isi = index[swap[i]];\n-                if (c[ii][ii] > c[isi][isi]) {\n-                    swap[r] = i;\n+                int isr = index[swapR];\n+                if (c[ii][ii] > c[isr][isr]) {\n+                    swapR = i;\n                 }\n             }\n \n \n             // swap elements\n-            if (swap[r] != r) {\n-                int tmp = index[r];\n-                index[r] = index[swap[r]];\n-                index[swap[r]] = tmp;\n+            if (swapR != r) {\n+                final int tmpIndex    = index[r];\n+                index[r]              = index[swapR];\n+                index[swapR]          = tmpIndex;\n+                final double[] tmpRow = b[r];\n+                b[r]                  = b[swapR];\n+                b[swapR]              = tmpRow;\n             }\n \n             // check diagonal element\n@@ -118,17 +120,18 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n             } else {\n \n                 // transform the matrix\n-                double sqrt = FastMath.sqrt(c[ir][ir]);\n+                final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n-                double inverse = 1 / sqrt;\n+                final double inverse  = 1 / sqrt;\n+                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n-                    int ii = index[i];\n-                    double e = inverse * c[ii][ir];\n+                    final int ii = index[i];\n+                    final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n-                    c[ii][ii] -= e * e;\n+                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n                     for (int j = r + 1; j < i; ++j) {\n-                        int ij = index[j];\n-                        double f = c[ii][ij] - e * b[j][r];\n+                        final int ij = index[j];\n+                        final double f = c[ii][ij] - e * b[j][r];\n                         c[ii][ij] = f;\n                         c[ij][ii] = f;\n                     }\n",
        "project": "commons-math",
        "linesAdd": 22,
        "jira_id": "789",
        "nb_skipped": 4,
        "commit": "621bbb8f",
        "nb_failure": 3,
        "linesRem": 19,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5851,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.random.EmpiricalDistributionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java b/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\nindex 3b3a8642d..61bb65b77 100644\n--- a/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\n+++ b/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\n@@ -593,7 +593,9 @@ public double density(double x) {\n      * <li>Compute K(B) = the probability mass of B with respect to the within-bin kernel\n      * and K(B-) = the kernel distribution evaluated at the lower endpoint of B</li>\n      * <li>Return P(B-) + P(B) * [K(x) - K(B-)] / K(B) where\n-     * K(x) is the within-bin kernel distribution function evaluated at x.</li></ol></p>\n+     * K(x) is the within-bin kernel distribution function evaluated at x.</li></ol>\n+     * If K is a constant distribution, we return P(B-) + P(B) (counting the full\n+     * mass of B).</p>\n      *\n      * @since 3.1\n      */\n@@ -606,10 +608,13 @@ public double cumulativeProbability(double x) {\n         final int binIndex = findBin(x);\n         final double pBminus = pBminus(binIndex);\n         final double pB = pB(binIndex);\n+        final RealDistribution kernel = k(x);\n+        if (kernel instanceof ConstantRealDistribution) {\n+            return pBminus + pB;\n+        }\n         final double[] binBounds = getUpperBounds();\n         final double kB = kB(binIndex);\n         final double lower = binIndex == 0 ? min : binBounds[binIndex - 1];\n-        final RealDistribution kernel = k(x);\n         final double withinBinCum =\n             (kernel.cumulativeProbability(x) -  kernel.cumulativeProbability(lower)) / kB;\n         return pBminus + pB * withinBinCum;\n",
        "project": "commons-math",
        "linesAdd": 4,
        "jira_id": "1203",
        "nb_skipped": 3,
        "commit": "b148046a",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3499,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.genetics.ElitisticListPopulationTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\nindex a3090806c..829c97d3b 100644\n--- a/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java\n@@ -24,7 +24,7 @@\n import org.apache.commons.math3.util.FastMath;\n \n /**\n- * Population of chromosomes which uses elitism (certain percentace of the best\n+ * Population of chromosomes which uses elitism (certain percentage of the best\n  * chromosomes is directly copied to the next generation).\n  *\n  * @version $Id$\n@@ -42,12 +42,13 @@\n      * @param populationLimit maximal size of the population\n      * @param elitismRate how many best chromosomes will be directly transferred to the\n      *                    next generation [in %]\n+     * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range\n      */\n     public ElitisticListPopulation(final List<Chromosome> chromosomes,\n                                    final int populationLimit,\n                                    final double elitismRate) {\n         super(chromosomes, populationLimit);\n-        this.elitismRate = elitismRate;\n+        setElitismRate(elitismRate);\n     }\n \n     /**\n@@ -57,10 +58,11 @@ public ElitisticListPopulation(final List<Chromosome> chromosomes,\n      * @param populationLimit maximal size of the population\n      * @param elitismRate how many best chromosomes will be directly transferred to the\n      *                    next generation [in %]\n+     * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range\n      */\n     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n         super(populationLimit);\n-        this.elitismRate = elitismRate;\n+        setElitismRate(elitismRate);\n     }\n \n     /**\n",
        "project": "commons-math",
        "linesAdd": 2,
        "jira_id": "776",
        "nb_skipped": 1,
        "commit": "b9ca51f0",
        "nb_failure": 4,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3124,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.optimization.linear.SimplexSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex fd8943203..d96c9167b 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -407,7 +407,12 @@ protected RealPointValuePair getSolution() {\n             continue;\n           }\n           Integer basicRow = getBasicRow(colIndex);\n-          if (basicRows.contains(basicRow)) {\n+          if (basicRow != null && basicRow == 0) {\n+              // if the basic row is found to be the objective function row\n+              // set the coefficient to 0 -> this case handles unconstrained \n+              // variables that are still part of the objective function\n+              coefficients[i] = 0;\n+          } else if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n",
        "project": "commons-math",
        "linesAdd": 3,
        "jira_id": "713",
        "nb_skipped": 1,
        "commit": "f656676e",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4514,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.distribution.NormalDistributionTest",
            "org.apache.commons.math3.distribution.LogNormalDistributionTest",
            "org.apache.commons.math3.random.EmpiricalDistributionTest",
            "org.apache.commons.math3.distribution.GammaDistributionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java b/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\nindex a621d7b8a..fab295bfb 100644\n--- a/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\n@@ -16,21 +16,26 @@\n  */\n package org.apache.commons.math3.random;\n \n+import java.io.Serializable;\n+\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.util.FastMath;\n \n /** Base class for random number generators that generates bits streams.\n-\n+ *\n  * @version $Id$\n  * @since 2.0\n-\n  */\n-public abstract class BitsStreamGenerator implements RandomGenerator {\n-\n+public abstract class BitsStreamGenerator\n+    implements RandomGenerator,\n+               Serializable {\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 20130104L;\n     /** Next gaussian. */\n     private double nextGaussian;\n \n-    /** Creates a new random number generator.\n+    /**\n+     * Creates a new random number generator.\n      */\n     public BitsStreamGenerator() {\n         nextGaussian = Double.NaN;\n",
        "project": "commons-math",
        "linesAdd": 6,
        "jira_id": "927",
        "nb_skipped": 4,
        "commit": "185e3033",
        "nb_failure": 4,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2130,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.analysis.solvers.BrentSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex e0cb42714..7fc090e2b 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -112,7 +112,7 @@ public double solve(final UnivariateRealFunction f,\n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n+            setResult(min, 0);\n             return result;\n         }\n \n@@ -124,7 +124,7 @@ public double solve(final UnivariateRealFunction f,\n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n+            setResult(max, 0);\n             return result;\n         }\n \n",
        "project": "commons-math",
        "linesAdd": 2,
        "jira_id": "344",
        "nb_skipped": 0,
        "commit": "a0b4b4b7",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2085,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.random.RandomDataTest",
            "org.apache.commons.math.random.AbstractRandomGeneratorTest",
            "org.apache.commons.math.random.RandomAdaptorTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\nindex d5d2474f7..a44720fbe 100644\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n@@ -457,12 +457,11 @@ public double nextGaussian(double mu, double sigma) {\n      * uniform deviates.\n      * </p>\n      *\n-     * @param mean\n-     *            the mean of the distribution\n+     * @param mean the mean of the distribution\n      * @return the random Exponential value\n      */\n     public double nextExponential(double mean) {\n-        if (mean < 0.0) {\n+        if (mean <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"mean must be positive ({0})\", mean);\n         }\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "309",
        "nb_skipped": 0,
        "commit": "0596e314",
        "nb_failure": 3,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 5822,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.geometry.euclidean.oned.IntervalTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Interval.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Interval.java\nindex 97857761b..87dbba16c 100644\n--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Interval.java\n+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/oned/Interval.java\n@@ -17,6 +17,8 @@\n package org.apache.commons.math4.geometry.euclidean.oned;\n \n import org.apache.commons.math4.geometry.partitioning.Region.Location;\n+import org.apache.commons.math4.exception.NumberIsTooSmallException;\n+import org.apache.commons.math4.exception.util.LocalizedFormats;\n \n \n /** This class represents a 1D interval.\n@@ -36,6 +38,10 @@\n      * @param upper upper bound of the interval\n      */\n     public Interval(final double lower, final double upper) {\n+        if (upper < lower) {\n+            throw new NumberIsTooSmallException(LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\n+                                                upper, lower, true);\n+        }\n         this.lower = lower;\n         this.upper = upper;\n     }\n",
        "project": "commons-math",
        "linesAdd": 6,
        "jira_id": "1256",
        "nb_skipped": 3,
        "commit": "41f29780",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 3326,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.random.Well512aTest",
            "org.apache.commons.math.random.Well1024aTest",
            "org.apache.commons.math.random.RandomDataTest",
            "org.apache.commons.math.random.Well44497bTest",
            "org.apache.commons.math.random.MersenneTwisterTest",
            "org.apache.commons.math.random.ISAACTest",
            "org.apache.commons.math.random.BitsStreamGeneratorTest",
            "org.apache.commons.math.random.AbstractRandomGeneratorTest",
            "org.apache.commons.math.random.Well44497aTest",
            "org.apache.commons.math.random.Well19937aTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\nindex cfec8ca1e..c5c14a96c 100644\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n@@ -116,6 +116,7 @@\n     INDEX_OUT_OF_RANGE(\"index {0} out of allowed range [{1}, {2}]\"),\n     INDEX(\"index ({0})\"), /* keep */\n     NOT_FINITE_NUMBER(\"{0} is not a finite number\"), /* keep */\n+    INFINITE_BOUND(\"interval bounds must be finite\"),\n     ARRAY_ELEMENT(\"value {0} at index {1}\"), /* keep */\n     INFINITE_ARRAY_ELEMENT(\"Array contains an infinite element, {0} at index {1}\"),\n     INFINITE_VALUE_CONVERSION(\"cannot convert infinite value\"),\n@@ -240,6 +241,7 @@\n     NO_REGRESSORS(\"Regression model must include at least one regressor\"),\n     NO_RESULT_AVAILABLE(\"no result available\"),\n     NO_SUCH_MATRIX_ENTRY(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\"),\n+    NAN_NOT_ALLOWED(\"NaN is not allowed\"),\n     NULL_NOT_ALLOWED(\"null is not allowed\"), /* keep */\n     ARRAY_ZERO_LENGTH_OR_NULL_NOTALLOWED(\"A null or zero length array not allowed\"),\n     COVARIANCE_MATRIX(\"covariance matrix\"), /* keep */\ndiff --git a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\nindex 0fda68822..16d655bb8 100644\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n@@ -36,6 +36,7 @@\n import org.apache.commons.math.distribution.TDistribution;\n import org.apache.commons.math.distribution.WeibullDistribution;\n import org.apache.commons.math.distribution.ZipfDistribution;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n@@ -250,7 +251,8 @@ public int nextInt(int lower, int upper) {\n                                                 lower, upper, false);\n         }\n         double r = getRan().nextDouble();\n-        return (int) ((r * upper) + ((1.0 - r) * lower) + r);\n+        double scaled = r * upper + (1.0 - r) * lower + r;\n+        return (int)FastMath.floor(scaled);\n     }\n \n     /**\n@@ -270,7 +272,8 @@ public long nextLong(long lower, long upper) {\n                                                 lower, upper, false);\n         }\n         double r = getRan().nextDouble();\n-        return (long) ((r * upper) + ((1.0 - r) * lower) + r);\n+        double scaled = r * upper + (1.0 - r) * lower + r;\n+        return (long)FastMath.floor(scaled);\n     }\n \n     /**\n@@ -361,7 +364,9 @@ public int nextSecureInt(int lower, int upper) {\n                                                 lower, upper, false);\n         }\n         SecureRandom sec = getSecRan();\n-        return lower + (int) (sec.nextDouble() * (upper - lower + 1));\n+        double r = sec.nextDouble();\n+        double scaled = r * upper + (1.0 - r) * lower + r;\n+        return (int)FastMath.floor(scaled);\n     }\n \n     /**\n@@ -382,7 +387,9 @@ public long nextSecureLong(long lower, long upper) {\n                                                 lower, upper, false);\n         }\n         SecureRandom sec = getSecRan();\n-        return lower + (long) (sec.nextDouble() * (upper - lower + 1));\n+        double r = sec.nextDouble();\n+        double scaled = r * upper + (1.0 - r) * lower + r;\n+        return (long)FastMath.floor(scaled);\n     }\n \n     /**\n@@ -579,19 +586,26 @@ public double nextExponential(double mean) {\n      * provide a symmetric output interval (both endpoints excluded).\n      * </p>\n      *\n-     * @param lower\n-     *            the lower bound.\n-     * @param upper\n-     *            the upper bound.\n-     * @return a uniformly distributed random value from the interval (lower,\n-     *         upper)\n-     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     * @param lower the lower bound.\n+     * @param upper the upper bound.\n+     * @return a uniformly distributed random value from the interval (lower, upper)\n+     * @throws MathIllegalArgumentException if {@code lower >= upper}\n+     * or either bound is infinite or NaN\n      */\n     public double nextUniform(double lower, double upper) {\n         if (lower >= upper) {\n-            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n-                                                lower, upper, false);\n+            throw new MathIllegalArgumentException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n+                                                lower, upper);\n+        }\n+\n+        if (Double.isInfinite(lower) || Double.isInfinite(upper)) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_BOUND);\n         }\n+\n+        if (Double.isNaN(lower) || Double.isNaN(upper)) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.NAN_NOT_ALLOWED);\n+        }\n+\n         final RandomGenerator generator = getRan();\n \n         // ensure nextDouble() isn't 0.0\n@@ -600,7 +614,7 @@ public double nextUniform(double lower, double upper) {\n             u = generator.nextDouble();\n         }\n \n-        return lower + u * (upper - lower);\n+        return u * upper + (1.0 - u) * lower;\n     }\n \n     /**\n",
        "project": "commons-math",
        "linesAdd": 25,
        "jira_id": "724",
        "nb_skipped": 1,
        "commit": "9c8bb934",
        "nb_failure": 70,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3542,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\nindex 6ba72be94..add24acea 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n@@ -132,7 +132,9 @@ protected void computeGeometricalProperties() {\n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n-            if ((Boolean) getTree(false).getAttribute()) {\n+            final BSPTree<Euclidean2D> tree = getTree(false);\n+            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n+                // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n",
        "project": "commons-math",
        "linesAdd": 2,
        "jira_id": "780",
        "nb_skipped": 1,
        "commit": "dd6cefb0",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4164,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.dfp.DfpTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/dfp/Dfp.java b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\nindex d278a3128..3a9198271 100644\n--- a/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n@@ -1595,12 +1595,24 @@ public Dfp multiply(final Dfp x) {\n \n     }\n \n-    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n-     * There are speed advantages in this special case\n+    /** Multiply this by a single digit x.\n      * @param x multiplicand\n      * @return product of this and x\n      */\n     public Dfp multiply(final int x) {\n+        if (x >= 0 && x < RADIX) {\n+            return multiplyFast(x);\n+        } else {\n+            return multiply(newInstance(x));\n+        }\n+    }\n+\n+    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n+     * There are speed advantages in this special case.\n+     * @param x multiplicand\n+     * @return product of this and x\n+     */\n+    private Dfp multiplyFast(final int x) {\n         Dfp result = newInstance(this);\n \n         /* handle special cases */\n",
        "project": "commons-math",
        "linesAdd": 8,
        "jira_id": "778",
        "nb_skipped": 4,
        "commit": "5b9302d5",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4794,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.geometry.euclidean.threed.LineTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\nindex 0c3941168..7c9a28f14 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\n@@ -84,7 +84,9 @@ public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgume\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        return new Line(zero, zero.subtract(direction));\n+        final Line reverted = new Line(this);\n+        reverted.direction = reverted.direction.negate();\n+        return reverted;\n     }\n \n     /** Get the normalized direction vector.\n",
        "project": "commons-math",
        "linesAdd": 3,
        "jira_id": "938",
        "nb_skipped": 4,
        "commit": "73605560",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 2245,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java b/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\nindex 10bc9e66c..26fd5e0ac 100644\n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n@@ -89,12 +89,12 @@ public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n+        return optimaValues[0];\n     }\n \n     /** {@inheritDoc} */\n     public double getResult() {\n-        return optimizer.getResult();\n+        return optima[0];\n     }\n \n     /** {@inheritDoc} */\ndiff --git a/src/main/java/org/apache/commons/math/optimization/UnivariateRealOptimizer.java b/src/main/java/org/apache/commons/math/optimization/UnivariateRealOptimizer.java\nindex bf406ab6b..07d8c4f98 100644\n--- a/src/main/java/org/apache/commons/math/optimization/UnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/UnivariateRealOptimizer.java\n@@ -36,7 +36,7 @@\n     void setMaxEvaluations(int maxEvaluations);\n \n     /** Get the maximal number of functions evaluations.\n-     * @return maximal number of functions evaluations\n+     * @return the maximal number of functions evaluations.\n      */\n     int getMaxEvaluations();\n \n@@ -46,7 +46,7 @@\n      * {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize}\n      * method. It is 0 if the method has not been called yet.\n      * </p>\n-     * @return number of evaluations of the objective function\n+     * @return the number of evaluations of the objective function.\n      */\n     int getEvaluations();\n \n@@ -57,16 +57,16 @@\n      * </p>\n      * @param f the function to optimize.\n      * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n-     * or {@link GoalType#MINIMIZE}\n+     * or {@link GoalType#MINIMIZE}.\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n-     * @return a value where the function is optimum\n+     * @return a value where the function is optimum.\n      * @throws ConvergenceException if the maximum iteration count is exceeded\n      * or the optimizer detects convergence problems otherwise.\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * function.\n      * @throws IllegalArgumentException if min > max or the endpoints do not\n-     * satisfy the requirements specified by the optimizer\n+     * satisfy the requirements specified by the optimizer.\n      */\n     double optimize(UnivariateRealFunction f, GoalType goalType,\n                     double min, double max)\n@@ -79,17 +79,17 @@\n      * </p>\n      * @param f the function to optimize.\n      * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n-     * or {@link GoalType#MINIMIZE}\n+     * or {@link GoalType#MINIMIZE}.\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n-     * @param startValue the start value to use\n-     * @return a value where the function is optimum\n+     * @param startValue the start value to use.\n+     * @return a value where the function is optimum.\n      * @throws ConvergenceException if the maximum iteration count is exceeded\n      * or the optimizer detects convergence problems otherwise.\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function\n+     * function.\n      * @throws IllegalArgumentException if min > max or the arguments do not\n-     * satisfy the requirements specified by the optimizer\n+     * satisfy the requirements specified by the optimizer.\n      */\n     double optimize(UnivariateRealFunction f, GoalType goalType,\n                     double min, double max, double startValue)\n@@ -98,7 +98,7 @@\n     /**\n      * Get the result of the last run of the optimizer.\n      *\n-     * @return the last result.\n+     * @return the optimum.\n      * @throws IllegalStateException if there is no result available, either\n      * because no result was yet computed or the last attempt failed.\n      */\n@@ -107,7 +107,7 @@\n     /**\n      * Get the result of the last run of the optimizer.\n      *\n-     * @return the value of the function at the last result.\n+     * @return the value of the function at the optimum.\n      * @throws IllegalStateException if there is no result available, either\n      * because no result was yet computed or the last attempt failed.\n      */\n",
        "project": "commons-math",
        "linesAdd": 2,
        "jira_id": "393",
        "nb_skipped": 0,
        "commit": "d4b02f6a",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5603,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.util.PrecisionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/util/Precision.java b/src/main/java/org/apache/commons/math3/util/Precision.java\nindex f0b0c4ff7..441e015ac 100644\n--- a/src/main/java/org/apache/commons/math3/util/Precision.java\n+++ b/src/main/java/org/apache/commons/math3/util/Precision.java\n@@ -392,10 +392,11 @@ public static double round(double x, int scale) {\n      */\n     public static double round(double x, int scale, int roundingMethod) {\n         try {\n-            return (new BigDecimal\n-                   (Double.toString(x))\n+            final double rounded = (new BigDecimal(Double.toString(x))\n                    .setScale(scale, roundingMethod))\n                    .doubleValue();\n+            // MATH-1089: negative values rounded to zero should result in negative zero\n+            return rounded == 0.0 ? rounded * FastMath.copySign(1d, x) : rounded;\n         } catch (NumberFormatException ex) {\n             if (Double.isInfinite(x)) {\n                 return x;\n",
        "project": "commons-math",
        "linesAdd": 2,
        "jira_id": "1089",
        "nb_skipped": 5,
        "commit": "e91d0f05",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5605,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.util.MultidimensionalCounterTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/util/MultidimensionalCounter.java b/src/main/java/org/apache/commons/math3/util/MultidimensionalCounter.java\nindex 0553c6b03..3c87fba4c 100644\n--- a/src/main/java/org/apache/commons/math3/util/MultidimensionalCounter.java\n+++ b/src/main/java/org/apache/commons/math3/util/MultidimensionalCounter.java\n@@ -17,6 +17,7 @@\n \n package org.apache.commons.math3.util;\n \n+import java.util.NoSuchElementException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n@@ -77,6 +78,10 @@\n          * Unidimensional counter.\n          */\n         private int count = -1;\n+        /**\n+         * Maximum value for {@link #count}.\n+         */\n+        private final int maxCount = totalSize - 1;\n \n         /**\n          * Create an iterator\n@@ -90,19 +95,20 @@\n          * {@inheritDoc}\n          */\n         public boolean hasNext() {\n-            for (int i = 0; i < dimension; i++) {\n-                if (counter[i] != size[i] - 1) {\n-                    return true;\n-                }\n-            }\n-            return false;\n+            return count < maxCount;\n         }\n \n         /**\n          * @return the unidimensional count after the counter has been\n          * incremented by {@code 1}.\n+         * @throws NoSuchElementException if {@link #hasNext()} would have\n+         * returned {@code false}.\n          */\n         public Integer next() {\n+            if (!hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+\n             for (int i = last; i >= 0; i--) {\n                 if (counter[i] == size[i] - 1) {\n                     counter[i] = 0;\n",
        "project": "commons-math",
        "linesAdd": 7,
        "jira_id": "1088",
        "nb_skipped": 5,
        "commit": "63d88c74",
        "nb_failure": 1,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2325,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.optimization.fitting.GaussianFitterTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\nindex 725b5ca84..e1b54f49e 100644\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n@@ -21,10 +21,12 @@\n import java.util.Comparator;\n \n import org.apache.commons.math.analysis.function.Gaussian;\n+import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.ZeroException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.fitting.CurveFitter;\n@@ -61,25 +62,63 @@\n     /**\n      * Constructs an instance using the specified optimizer.\n      *\n-     * @param optimizer optimizer to use for the fitting\n+     * @param optimizer Optimizer to use for the fitting.\n      */\n     public GaussianFitter(DifferentiableMultivariateVectorialOptimizer optimizer) {\n-        super(optimizer);;\n+        super(optimizer);\n     }\n \n+    /**\n+     * Fits a Gaussian function to the observed points.\n+     *\n+     * @param initialGuess First guess values in the following order:\n+     * <ul>\n+     *  <li>Norm</li>\n+     *  <li>Mean</li>\n+     *  <li>Sigma</li>\n+     * </ul>\n+     * @return the parameters of the Gaussian function that best fits the\n+     * observed points (in the same order as above).\n+     */\n+    public double[] fit(double[] initialGuess) {\n+        final ParametricUnivariateRealFunction f = new ParametricUnivariateRealFunction() {\n+                private final ParametricUnivariateRealFunction g = new Gaussian.Parametric();\n+\n+                public double value(double x, double[] p) {\n+                    double v = Double.POSITIVE_INFINITY;\n+                    try {\n+                        v = g.value(x, p);\n+                    } catch (NotStrictlyPositiveException e) {\n+                        // Do nothing.\n+                    }\n+                    return v;\n+                }\n+\n+                public double[] gradient(double x, double[] p) {\n+                    double[] v = { Double.POSITIVE_INFINITY,\n+                                   Double.POSITIVE_INFINITY,\n+                                   Double.POSITIVE_INFINITY };\n+                    try {\n+                        v = g.gradient(x, p);\n+                    } catch (NotStrictlyPositiveException e) {\n+                        // Do nothing.\n+                    }\n+                    return v;\n+                }\n+            };\n+\n+        return fit(f, initialGuess);\n+    }\n \n     /**\n-     * Fits Gaussian function to the observed points.\n-     * It will call the base class\n-     * {@link CurveFitter#fit(\n-     * org.apache.commons.math.analysis.ParametricUnivariateRealFunction,\n-     * double[]) fit} method.\n+     * Fits a Gaussian function to the observed points.\n      *\n-     * @return the Gaussian function that best fits the observed points.\n+     * @return the parameters of the Gaussian function that best fits the\n+     * observed points (in the same order as above).\n      */\n     public double[] fit() {\n-        return fit(new Gaussian.Parametric(),\n-                   (new ParameterGuesser(getObservations())).guess());\n+        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n+        return fit(guess);\n     }\n \n     /**\n@@ -112,7 +150,7 @@ public ParameterGuesser(WeightedObservedPoint[] observations) {\n         /**\n          * Guesses the parameters based on the observed points.\n          *\n-         * @return guessed parameters array <code>{norm, mean, sigma}</code>\n+         * @return the guessed parameters: norm, mean and sigma.\n          */\n         public double[] guess() {\n             if (parameters == null) {\n@@ -124,9 +162,8 @@ public ParameterGuesser(WeightedObservedPoint[] observations) {\n         /**\n          * Guesses the parameters based on the specified observed points.\n          *\n-         * @param points observed points upon which should base guess\n-         *\n-         * @return guessed parameters array <code>{norm, mean, sigma}</code>\n+         * @param points Observed points upon which should base guess.\n+         * @return the guessed parameters: norm, mean and sigma.\n          */\n         private double[] basicGuess(WeightedObservedPoint[] points) {\n             Arrays.sort(points, createWeightedObservedPointComparator());\n@@ -154,9 +190,8 @@ public ParameterGuesser(WeightedObservedPoint[] observations) {\n         /**\n          * Finds index of point in specified points with the largest Y.\n          *\n-         * @param points points to search\n-         *\n-         * @return index in specified points array\n+         * @param points Points to search.\n+         * @return the index in specified points array.\n          */\n         private int findMaxY(WeightedObservedPoint[] points) {\n             int maxYIdx = 0;\n@@ -169,20 +204,18 @@ private int findMaxY(WeightedObservedPoint[] points) {\n         }\n \n         /**\n-         * Interpolates using the specified points to determine X at the specified\n-         * Y.\n+         * Interpolates using the specified points to determine X at the\n+         * specified Y.\n          *\n-         * @param points points to use for interpolation\n-         * @param startIdx index within points from which to start search for\n-         *        interpolation bounds points\n-         * @param idxStep index step for search for interpolation bounds points\n-         * @param y Y value for which X should be determined\n-         *\n-         * @return value of X at the specified Y\n-         *\n-         * @throws IllegalArgumentException if idxStep is 0\n-         * @throws OutOfRangeException if specified <code>y</code> is not within the\n-         *         range of the specified <code>points</code>\n+         * @param points Points to use for interpolation.\n+         * @param startIdx Index within points from which to start search for\n+         *  interpolation bounds points.\n+         * @param idxStep Index step for search for interpolation bounds points.\n+         * @param y Y value for which X should be determined.\n+         * @return the value of X at the specified Y.\n+         * @throws ZeroException if {@code idxStep} is 0.\n+         * @throws OutOfRangeException if specified {@code y} is not within the\n+         * range of the specified {@code points}.\n          */\n         private double interpolateXAtY(WeightedObservedPoint[] points,\n                                        int startIdx, int idxStep, double y)\n@@ -208,18 +241,16 @@ private double interpolateXAtY(WeightedObservedPoint[] points,\n          * Gets the two bounding interpolation points from the specified points\n          * suitable for determining X at the specified Y.\n          *\n-         * @param points points to use for interpolation\n-         * @param startIdx index within points from which to start search for\n-         *        interpolation bounds points\n-         * @param idxStep index step for search for interpolation bounds points\n-         * @param y Y value for which X should be determined\n-         *\n-         * @return array containing two points suitable for determining X at the\n-         *         specified Y\n-         *\n-         * @throws IllegalArgumentException if idxStep is 0\n-         * @throws OutOfRangeException if specified <code>y</code> is not within the\n-         *         range of the specified <code>points</code>\n+         * @param points Points to use for interpolation.\n+         * @param startIdx Index within points from which to start search for\n+         * interpolation bounds points.\n+         * @param idxStep Index step for search for interpolation bounds points.\n+         * @param y Y value for which X should be determined.\n+         * @return the array containing two points suitable for determining X at\n+         * the specified Y.\n+         * @throws ZeroException if {@code idxStep} is 0.\n+         * @throws OutOfRangeException if specified {@code y} is not within the\n+         * range of the specified {@code points}.\n          */\n         private WeightedObservedPoint[] getInterpolationPointsForY(WeightedObservedPoint[] points,\n                                                                    int startIdx, int idxStep, double y)\n@@ -250,13 +280,12 @@ private double interpolateXAtY(WeightedObservedPoint[] points,\n         /**\n          * Determines whether a value is between two other values.\n          *\n-         * @param value value to determine whether is between <code>boundary1</code>\n-         *        and <code>boundary2</code>\n-         * @param boundary1 one end of the range\n-         * @param boundary2 other end of the range\n-         *\n-         * @return true if <code>value</code> is between <code>boundary1</code> and\n-         *         <code>boundary2</code> (inclusive); false otherwise\n+         * @param value Value to determine whether is between {@code boundary1}\n+         * and {@code boundary2}.\n+         * @param boundary1 One end of the range.\n+         * @param boundary2 Other end of the range.\n+         * @return {@code true} if {@code value} is between {@code boundary1} and\n+         * {@code boundary2} (inclusive), {@code false} otherwise.\n          */\n         private boolean isBetween(double value, double boundary1, double boundary2) {\n             return (value >= boundary1 && value <= boundary2) ||\n@@ -264,10 +293,10 @@ private boolean isBetween(double value, double boundary1, double boundary2) {\n         }\n \n         /**\n-         * Factory method creating <code>Comparator</code> for comparing\n-         * <code>WeightedObservedPoint</code> instances.\n+         * Factory method creating {@code Comparator} for comparing\n+         * {@code WeightedObservedPoint} instances.\n          *\n-         * @return new <code>Comparator</code> instance\n+         * @return the new {@code Comparator} instance.\n          */\n         private Comparator<WeightedObservedPoint> createWeightedObservedPointComparator() {\n             return new Comparator<WeightedObservedPoint>() {\n",
        "project": "commons-math",
        "linesAdd": 32,
        "jira_id": "519",
        "nb_skipped": 1,
        "commit": "26a61077",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4156,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.linear.SchurTransformerTest",
            "org.apache.commons.math3.linear.EigenDecompositionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java b/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\nindex 584505de6..a2ea88ee4 100644\n--- a/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\n+++ b/src/main/java/org/apache/commons/math3/linear/SchurTransformer.java\n@@ -140,69 +140,66 @@ private void transform() {\n \n         // Outer loop over eigenvalue index\n         int iteration = 0;\n-        int idx = n - 1;\n-        while (idx >= 0) {\n+        int iu = n - 1;\n+        while (iu >= 0) {\n \n             // Look for single small sub-diagonal element\n-            final int l = findSmallSubDiagonalElement(idx, norm);\n+            final int il = findSmallSubDiagonalElement(iu, norm);\n \n             // Check for convergence\n-            if (l == idx) {\n+            if (il == iu) {\n                 // One root found\n-                matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;\n-                idx--;\n+                matrixT[iu][iu] = matrixT[iu][iu] + shift.exShift;\n+                iu--;\n                 iteration = 0;\n-            } else if (l == idx - 1) {\n+            } else if (il == iu - 1) {\n                 // Two roots found\n-                shift.w = matrixT[idx][idx - 1] * matrixT[idx - 1][idx];\n-                double p = (matrixT[idx - 1][idx - 1] - matrixT[idx][idx]) / 2.0;\n-                double q = p * p + shift.w;\n-                double z = FastMath.sqrt(FastMath.abs(q));\n-                matrixT[idx][idx] = matrixT[idx][idx] + shift.exShift;\n-                matrixT[idx - 1][idx - 1] = matrixT[idx - 1][idx - 1] + shift.exShift;\n-                shift.x = matrixT[idx][idx];\n+                double p = (matrixT[iu - 1][iu - 1] - matrixT[iu][iu]) / 2.0;\n+                double q = p * p + matrixT[iu][iu - 1] * matrixT[iu - 1][iu];\n+                matrixT[iu][iu] += shift.exShift;\n+                matrixT[iu - 1][iu - 1] += shift.exShift;\n \n                 if (q >= 0) {\n+                    double z = FastMath.sqrt(FastMath.abs(q));\n                     if (p >= 0) {\n                         z = p + z;\n                     } else {\n                         z = p - z;\n                     }\n-                    shift.x = matrixT[idx][idx - 1];\n-                    double s = FastMath.abs(shift.x) + FastMath.abs(z);\n-                    p = shift.x / s;\n+                    final double x = matrixT[iu][iu - 1];\n+                    final double s = FastMath.abs(x) + FastMath.abs(z);\n+                    p = x / s;\n                     q = z / s;\n-                    double r = FastMath.sqrt(p * p + q * q);\n+                    final double r = FastMath.sqrt(p * p + q * q);\n                     p = p / r;\n                     q = q / r;\n \n                     // Row modification\n-                    for (int j = idx - 1; j < n; j++) {\n-                        z = matrixT[idx - 1][j];\n-                        matrixT[idx - 1][j] = q * z + p * matrixT[idx][j];\n-                        matrixT[idx][j] = q * matrixT[idx][j] - p * z;\n+                    for (int j = iu - 1; j < n; j++) {\n+                        z = matrixT[iu - 1][j];\n+                        matrixT[iu - 1][j] = q * z + p * matrixT[iu][j];\n+                        matrixT[iu][j] = q * matrixT[iu][j] - p * z;\n                     }\n \n                     // Column modification\n-                    for (int i = 0; i <= idx; i++) {\n-                        z = matrixT[i][idx - 1];\n-                        matrixT[i][idx - 1] = q * z + p * matrixT[i][idx];\n-                        matrixT[i][idx] = q * matrixT[i][idx] - p * z;\n+                    for (int i = 0; i <= iu; i++) {\n+                        z = matrixT[i][iu - 1];\n+                        matrixT[i][iu - 1] = q * z + p * matrixT[i][iu];\n+                        matrixT[i][iu] = q * matrixT[i][iu] - p * z;\n                     }\n \n                     // Accumulate transformations\n                     for (int i = 0; i <= n - 1; i++) {\n-                        z = matrixP[i][idx - 1];\n-                        matrixP[i][idx - 1] = q * z + p * matrixP[i][idx];\n-                        matrixP[i][idx] = q * matrixP[i][idx] - p * z;\n+                        z = matrixP[i][iu - 1];\n+                        matrixP[i][iu - 1] = q * z + p * matrixP[i][iu];\n+                        matrixP[i][iu] = q * matrixP[i][iu] - p * z;\n                     }\n                 }\n-                idx -= 2;\n+                iu -= 2;\n                 iteration = 0;\n             } else {\n                 // No convergence yet\n-\n-                computeShift(l, idx, iteration, shift);\n+                computeShift(il, iu, iteration, shift);\n \n                 // stop transformation after too many iterations\n                 if (++iteration > MAX_ITERATIONS) {\n@@ -210,43 +207,11 @@ private void transform() {\n                                                         MAX_ITERATIONS);\n                 }\n \n-                // Look for two consecutive small sub-diagonal elements\n-                int m = idx - 2;\n-\n                 // the initial houseHolder vector for the QR step\n                 final double[] hVec = new double[3];\n \n-                while (m >= l) {\n-                    double z = matrixT[m][m];\n-                    hVec[2] = shift.x - z;\n-                    double s = shift.y - z;\n-                    hVec[0] = (hVec[2] * s - shift.w) / matrixT[m + 1][m] + matrixT[m][m + 1];\n-                    hVec[1] = matrixT[m + 1][m + 1] - z - hVec[2] - s;\n-                    hVec[2] = matrixT[m + 2][m + 1];\n-                    s = FastMath.abs(hVec[0]) + FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]);\n-\n-                    if (m == l) {\n-                        break;\n-                    }\n-\n-                    for (int i = 0; i < hVec.length; i++) {\n-                        hVec[i] /= s;\n-                    }\n-\n-                    final double lhs = FastMath.abs(matrixT[m][m - 1]) *\n-                            (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n-\n-                    final double rhs = FastMath.abs(hVec[0]) *\n-                            (FastMath.abs(matrixT[m - 1][m - 1]) + FastMath.abs(z) +\n-                             FastMath.abs(matrixT[m + 1][m + 1]));\n-\n-                    if (lhs < epsilon * rhs) {\n-                        break;\n-                    }\n-                    m--;\n-                }\n-\n-                performDoubleQRStep(l, m, idx, shift, hVec);\n+                final int im = initQRStep(il, iu, shift, hVec);\n+                performDoubleQRStep(il, im, iu, shift, hVec);\n             }\n         }\n     }\n@@ -278,7 +243,7 @@ private int findSmallSubDiagonalElement(final int startIdx, final double norm) {\n         int l = startIdx;\n         while (l > 0) {\n             double s = FastMath.abs(matrixT[l - 1][l - 1]) + FastMath.abs(matrixT[l][l]);\n-            if (Precision.equals(s, 0.0, epsilon)) {\n+            if (s == 0.0) {\n                 s = norm;\n             }\n             if (FastMath.abs(matrixT[l][l - 1]) < epsilon * s) {\n@@ -312,8 +277,9 @@ private void computeShift(final int l, final int idx, final int iteration, final\n             for (int i = 0; i <= idx; i++) {\n                 matrixT[i][i] -= shift.x;\n             }\n-            double s = FastMath.abs(matrixT[idx][idx - 1]) + FastMath.abs(matrixT[idx - 1][idx - 2]);\n-            shift.x = shift.y = 0.75 * s;\n+            final double s = FastMath.abs(matrixT[idx][idx - 1]) + FastMath.abs(matrixT[idx - 1][idx - 2]);\n+            shift.x = 0.75 * s;\n+            shift.y = 0.75 * s;\n             shift.w = -0.4375 * s * s;\n         }\n \n@@ -321,7 +287,7 @@ private void computeShift(final int l, final int idx, final int iteration, final\n         if (iteration == 30) {\n             double s = (shift.y - shift.x) / 2.0;\n             s = s * s + shift.w;\n-            if (Precision.compareTo(s, 0.0d, epsilon) > 0) {\n+            if (s > 0.0) {\n                 s = FastMath.sqrt(s);\n                 if (shift.y < shift.x) {\n                     s = -s;\n@@ -336,16 +302,54 @@ private void computeShift(final int l, final int idx, final int iteration, final\n         }\n     }\n \n+    /**\n+     * Initialize the householder vectors for the QR step.\n+     *\n+     * @param il the index of the small sub-diagonal element\n+     * @param iu the current eigenvalue index\n+     * @param shift shift information holder\n+     * @param hVec the initial houseHolder vector\n+     * @return the start index for the QR step\n+     */\n+    private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec) {\n+        // Look for two consecutive small sub-diagonal elements\n+        int im = iu - 2;\n+        while (im >= il) {\n+            final double z = matrixT[im][im];\n+            final double r = shift.x - z;\n+            double s = shift.y - z;\n+            hVec[0] = (r * s - shift.w) / matrixT[im + 1][im] + matrixT[im][im + 1];\n+            hVec[1] = matrixT[im + 1][im + 1] - z - r - s;\n+            hVec[2] = matrixT[im + 2][im + 1];\n+\n+            if (im == il) {\n+                break;\n+            }\n+\n+            final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n+            final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n+                                                        FastMath.abs(z) +\n+                                                        FastMath.abs(matrixT[im + 1][im + 1]));\n+\n+            if (lhs < epsilon * rhs) {\n+                break;\n+            }\n+            im--;\n+        }\n+\n+        return im;\n+    }\n+\n     /**\n      * Perform a double QR step involving rows l:idx and columns m:n\n      *\n-     * @param l the index of the small sub-diagonal element\n-     * @param m the start index for the QR step\n-     * @param idx the current eigenvalue index\n+     * @param il the index of the small sub-diagonal element\n+     * @param im the start index for the QR step\n+     * @param iu the current eigenvalue index\n      * @param shift shift information holder\n      * @param hVec the initial houseHolder vector\n      */\n-    private void performDoubleQRStep(final int l, final int m, final int idx,\n+    private void performDoubleQRStep(final int il, final int im, final int iu,\n                                      final ShiftInfo shift, final double[] hVec) {\n \n         final int n = matrixT.length;\n@@ -353,9 +357,9 @@ private void performDoubleQRStep(final int l, final int m, final int idx,\n         double q = hVec[1];\n         double r = hVec[2];\n \n-        for (int k = m; k <= idx - 1; k++) {\n-            boolean notlast = k != idx - 1;\n-            if (k != m) {\n+        for (int k = im; k <= iu - 1; k++) {\n+            boolean notlast = k != (iu - 1);\n+            if (k != im) {\n                 p = matrixT[k][k - 1];\n                 q = matrixT[k + 1][k - 1];\n                 r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n@@ -366,17 +370,17 @@ private void performDoubleQRStep(final int l, final int m, final int idx,\n                     r = r / shift.x;\n                 }\n             }\n-            if (Precision.equals(shift.x, 0.0, epsilon)) {\n+            if (shift.x == 0.0) {\n                 break;\n             }\n             double s = FastMath.sqrt(p * p + q * q + r * r);\n             if (p < 0.0) {\n                 s = -s;\n             }\n-            if (!Precision.equals(s, 0.0, epsilon)) {\n-                if (k != m) {\n+            if (s != 0.0) {\n+                if (k != im) {\n                     matrixT[k][k - 1] = -s * shift.x;\n-                } else if (l != m) {\n+                } else if (il != im) {\n                     matrixT[k][k - 1] = -matrixT[k][k - 1];\n                 }\n                 p = p + s;\n@@ -398,7 +402,7 @@ private void performDoubleQRStep(final int l, final int m, final int idx,\n                 }\n \n                 // Column modification\n-                for (int i = 0; i <= FastMath.min(idx, k + 3); i++) {\n+                for (int i = 0; i <= FastMath.min(iu, k + 3); i++) {\n                     p = shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];\n                     if (notlast) {\n                         p = p + z * matrixT[i][k + 2];\n@@ -423,9 +427,9 @@ private void performDoubleQRStep(final int l, final int m, final int idx,\n         }  // k loop\n \n         // clean up pollution due to round-off errors\n-        for (int i = m+2; i <= idx; i++) {\n+        for (int i = im + 2; i <= iu; i++) {\n             matrixT[i][i-2] = 0.0;\n-            if (i > m+2) {\n+            if (i > im + 2) {\n                 matrixT[i][i-3] = 0.0;\n             }\n         }\n",
        "project": "commons-math",
        "linesAdd": 75,
        "jira_id": "848",
        "nb_skipped": 4,
        "commit": "ad252a8c",
        "nb_failure": 1,
        "linesRem": 80,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5852,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.geometry.euclidean.threed.PolyhedronsSetTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/PolyhedronsSet.java b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/PolyhedronsSet.java\nindex 9c46ae303..2f3bfa9a2 100644\n--- a/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/PolyhedronsSet.java\n+++ b/src/main/java/org/apache/commons/math4/geometry/euclidean/threed/PolyhedronsSet.java\n@@ -240,9 +240,9 @@ private void addContribution(final SubHyperplane<Euclidean3D> facet, final boole\n     /** Get the first sub-hyperplane crossed by a semi-infinite line.\n      * @param point start point of the part of the line considered\n      * @param line line to consider (contains point)\n-     * @return the first sub-hyperplaned crossed by the line after the\n+     * @return the first sub-hyperplane crossed by the line after the\n      * given point, or null if the line does not intersect any\n-     * sub-hyperplaned\n+     * sub-hyperplane\n      */\n     public SubHyperplane<Euclidean3D> firstIntersection(final Vector3D point, final Line line) {\n         return recurseFirstIntersection(getTree(true), point, line);\n@@ -252,9 +252,9 @@ private void addContribution(final SubHyperplane<Euclidean3D> facet, final boole\n      * @param node current node\n      * @param point start point of the part of the line considered\n      * @param line line to consider (contains point)\n-     * @return the first sub-hyperplaned crossed by the line after the\n+     * @return the first sub-hyperplane crossed by the line after the\n      * given point, or null if the line does not intersect any\n-     * sub-hyperplaned\n+     * sub-hyperplane\n      */\n     private SubHyperplane<Euclidean3D> recurseFirstIntersection(final BSPTree<Euclidean3D> node,\n                                                                 final Vector3D point,\n@@ -270,7 +270,7 @@ private void addContribution(final SubHyperplane<Euclidean3D> facet, final boole\n \n         // establish search order\n         final double offset = plane.getOffset((Point<Euclidean3D>) point);\n-        final boolean in    = FastMath.abs(offset) < 1.0e-10;\n+        final boolean in    = FastMath.abs(offset) < getTolerance();\n         final BSPTree<Euclidean3D> near;\n         final BSPTree<Euclidean3D> far;\n         if (offset < 0) {\n@@ -298,7 +298,7 @@ private void addContribution(final SubHyperplane<Euclidean3D> facet, final boole\n         if (!in) {\n             // search in the cut hyperplane\n             final Vector3D hit3D = plane.intersection(line);\n-            if (hit3D != null) {\n+            if (hit3D != null && line.getAbscissa(hit3D) > line.getAbscissa(point)) {\n                 final SubHyperplane<Euclidean3D> facet = boundaryFacet(hit3D, node);\n                 if (facet != null) {\n                     return facet;\n",
        "project": "commons-math",
        "linesAdd": 2,
        "jira_id": "1211",
        "nb_skipped": 3,
        "commit": "a06a1584",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5472,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.util.PrecisionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/util/Precision.java b/src/main/java/org/apache/commons/math3/util/Precision.java\nindex ef3b57f39..f0b0c4ff7 100644\n--- a/src/main/java/org/apache/commons/math3/util/Precision.java\n+++ b/src/main/java/org/apache/commons/math3/util/Precision.java\n@@ -491,8 +491,7 @@ private static double roundUnscaled(double unscaled,\n                 unscaled = FastMath.floor(unscaled);\n             } else {\n                 // The following equality test is intentional and needed for rounding purposes\n-                if (FastMath.floor(unscaled) / 2.0 == FastMath.floor(Math\n-                    .floor(unscaled) / 2.0)) { // even\n+                if (FastMath.floor(unscaled) / 2.0 == FastMath.floor(FastMath.floor(unscaled) / 2.0)) { // even\n                     unscaled = FastMath.floor(unscaled);\n                 } else { // odd\n                     unscaled = FastMath.ceil(unscaled);\n@@ -516,7 +515,10 @@ private static double roundUnscaled(double unscaled,\n             }\n             break;\n         case BigDecimal.ROUND_UP :\n+            // do not round if the discarded fraction is equal to zero\n+            if (unscaled != FastMath.floor(unscaled)) {\n                 unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+            }\n             break;\n         default :\n             throw new MathIllegalArgumentException(LocalizedFormats.INVALID_ROUNDING_METHOD,\n",
        "project": "commons-math",
        "linesAdd": 3,
        "jira_id": "1070",
        "nb_skipped": 5,
        "commit": "8e5867ed",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 3646,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.linear.ArrayRealVectorTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java b/src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java\nindex ee67e03b2..ef02a750f 100644\n--- a/src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/ArrayRealVector.java\n@@ -455,16 +455,8 @@ public double dotProduct(RealVector v) {\n                 dot += data[i] * vData[i];\n             }\n             return dot;\n-        } else {\n-            checkVectorDimensions(v);\n-            double dot = 0;\n-            Iterator<Entry> it = v.sparseIterator();\n-            while (it.hasNext()) {\n-                final Entry e = it.next();\n-                dot += data[e.getIndex()] * e.getValue();\n-            }\n-            return dot;\n         }\n+        return super.dotProduct(v);\n     }\n \n     /** {@inheritDoc} */\ndiff --git a/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java b/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java\nindex 49e22c264..b3e04be60 100644\n--- a/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java\n@@ -304,38 +304,6 @@ public OpenMapRealVector copy() {\n         return new OpenMapRealVector(this);\n     }\n \n-    /**\n-     * Optimized method to compute the dot product with an OpenMapRealVector.\n-     * It iterates over the smallest of the two.\n-     *\n-     * @param v Cector to compute the dot product with.\n-     * @return the dot product of {@code this} and {@code v}.\n-     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n-     * if the dimensions do not match.\n-     */\n-    public double dotProduct(OpenMapRealVector v) {\n-        checkVectorDimensions(v.getDimension());\n-        boolean thisIsSmaller  = entries.size() < v.entries.size();\n-        Iterator iter = thisIsSmaller  ? entries.iterator() : v.entries.iterator();\n-        OpenIntToDoubleHashMap larger = thisIsSmaller  ? v.entries : entries;\n-        double d = 0;\n-        while(iter.hasNext()) {\n-            iter.advance();\n-            d += iter.value() * larger.get(iter.key());\n-        }\n-        return d;\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public double dotProduct(RealVector v) {\n-        if(v instanceof OpenMapRealVector) {\n-            return dotProduct((OpenMapRealVector)v);\n-        } else {\n-            return super.dotProduct(v);\n-        }\n-    }\n-\n     /** {@inheritDoc} */\n     @Override\n     public OpenMapRealVector ebeDivide(RealVector v) {\ndiff --git a/src/main/java/org/apache/commons/math3/linear/RealVector.java b/src/main/java/org/apache/commons/math3/linear/RealVector.java\nindex 5dc8ddfa6..89611c34c 100644\n--- a/src/main/java/org/apache/commons/math3/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RealVector.java\n@@ -303,10 +303,9 @@ public RealVector mapAddToSelf(double d) {\n     public double dotProduct(RealVector v) {\n         checkVectorDimensions(v);\n         double d = 0;\n-        Iterator<Entry> it = sparseIterator();\n-        while (it.hasNext()) {\n-            final Entry e = it.next();\n-            d += e.getValue() * v.getEntry(e.getIndex());\n+        final int n = getDimension();\n+        for (int i = 0; i < n; i++) {\n+            d += getEntry(i) * v.getEntry(i);\n         }\n         return d;\n     }\n",
        "project": "commons-math",
        "linesAdd": 4,
        "jira_id": "812",
        "nb_skipped": 7,
        "commit": "6eb46555",
        "nb_failure": 1,
        "linesRem": 35,
        "singleLine": false
    },
    {
        "files": 4,
        "nb_test": 2947,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.analysis.solvers.RegulaFalsiSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex c781a9011..034752553 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -19,6 +19,7 @@\n \n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.MathInternalError;\n \n /**\n@@ -61,8 +62,8 @@\n     /**\n      * Construct a solver.\n      *\n-     * @param absoluteAccuracy absolute accuracy\n-     * @param method <em>Secant</em>-based root-finding method to use\n+     * @param absoluteAccuracy Absolute accuracy.\n+     * @param method <em>Secant</em>-based root-finding method to use.\n      */\n     protected BaseSecantSolver(final double absoluteAccuracy, final Method method) {\n         super(absoluteAccuracy);\n@@ -73,9 +74,9 @@ protected BaseSecantSolver(final double absoluteAccuracy, final Method method) {\n     /**\n      * Construct a solver.\n      *\n-     * @param relativeAccuracy relative accuracy\n-     * @param absoluteAccuracy absolute accuracy\n-     * @param method <em>Secant</em>-based root-finding method to use\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n+     * @param method <em>Secant</em>-based root-finding method to use.\n      */\n     protected BaseSecantSolver(final double relativeAccuracy,\n                                final double absoluteAccuracy,\n@@ -183,7 +184,11 @@ protected final double doSolve() {\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n-                    // Nothing.\n+                    // Detect early that algorithm is stuck, instead of waiting\n+                    // for the maximum number of iterations to be exceeded.\n+                    if (x == x1) {\n+                        throw new ConvergenceException();\n+                    }\n                     break;\n                 default:\n                     // Should never happen.\ndiff --git a/src/main/java/org/apache/commons/math/analysis/solvers/IllinoisSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/IllinoisSolver.java\nindex ede0c2792..47c340c01 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/IllinoisSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/IllinoisSolver.java\n@@ -26,7 +26,9 @@\n  * <p>Like the <em>Regula Falsi</em> method, convergence is guaranteed by\n  * maintaining a bracketed solution. The <em>Illinois</em> method however,\n  * should converge much faster than the original <em>Regula Falsi</em>\n- * method.</p>\n+ * method. Furthermore, this implementation of the <em>Illinois</em> method\n+ * should not suffer from the same implementation issues as the <em>Regula\n+ * Falsi</em> method, which may fail to convergence in certain cases.</p>\n  *\n  * <p>The <em>Illinois</em> method assumes that the function is continuous,\n  * but not necessarily smooth.</p>\n@@ -49,7 +51,7 @@ public IllinoisSolver() {\n     /**\n      * Construct a solver.\n      *\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param absoluteAccuracy Absolute accuracy.\n      */\n     public IllinoisSolver(final double absoluteAccuracy) {\n         super(absoluteAccuracy, Method.ILLINOIS);\n@@ -58,8 +60,8 @@ public IllinoisSolver(final double absoluteAccuracy) {\n     /**\n      * Construct a solver.\n      *\n-     * @param relativeAccuracy relative accuracy\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n      */\n     public IllinoisSolver(final double relativeAccuracy,\n                           final double absoluteAccuracy) {\n@@ -69,8 +71,8 @@ public IllinoisSolver(final double relativeAccuracy,\n     /**\n      * Construct a solver.\n      *\n-     * @param relativeAccuracy relative accuracy\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n      * @param functionValueAccuracy Maximum function value error.\n      */\n     public IllinoisSolver(final double relativeAccuracy,\ndiff --git a/src/main/java/org/apache/commons/math/analysis/solvers/PegasusSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/PegasusSolver.java\nindex 08fb0c7d0..457c9580d 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/PegasusSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/PegasusSolver.java\n@@ -24,10 +24,13 @@\n  *\n  * <p>Like the <em>Regula Falsi</em> method, convergence is guaranteed by\n  * maintaining a bracketed solution. The <em>Pegasus</em> method however,\n- * should converge much faster than the original <em>Regula Falsi</em> method.\n- * Furthermore, it should converge faster than the\n- * {@link IllinoisSolver <em>Illinois</em>} method, another\n- * <em>Regula Falsi</em>-based method.</p>\n+ * should converge much faster than the original <em>Regula Falsi</em>\n+ * method. Furthermore, this implementation of the <em>Pegasus</em> method\n+ * should not suffer from the same implementation issues as the <em>Regula\n+ * Falsi</em> method, which may fail to convergence in certain cases. Also,\n+ * the <em>Pegasus</em> method should converge faster than the\n+ * {@link IllinoisSolver <em>Illinois</em>} method, another <em>Regula\n+ * Falsi</em>-based method.</p>\n  *\n  * <p>The <em>Pegasus</em> method assumes that the function is continuous,\n  * but not necessarily smooth.</p>\n@@ -50,7 +53,7 @@ public PegasusSolver() {\n     /**\n      * Construct a solver.\n      *\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param absoluteAccuracy Absolute accuracy.\n      */\n     public PegasusSolver(final double absoluteAccuracy) {\n         super(absoluteAccuracy, Method.PEGASUS);\n@@ -59,8 +62,8 @@ public PegasusSolver(final double absoluteAccuracy) {\n     /**\n      * Construct a solver.\n      *\n-     * @param relativeAccuracy relative accuracy\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n      */\n     public PegasusSolver(final double relativeAccuracy,\n                          final double absoluteAccuracy) {\n@@ -70,8 +73,8 @@ public PegasusSolver(final double relativeAccuracy,\n     /**\n      * Construct a solver.\n      *\n-     * @param relativeAccuracy relative accuracy\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n      * @param functionValueAccuracy Maximum function value error.\n      */\n     public PegasusSolver(final double relativeAccuracy,\ndiff --git a/src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java\nindex 89c50dfd0..71224a0da 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolver.java\n@@ -21,9 +20,27 @@\n /**\n  * Implements the <em>Regula Falsi</em> or <em>False position</em> method for\n  * root-finding (approximating a zero of a univariate real function). It is a\n- * modified {@link SecantSolver <em>Secant</em>} method. Unlike the\n- * <em>Secant</em> method, convergence is guaranteed by maintaining a\n- * bracketed solution.\n+ * modified {@link SecantSolver <em>Secant</em>} method.\n+ *\n+ * <p>The <em>Regula Falsi</em> method is included for completeness, for\n+ * testing purposes, for educational purposes, for comparison to other\n+ * algorithms, etc. It is however <strong>not</strong> intended to be used\n+ * for actual problems, as one of the bounds often remains fixed, resulting\n+ * in very slow convergence. Instead, one of the well-known modified\n+ * <em>Regula Falsi</em> algorithms can be used ({@link IllinoisSolver\n+ * <em>Illinois</em>} or {@link PegasusSolver <em>Pegasus</em>}). These two\n+ * algorithms solve the fundamental issues of the original <em>Regula\n+ * Falsi</em> algorithm, and greatly out-performs it for most, if not all,\n+ * (practical) functions.\n+ *\n+ * <p>Unlike the <em>Secant</em> method, the <em>Regula Falsi</em> guarantees\n+ * convergence, by maintaining a bracketed solution. Note however, that due to\n+ * the finite/limited precision of Java's {@link Double double} type, which is\n+ * used in this implementation, the algorithm may get stuck in a situation\n+ * where it no longer makes any progress. Such cases are detected and result\n+ * in a {@code ConvergenceException} exception being thrown. In other words,\n+ * the algorithm theoretically guarantees convergence, but the implementation\n+ * does not.</p>\n  *\n  * <p>The <em>Regula Falsi</em> method assumes that the function is continuous,\n  * but not necessarily smooth.</p>\n@@ -46,7 +63,7 @@ public RegulaFalsiSolver() {\n     /**\n      * Construct a solver.\n      *\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param absoluteAccuracy Absolute accuracy.\n      */\n     public RegulaFalsiSolver(final double absoluteAccuracy) {\n         super(absoluteAccuracy, Method.REGULA_FALSI);\n@@ -55,8 +72,8 @@ public RegulaFalsiSolver(final double absoluteAccuracy) {\n     /**\n      * Construct a solver.\n      *\n-     * @param relativeAccuracy relative accuracy\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n      */\n     public RegulaFalsiSolver(final double relativeAccuracy,\n                              final double absoluteAccuracy) {\n@@ -66,8 +83,8 @@ public RegulaFalsiSolver(final double relativeAccuracy,\n     /**\n      * Construct a solver.\n      *\n-     * @param relativeAccuracy relative accuracy\n-     * @param absoluteAccuracy absolute accuracy\n+     * @param relativeAccuracy Relative accuracy.\n+     * @param absoluteAccuracy Absolute accuracy.\n      * @param functionValueAccuracy Maximum function value error.\n      */\n     public RegulaFalsiSolver(final double relativeAccuracy,\n",
        "project": "commons-math",
        "linesAdd": 4,
        "jira_id": "631",
        "nb_skipped": 1,
        "commit": "c0b49542",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2125,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.linear.SingularValueSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\nindex 6003ed677..e418c084f 100644\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n@@ -159,27 +159,28 @@ public RealMatrix getU()\n             if (m >= n) {\n                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                 final RealMatrix e =\n-                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n+                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[m][p];\n                 double[] ei1 = eData[0];\n-                for (int i = 0; i < p - 1; ++i) {\n+                for (int i = 0; i < p; ++i) {\n                     // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                     final double mi = mainBidiagonal[i];\n-                    final double si = secondaryBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n+                    if (i < n - 1) {\n                         ei1 = eData[i + 1];\n+                        final double si = secondaryBidiagonal[i];\n                         for (int j = 0; j < p; ++j) {\n                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                         }\n-                }\n-                // last row\n-                final double lastMain = mainBidiagonal[p - 1];\n-                final double[] wr1  = wData[p - 1];\n+                    } else {\n                         for (int j = 0; j < p; ++j) {\n-                    wr1[j] = ei1[j] * lastMain / singularValues[j];\n+                            wi[j] = mi * ei0[j] / singularValues[j];\n+                        }\n                     }\n+                }\n+\n                 for (int i = p; i < m; ++i) {\n                     wData[i] = new double[p];\n                 }\n@@ -247,25 +248,25 @@ public RealMatrix getV()\n                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                 // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n                 final RealMatrix e =\n-                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n+                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[n][p];\n                 double[] ei1 = eData[0];\n-                for (int i = 0; i < p - 1; ++i) {\n+                for (int i = 0; i < p; ++i) {\n                     final double mi = mainBidiagonal[i];\n-                    final double si = secondaryBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n+                    if (i < m - 1) {\n                         ei1 = eData[i + 1];\n+                        final double si = secondaryBidiagonal[i];\n                         for (int j = 0; j < p; ++j) {\n                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                         }\n-                }\n-                // last row\n-                final double lastMain = mainBidiagonal[p - 1];\n-                final double[] wr1  = wData[p - 1];\n+                    } else {\n                         for (int j = 0; j < p; ++j) {\n-                    wr1[j] = ei1[j] * lastMain / singularValues[j];\n+                            wi[j] = mi * ei0[j] / singularValues[j];\n+                        }\n+                    }\n                 }\n                 for (int i = p; i < n; ++i) {\n                     wData[i] = new double[p];\n",
        "project": "commons-math",
        "linesAdd": 17,
        "jira_id": "320",
        "nb_skipped": 0,
        "commit": "b2f3f6db",
        "nb_failure": 2,
        "linesRem": 14,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2068,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.optimization.linear.SimplexSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex 1cb45cce7..23dc90c83 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -74,6 +74,9 @@\n     /** Whether to restrict the variables to non-negative values. */\n     private final boolean restrictToNonNegative;\n \n+    /** The variables each column represents */\n+    private final List<String> columnLabels = new ArrayList<String>();\n+\n     /** Simple tableau. */\n     private transient RealMatrix tableau;\n \n@@ -113,6 +116,27 @@\n         this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +\n                                       getConstraintTypeCounts(Relationship.GEQ);\n         this.tableau = createTableau(goalType == GoalType.MAXIMIZE);\n+        initializeColumnLabels();\n+    }\n+\n+    protected void initializeColumnLabels() {\n+      if (getNumObjectiveFunctions() == 2) {\n+        columnLabels.add(\"W\");\n+      }\n+      columnLabels.add(\"Z\");\n+      for (int i = 0; i < getOriginalNumDecisionVariables(); i++) {\n+        columnLabels.add(\"x\" + i);\n+      }\n+      if (!restrictToNonNegative) {\n+        columnLabels.add(\"x-\");\n+      }\n+      for (int i = 0; i < getNumSlackVariables(); i++) {\n+        columnLabels.add(\"s\" + i);\n+      }\n+      for (int i = 0; i < getNumArtificialVariables(); i++) {\n+        columnLabels.add(\"a\" + i);\n+      }\n+      columnLabels.add(\"RHS\");\n     }\n \n     /**\n@@ -301,6 +325,10 @@ protected void dropPhase1Objective() {\n           }\n         }\n \n+        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n+          columnLabels.remove((int) columnsToDrop.get(i));\n+        }\n+\n         this.tableau = new Array2DRowRealMatrix(matrix);\n         this.numArtificialVariables = 0;\n     }\n@@ -332,12 +360,19 @@ boolean isOptimal() {\n      * @return current solution\n      */\n     protected RealPointValuePair getSolution() {\n-      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n-      Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());\n+      int negativeVarColumn = columnLabels.indexOf(\"x-\");\n+      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n+\n       Set<Integer> basicRows = new HashSet<Integer>();\n+      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n       for (int i = 0; i < coefficients.length; i++) {\n-          Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n+          int colIndex = columnLabels.indexOf(\"x\" + i);\n+          if (colIndex < 0) {\n+            coefficients[i] = 0;\n+            continue;\n+          }\n+          Integer basicRow = getBasicRow(colIndex);\n           if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n@@ -442,15 +477,6 @@ protected final int getRhsOffset() {\n         return getWidth() - 1;\n     }\n \n-    /**\n-     * Returns the offset of the extra decision variable added when there is a\n-     * negative decision variable in the original problem.\n-     * @return the offset of x-\n-     */\n-    protected final int getNegativeDecisionVariableOffset() {\n-      return getNumObjectiveFunctions() + getOriginalNumDecisionVariables();\n-    }\n-\n     /**\n      * Get the number of decision variables.\n      * <p>\n@@ -471,7 +497,7 @@ protected final int getNumDecisionVariables() {\n      * @see #getNumDecisionVariables()\n      */\n     protected final int getOriginalNumDecisionVariables() {\n-        return restrictToNonNegative ? numDecisionVariables : numDecisionVariables - 1;\n+        return f.getCoefficients().getDimension();\n     }\n \n     /**\n",
        "project": "commons-math",
        "linesAdd": 38,
        "jira_id": "293",
        "nb_skipped": 0,
        "commit": "59a0da9c",
        "nb_failure": 0,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 2119,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.linear.ArrayRealVectorTest",
            "org.apache.commons.math.linear.SparseRealVectorTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\nindex cf103c066..ace4b8d21 100644\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealVector.java\n@@ -205,6 +205,40 @@ public double getDistance(RealVector v) throws IllegalArgumentException {\n         return Math.sqrt(d);\n     }\n \n+    /** {@inheritDoc} */\n+    public double getNorm() {\n+        double sum = 0;\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            final double value = e.getValue();\n+            sum += value * value;\n+        }\n+        return Math.sqrt(sum);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Norm() {\n+        double norm = 0;\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            norm += Math.abs(e.getValue());\n+        }\n+        return norm;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfNorm() {\n+        double norm = 0;\n+        Iterator<Entry> it = sparseIterator();\n+        Entry e;\n+        while (it.hasNext() && (e = it.next()) != null) {\n+            norm = Math.max(norm, Math.abs(e.getValue()));\n+        }\n+        return norm;\n+    }\n+\n     /** {@inheritDoc} */\n     public double getDistance(double[] v) throws IllegalArgumentException {\n         return getDistance(new ArrayRealVector(v,false));\ndiff --git a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\nindex 45c091921..22d0a280f 100644\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n@@ -694,6 +694,7 @@ public double dotProduct(ArrayRealVector v)\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getNorm() {\n         double sum = 0;\n         for (double a : data) {\n@@ -703,6 +704,7 @@ public double getNorm() {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getL1Norm() {\n         double sum = 0;\n         for (double a : data) {\n@@ -712,10 +714,11 @@ public double getL1Norm() {\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getLInfNorm() {\n         double max = 0;\n         for (double a : data) {\n-            max += Math.max(max, Math.abs(a));\n+            max = Math.max(max, Math.abs(a));\n         }\n         return max;\n     }\ndiff --git a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\nindex febea7a87..eb5be1b68 100644\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n@@ -495,17 +495,6 @@ public double getL1Distance(double[] v) throws IllegalArgumentException {\n         return max;\n     }\n \n-    /** {@inheritDoc} */\n-    public double getL1Norm() {\n-        double res = 0;\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            res += Math.abs(iter.value());\n-        }\n-        return res;\n-    }\n-\n     /**\n      * Optimized method to compute LInfDistance.\n      * @param v The vector to compute from\n@@ -556,28 +545,6 @@ public double getLInfDistance(double[] v) throws IllegalArgumentException {\n         return max;\n     }\n \n-    /** {@inheritDoc} */\n-    public double getLInfNorm() {\n-        double max = 0;\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            max += iter.value();\n-        }\n-        return max;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getNorm() {\n-        double res = 0;\n-        Iterator iter = entries.iterator();\n-        while (iter.hasNext()) {\n-            iter.advance();\n-            res += iter.value() * iter.value();\n-        }\n-        return Math.sqrt(res);\n-    }\n-\n     /** {@inheritDoc} */\n     public boolean isInfinite() {\n         boolean infiniteFound = false;\n",
        "project": "commons-math",
        "linesAdd": 35,
        "jira_id": "326",
        "nb_skipped": 0,
        "commit": "ce185345",
        "nb_failure": 2,
        "linesRem": 31,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4921,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.stat.correlation.SpearmansRankCorrelationTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/stat/correlation/SpearmansCorrelation.java b/src/main/java/org/apache/commons/math3/stat/correlation/SpearmansCorrelation.java\nindex 2cd4151ab..14c48c67d 100644\n--- a/src/main/java/org/apache/commons/math3/stat/correlation/SpearmansCorrelation.java\n+++ b/src/main/java/org/apache/commons/math3/stat/correlation/SpearmansCorrelation.java\n@@ -17,22 +17,28 @@\n \n package org.apache.commons.math3.stat.correlation;\n \n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.linear.BlockRealMatrix;\n import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.stat.ranking.NaNStrategy;\n import org.apache.commons.math3.stat.ranking.NaturalRanking;\n import org.apache.commons.math3.stat.ranking.RankingAlgorithm;\n \n /**\n- * <p>Spearman's rank correlation. This implementation performs a rank\n+ * Spearman's rank correlation. This implementation performs a rank\n  * transformation on the input data and then computes {@link PearsonsCorrelation}\n- * on the ranked data.</p>\n- *\n- * <p>By default, ranks are computed using {@link NaturalRanking} with default\n+ * on the ranked data.\n+ * <p>\n+ * By default, ranks are computed using {@link NaturalRanking} with default\n  * strategies for handling NaNs and ties in the data (NaNs maximal, ties averaged).\n- * The ranking algorithm can be set using a constructor argument.</p>\n+ * The ranking algorithm can be set using a constructor argument.\n  *\n  * @since 2.0\n  * @version $Id$\n@@ -58,6 +63,9 @@ public SpearmansCorrelation() {\n \n     /**\n      * Create a SpearmansCorrelation with the given ranking algorithm.\n+     * <p>\n+     * From version 4.0 onwards this constructor will throw an exception\n+     * if the provided {@link NaturalRanking} uses a {@link NaNStrategy#REMOVED} strategy.\n      *\n      * @param rankingAlgorithm ranking algorithm\n      * @since 3.1\n@@ -81,15 +89,17 @@ public SpearmansCorrelation(final RealMatrix dataMatrix) {\n     /**\n      * Create a SpearmansCorrelation with the given input data matrix\n      * and ranking algorithm.\n+     * <p>\n+     * From version 4.0 onwards this constructor will throw an exception\n+     * if the provided {@link NaturalRanking} uses a {@link NaNStrategy#REMOVED} strategy.\n      *\n      * @param dataMatrix matrix of data with columns representing\n      * variables to correlate\n      * @param rankingAlgorithm ranking algorithm\n      */\n     public SpearmansCorrelation(final RealMatrix dataMatrix, final RankingAlgorithm rankingAlgorithm) {\n-        this.data = dataMatrix.copy();\n         this.rankingAlgorithm = rankingAlgorithm;\n-        rankTransform(data);\n+        this.data = rankTransform(dataMatrix);\n         rankCorrelation = new PearsonsCorrelation(data);\n     }\n \n@@ -125,9 +135,8 @@ public PearsonsCorrelation getRankCorrelation() {\n      * @param matrix matrix with columns representing variables to correlate\n      * @return correlation matrix\n      */\n-    public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n-        RealMatrix matrixCopy = matrix.copy();\n-        rankTransform(matrixCopy);\n+    public RealMatrix computeCorrelationMatrix(final RealMatrix matrix) {\n+        final RealMatrix matrixCopy = rankTransform(matrix);\n         return new PearsonsCorrelation().computeCorrelationMatrix(matrixCopy);\n     }\n \n@@ -139,7 +148,7 @@ public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n      * @param matrix matrix with columns representing variables to correlate\n      * @return correlation matrix\n      */\n-    public RealMatrix computeCorrelationMatrix(double[][] matrix) {\n+    public RealMatrix computeCorrelationMatrix(final double[][] matrix) {\n        return computeCorrelationMatrix(new BlockRealMatrix(matrix));\n     }\n \n@@ -159,20 +168,93 @@ public double correlation(final double[] xArray, final double[] yArray) {\n             throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                                    xArray.length, 2);\n         } else {\n-            return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(xArray),\n-                    rankingAlgorithm.rank(yArray));\n+            double[] x = xArray;\n+            double[] y = yArray;\n+            if (rankingAlgorithm instanceof NaturalRanking &&\n+                NaNStrategy.REMOVED == ((NaturalRanking) rankingAlgorithm).getNanStrategy()) {\n+                final Set<Integer> nanPositions = new HashSet<Integer>();\n+\n+                nanPositions.addAll(getNaNPositions(xArray));\n+                nanPositions.addAll(getNaNPositions(yArray));\n+\n+                x = removeValues(xArray, nanPositions);\n+                y = removeValues(yArray, nanPositions);\n+            }\n+            return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(x), rankingAlgorithm.rank(y));\n         }\n     }\n \n     /**\n      * Applies rank transform to each of the columns of <code>matrix</code>\n-     * using the current <code>rankingAlgorithm</code>\n+     * using the current <code>rankingAlgorithm</code>.\n      *\n      * @param matrix matrix to transform\n+     * @return a rank-transformed matrix\n      */\n-    private void rankTransform(RealMatrix matrix) {\n+    private RealMatrix rankTransform(final RealMatrix matrix) {\n+        RealMatrix transformed = null;\n+\n+        if (rankingAlgorithm instanceof NaturalRanking &&\n+                ((NaturalRanking) rankingAlgorithm).getNanStrategy() == NaNStrategy.REMOVED) {\n+            final Set<Integer> nanPositions = new HashSet<Integer>();\n             for (int i = 0; i < matrix.getColumnDimension(); i++) {\n-            matrix.setColumn(i, rankingAlgorithm.rank(matrix.getColumn(i)));\n+                nanPositions.addAll(getNaNPositions(matrix.getColumn(i)));\n+            }\n+\n+            // if we have found NaN values, we have to update the matrix size\n+            if (!nanPositions.isEmpty()) {\n+                transformed = new BlockRealMatrix(matrix.getRowDimension() - nanPositions.size(),\n+                                                  matrix.getColumnDimension());\n+                for (int i = 0; i < transformed.getColumnDimension(); i++) {\n+                    transformed.setColumn(i, removeValues(matrix.getColumn(i), nanPositions));\n+                }\n+            }\n+        }\n+\n+        if (transformed == null) {\n+            transformed = matrix.copy();\n+        }\n+\n+        for (int i = 0; i < transformed.getColumnDimension(); i++) {\n+            transformed.setColumn(i, rankingAlgorithm.rank(transformed.getColumn(i)));\n+        }\n+\n+        return transformed;\n+    }\n+\n+    /**\n+     * Returns a list containing the indices of NaN values in the input array.\n+     *\n+     * @param input the input array\n+     * @return a list of NaN positions in the input array\n+     */\n+    private List<Integer> getNaNPositions(final double[] input) {\n+        final List<Integer> positions = new ArrayList<Integer>();\n+        for (int i = 0; i < input.length; i++) {\n+            if (Double.isNaN(input[i])) {\n+                positions.add(i);\n+            }\n+        }\n+        return positions;\n+    }\n+\n+    /**\n+     * Removes all values from the input array at the specified indices.\n+     *\n+     * @param input the input array\n+     * @param indices a set containing the indices to be removed\n+     * @return the input array without the values at the specified indices\n+     */\n+    private double[] removeValues(final double[] input, final Set<Integer> indices) {\n+        if (indices.isEmpty()) {\n+            return input;\n+        }\n+        final double[] result = new double[input.length - indices.size()];\n+        for (int i = 0, j = 0; i < input.length; i++) {\n+            if (!indices.contains(i)) {\n+                result[j++] = input[i];\n+            }\n         }\n+        return result;\n     }\n }\n",
        "project": "commons-math",
        "linesAdd": 72,
        "jira_id": "891",
        "nb_skipped": 4,
        "commit": "2b852d79",
        "nb_failure": 1,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2272,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.util.MathUtilsTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 887dc66a2..ab0fe3358 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -407,20 +407,14 @@ public static double cosh(double x) {\n \n     /**\n      * Returns true iff they are equal as defined by\n-     * {@link #equals(double,double,int) this method}.\n+     * {@link #equals(double,double,int) equals(x, y, 1)}.\n      *\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n-     * @deprecated This method considers that {@code NaN == NaN}. In release\n-     * 3.0, the semantics will change in order to comply with IEEE754 where it\n-     * is specified that {@code NaN != NaN}.\n-     * New methods have been added for those cases wher the old semantics is\n-     * useful (see e.g. {@link #equalsIncludingNaN(double,double)\n-     * equalsIncludingNaN}.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return equals(x, y, 1);\n     }\n \n     /**\n@@ -524,12 +518,6 @@ public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n      * @param y second array\n      * @return true if the values are both null or have same dimension\n      * and equal elements.\n-     * @deprecated This method considers that {@code NaN == NaN}. In release\n-     * 3.0, the semantics will change in order to comply with IEEE754 where it\n-     * is specified that {@code NaN != NaN}.\n-     * New methods have been added for those cases wher the old semantics is\n-     * useful (see e.g. {@link #equalsIncludingNaN(double[],double[])\n-     * equalsIncludingNaN}.\n      */\n     public static boolean equals(double[] x, double[] y) {\n         if ((x == null) || (y == null)) {\n@@ -1101,29 +1089,6 @@ public static long mulAndCheck(long a, long b) {\n         return ret;\n     }\n \n-    /**\n-     * Get the next machine representable number after a number, moving\n-     * in the direction of another number.\n-     * <p>\n-     * If <code>direction</code> is greater than or equal to<code>d</code>,\n-     * the smallest machine representable number strictly greater than\n-     * <code>d</code> is returned; otherwise the largest representable number\n-     * strictly less than <code>d</code> is returned.</p>\n-     * <p>\n-     * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>\n-     *\n-     * @param d base number\n-     * @param direction (the only important thing is whether\n-     * direction is greater or smaller than d)\n-     * @return the next machine representable number in the specified direction\n-     * @since 1.2\n-     * @deprecated as of 2.2, replaced by {@link FastMath#nextAfter(double, double)}\n-     */\n-    @Deprecated\n-    public static double nextAfter(double d, double direction) {\n-        return FastMath.nextAfter(d, direction);\n-    }\n-\n     /**\n      * Scale a number by 2<sup>scaleFactor</sup>.\n      * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>\n@@ -1318,23 +1283,23 @@ private static double roundUnscaled(double unscaled, double sign,\n         switch (roundingMethod) {\n         case BigDecimal.ROUND_CEILING :\n             if (sign == -1) {\n-                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             } else {\n-                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n             }\n             break;\n         case BigDecimal.ROUND_DOWN :\n-            unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+            unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             break;\n         case BigDecimal.ROUND_FLOOR :\n             if (sign == -1) {\n-                unscaled = FastMath.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n             } else {\n-                unscaled = FastMath.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n             }\n             break;\n         case BigDecimal.ROUND_HALF_DOWN : {\n-            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n+            unscaled = FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n             double fraction = unscaled - FastMath.floor(unscaled);\n             if (fraction > 0.5) {\n                 unscaled = FastMath.ceil(unscaled);\n@@ -1361,7 +1326,7 @@ private static double roundUnscaled(double unscaled, double sign,\n             break;\n         }\n         case BigDecimal.ROUND_HALF_UP : {\n-            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n+            unscaled = FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY);\n             double fraction = unscaled - FastMath.floor(unscaled);\n             if (fraction >= 0.5) {\n                 unscaled = FastMath.ceil(unscaled);\n@@ -1376,7 +1341,7 @@ private static double roundUnscaled(double unscaled, double sign,\n             }\n             break;\n         case BigDecimal.ROUND_UP :\n-            unscaled = FastMath.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n+            unscaled = FastMath.ceil(FastMath.nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n             break;\n         default :\n             throw MathRuntimeException.createIllegalArgumentException(\n@@ -1904,24 +1869,6 @@ public static void checkOrder(double[] val) {\n         checkOrder(val, OrderDirection.INCREASING, true);\n     }\n \n-    /**\n-     * Checks that the given array is sorted.\n-     *\n-     * @param val Values\n-     * @param dir Order direction (-1 for decreasing, 1 for increasing)\n-     * @param strict Whether the order should be strict\n-     * @throws NonMonotonousSequenceException if the array is not sorted.\n-     * @deprecated as of 2.2 (please use the new {@link #checkOrder(double[],OrderDirection,boolean)\n-     * checkOrder} method). To be removed in 3.0.\n-     */\n-    public static void checkOrder(double[] val, int dir, boolean strict) {\n-        if (dir > 0) {\n-            checkOrder(val, OrderDirection.INCREASING, strict);\n-        } else {\n-            checkOrder(val, OrderDirection.DECREASING, strict);\n-        }\n-    }\n-\n     /**\n      * Returns the Cartesian norm (2-norm), handling both overflow and underflow.\n      * Translation of the minpack enorm subroutine.\n",
        "project": "commons-math",
        "linesAdd": 9,
        "jira_id": "370",
        "nb_skipped": 0,
        "commit": "495f04bc",
        "nb_failure": 1,
        "linesRem": 22,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2041,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.optimization.linear.SimplexSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 16d3baea1..60a1b3ac5 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -77,9 +77,10 @@ private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n-            double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n-            if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) {\n-                double ratio = rhs / tableau.getEntry(i, col);\n+            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n+            final double entry = tableau.getEntry(i, col);\n+            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n+                final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n",
        "project": "commons-math",
        "linesAdd": 4,
        "jira_id": "288",
        "nb_skipped": 0,
        "commit": "38983e82",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2167,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.analysis.solvers.BisectionSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f669271a..180caefbc 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -69,7 +69,7 @@ public double solve(double min, double max)\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "369",
        "nb_skipped": 0,
        "commit": "f4a4464b",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 2263,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex d1531a812..468dca712 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -561,7 +561,7 @@ private void findEigenVectors(double[][] householderMatrix) {\n                             z[ia][i] = c * z[ia][i] - s * p;\n                         }\n                     }\n-                    if (e[i + 1] == 0.0 && i >= j)\n+                    if (t == 0.0 && i >= j)\n                         continue;\n                     realEigenvalues[j] -= u;\n                     e[j] = q;\ndiff --git a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\nindex 3abf3f0d8..597f6c42f 100644\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n@@ -141,7 +140,7 @@ public SingularValueDecompositionImpl(final RealMatrix matrix)\n             singularValues[i] = Math.sqrt(Math.abs(singularValues[i]));\n         }\n         // Up to this point, U and V are computed independently of each other.\n-        // There still an sign indetermination of each column of, say, U.\n+        // There still a sign indetermination of each column of, say, U.\n         // The sign is set such that A.V_i=sigma_i.U_i (i<=p)\n         // The right sign corresponds to a positive dot product of A.V_i and U_i\n         for (int i = 0; i < p; i++) {\ndiff --git a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 10f776263..5a60da853 100644\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -237,23 +237,20 @@ protected void updateResidualsAndCost()\n      * @return RMS value\n      */\n     public double getRMS() {\n-        double criterion = 0;\n-        for (int i = 0; i < rows; ++i) {\n-            final double residual = residuals[i];\n-            criterion += residualsWeights[i] * residual * residual;\n-        }\n-        return Math.sqrt(criterion / rows);\n+        return Math.sqrt(getChiSquare() / rows);\n     }\n \n     /**\n-     * Get the Chi-Square value.\n+     * Get a Chi-Square-like value assuming the N residuals follow N\n+     * distinct normal distributions centered on 0 and whose variances are\n+     * the reciprocal of the weights.\n      * @return chi-square value\n      */\n     public double getChiSquare() {\n         double chiSquare = 0;\n         for (int i = 0; i < rows; ++i) {\n             final double residual = residuals[i];\n-            chiSquare += residual * residual / residualsWeights[i];\n+            chiSquare += residual * residual * residualsWeights[i];\n         }\n         return chiSquare;\n     }\n",
        "project": "commons-math",
        "linesAdd": 3,
        "jira_id": "377",
        "nb_skipped": 0,
        "commit": "c640932d",
        "nb_failure": 1,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 6076,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.distribution.UniformIntegerDistributionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/distribution/UniformIntegerDistribution.java b/src/main/java/org/apache/commons/math3/distribution/UniformIntegerDistribution.java\nindex 3c26fdf88..c3a55b033 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/UniformIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/UniformIntegerDistribution.java\n@@ -59,7 +59,7 @@ public UniformIntegerDistribution(int lower, int upper)\n      * @param rng Random number generator.\n      * @param lower Lower bound (inclusive) of this distribution.\n      * @param upper Upper bound (inclusive) of this distribution.\n-     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     * @throws NumberIsTooLargeException if {@code lower > upper}.\n      * @since 3.1\n      */\n     public UniformIntegerDistribution(RandomGenerator rng,\n@@ -68,10 +68,10 @@ public UniformIntegerDistribution(RandomGenerator rng,\n         throws NumberIsTooLargeException {\n         super(rng);\n \n-        if (lower >= upper) {\n+        if (lower > upper) {\n             throw new NumberIsTooLargeException(\n                             LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n-                            lower, upper, false);\n+                            lower, upper, true);\n         }\n         this.lower = lower;\n         this.upper = upper;\n",
        "project": "commons-math",
        "linesAdd": 2,
        "jira_id": "1141",
        "nb_skipped": 3,
        "commit": "2f2a2dda",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 6167,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.ml.clustering.FuzzyKMeansClustererTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/ml/clustering/FuzzyKMeansClusterer.java b/src/main/java/org/apache/commons/math3/ml/clustering/FuzzyKMeansClusterer.java\nindex ed2204789..5f89934a7 100644\n--- a/src/main/java/org/apache/commons/math3/ml/clustering/FuzzyKMeansClusterer.java\n+++ b/src/main/java/org/apache/commons/math3/ml/clustering/FuzzyKMeansClusterer.java\n@@ -346,18 +346,32 @@ private void updateClusterCenters() {\n     private void updateMembershipMatrix() {\n         for (int i = 0; i < points.size(); i++) {\n             final T point = points.get(i);\n-            double maxMembership = 0.0;\n+            double maxMembership = Double.MIN_VALUE;\n             int newCluster = -1;\n             for (int j = 0; j < clusters.size(); j++) {\n                 double sum = 0.0;\n                 final double distA = FastMath.abs(distance(point, clusters.get(j).getCenter()));\n \n+                if (distA != 0.0) {\n                     for (final CentroidCluster<T> c : clusters) {\n                         final double distB = FastMath.abs(distance(point, c.getCenter()));\n+                        if (distB == 0.0) {\n+                            sum = Double.POSITIVE_INFINITY;\n+                            break;\n+                        }\n                         sum += FastMath.pow(distA / distB, 2.0 / (fuzziness - 1.0));\n                     }\n+                }\n \n-                membershipMatrix[i][j] = 1.0 / sum;\n+                double membership;\n+                if (sum == 0.0) {\n+                    membership = 1.0;\n+                } else if (sum == Double.POSITIVE_INFINITY) {\n+                    membership = 0.0;\n+                } else {\n+                    membership = 1.0 / sum;\n+                }\n+                membershipMatrix[i][j] = membership;\n \n                 if (membershipMatrix[i][j] > maxMembership) {\n                     maxMembership = membershipMatrix[i][j];\n",
        "project": "commons-math",
        "linesAdd": 16,
        "jira_id": "1165",
        "nb_skipped": 3,
        "commit": "596ccd59",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4084,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.optimization.univariate.BrentOptimizerTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\nindex cff5bfd33..25f2f5049 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -24,13 +24,19 @@\n import org.apache.commons.math3.optimization.GoalType;\n \n /**\n- * Implements Richard Brent's algorithm (from his book \"Algorithms for\n+ * For a function defined on some interval {@code (lo, hi)}, this class\n+ * finds an approximation {@code x} to the point at which the function\n+ * attains its minimum.\n+ * It implements Richard Brent's algorithm (from his book \"Algorithms for\n  * Minimization without Derivatives\", p. 79) for finding minima of real\n- * univariate functions. This implementation is an adaptation partly\n- * based on the Python code from SciPy (module \"optimize.py\" v0.5).\n- * If the function is defined on some interval {@code (lo, hi)}, then\n- * this method finds an approximation {@code x} to the point at which\n- * the function attains its minimum.\n+ * univariate functions.\n+ * <br/>\n+ * This code is an adaptation, partly based on the Python code from SciPy\n+ * (module \"optimize.py\" v0.5); the original algorithm is also modified\n+ * <ul>\n+ *  <li>to use an initial guess provided by the user,</li>\n+ *  <li>to ensure that the best point encountered is the one returned.</li>\n+ * </ul>\n  *\n  * @version $Id$\n  * @since 2.0\n@@ -141,6 +147,8 @@ protected UnivariatePointValuePair doOptimize() {\n         UnivariatePointValuePair previous = null;\n         UnivariatePointValuePair current\n             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n+        // Best point encountered so far (which is the initial guess).\n+        UnivariatePointValuePair best = current;\n \n         int iter = 0;\n         while (true) {\n@@ -224,10 +232,15 @@ protected UnivariatePointValuePair doOptimize() {\n                 // User-defined convergence checker.\n                 previous = current;\n                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n+                best = best(best,\n+                            best(current,\n+                                 previous,\n+                                 isMinim),\n+                            isMinim);\n \n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n-                        return best(current, previous, isMinim);\n+                        return best;\n                     }\n                 }\n \n@@ -264,7 +277,11 @@ protected UnivariatePointValuePair doOptimize() {\n                     }\n                 }\n             } else { // Default termination (Brent's criterion).\n-                return best(current, previous, isMinim);\n+                return best(best,\n+                            best(current,\n+                                 previous,\n+                                 isMinim),\n+                            isMinim);\n             }\n             ++iter;\n         }\n@@ -278,7 +295,8 @@ protected UnivariatePointValuePair doOptimize() {\n      * @param isMinim {@code true} if the selected point must be the one with\n      * the lowest value.\n      * @return the best point, or {@code null} if {@code a} and {@code b} are\n-     * both {@code null}.\n+     * both {@code null}. When {@code a} and {@code b} have the same function\n+     * value, {@code a} is returned.\n      */\n     private UnivariatePointValuePair best(UnivariatePointValuePair a,\n                                           UnivariatePointValuePair b,\n@@ -291,9 +309,9 @@ private UnivariatePointValuePair best(UnivariatePointValuePair a,\n         }\n \n         if (isMinim) {\n-            return a.getValue() < b.getValue() ? a : b;\n+            return a.getValue() <= b.getValue() ? a : b;\n         } else {\n-            return a.getValue() > b.getValue() ? a : b;\n+            return a.getValue() >= b.getValue() ? a : b;\n         }\n     }\n }\n",
        "project": "commons-math",
        "linesAdd": 14,
        "jira_id": "855",
        "nb_skipped": 4,
        "commit": "ac597cc1",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 2357,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.distribution.PoissonDistributionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\nindex 6aca50999..d20eb53c5 100644\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n@@ -40,18 +39,6 @@\n      */\n     double getMean();\n \n-    /**\n-     * Set the mean for the distribution.\n-     * The parameter value must be positive; otherwise an\n-     * <code>IllegalArgument</code> is thrown.\n-     *\n-     * @param p the mean\n-     * @throws IllegalArgumentException if p &le; 0\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setMean(double p);\n-\n     /**\n      * Calculates the Poisson distribution function using a normal approximation.\n      *\ndiff --git a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\nindex 64f792b60..0a8123390 100644\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n@@ -19,7 +19,7 @@\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Gamma;\n import org.apache.commons.math.util.MathUtils;\n@@ -77,7 +77,7 @@\n      * @throws IllegalArgumentException if p &le; 0\n      */\n     public PoissonDistributionImpl(double p) {\n-        this(p, new NormalDistributionImpl());\n+        this(p, DEFAULT_EPSILON, DEFAULT_MAX_ITERATIONS);\n     }\n \n     /**\n@@ -90,7 +90,11 @@ public PoissonDistributionImpl(double p) {\n      * @since 2.1\n      */\n     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n-        setMean(p);\n+        if (p <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);\n+        }\n+        mean = p;\n+        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n         this.epsilon = epsilon;\n         this.maxIterations = maxIterations;\n     }\n@@ -103,8 +107,7 @@ public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n      * @since 2.1\n      */\n     public PoissonDistributionImpl(double p, double epsilon) {\n-        setMean(p);\n-        this.epsilon = epsilon;\n+        this(p, epsilon, DEFAULT_MAX_ITERATIONS);\n     }\n \n     /**\n@@ -115,26 +118,7 @@ public PoissonDistributionImpl(double p, double epsilon) {\n      * @since 2.1\n      */\n     public PoissonDistributionImpl(double p, int maxIterations) {\n-        setMean(p);\n-        this.maxIterations = maxIterations;\n-    }\n-\n-\n-    /**\n-     * Create a new Poisson distribution with the given the mean. The mean value\n-     * must be positive; otherwise an <code>IllegalArgument</code> is thrown.\n-     *\n-     * @param p the Poisson mean\n-     * @param z a normal distribution used to compute normal approximations.\n-     * @throws IllegalArgumentException if p &le; 0\n-     * @since 1.2\n-     * @deprecated as of 2.1 (to avoid possibly inconsistent state, the\n-     * \"NormalDistribution\" will be instantiated internally)\n-     */\n-    @Deprecated\n-    public PoissonDistributionImpl(double p, NormalDistribution z) {\n-        super();\n-        setNormalAndMeanInternal(z, p);\n+        this(p, DEFAULT_EPSILON, maxIterations);\n     }\n \n     /**\n@@ -146,38 +130,6 @@ public double getMean() {\n         return mean;\n     }\n \n-    /**\n-     * Set the Poisson mean for the distribution. The mean value must be\n-     * positive; otherwise an <code>IllegalArgument</code> is thrown.\n-     *\n-     * @param p the Poisson mean value\n-     * @throws IllegalArgumentException if p &le; 0\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setMean(double p) {\n-        setNormalAndMeanInternal(normal, p);\n-    }\n-    /**\n-     * Set the Poisson mean for the distribution. The mean value must be\n-     * positive; otherwise an <code>IllegalArgument</code> is thrown.\n-     *\n-     * @param z the new distribution\n-     * @param p the Poisson mean value\n-     * @throws IllegalArgumentException if p &le; 0\n-     */\n-    private void setNormalAndMeanInternal(NormalDistribution z,\n-                                          double p) {\n-        if (p <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n-        }\n-        mean = p;\n-        normal = z;\n-        normal.setMean(p);\n-        normal.setStandardDeviation(FastMath.sqrt(p));\n-    }\n-\n     /**\n      * The probability mass function P(X = x) for a Poisson distribution.\n      *\n@@ -286,18 +238,4 @@ protected int getDomainLowerBound(double p) {\n     protected int getDomainUpperBound(double p) {\n         return Integer.MAX_VALUE;\n     }\n-\n-    /**\n-     * Modify the normal distribution used to compute normal approximations. The\n-     * caller is responsible for insuring the normal distribution has the proper\n-     * parameter settings.\n-     *\n-     * @param value the new distribution\n-     * @since 1.2\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setNormal(NormalDistribution value) {\n-        setNormalAndMeanInternal(value, mean);\n-    }\n }\n",
        "project": "commons-math",
        "linesAdd": 9,
        "jira_id": "349",
        "nb_skipped": 1,
        "commit": "4cc9a49d",
        "nb_failure": 0,
        "linesRem": 38,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 2377,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.optimization.linear.SimplexSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 5c25548dd..b9afc0ad6 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -22,6 +22,7 @@\n \n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n \n@@ -32,25 +33,33 @@\n  */\n public class SimplexSolver extends AbstractLinearOptimizer {\n     \n-    /** Default amount of error to accept in floating point comparisons. */\n+    /** Default amount of error to accept for algorithm convergence. */\n     private static final double DEFAULT_EPSILON = 1.0e-6;\n      \n-    /** Amount of error to accept in floating point comparisons. */\n+    /** Amount of error to accept for algorithm convergence. */\n     protected final double epsilon;\n \n+    /** Default amount of error to accept in floating point comparisons (as ulps). */\n+    private static final int DEFAULT_ULPS = 10;\n+\n+    /** Amount of error to accept in floating point comparisons (as ulps). */\n+    protected final int maxUlps;\n+\n     /**\n      * Build a simplex solver with default settings.\n      */\n     public SimplexSolver() {\n-        this(DEFAULT_EPSILON);\n+        this(DEFAULT_EPSILON, DEFAULT_ULPS);\n     }\n \n     /**\n      * Build a simplex solver with a specified accepted amount of error\n-     * @param epsilon the amount of error to accept in floating point comparisons\n+     * @param epsilon the amount of error to accept for algorithm convergence\n+     * @param maxUlps amount of error to accept in floating point comparisons \n      */\n-    public SimplexSolver(final double epsilon) {\n+    public SimplexSolver(final double epsilon, final int maxUlps) {\n         this.epsilon = epsilon;\n+        this.maxUlps = maxUlps;\n     }\n \n     /**\n@@ -62,8 +71,9 @@ private Integer getPivotColumn(SimplexTableau tableau) {\n         double minValue = 0;\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n+            final double entry = tableau.getEntry(0, i);\n+            if (MathUtils.compareTo(entry, minValue, getEpsilon(entry)) < 0) {\n+                minValue = entry;\n                 minPos = i;\n             }\n         }\n@@ -83,11 +93,13 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n+            \n+            if (MathUtils.compareTo(entry, 0d, getEpsilon(entry)) > 0) {\n                 final double ratio = rhs / entry;\n-                if (MathUtils.equals(ratio, minRatio, epsilon)) {\n+                final int cmp = MathUtils.compareTo(ratio, minRatio, getEpsilon(ratio));\n+                if (cmp == 0) {\n                     minRatioPositions.add(i);\n-                } else if (ratio < minRatio) {\n+                } else if (cmp < 0) {\n                     minRatio = ratio;\n                     minRatioPositions = new ArrayList<Integer>();\n                     minRatioPositions.add(i);\n@@ -103,7 +115,8 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {\n           for (Integer row : minRatioPositions) {\n             for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n               int column = i + tableau.getArtificialVariableOffset();\n-              if (MathUtils.equals(tableau.getEntry(row, column), 1, epsilon) &&\n+              final double entry = tableau.getEntry(row, column);\n+              if (MathUtils.equals(entry, 1d, getEpsilon(entry)) &&\n                   row.equals(tableau.getBasicRow(column))) {\n                 return row;\n               }\n@@ -162,7 +175,7 @@ protected void solvePhase1(final SimplexTableau tableau) throws OptimizationExce\n         }\n \n         // if W is not zero then we have no feasible solution\n-        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {\n+        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0d, epsilon)) {\n             throw new NoFeasibleSolutionException();\n         }\n     }\n@@ -171,7 +184,8 @@ protected void solvePhase1(final SimplexTableau tableau) throws OptimizationExce\n     @Override\n     public RealPointValuePair doOptimize() throws OptimizationException {\n         final SimplexTableau tableau =\n-            new SimplexTableau(function, linearConstraints, goal, nonNegative, epsilon);\n+            new SimplexTableau(function, linearConstraints, goal, nonNegative, \n+                               epsilon, maxUlps);\n \n         solvePhase1(tableau);\n         tableau.dropPhase1Objective();\n@@ -182,4 +196,12 @@ public RealPointValuePair doOptimize() throws OptimizationException {\n         return tableau.getSolution();\n     }\n \n+    /**\n+     * Get an epsilon that is adjusted to the magnitude of the given value.\n+     * @param value the value for which to get the epsilon\n+     * @return magnitude-adjusted epsilon using {@link FastMath.ulp}\n+     */\n+    private double getEpsilon(double value) {\n+        return FastMath.ulp(value) * (double) maxUlps;\n+    }\n }\ndiff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex 647d6bebd..0d1d91122 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -33,6 +33,7 @@\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n@@ -65,6 +66,9 @@\n     /** Column label for negative vars. */\n     private static final String NEGATIVE_VAR_COLUMN_LABEL = \"x-\";\n \n+    /** Default amount of error to accept in floating point comparisons (as ulps). */\n+    private static final int DEFAULT_ULPS = 10;\n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -1369660067587938365L;\n \n@@ -92,9 +96,12 @@\n     /** Number of artificial variables. */\n     private int numArtificialVariables;\n \n-    /** Amount of error to accept in floating point comparisons. */\n+    /** Amount of error to accept when checking for optimality. */\n     private final double epsilon;\n \n+    /** Amount of error to accept in floating point comparisons. */\n+    private final int maxUlps;\n+\n     /**\n      * Build a tableau for a linear problem.\n      * @param f linear objective function\n@@ -102,16 +109,35 @@\n      * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n      * or {@link GoalType#MINIMIZE}\n      * @param restrictToNonNegative whether to restrict the variables to non-negative values\n-     * @param epsilon amount of error to accept in floating point comparisons\n+     * @param epsilon amount of error to accept when checking for optimality\n      */\n     SimplexTableau(final LinearObjectiveFunction f,\n                    final Collection<LinearConstraint> constraints,\n                    final GoalType goalType, final boolean restrictToNonNegative,\n                    final double epsilon) {\n+        this(f, constraints, goalType, restrictToNonNegative, epsilon, DEFAULT_ULPS);\n+    }\n+    \n+    /**\n+     * Build a tableau for a linear problem.\n+     * @param f linear objective function\n+     * @param constraints linear constraints\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param restrictToNonNegative whether to restrict the variables to non-negative values\n+     * @param epsilon amount of error to accept when checking for optimality\n+     * @param maxUlps amount of error to accept in floating point comparisons \n+     */\n+    SimplexTableau(final LinearObjectiveFunction f,\n+                   final Collection<LinearConstraint> constraints,\n+                   final GoalType goalType, final boolean restrictToNonNegative,\n+                   final double epsilon,\n+                   final int maxUlps) {\n         this.f                      = f;\n         this.constraints            = normalizeConstraints(constraints);\n         this.restrictToNonNegative  = restrictToNonNegative;\n         this.epsilon                = epsilon;\n+        this.maxUlps                = maxUlps;\n         this.numDecisionVariables   = f.getCoefficients().getDimension() +\n                                       (restrictToNonNegative ? 0 : 1);\n         this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +\n@@ -172,7 +198,7 @@ protected RealMatrix createTableau(final boolean maximize) {\n \n         if (!restrictToNonNegative) {\n             matrix.setEntry(zIndex, getSlackVariableOffset() - 1,\n-                getInvertedCoeffiecientSum(objectiveCoefficients));\n+                getInvertedCoefficientSum(objectiveCoefficients));\n         }\n \n         // initialize the constraint rows\n@@ -188,7 +214,7 @@ protected RealMatrix createTableau(final boolean maximize) {\n             // x-\n             if (!restrictToNonNegative) {\n                 matrix.setEntry(row, getSlackVariableOffset() - 1,\n-                    getInvertedCoeffiecientSum(constraint.getCoefficients()));\n+                    getInvertedCoefficientSum(constraint.getCoefficients()));\n             }\n \n             // RHS\n@@ -269,7 +295,7 @@ private int getConstraintTypeCounts(final Relationship relationship) {\n      * @param coefficients coefficients to sum\n      * @return the -1 times the sum of all coefficients in the given array.\n      */\n-    protected static double getInvertedCoeffiecientSum(final RealVector coefficients) {\n+    protected static double getInvertedCoefficientSum(final RealVector coefficients) {\n         double sum = 0;\n         for (double coefficient : coefficients.getData()) {\n             sum -= coefficient;\n@@ -285,9 +311,10 @@ protected static double getInvertedCoeffiecientSum(final RealVector coefficients\n     protected Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = 0; i < getHeight(); i++) {\n-            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n+            final double entry = getEntry(i, col);\n+            if (MathUtils.equals(entry, 1d, getEpsilon(entry)) && (row == null)) {\n                 row = i;\n-            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n+            } else if (!MathUtils.equals(entry, 0d, getEpsilon(entry))) {\n                 return null;\n             }\n         }\n@@ -308,7 +335,8 @@ protected void dropPhase1Objective() {\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n-          if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) > 0) {\n+            final double entry = tableau.getEntry(0, i);\n+            if (MathUtils.compareTo(entry, 0d, getEpsilon(entry)) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n@@ -353,7 +381,8 @@ private void copyArray(final double[] src, final double[] dest) {\n      */\n     boolean isOptimal() {\n         for (int i = getNumObjectiveFunctions(); i < getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {\n+            final double entry = tableau.getEntry(0, i);\n+            if (MathUtils.compareTo(entry, 0d, epsilon) < 0) {\n                 return false;\n             }\n         }\n@@ -382,7 +411,7 @@ protected RealPointValuePair getSolution() {\n           if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n-              coefficients[i] = 0;\n+              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n               coefficients[i] =\n@@ -545,6 +574,7 @@ public boolean equals(Object other) {\n                  (numSlackVariables      == rhs.numSlackVariables) &&\n                  (numArtificialVariables == rhs.numArtificialVariables) &&\n                  (epsilon                == rhs.epsilon) &&\n+                 (maxUlps                == rhs.maxUlps) &&\n                  f.equals(rhs.f) &&\n                  constraints.equals(rhs.constraints) &&\n                  tableau.equals(rhs.tableau);\n@@ -560,6 +590,7 @@ public int hashCode() {\n                numSlackVariables ^\n                numArtificialVariables ^\n                Double.valueOf(epsilon).hashCode() ^\n+               maxUlps ^\n                f.hashCode() ^\n                constraints.hashCode() ^\n                tableau.hashCode();\n@@ -586,4 +617,12 @@ private void readObject(ObjectInputStream ois)\n         MatrixUtils.deserializeRealMatrix(this, \"tableau\", ois);\n     }\n     \n+    /**\n+     * Get an epsilon that is adjusted to the magnitude of the given value.\n+     * @param value the value for which to get the epsilon\n+     * @return magnitude-adjusted epsilon using {@link FastMath.ulp}\n+     */\n+    private double getEpsilon(double value) {\n+        return FastMath.ulp(value) * (double) maxUlps;\n+    }    \n }\n",
        "project": "commons-math",
        "linesAdd": 54,
        "jira_id": "434",
        "nb_skipped": 1,
        "commit": "133cbc2d",
        "nb_failure": 3,
        "linesRem": 18,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5958,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSetTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\nindex 3c1b26cc3..4d0c9d8cc 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n@@ -64,6 +64,16 @@ public PolygonsSet(final double tolerance) {\n      * cells). In order to avoid building too many small objects, it is\n      * recommended to use the predefined constants\n      * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n+     * <p>\n+     * This constructor is aimed at expert use, as building the tree may\n+     * be a difficult taks. It is not intended for general use and for\n+     * performances reasons does not check thoroughly its input, as this would\n+     * require walking the full tree each time. Failing to provide a tree with\n+     * the proper attributes, <em>will</em> therefore generate problems like\n+     * {@link NullPointerException} or {@link ClassCastException} only later on.\n+     * This limitation is known and explains why this constructor is for expert\n+     * use only. The caller does have the responsibility to provided correct arguments.\n+     * </p>\n      * @param tree inside/outside BSP tree representing the region\n      * @param tolerance tolerance below which points are considered identical\n      * @since 3.3\n@@ -219,6 +229,10 @@ public PolygonsSet(final double xMin, final double xMax,\n     private static Line[] boxBoundary(final double xMin, final double xMax,\n                                       final double yMin, final double yMax,\n                                       final double tolerance) {\n+        if ((xMin >= xMax - tolerance) || (yMin >= yMax - tolerance)) {\n+            // too thin box, build an empty polygons set\n+            return null;\n+        }\n         final Vector2D minMin = new Vector2D(xMin, yMin);\n         final Vector2D minMax = new Vector2D(xMin, yMax);\n         final Vector2D maxMin = new Vector2D(xMax, yMin);\n",
        "project": "commons-math",
        "linesAdd": 3,
        "jira_id": "1117",
        "nb_skipped": 3,
        "commit": "f4c926ea",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5477,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.stat.correlation.KendallsCorrelationTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/stat/correlation/KendallsCorrelation.java b/src/main/java/org/apache/commons/math3/stat/correlation/KendallsCorrelation.java\nindex 1e4495ce2..81fb39fb2 100644\n--- a/src/main/java/org/apache/commons/math3/stat/correlation/KendallsCorrelation.java\n+++ b/src/main/java/org/apache/commons/math3/stat/correlation/KendallsCorrelation.java\n@@ -160,7 +160,7 @@ public double correlation(final double[] xArray, final double[] yArray)\n         }\n \n         final int n = xArray.length;\n-        final int numPairs = n * (n - 1) / 2;\n+        final long numPairs = n * (n - 1l) / 2l;\n \n         @SuppressWarnings(\"unchecked\")\n         Pair<Double, Double>[] pairs = new Pair[n];\n@@ -254,7 +254,8 @@ public int compare(Pair<Double, Double> pair1, Pair<Double, Double> pair2) {\n         }\n         tiedYPairs += consecutiveYTies * (consecutiveYTies - 1) / 2;\n \n-        int concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;\n-        return concordantMinusDiscordant / FastMath.sqrt((numPairs - tiedXPairs) * (numPairs - tiedYPairs));\n+        final long concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;\n+        final double nonTiedPairsMultiplied = (numPairs - tiedXPairs) * (double) (numPairs - tiedYPairs);\n+        return concordantMinusDiscordant / FastMath.sqrt(nonTiedPairsMultiplied);\n     }\n }\n",
        "project": "commons-math",
        "linesAdd": 4,
        "jira_id": "1068",
        "nb_skipped": 5,
        "commit": "b12610d3",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 6081,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.ml.neuralnet.sofm.KohonenUpdateActionTest",
            "org.apache.commons.math3.geometry.euclidean.twod.hull.AklToussaintHeuristicTest",
            "org.apache.commons.math3.geometry.euclidean.twod.hull.MonotoneChainTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHull2D.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHull2D.java\nindex 1e0eec386..5d9734b3b 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHull2D.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHull2D.java\n@@ -28,8 +28,8 @@\n import org.apache.commons.math3.geometry.hull.ConvexHull;\n import org.apache.commons.math3.geometry.partitioning.Region;\n import org.apache.commons.math3.geometry.partitioning.RegionFactory;\n-import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.util.Precision;\n \n /**\n  * This class represents a convex hull in an two-dimensional euclidean space.\n@@ -62,12 +62,14 @@\n     public ConvexHull2D(final Vector2D[] vertices, final double tolerance)\n         throws MathIllegalArgumentException {\n \n+        // assign tolerance as it will be used by the isConvex method\n+        this.tolerance = tolerance;\n+\n         if (!isConvex(vertices)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NOT_CONVEX);\n         }\n \n         this.vertices = vertices.clone();\n-        this.tolerance = tolerance;\n     }\n \n     /**\n@@ -80,7 +82,7 @@ private boolean isConvex(final Vector2D[] hullVertices) {\n             return true;\n         }\n \n-        double sign = 0.0;\n+        int sign = 0;\n         for (int i = 0; i < hullVertices.length; i++) {\n             final Vector2D p1 = hullVertices[i == 0 ? hullVertices.length - 1 : i - 1];\n             final Vector2D p2 = hullVertices[i];\n@@ -89,14 +91,14 @@ private boolean isConvex(final Vector2D[] hullVertices) {\n             final Vector2D d1 = p2.subtract(p1);\n             final Vector2D d2 = p3.subtract(p2);\n \n-            final double cross = FastMath.signum(MathArrays.linearCombination( d1.getX(), d2.getY(),\n-                                                                              -d1.getY(), d2.getX()));\n+            final double crossProduct = MathArrays.linearCombination(d1.getX(), d2.getY(), -d1.getY(), d2.getX());\n+            final int cmp = Precision.compareTo(crossProduct, 0.0, tolerance);\n             // in case of collinear points the cross product will be zero\n-            if (cross != 0.0) {\n-                if (sign != 0.0 && cross != sign) {\n+            if (cmp != 0.0) {\n+                if (sign != 0.0 && cmp != sign) {\n                     return false;\n                 }\n-                sign = cross;\n+                sign = cmp;\n             }\n         }\n \ndiff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java\nindex 6e56fc634..a811ddace 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java\n@@ -25,6 +25,7 @@\n import org.apache.commons.math3.geometry.euclidean.twod.Line;\n import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;\n import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.Precision;\n \n /**\n  * Implements Andrew's monotone chain method to generate the convex hull of a finite set of\n@@ -80,9 +81,12 @@ public MonotoneChain(final boolean includeCollinearPoints, final double toleranc\n         // sort the points in increasing order on the x-axis\n         Collections.sort(pointsSortedByXAxis, new Comparator<Vector2D>() {\n             public int compare(final Vector2D o1, final Vector2D o2) {\n-                final int diff = (int) FastMath.signum(o1.getX() - o2.getX());\n+                final double tolerance = getTolerance();\n+                // need to take the tolerance value into account, otherwise collinear points\n+                // will not be handled correctly when building the upper/lower hull\n+                final int diff = Precision.compareTo(o1.getX(), o2.getX(), tolerance);\n                 if (diff == 0) {\n-                    return (int) FastMath.signum(o1.getY() - o2.getY());\n+                    return Precision.compareTo(o1.getY(), o2.getY(), tolerance);\n                 } else {\n                     return diff;\n                 }\n",
        "project": "commons-math",
        "linesAdd": 13,
        "jira_id": "1148",
        "nb_skipped": 3,
        "commit": "4080feff",
        "nb_failure": 1,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3070,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.ode.events.EventStateTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\nindex 2d878b15f..8f315e334 100644\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n@@ -40,7 +40,6 @@\n import org.apache.commons.math.ode.sampling.StepHandler;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.Incrementor;\n-import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.Precision;\n \n /**\n@@ -278,7 +277,6 @@ protected double acceptStep(final AbstractStepInterpolator interpolator,\n \n             double previousT = interpolator.getGlobalPreviousTime();\n             final double currentT = interpolator.getGlobalCurrentTime();\n-            resetOccurred = false;\n \n             // initialize the events states if needed\n             if (! statesInitialized) {\n@@ -332,6 +330,9 @@ public int compare(EventState es0, EventState es1) {\n                 if (isLastStep) {\n                     // the event asked to stop integration\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n+                    for (final EventState remaining : occuringEvents) {\n+                        remaining.stepAccepted(eventT, eventY);\n+                    }\n                     return eventT;\n                 }\n \n@@ -341,6 +342,9 @@ public int compare(EventState es0, EventState es1) {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n+                    for (final EventState remaining : occuringEvents) {\n+                        remaining.stepAccepted(eventT, eventY);\n+                    }\n                     return eventT;\n                 }\n \n",
        "project": "commons-math",
        "linesAdd": 6,
        "jira_id": "695",
        "nb_skipped": 1,
        "commit": "7980a242",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2378,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.util.MathUtilsTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 06c87c6c4..e061a351a 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -515,10 +515,6 @@ public static boolean equalsIncludingNaN(float x, float y, float eps) {\n      * @since 2.2\n      */\n     public static boolean equals(float x, float y, int maxUlps) {\n-        // Check that \"maxUlps\" is non-negative and small enough so that\n-        // NaN won't compare as equal to anything (except another NaN).\n-        assert maxUlps > 0 && maxUlps < NAN_GAP;\n-\n         int xInt = Float.floatToIntBits(x);\n         int yInt = Float.floatToIntBits(y);\n \n@@ -675,10 +671,6 @@ public static boolean equalsIncludingNaN(double x, double y, double eps) {\n      * point values between {@code x} and {@code y}.\n      */\n     public static boolean equals(double x, double y, int maxUlps) {\n-        // Check that \"maxUlps\" is non-negative and small enough so that\n-        // NaN won't compare as equal to anything (except another NaN).\n-        assert maxUlps > 0 && maxUlps < NAN_GAP;\n-\n         long xInt = Double.doubleToLongBits(x);\n         long yInt = Double.doubleToLongBits(y);\n \n",
        "project": "commons-math",
        "linesAdd": 0,
        "jira_id": "559",
        "nb_skipped": 1,
        "commit": "fc409e88",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4152,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.optimization.direct.CMAESOptimizerTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\nindex d01cd158c..b54cb3744 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -24,9 +24,11 @@\n import org.apache.commons.math3.analysis.MultivariateFunction;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n+import org.apache.commons.math3.exception.MathIllegalStateException;\n import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n import org.apache.commons.math3.linear.EigenDecomposition;\n import org.apache.commons.math3.linear.MatrixUtils;\n@@ -414,7 +416,7 @@ protected PointValuePair doOptimize() {\n                     bestValue = bestFitness;\n                     lastResult = optimum;\n                     optimum = new PointValuePair(\n-                            fitfun.decode(bestArx.getColumn(0)),\n+                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n                             isMinimize ? bestFitness : -bestFitness);\n                     if (getConvergenceChecker() != null && lastResult != null) {\n                         if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n@@ -911,6 +913,16 @@ public FitnessFunction() {\n             return res;\n         }\n \n+        /**\n+         * @param x Normalized objective variables.\n+         * @return the original objective variables, possibly repaired.\n+         */\n+        public double[] repairAndDecode(final double[] x) {\n+            return boundaries != null && isRepairMode ?\n+                decode(repair(x)) :\n+                decode(x);\n+        }\n+\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables.\n",
        "project": "commons-math",
        "linesAdd": 9,
        "jira_id": "864",
        "nb_skipped": 4,
        "commit": "abe53a53",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5851,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.random.EmpiricalDistributionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java b/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\nindex 61bb65b77..685c08b9c 100644\n--- a/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\n+++ b/src/main/java/org/apache/commons/math4/random/EmpiricalDistribution.java\n@@ -610,8 +610,12 @@ public double cumulativeProbability(double x) {\n         final double pB = pB(binIndex);\n         final RealDistribution kernel = k(x);\n         if (kernel instanceof ConstantRealDistribution) {\n+            if (x < kernel.getNumericalMean()) {\n+                return pBminus;\n+            } else {\n                 return pBminus + pB;\n             }\n+        }\n         final double[] binBounds = getUpperBounds();\n         final double kB = kB(binIndex);\n         final double lower = binIndex == 0 ? min : binBounds[binIndex - 1];\n",
        "project": "commons-math",
        "linesAdd": 4,
        "jira_id": "1208",
        "nb_skipped": 3,
        "commit": "ce2badf0",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5809,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.ode.JacobianMatricesTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/ode/UnknownParameterException.java b/src/main/java/org/apache/commons/math4/ode/UnknownParameterException.java\nindex 75c621056..bbbaa4a16 100644\n--- a/src/main/java/org/apache/commons/math4/ode/UnknownParameterException.java\n+++ b/src/main/java/org/apache/commons/math4/ode/UnknownParameterException.java\n@@ -38,7 +38,7 @@\n      * @param name parameter name.\n      */\n     public UnknownParameterException(final String name) {\n-        super(LocalizedFormats.UNKNOWN_PARAMETER);\n+        super(LocalizedFormats.UNKNOWN_PARAMETER, name);\n         this.name = name;\n     }\n \n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "1232",
        "nb_skipped": 3,
        "commit": "8f35fcb8",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2372,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.util.MathUtilsTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 85d9a048f..52ebeb6ea 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -33,7 +33,6 @@\n import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.MathIllegalArgumentException;\n-import org.apache.commons.math.exception.MathRuntimeException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.NotFiniteNumberException;\n \n@@ -1333,15 +1332,22 @@ public static double round(double x, int scale) {\n     }\n \n     /**\n-     * Round the given value to the specified number of decimal places. The\n+     * <p>Round the given value to the specified number of decimal places. The\n      * value is rounded using the given method which is any method defined in\n-     * {@link BigDecimal}.\n+     * {@link BigDecimal}.</p>\n+     *\n+     * <p>If {@code x} is infinite or NaN, then the value of {@code x} is\n+     * returned unchanged, regardless of the other parameters.</p>\n      *\n      * @param x the value to round.\n      * @param scale the number of digits to the right of the decimal point.\n      * @param roundingMethod the rounding method as defined in\n      *        {@link BigDecimal}.\n      * @return the rounded value.\n+     * @throws ArithmeticException if roundingMethod==ROUND_UNNECESSARY and the\n+     * specified scaling operation would require rounding.\n+     * @throws IllegalArgumentException if roundingMethod does not represent a\n+     * valid rounding mode.\n      * @since 1.1\n      */\n     public static double round(double x, int scale, int roundingMethod) {\n@@ -1356,8 +1362,6 @@ public static double round(double x, int scale, int roundingMethod) {\n             } else {\n                 return Double.NaN;\n             }\n-        } catch (RuntimeException ex) {\n-            throw new MathRuntimeException(ex);\n         }\n     }\n \n",
        "project": "commons-math",
        "linesAdd": 0,
        "jira_id": "555",
        "nb_skipped": 1,
        "commit": "328513f3",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 4502,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.optimization.fitting.PolynomialFitterTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/Weight.java b/src/main/java/org/apache/commons/math3/optimization/Weight.java\nindex 8e7538f22..28c161903 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/Weight.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/Weight.java\n@@ -18,7 +18,7 @@\n package org.apache.commons.math3.optimization;\n \n import org.apache.commons.math3.linear.RealMatrix;\n-import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math3.linear.DiagonalMatrix;\n import org.apache.commons.math3.linear.NonSquareMatrixException;\n \n /**\n@@ -41,11 +41,7 @@\n      * @param weight List of the values of the diagonal.\n      */\n     public Weight(double[] weight) {\n-        final int dim = weight.length;\n-        weightMatrix = new Array2DRowRealMatrix(dim, dim);\n-        for (int i = 0; i < dim; i++) {\n-            weightMatrix.setEntry(i, i, weight[i]);\n-        }\n+        weightMatrix = new DiagonalMatrix(weight);\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex b6c97e7e5..982e559eb 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -26,6 +26,7 @@\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.linear.ArrayRealVector;\n import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.linear.DiagonalMatrix;\n import org.apache.commons.math3.linear.DecompositionSolver;\n import org.apache.commons.math3.linear.MatrixUtils;\n import org.apache.commons.math3.linear.QRDecomposition;\n@@ -558,7 +559,16 @@ protected void setUp() {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n+        if (m instanceof DiagonalMatrix) {\n+            final int dim = m.getRowDimension();\n+            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n+            for (int i = 0; i < dim; i++) {\n+               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n+            }\n+            return sqrtM;\n+        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n         }\n     }\n+}\n",
        "project": "commons-math",
        "linesAdd": 12,
        "jira_id": "924",
        "nb_skipped": 4,
        "commit": "2836a6f9",
        "nb_failure": 0,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4818,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.distribution.DiscreteRealDistributionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\nindex 8c08dbe36..879eb2a29 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n@@ -16,9 +16,9 @@\n  */\n package org.apache.commons.math3.distribution;\n \n-import java.lang.reflect.Array;\n import java.util.ArrayList;\n import java.util.List;\n+\n import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.NotPositiveException;\n@@ -178,13 +178,13 @@ public T sample() {\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n+    public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {\n         if (sampleSize <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                     sampleSize);\n         }\n-        @SuppressWarnings(\"unchecked\")\n-        final T[]out = (T[]) Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+\n+        final Object[] out = new Object[sampleSize];\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n",
        "project": "commons-math",
        "linesAdd": 4,
        "jira_id": "942",
        "nb_skipped": 4,
        "commit": "0d057fc6",
        "nb_failure": 0,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2891,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.analysis.solvers.RegulaFalsiSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex fde7172e3..b3a23a1d4 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -169,25 +169,37 @@ protected final double doSolve() {\n \n             // Update the bounds with the new approximation.\n             if (f1 * fx < 0) {\n-                // We had [x0..x1]. We update it to [x1, x]. Note that the\n-                // value of x1 has switched to the other bound, thus inverting\n+                // The value of x1 has switched to the other bound, thus inverting\n                 // the interval.\n                 x0 = x1;\n                 f0 = f1;\n-                x1 = x;\n-                f1 = fx;\n                 inverted = !inverted;\n             } else {\n-                // We had [x0..x1]. We update it to [x0, x].\n-                if (method == Method.ILLINOIS) {\n+                switch (method) {\n+                case ILLINOIS:\n                     f0 *= 0.5;\n-                }\n-                if (method == Method.PEGASUS) {\n+                    break;\n+                case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n+                    break;\n+                case REGULA_FALSI:\n+                    if (x == x1) {\n+                        final double delta = FastMath.max(rtol * FastMath.abs(x1),\n+                                                          atol);\n+                        // Update formula cannot make any progress: Update the\n+                        // search interval.\n+                        x0 = 0.5 * (x0 + x1 - delta);\n+                        f0 = computeObjectiveValue(x0);\n                     }\n+                    break;\n+                default:\n+                    // Should never happen.\n+                    throw new MathInternalError();\n+                }\n+            }\n+            // Update from [x0, x1] to [x0, x].\n             x1 = x;\n             f1 = fx;\n-            }\n \n             // If the function value of the last approximation is too small,\n             // given the function value accuracy, then we can't get closer to\n",
        "project": "commons-math",
        "linesAdd": 16,
        "jira_id": "631",
        "nb_skipped": 1,
        "commit": "334c01e6",
        "nb_failure": 0,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4252,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.util.FastMathTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/util/FastMath.java b/src/main/java/org/apache/commons/math3/util/FastMath.java\nindex fd1ce2d85..9dc84c631 100644\n--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n@@ -309,6 +309,8 @@\n \n     /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */\n     private static final double TWO_POWER_52 = 4503599627370496.0;\n+    /** 2^53 - double numbers this large must be even. */\n+    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;\n \n     /** Constant: {@value}. */\n     private static final double F_1_3 = 1d / 3d;\n@@ -1537,7 +1539,7 @@ public static double pow(double x, double y) {\n         /* Handle special case x<0 */\n         if (x < 0) {\n             // y is an even integer in this case\n-            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n+            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {\n                 return pow(-x, y);\n             }\n \n",
        "project": "commons-math",
        "linesAdd": 2,
        "jira_id": "904",
        "nb_skipped": 4,
        "commit": "6844aba9",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 5428,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.special.BetaTest",
            "org.apache.commons.math3.distribution.WeibullDistributionTest",
            "org.apache.commons.math3.distribution.LogNormalDistributionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/distribution/LogNormalDistribution.java b/src/main/java/org/apache/commons/math3/distribution/LogNormalDistribution.java\nindex 810c9e407..ab7a13be4 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/LogNormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/LogNormalDistribution.java\n@@ -289,7 +289,7 @@ public double getNumericalMean() {\n     public double getNumericalVariance() {\n         final double s = shape;\n         final double ss = s * s;\n-        return (FastMath.exp(ss) - 1) * FastMath.exp(2 * scale + ss);\n+        return (FastMath.expm1(ss)) * FastMath.exp(2 * scale + ss);\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/math3/distribution/WeibullDistribution.java b/src/main/java/org/apache/commons/math3/distribution/WeibullDistribution.java\nindex ec34b508c..6e69bc9be 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/WeibullDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/WeibullDistribution.java\n@@ -221,7 +221,7 @@ public double inverseCumulativeProbability(double p) {\n         } else  if (p == 1) {\n             ret = Double.POSITIVE_INFINITY;\n         } else {\n-            ret = scale * FastMath.pow(-FastMath.log(1.0 - p), 1.0 / shape);\n+            ret = scale * FastMath.pow(-FastMath.log1p(-p), 1.0 / shape);\n         }\n         return ret;\n     }\ndiff --git a/src/main/java/org/apache/commons/math3/special/Beta.java b/src/main/java/org/apache/commons/math3/special/Beta.java\nindex 59f696a0b..c6091b48c 100644\n--- a/src/main/java/org/apache/commons/math3/special/Beta.java\n+++ b/src/main/java/org/apache/commons/math3/special/Beta.java\n@@ -218,7 +218,7 @@ protected double getA(int n, double x) {\n                     return 1.0;\n                 }\n             };\n-            ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) -\n+            ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log1p(-x)) -\n                 FastMath.log(a) - logBeta(a, b)) *\n                 1.0 / fraction.evaluate(x, epsilon, maxIterations);\n         }\n",
        "project": "commons-math",
        "linesAdd": 3,
        "jira_id": "1058",
        "nb_skipped": 4,
        "commit": "4ebd967c",
        "nb_failure": 3,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4795,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.stat.correlation.CovarianceTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/stat/correlation/Covariance.java b/src/main/java/org/apache/commons/math3/stat/correlation/Covariance.java\nindex ba62463c5..ace3205c0 100644\n--- a/src/main/java/org/apache/commons/math3/stat/correlation/Covariance.java\n+++ b/src/main/java/org/apache/commons/math3/stat/correlation/Covariance.java\n@@ -17,6 +17,7 @@\n package org.apache.commons.math3.stat.correlation;\n \n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.linear.RealMatrix;\n import org.apache.commons.math3.linear.BlockRealMatrix;\n@@ -70,16 +71,18 @@ public Covariance() {\n      * <p>The <code>biasCorrected</code> parameter determines whether or not\n      * covariance estimates are bias-corrected.</p>\n      *\n-     * <p>The input array must be rectangular with at least two columns\n+     * <p>The input array must be rectangular with at least one column\n      * and two rows.</p>\n      *\n      * @param data rectangular array with columns representing covariates\n      * @param biasCorrected true means covariances are bias-corrected\n      * @throws MathIllegalArgumentException if the input data array is not\n-     * rectangular with at least two rows and two columns.\n+     * rectangular with at least two rows and one column.\n+     * @throws NotStrictlyPositiveException if the input data array is not\n+     * rectangular with at least one row and one column.\n      */\n     public Covariance(double[][] data, boolean biasCorrected)\n-    throws MathIllegalArgumentException {\n+    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n         this(new BlockRealMatrix(data), biasCorrected);\n     }\n \n@@ -87,14 +90,17 @@ public Covariance(double[][] data, boolean biasCorrected)\n      * Create a Covariance matrix from a rectangular array\n      * whose columns represent covariates.\n      *\n-     * <p>The input array must be rectangular with at least two columns\n+     * <p>The input array must be rectangular with at least one column\n      * and two rows</p>\n      *\n      * @param data rectangular array with columns representing covariates\n      * @throws MathIllegalArgumentException if the input data array is not\n-     * rectangular with at least two rows and two columns.\n+     * rectangular with at least two rows and one column.\n+     * @throws NotStrictlyPositiveException if the input data array is not\n+     * rectangular with at least one row and one column.\n      */\n-    public Covariance(double[][] data) throws MathIllegalArgumentException {\n+    public Covariance(double[][] data)\n+    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n         this(data, true);\n     }\n \n@@ -105,12 +111,12 @@ public Covariance(double[][] data) throws MathIllegalArgumentException {\n      * <p>The <code>biasCorrected</code> parameter determines whether or not\n      * covariance estimates are bias-corrected.</p>\n      *\n-     * <p>The matrix must have at least two columns and two rows</p>\n+     * <p>The matrix must have at least one column and two rows</p>\n      *\n      * @param matrix matrix with columns representing covariates\n      * @param biasCorrected true means covariances are bias-corrected\n      * @throws MathIllegalArgumentException if the input matrix does not have\n-     * at least two rows and two columns\n+     * at least two rows and one column\n      */\n     public Covariance(RealMatrix matrix, boolean biasCorrected)\n     throws MathIllegalArgumentException {\n@@ -123,11 +129,11 @@ public Covariance(RealMatrix matrix, boolean biasCorrected)\n      * Create a covariance matrix from a matrix whose columns\n      * represent covariates.\n      *\n-     * <p>The matrix must have at least two columns and two rows</p>\n+     * <p>The matrix must have at least one column and two rows</p>\n      *\n      * @param matrix matrix with columns representing covariates\n      * @throws MathIllegalArgumentException if the input matrix does not have\n-     * at least two rows and two columns\n+     * at least two rows and one column\n      */\n     public Covariance(RealMatrix matrix) throws MathIllegalArgumentException {\n         this(matrix, true);\n@@ -154,7 +160,7 @@ public int getN() {\n     /**\n      * Compute a covariance matrix from a matrix whose columns represent\n      * covariates.\n-     * @param matrix input matrix (must have at least two columns and two rows)\n+     * @param matrix input matrix (must have at least one column and two rows)\n      * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n      * @return covariance matrix\n      * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\n@@ -178,7 +184,7 @@ protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorr\n     /**\n      * Create a covariance matrix from a matrix whose columns represent\n      * covariates. Covariances are computed using the bias-corrected formula.\n-     * @param matrix input matrix (must have at least two columns and two rows)\n+     * @param matrix input matrix (must have at least one column and two rows)\n      * @return covariance matrix\n      * @throws MathIllegalArgumentException if matrix does not contain sufficient data\n      * @see #Covariance\n@@ -191,26 +197,31 @@ protected RealMatrix computeCovarianceMatrix(RealMatrix matrix)\n     /**\n      * Compute a covariance matrix from a rectangular array whose columns represent\n      * covariates.\n-     * @param data input array (must have at least two columns and two rows)\n+     * @param data input array (must have at least one column and two rows)\n      * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n      * @return covariance matrix\n      * @throws MathIllegalArgumentException if the data array does not contain sufficient\n      * data\n+     * @throws NotStrictlyPositiveException if the input data array is not\n+     * rectangular with at least one row and one column.\n      */\n     protected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected)\n-    throws MathIllegalArgumentException {\n+    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n         return computeCovarianceMatrix(new BlockRealMatrix(data), biasCorrected);\n     }\n \n     /**\n      * Create a covariance matrix from a rectangular array whose columns represent\n      * covariates. Covariances are computed using the bias-corrected formula.\n-     * @param data input array (must have at least two columns and two rows)\n+     * @param data input array (must have at least one column and two rows)\n      * @return covariance matrix\n      * @throws MathIllegalArgumentException if the data array does not contain sufficient data\n+     * @throws NotStrictlyPositiveException if the input data array is not\n+     * rectangular with at least one row and one column.\n      * @see #Covariance\n      */\n-    protected RealMatrix computeCovarianceMatrix(double[][] data) throws MathIllegalArgumentException {\n+    protected RealMatrix computeCovarianceMatrix(double[][] data)\n+    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n         return computeCovarianceMatrix(data, true);\n     }\n \n@@ -268,7 +279,7 @@ public double covariance(final double[] xArray, final double[] yArray)\n \n     /**\n      * Throws MathIllegalArgumentException if the matrix does not have at least\n-     * two columns and two rows.\n+     * one column and two rows.\n      * @param matrix matrix to check\n      * @throws MathIllegalArgumentException if the matrix does not contain sufficient data\n      * to compute covariance\n@@ -276,7 +287,7 @@ public double covariance(final double[] xArray, final double[] yArray)\n     private void checkSufficientData(final RealMatrix matrix) throws MathIllegalArgumentException {\n         int nRows = matrix.getRowDimension();\n         int nCols = matrix.getColumnDimension();\n-        if (nRows < 2 || nCols < 2) {\n+        if (nRows < 2 || nCols < 1) {\n             throw new MathIllegalArgumentException(\n                     LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS,\n                     nRows, nCols);\n",
        "project": "commons-math",
        "linesAdd": 8,
        "jira_id": "939",
        "nb_skipped": 4,
        "commit": "49444ee6",
        "nb_failure": 0,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3968,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.fraction.FractionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/fraction/Fraction.java b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\nindex f84218ebd..f81ff0a94 100644\n--- a/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n@@ -594,7 +594,7 @@ public Fraction divide(final int i) {\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+        return 100 * doubleValue();\n     }\n \n     /**\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "835",
        "nb_skipped": 4,
        "commit": "63a48705",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3209,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 13ced27d7..d2bbf6725 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -247,6 +247,15 @@ public void integrate(final ExpandableStatefulODE equations, final double t)\n         }\n \n         stepSize = hNew;\n+        if (forward) {\n+            if (stepStart + stepSize >= t) {\n+                stepSize = t - stepStart;\n+            }\n+        } else {\n+            if (stepStart + stepSize <= t) {\n+                stepSize = t - stepStart;\n+            }\n+        }\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {\n",
        "project": "commons-math",
        "linesAdd": 9,
        "jira_id": "727",
        "nb_skipped": 1,
        "commit": "d2777388",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 4501,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.fitting.PolynomialFitterTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java\nindex 789bc256d..aa3299aea 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java\n@@ -18,7 +18,7 @@\n \n import org.apache.commons.math3.optim.OptimizationData;\n import org.apache.commons.math3.linear.RealMatrix;\n-import org.apache.commons.math3.linear.MatrixUtils;\n+import org.apache.commons.math3.linear.DiagonalMatrix;\n import org.apache.commons.math3.linear.NonSquareMatrixException;\n \n /**\n@@ -40,10 +40,7 @@\n      */\n     public Weight(double[] weight) {\n         final int dim = weight.length;\n-        weightMatrix = MatrixUtils.createRealMatrix(dim, dim);\n-        for (int i = 0; i < dim; i++) {\n-            weightMatrix.setEntry(i, i, weight[i]);\n-        }\n+        weightMatrix = new DiagonalMatrix(weight);\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\nindex b7bb6f575..ef5294324 100644\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java\n@@ -20,6 +20,7 @@\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n import org.apache.commons.math3.linear.ArrayRealVector;\n import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.linear.DiagonalMatrix;\n import org.apache.commons.math3.linear.DecompositionSolver;\n import org.apache.commons.math3.linear.MatrixUtils;\n import org.apache.commons.math3.linear.QRDecomposition;\n@@ -263,7 +264,16 @@ private void parseOptimizationData(OptimizationData... optData) {\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n+        if (m instanceof DiagonalMatrix) {\n+            final int dim = m.getRowDimension();\n+            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n+            for (int i = 0; i < dim; i++) {\n+                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n+            }\n+            return sqrtM;\n+        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n         }\n     }\n+}\n",
        "project": "commons-math",
        "linesAdd": 12,
        "jira_id": "924",
        "nb_skipped": 4,
        "commit": "b07ecae3",
        "nb_failure": 0,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 4049,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.optimization.fitting.HarmonicFitterTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java b/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\nindex 1ca563575..04edd0b46 100644\n--- a/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\n@@ -344,7 +344,7 @@\n     WRONG_BLOCK_LENGTH(\"wrong array shape (block length = {0}, expected {1})\"),\n     WRONG_NUMBER_OF_POINTS(\"{0} points are required, got only {1}\"),\n     NUMBER_OF_POINTS(\"number of points ({0})\"), /* keep */\n-    ZERO_DENOMINATOR(\"denominator must be different from 0\"),\n+    ZERO_DENOMINATOR(\"denominator must be different from 0\"), /* keep */\n     ZERO_DENOMINATOR_IN_FRACTION(\"zero denominator in fraction {0}/{1}\"),\n     ZERO_FRACTION_TO_DIVIDE_BY(\"the fraction to divide by must not be zero: {0}/{1}\"),\n     ZERO_NORM(\"zero norm\"),\ndiff --git a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\nindex ebb36d310..c7af9ae56 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n@@ -21,6 +21,7 @@\n import org.apache.commons.math3.analysis.function.HarmonicOscillator;\n import org.apache.commons.math3.exception.ZeroException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.exception.MathIllegalStateException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n \n@@ -250,6 +251,8 @@ private void sortObservations() {\n          * has been called previously.\n          *\n          * @throws ZeroException if the abscissa range is zero.\n+         * @throws MathIllegalStateException when the guessing procedure cannot\n+         * produce sensible results.\n          */\n         private void guessAOmega() {\n             // initialize the sums for the linear model between the two integrals\n@@ -317,6 +320,12 @@ private void guessAOmega() {\n                 }\n                 a = 0.5 * (yMax - yMin);\n             } else {\n+                if (c2 == 0) {\n+                    // In some ill-conditioned cases (cf. MATH-844), the guesser\n+                    // procedure cannot produce sensible results.\n+                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);\n+                }\n+\n                 a = FastMath.sqrt(c1 / c2);\n                 omega = FastMath.sqrt(c2 / c3);\n             }\n",
        "project": "commons-math",
        "linesAdd": 6,
        "jira_id": "844",
        "nb_skipped": 4,
        "commit": "7994d3ee",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3524,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.optimization.linear.SimplexSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\nindex 9a6993a55..327b2ae65 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n@@ -335,7 +335,7 @@ protected void dropPhase1Objective() {\n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+            if (Precision.compareTo(entry, 0d, epsilon) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "781",
        "nb_skipped": 1,
        "commit": "3c4cb189",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 2,
        "nb_test": 5808,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.optim.linear.SimplexSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/optim/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math4/optim/linear/SimplexSolver.java\nindex d4b4259f7..743fe9bc3 100644\n--- a/src/main/java/org/apache/commons/math4/optim/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math4/optim/linear/SimplexSolver.java\n@@ -19,6 +19,7 @@\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.apache.commons.math4.exception.DimensionMismatchException;\n import org.apache.commons.math4.exception.TooManyIterationsException;\n import org.apache.commons.math4.optim.OptimizationData;\n import org.apache.commons.math4.optim.PointValuePair;\n@@ -146,6 +147,8 @@ public SimplexSolver(final double epsilon, final int maxUlps, final double cutOf\n      *\n      * @return {@inheritDoc}\n      * @throws TooManyIterationsException if the maximal number of iterations is exceeded.\n+     * @throws DimensionMismatchException if the dimension of the constraints does not match the\n+     *   dimension of the objective function\n      */\n     @Override\n     public PointValuePair optimize(OptimizationData... optData)\ndiff --git a/src/main/java/org/apache/commons/math4/optim/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math4/optim/linear/SimplexTableau.java\nindex e869a7489..f0a842f16 100644\n--- a/src/main/java/org/apache/commons/math4/optim/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math4/optim/linear/SimplexTableau.java\n@@ -28,6 +28,7 @@\n import java.util.Set;\n import java.util.TreeSet;\n \n+import org.apache.commons.math4.exception.DimensionMismatchException;\n import org.apache.commons.math4.linear.Array2DRowRealMatrix;\n import org.apache.commons.math4.linear.MatrixUtils;\n import org.apache.commons.math4.linear.RealVector;\n@@ -112,6 +113,8 @@\n      * or {@link GoalType#MINIMIZE}.\n      * @param restrictToNonNegative Whether to restrict the variables to non-negative values.\n      * @param epsilon Amount of error to accept when checking for optimality.\n+     * @throws DimensionMismatchException if the dimension of the constraints does not match the\n+     *   dimension of the objective function\n      */\n     SimplexTableau(final LinearObjectiveFunction f,\n                    final Collection<LinearConstraint> constraints,\n@@ -129,13 +132,16 @@\n      * @param restrictToNonNegative whether to restrict the variables to non-negative values\n      * @param epsilon amount of error to accept when checking for optimality\n      * @param maxUlps amount of error to accept in floating point comparisons\n+     * @throws DimensionMismatchException if the dimension of the constraints does not match the\n+     *   dimension of the objective function\n      */\n     SimplexTableau(final LinearObjectiveFunction f,\n                    final Collection<LinearConstraint> constraints,\n                    final GoalType goalType,\n                    final boolean restrictToNonNegative,\n                    final double epsilon,\n-                   final int maxUlps) {\n+                   final int maxUlps) throws DimensionMismatchException {\n+        checkDimensions(f, constraints);\n         this.f                      = f;\n         this.constraints            = normalizeConstraints(constraints);\n         this.restrictToNonNegative  = restrictToNonNegative;\n@@ -153,6 +159,23 @@\n         initializeColumnLabels();\n     }\n \n+    /**\n+     * Checks that the dimensions of the objective function and the constraints match.\n+     * @param f the objective function\n+     * @param constraints the set of constraints\n+     * @throws DimensionMismatchException if the constraint dimensions do not match with the\n+     *   dimension of the objective function\n+     */\n+    private void checkDimensions(final LinearObjectiveFunction f,\n+                                 final Collection<LinearConstraint> constraints) {\n+        final int dimension = f.getCoefficients().getDimension();\n+        for (final LinearConstraint constraint : constraints) {\n+            final int constraintDimension = constraint.getCoefficients().getDimension();\n+            if (constraintDimension != dimension) {\n+                throw new DimensionMismatchException(constraintDimension, dimension);\n+            }\n+        }\n+    }\n     /**\n      * Initialize the labels for the columns.\n      */\n",
        "project": "commons-math",
        "linesAdd": 14,
        "jira_id": "1230",
        "nb_skipped": 3,
        "commit": "96eb80ef",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3508,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.genetics.ListPopulationTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\nindex 8fe3ffe71..3f3919cb6 100644\n--- a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n@@ -200,11 +200,12 @@ public String toString() {\n     }\n \n     /**\n-     * Chromosome list iterator\n+     * Returns an iterator over the unmodifiable list of chromosomes.\n+     * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+        return getChromosomes().iterator();\n     }\n }\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "779",
        "nb_skipped": 1,
        "commit": "ebadb558",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 2,
        "nb_test": 2124,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.linear.SingularValueSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java b/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\nindex 5f91636e6..bbb205736 100644\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n@@ -24,9 +24,17 @@\n  * Singular Value Decomposition of a real matrix.\n  * <p>The Singular Value Decomposition of matrix A is a set of three matrices:\n  * U, &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>.\n- * Let A be an m &times; n matrix, then U is an m &times; n orthogonal matrix,\n- * &Sigma; is a n &times; n diagonal matrix with positive diagonal elements,\n- * and V is an n &times; n orthogonal matrix.</p>\n+ * Let A be a m &times; n matrix, then U is a m &times; p orthogonal matrix,\n+ * &Sigma; is a p &times; p diagonal matrix with positive diagonal elements,\n+ * V is a n &times; p orthogonal matrix (hence V<sup>T</sup> is a p &times; n\n+ * orthogonal matrix). The size p depends on the chosen algorithm:\n+ * <ul>\n+ *   <li>for full SVD, p is n,</li>\n+ *   <li>for compact SVD, p is the rank r of the matrix\n+ *       (i. e. the number of positive singular values),</li>\n+ *   <li>for truncated SVD p is min(r, t) where t is user-specified.</li>\n+ * </ul>\n+ * </p>\n  * <p>This interface is similar to the class with similar name from the\n  * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n  * following changes:</p>\ndiff --git a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\nindex 0da87ab2a..6003ed677 100644\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n@@ -21,12 +21,24 @@\n import org.apache.commons.math.util.MathUtils;\n \n /**\n- * Calculates the Singular Value Decomposition of a matrix.\n+ * Calculates the compact or truncated Singular Value Decomposition of a matrix.\n  * <p>The Singular Value Decomposition of matrix A is a set of three matrices:\n  * U, &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>.\n- * Let A be an m &times; n matrix, then U is an m &times; n orthogonal matrix,\n- * &Sigma; is a n &times; n diagonal matrix with positive diagonal elements,\n- * and V is an n &times; n orthogonal matrix.</p>\n+ * Let A be a m &times; n matrix, then U is a m &times; p orthogonal matrix,\n+ * &Sigma; is a p &times; p diagonal matrix with positive diagonal elements,\n+ * V is a n &times; p orthogonal matrix (hence V<sup>T</sup> is a p &times; n\n+ * orthogonal matrix). The size p depends on the chosen algorithm:\n+ * <ul>\n+ *   <li>for full SVD, p would be n, but this is not supported by this implementation,</li>\n+ *   <li>for compact SVD, p is the rank r of the matrix\n+ *       (i. e. the number of positive singular values),</li>\n+ *   <li>for truncated SVD p is min(r, t) where t is user-specified.</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * Note that since this class computes only the compact or truncated SVD and not\n+ * the full SVD, the singular values computed are always positive.\n+ * </p>\n  *\n  * @version $Revision$ $Date$\n  * @since 2.0\n@@ -75,13 +87,25 @@\n     /** Cached value of V<sup>T</sup>. */\n     private RealMatrix cachedVt;\n \n+    /**\n+     * Calculates the compact Singular Value Decomposition of the given matrix.\n+     * @param matrix The matrix to decompose.\n+     * @exception InvalidMatrixException (wrapping a {@link\n+     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n+     */\n+    public SingularValueDecompositionImpl(final RealMatrix matrix)\n+        throws InvalidMatrixException {\n+        this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));\n+    }\n+\n     /**\n      * Calculates the Singular Value Decomposition of the given matrix.\n      * @param matrix The matrix to decompose.\n+     * @param max maximal number of singular values to compute\n      * @exception InvalidMatrixException (wrapping a {@link\n      * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n      */\n-    public SingularValueDecompositionImpl(RealMatrix matrix)\n+    public SingularValueDecompositionImpl(final RealMatrix matrix, final int max)\n         throws InvalidMatrixException {\n \n         m = matrix.getRowDimension();\n@@ -113,10 +137,14 @@ public SingularValueDecompositionImpl(RealMatrix matrix)\n         eigenDecomposition =\n             new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal,\n                                        MathUtils.SAFE_MIN);\n-        singularValues = eigenDecomposition.getRealEigenvalues();\n-        for (int i = 0; i < singularValues.length; ++i) {\n-            final double si = singularValues[i];\n-            singularValues[i] = (si < 0) ? 0.0 : Math.sqrt(si);\n+        final double[] eigenValues = eigenDecomposition.getRealEigenvalues();\n+        int p = Math.min(max, eigenValues.length);\n+        while ((p > 0) && (eigenValues[p - 1] <= 0)) {\n+            --p;\n+        }\n+        singularValues = new double[p];\n+        for (int i = 0; i < p; ++i) {\n+            singularValues[i] = Math.sqrt(eigenValues[i]);\n         }\n \n     }\n@@ -127,37 +155,41 @@ public RealMatrix getU()\n \n         if (cachedU == null) {\n \n+            final int p = singularValues.length;\n             if (m >= n) {\n                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n-                final double[][] eData = eigenDecomposition.getV().getData();\n-                final double[][] iData = new double[m][];\n+                final RealMatrix e =\n+                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n+                final double[][] eData = e.getData();\n+                final double[][] wData = new double[m][p];\n                 double[] ei1 = eData[0];\n-                iData[0] = ei1;\n-                for (int i = 0; i < n - 1; ++i) {\n-                    // compute B.E.S^(-1) where E is the eigenvectors matrix\n-                    // we reuse the array from matrix E to store the result\n+                for (int i = 0; i < p - 1; ++i) {\n+                    // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                     final double mi = mainBidiagonal[i];\n                     final double si = secondaryBidiagonal[i];\n                     final double[] ei0 = ei1;\n+                    final double[] wi  = wData[i];\n                     ei1 = eData[i + 1];\n-                    iData[i + 1] = ei1;\n-                    for (int j = 0; j < n; ++j) {\n-                        ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n+                    for (int j = 0; j < p; ++j) {\n+                        wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                     }\n                 }\n                 // last row\n-                final double lastMain = mainBidiagonal[n - 1];\n-                for (int j = 0; j < n; ++j) {\n-                    ei1[j] *= lastMain / singularValues[j];\n+                final double lastMain = mainBidiagonal[p - 1];\n+                final double[] wr1  = wData[p - 1];\n+                for (int j = 0; j < p; ++j) {\n+                    wr1[j] = ei1[j] * lastMain / singularValues[j];\n                 }\n-                for (int i = n; i < m; ++i) {\n-                    iData[i] = new double[n];\n+                for (int i = p; i < m; ++i) {\n+                    wData[i] = new double[p];\n                 }\n                 cachedU =\n-                    transformer.getU().multiply(MatrixUtils.createRealMatrix(iData));\n+                    transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n             } else {\n                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n-                cachedU = transformer.getU().multiply(eigenDecomposition.getV());\n+                final RealMatrix e =\n+                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n+                cachedU = transformer.getU().multiply(e);\n             }\n \n         }\n@@ -205,37 +237,41 @@ public RealMatrix getV()\n \n         if (cachedV == null) {\n \n+            final int p = singularValues.length;\n             if (m >= n) {\n                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n-                cachedV = transformer.getV().multiply(eigenDecomposition.getV());\n+                final RealMatrix e =\n+                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n+                cachedV = transformer.getV().multiply(e);\n             } else {\n                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n-                final double[][] eData = eigenDecomposition.getV().getData();\n-                final double[][] iData = new double[n][];\n+                // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n+                final RealMatrix e =\n+                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n+                final double[][] eData = e.getData();\n+                final double[][] wData = new double[n][p];\n                 double[] ei1 = eData[0];\n-                iData[0] = ei1;\n-                for (int i = 0; i < m - 1; ++i) {\n-                    // compute Bt.E.S^(-1) where E is the eigenvectors matrix\n-                    // we reuse the array from matrix E to store the result\n+                for (int i = 0; i < p - 1; ++i) {\n                     final double mi = mainBidiagonal[i];\n                     final double si = secondaryBidiagonal[i];\n                     final double[] ei0 = ei1;\n+                    final double[] wi  = wData[i];\n                     ei1 = eData[i + 1];\n-                    iData[i + 1] = ei1;\n-                    for (int j = 0; j < m; ++j) {\n-                        ei0[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n+                    for (int j = 0; j < p; ++j) {\n+                        wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                     }\n                 }\n                 // last row\n-                final double lastMain = mainBidiagonal[m - 1];\n-                for (int j = 0; j < m; ++j) {\n-                    ei1[j] *= lastMain / singularValues[j];\n+                final double lastMain = mainBidiagonal[p - 1];\n+                final double[] wr1  = wData[p - 1];\n+                for (int j = 0; j < p; ++j) {\n+                    wr1[j] = ei1[j] * lastMain / singularValues[j];\n                 }\n-                for (int i = m; i < n; ++i) {\n-                    iData[i] = new double[m];\n+                for (int i = p; i < n; ++i) {\n+                    wData[i] = new double[p];\n                 }\n                 cachedV =\n-                    transformer.getV().multiply(MatrixUtils.createRealMatrix(iData));\n+                    transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\n             }\n \n         }\n@@ -262,8 +298,9 @@ public RealMatrix getVT()\n     public RealMatrix getCovariance(final double minSingularValue) {\n \n         // get the number of singular values to consider\n+        final int p = singularValues.length;\n         int dimension = 0;\n-        while ((dimension < n) && (singularValues[dimension] >= minSingularValue)) {\n+        while ((dimension < p) && (singularValues[dimension] >= minSingularValue)) {\n             ++dimension;\n         }\n \n@@ -273,14 +310,14 @@ public RealMatrix getCovariance(final double minSingularValue) {\n                   minSingularValue, singularValues[0]);\n         }\n \n-        final double[][] data = new double[dimension][n];\n+        final double[][] data = new double[dimension][p];\n         getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n             /** {@inheritDoc} */\n             @Override\n             public void visit(final int row, final int column, final double value) {\n                 data[row][column] = value / singularValues[row];\n             }\n-        }, 0, dimension - 1, 0, n - 1);\n+        }, 0, dimension - 1, 0, p - 1);\n \n         RealMatrix jv = new Array2DRowRealMatrix(data, false);\n         return jv.transpose().multiply(jv);\n@@ -317,20 +354,14 @@ public int getRank()\n     /** {@inheritDoc} */\n     public DecompositionSolver getSolver() {\n         return new Solver(singularValues, getUT(), getV(),\n-                          getRank() == singularValues.length);\n+                          getRank() == Math.max(m, n));\n     }\n \n     /** Specialized solver. */\n     private static class Solver implements DecompositionSolver {\n \n-        /** Singular values. */\n-        private final double[] singularValues;\n-\n-        /** U<sup>T</sup> matrix of the decomposition. */\n-        private final RealMatrix uT;\n-\n-        /** V matrix of the decomposition. */\n-        private final RealMatrix v;\n+        /** Pseudo-inverse of the initial matrix. */\n+        private final RealMatrix pseudoInverse;\n \n         /** Singularity indicator. */\n         private boolean nonSingular;\n@@ -344,9 +375,15 @@ public DecompositionSolver getSolver() {\n          */\n         private Solver(final double[] singularValues, final RealMatrix uT, final RealMatrix v,\n                        final boolean nonSingular) {\n-            this.singularValues = singularValues;\n-            this.uT             = uT;\n-            this.v              = v;\n+            double[][] suT      = uT.getData();\n+            for (int i = 0; i < singularValues.length; ++i) {\n+                final double a      = 1.0 / singularValues[i];\n+                final double[] suTi = suT[i];\n+                for (int j = 0; j < suTi.length; ++j) {\n+                    suTi[j] *= a;\n+                }\n+            }\n+            pseudoInverse    = v.multiply(new Array2DRowRealMatrix(suT, false));\n             this.nonSingular = nonSingular;\n         }\n \n@@ -356,27 +393,10 @@ private Solver(final double[] singularValues, final RealMatrix uT, final RealMat\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a vector X that minimizes the two norm of A &times; X - B\n          * @exception IllegalArgumentException if matrices dimensions don't match\n-         * @exception InvalidMatrixException if decomposed matrix is singular\n          */\n         public double[] solve(final double[] b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n-\n-            if (b.length != uT.getColumnDimension()) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\",\n-                        b.length, uT.getColumnDimension());\n-            }\n-\n-            final double[] w = uT.operate(b);\n-            for (int i = 0; i < singularValues.length; ++i) {\n-                final double si = singularValues[i];\n-                if (si == 0) {\n-                    throw new SingularMatrixException();\n-                }\n-                w[i] /= si;\n-            }\n-            return v.operate(w);\n-\n+            throws IllegalArgumentException {\n+            return pseudoInverse.operate(b);\n         }\n \n         /** Solve the linear equation A &times; X = B in least square sense.\n@@ -385,27 +405,10 @@ private Solver(final double[] singularValues, final RealMatrix uT, final RealMat\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a vector X that minimizes the two norm of A &times; X - B\n          * @exception IllegalArgumentException if matrices dimensions don't match\n-         * @exception InvalidMatrixException if decomposed matrix is singular\n          */\n         public RealVector solve(final RealVector b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n-\n-            if (b.getDimension() != uT.getColumnDimension()) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        \"vector length mismatch: got {0} but expected {1}\",\n-                         b.getDimension(), uT.getColumnDimension());\n-            }\n-\n-            final RealVector w = uT.operate(b);\n-            for (int i = 0; i < singularValues.length; ++i) {\n-                final double si = singularValues[i];\n-                if (si == 0) {\n-                    throw new SingularMatrixException();\n-                }\n-                w.setEntry(i, w.getEntry(i) / si);\n-            }\n-            return v.operate(w);\n-\n+            throws IllegalArgumentException {\n+            return pseudoInverse.operate(b);\n         }\n \n         /** Solve the linear equation A &times; X = B in least square sense.\n@@ -414,31 +417,10 @@ public RealVector solve(final RealVector b)\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a matrix X that minimizes the two norm of A &times; X - B\n          * @exception IllegalArgumentException if matrices dimensions don't match\n-         * @exception InvalidMatrixException if decomposed matrix is singular\n          */\n         public RealMatrix solve(final RealMatrix b)\n-            throws IllegalArgumentException, InvalidMatrixException {\n-\n-            if (b.getRowDimension() != singularValues.length) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n-                        b.getRowDimension(), b.getColumnDimension(),\n-                        singularValues.length, \"n\");\n-            }\n-\n-            final RealMatrix w = uT.multiply(b);\n-            for (int i = 0; i < singularValues.length; ++i) {\n-                final double si  = singularValues[i];\n-                if (si == 0) {\n-                    throw new SingularMatrixException();\n-                }\n-                final double inv = 1.0 / si;\n-                for (int j = 0; j < b.getColumnDimension(); ++j) {\n-                    w.multiplyEntry(i, j, inv);\n-                }\n-            }\n-            return v.multiply(w);\n-\n+            throws IllegalArgumentException {\n+            return pseudoInverse.multiply(b);\n         }\n \n         /**\n@@ -451,17 +433,9 @@ public boolean isNonSingular() {\n \n         /** Get the pseudo-inverse of the decomposed matrix.\n          * @return inverse matrix\n-         * @throws InvalidMatrixException if decomposed matrix is singular\n          */\n-        public RealMatrix getInverse()\n-            throws InvalidMatrixException {\n-\n-            if (!isNonSingular()) {\n-                throw new SingularMatrixException();\n-            }\n-\n-            return solve(MatrixUtils.createRealIdentityMatrix(singularValues.length));\n-\n+        public RealMatrix getInverse() {\n+            return pseudoInverse;\n         }\n \n     }\n",
        "project": "commons-math",
        "linesAdd": 75,
        "jira_id": "320",
        "nb_skipped": 0,
        "commit": "c06cc933",
        "nb_failure": 2,
        "linesRem": 112,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2495,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.complex.ComplexTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex e0a8e97e9..ab58c78d4 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -150,6 +150,9 @@ public double abs() {\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n+        if (isNaN || rhs.isNaN) {\n+            return NaN;\n+        }\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }\n",
        "project": "commons-math",
        "linesAdd": 3,
        "jira_id": "618",
        "nb_skipped": 1,
        "commit": "2123f780",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4083,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.optimization.univariate.BrentOptimizerTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\nindex ee2227cdb..cff5bfd33 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -85,7 +86,7 @@ public BrentOptimizer(double rel,\n     }\n \n     /**\n-     * The arguments are used implement the original stopping criterion\n+     * The arguments are used for implementing the original stopping criterion\n      * of Brent's algorithm.\n      * {@code abs} and {@code rel} define a tolerance\n      * {@code tol = rel |x| + abs}. {@code rel} should be no smaller than\n@@ -226,7 +227,7 @@ protected UnivariatePointValuePair doOptimize() {\n \n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n-                        return current;\n+                        return best(current, previous, isMinim);\n                     }\n                 }\n \n@@ -263,9 +264,36 @@ protected UnivariatePointValuePair doOptimize() {\n                     }\n                 }\n             } else { // Default termination (Brent's criterion).\n-                return current;\n+                return best(current, previous, isMinim);\n             }\n             ++iter;\n         }\n     }\n+\n+    /**\n+     * Selects the best of two points.\n+     *\n+     * @param a Point and value.\n+     * @param b Point and value.\n+     * @param isMinim {@code true} if the selected point must be the one with\n+     * the lowest value.\n+     * @return the best point, or {@code null} if {@code a} and {@code b} are\n+     * both {@code null}.\n+     */\n+    private UnivariatePointValuePair best(UnivariatePointValuePair a,\n+                                          UnivariatePointValuePair b,\n+                                          boolean isMinim) {\n+        if (a == null) {\n+            return b;\n+        }\n+        if (b == null) {\n+            return a;\n+        }\n+\n+        if (isMinim) {\n+            return a.getValue() < b.getValue() ? a : b;\n+        } else {\n+            return a.getValue() > b.getValue() ? a : b;\n+        }\n+    }\n }\n",
        "project": "commons-math",
        "linesAdd": 19,
        "jira_id": "855",
        "nb_skipped": 4,
        "commit": "350f726c",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 4,
        "nb_test": 2272,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.stat.StatUtilsTest",
            "org.apache.commons.math.stat.descriptive.summary.ProductTest",
            "org.apache.commons.math.stat.descriptive.summary.SumTest",
            "org.apache.commons.math.stat.descriptive.summary.SumLogTest",
            "org.apache.commons.math.stat.descriptive.summary.SumSqTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\nindex da6e3809d..f9796b458 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n@@ -25,7 +25,8 @@\n /**\n  * Returns the product of the available values.\n  * <p>\n- * If there are no values in the dataset, or any of the values are\n+ * If there are no values in the dataset, then 1 is returned.\n+ *  If any of the values are\n  * <code>NaN</code>, then <code>NaN</code> is returned.</p>\n  * <p>\n  * <strong>Note that this implementation is not synchronized.</strong> If\n@@ -53,7 +54,7 @@\n      */\n     public Product() {\n         n = 0;\n-        value = Double.NaN;\n+        value = 1;\n     }\n \n     /**\n@@ -71,11 +72,7 @@ public Product(Product original) {\n      */\n     @Override\n     public void increment(final double d) {\n-        if (n == 0) {\n-            value = d;\n-        } else {\n         value *= d;\n-        }\n         n++;\n     }\n \n@@ -99,7 +96,7 @@ public long getN() {\n      */\n     @Override\n     public void clear() {\n-        value = Double.NaN;\n+        value = 1;\n         n = 0;\n     }\n \n@@ -113,14 +110,14 @@ public void clear() {\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the product of the values or Double.NaN if length = 0\n+     * @return the product of the values or 1 if length = 0\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     @Override\n     public double evaluate(final double[] values, final int begin, final int length) {\n         double product = Double.NaN;\n-        if (test(values, begin, length)) {\n+        if (test(values, begin, length, true)) {\n             product = 1.0;\n             for (int i = begin; i < begin + length; i++) {\n                 product *= values[i];\n@@ -153,14 +150,14 @@ public double evaluate(final double[] values, final int begin, final int length)\n      * @param weights the weights array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the product of the values or Double.NaN if length = 0\n+     * @return the product of the values or 1 if length = 0\n      * @throws IllegalArgumentException if the parameters are not valid\n      * @since 2.1\n      */\n     public double evaluate(final double[] values, final double[] weights,\n                            final int begin, final int length) {\n         double product = Double.NaN;\n-        if (test(values, weights, begin, length)) {\n+        if (test(values, weights, begin, length, true)) {\n             product = 1.0;\n             for (int i = begin; i < begin + length; i++) {\n                 product *= FastMath.pow(values[i], weights[i]);\ndiff --git a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\nindex 2b0fd9b75..3543575de 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n@@ -24,7 +24,8 @@\n /**\n   * Returns the sum of the available values.\n  * <p>\n- * If there are no values in the dataset, or any of the values are\n+ * If there are no values in the dataset, then 0 is returned. \n+ * If any of the values are\n  * <code>NaN</code>, then <code>NaN</code> is returned.</p>\n  * <p>\n  * <strong>Note that this implementation is not synchronized.</strong> If\n@@ -52,7 +53,7 @@\n      */\n     public Sum() {\n         n = 0;\n-        value = Double.NaN;\n+        value = 0;\n     }\n \n     /**\n@@ -70,11 +71,7 @@ public Sum(Sum original) {\n      */\n     @Override\n     public void increment(final double d) {\n-        if (n == 0) {\n-            value = d;\n-        } else {\n         value += d;\n-        }\n         n++;\n     }\n \n@@ -98,13 +95,13 @@ public long getN() {\n      */\n     @Override\n     public void clear() {\n-        value = Double.NaN;\n+        value = 0;\n         n = 0;\n     }\n \n     /**\n      * The sum of the entries in the specified portion of\n-     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * the input array, or 0 if the designated subarray\n      * is empty.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n@@ -112,14 +109,14 @@ public void clear() {\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the sum of the values or Double.NaN if length = 0\n+     * @return the sum of the values or 0 if length = 0\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     @Override\n     public double evaluate(final double[] values, final int begin, final int length) {\n         double sum = Double.NaN;\n-        if (test(values, begin, length)) {\n+        if (test(values, begin, length, true)) {\n             sum = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n                 sum += values[i];\n@@ -130,7 +127,7 @@ public double evaluate(final double[] values, final int begin, final int length)\n \n     /**\n      * The weighted sum of the entries in the specified portion of\n-     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * the input array, or 0 if the designated subarray\n      * is empty.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if any of the following are true:\n@@ -151,14 +148,14 @@ public double evaluate(final double[] values, final int begin, final int length)\n      * @param weights the weights array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the sum of the values or Double.NaN if length = 0\n+     * @return the sum of the values or 0 if length = 0\n      * @throws IllegalArgumentException if the parameters are not valid\n      * @since 2.1\n      */\n     public double evaluate(final double[] values, final double[] weights,\n                            final int begin, final int length) {\n         double sum = Double.NaN;\n-        if (test(values, weights, begin, length)) {\n+        if (test(values, weights, begin, length, true)) {\n             sum = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n                 sum += values[i] * weights[i];\ndiff --git a/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java b/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\nindex b4280cc82..24960e3d4 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n@@ -24,7 +24,7 @@\n /**\n  * Returns the sum of the natural logs for this collection of values.\n  * <p>\n- * Uses {@link java.lang.Math#log(double)} to compute the logs.  Therefore,\n+ * Uses {@link org.apache.commons.Math.util.FastMath#log(double)} to compute the logs.  Therefore,\n  * <ul>\n  * <li>If any of values are < 0, the result is <code>NaN.</code></li>\n  * <li>If all values are non-negative and less than\n@@ -87,11 +87,7 @@ public void increment(final double d) {\n      */\n     @Override\n     public double getResult() {\n-        if (n > 0) {\n         return value;\n-        } else {\n-            return Double.NaN;\n-        }\n     }\n \n     /**\n@@ -122,7 +118,7 @@ public void clear() {\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the sum of the natural logs of the values or Double.NaN if\n+     * @return the sum of the natural logs of the values or 0 if\n      * length = 0\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n@@ -130,7 +126,7 @@ public void clear() {\n     @Override\n     public double evaluate(final double[] values, final int begin, final int length) {\n         double sumLog = Double.NaN;\n-        if (test(values, begin, length)) {\n+        if (test(values, begin, length, true)) {\n             sumLog = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n                 sumLog += FastMath.log(values[i]);\ndiff --git a/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java b/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\nindex a1429f974..36a216817 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n@@ -23,7 +23,8 @@\n /**\n  * Returns the sum of the squares of the available values.\n  * <p>\n- * If there are no values in the dataset, or any of the values are\n+ * If there are no values in the dataset, then 0 is returned.\n+ * If any of the values are\n  * <code>NaN</code>, then <code>NaN</code> is returned.</p>\n  * <p>\n  * <strong>Note that this implementation is not synchronized.</strong> If\n@@ -51,7 +52,7 @@\n      */\n     public SumOfSquares() {\n         n = 0;\n-        value = Double.NaN;\n+        value = 0;\n     }\n \n     /**\n@@ -69,11 +70,7 @@ public SumOfSquares(SumOfSquares original) {\n      */\n     @Override\n     public void increment(final double d) {\n-        if (n == 0) {\n-            value = d * d;\n-        } else {\n         value += d * d;\n-        }\n         n++;\n     }\n \n@@ -97,7 +94,7 @@ public long getN() {\n      */\n     @Override\n     public void clear() {\n-        value = Double.NaN;\n+        value = 0;\n         n = 0;\n     }\n \n@@ -111,14 +108,14 @@ public void clear() {\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the sum of the squares of the values or Double.NaN if length = 0\n+     * @return the sum of the squares of the values or 0 if length = 0\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n     @Override\n     public double evaluate(final double[] values,final int begin, final int length) {\n         double sumSq = Double.NaN;\n-        if (test(values, begin, length)) {\n+        if (test(values, begin, length, true)) {\n             sumSq = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n                 sumSq += values[i] * values[i];\n",
        "project": "commons-math",
        "linesAdd": 12,
        "jira_id": "373",
        "nb_skipped": 0,
        "commit": "bfe4623c",
        "nb_failure": 15,
        "linesRem": 28,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2087,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.linear.EigenDecompositionImplTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 3fc328d8b..9d1b797be 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1132,7 +1132,7 @@ private int goodStep(final int start, final int end) {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * (n - 1);\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "318",
        "nb_skipped": 0,
        "commit": "83f18d52",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 2251,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.optimization.univariate.BrentOptimizerTest",
            "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java b/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java\nindex 883578b64..0c4eabeda 100644\n--- a/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java\n+++ b/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java\n@@ -139,14 +139,14 @@ protected void resetIterationsCounter() {\n     /**\n      * Increment the iterations counter by 1.\n      *\n-     * @throws OptimizationException if the maximal number\n+     * @throws MaxIterationsExceededException if the maximal number\n      * of iterations is exceeded.\n      * @since 2.2\n      */\n     protected void incrementIterationsCounter()\n-        throws ConvergenceException {\n+        throws MaxIterationsExceededException {\n         if (++iterationCount > maximalIterationCount) {\n-            throw new ConvergenceException(new MaxIterationsExceededException(maximalIterationCount));\n+            throw new MaxIterationsExceededException(maximalIterationCount);\n         }\n     }\n }\ndiff --git a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\nindex d312243bc..c6eeb53d0 100644\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n@@ -260,5 +260,6 @@ public double optimize(UnivariateRealFunction f, GoalType goal,\n      *\n      * @return the optimum.\n      */\n-    protected abstract double doOptimize();\n+    protected abstract double doOptimize()\n+        throws MaxIterationsExceededException, FunctionEvaluationException;\n }\ndiff --git a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\nindex 62f2fcb6a..46c4afae0 100644\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n@@ -41,39 +41,37 @@\n      * Construct a solver.\n      */\n     public BrentOptimizer() {\n-        super(100, 1E-10);\n+        setMaxEvaluations(1000);\n+        setMaximalIterationCount(100);\n+        setAbsoluteAccuracy(1e-11);\n+        setRelativeAccuracy(1e-9);\n     }\n \n-    /** {@inheritDoc} */\n-    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n-                           final double min, final double max, final double startValue)\n+    /**\n+     * Perform the optimization.\n+     *\n+     * @return the optimum.\n+     */\n+    protected double doOptimize()\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        clearResult();\n-        return localMin(f, goalType, min, startValue, max,\n+        return localMin(getGoalType() == GoalType.MINIMIZE,\n+                        getMin(), getStartValue(), getMax(),\n                         getRelativeAccuracy(), getAbsoluteAccuracy());\n     }\n \n-    /** {@inheritDoc} */\n-    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n-                           final double min, final double max)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n-    }\n-\n     /**\n-     * Find the minimum of the function {@code f} within the interval {@code (a, b)}.\n+     * Find the minimum of the function within the interval {@code (lo, hi)}.\n      *\n-     * If the function {@code f} is defined on the interval {@code (a, b)}, then\n-     * this method finds an approximation {@code x} to the point at which {@code f}\n-     * attains its minimum.<br/>\n-     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t} and\n-     * {@code f} is never evaluated at two points closer together than {@code tol}.\n-     * {@code eps} should be no smaller than <em>2 macheps</em> and preferable not\n-     * much less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative\n-     * machine precision. {@code t} should be positive.\n-     * @param f the function to solve.\n-     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n-     * or {@link GoalType#MINIMIZE}.\n+     * If the function is defined on the interval {@code (lo, hi)}, then\n+     * this method finds an approximation {@code x} to the point at which\n+     * the function attains its minimum.<br/>\n+     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t}\n+     * and the function is never evaluated at two points closer together than\n+     * {@code tol}. {@code eps} should be no smaller than <em>2 macheps</em> and\n+     * preferable not much less than <em>sqrt(macheps)</em>, where\n+     * <em>macheps</em> is the relative machine precision. {@code t} should be\n+     * positive.\n+     * @param isMinim {@code true} when minimizing the function.\n      * @param lo Lower bound of the interval.\n      * @param mid Point inside the interval {@code [lo, hi]}.\n      * @param hi Higher bound of the interval.\n@@ -85,8 +83,7 @@ public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n      * @throws FunctionEvaluationException if an error occurs evaluating\n      * the function.\n      */\n-    private double localMin(UnivariateRealFunction f,\n-                            GoalType goalType,\n+    private double localMin(boolean isMinim,\n                             double lo, double mid, double hi,\n                             double eps, double t)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n@@ -108,16 +105,16 @@ private double localMin(UnivariateRealFunction f,\n         double x = mid;\n         double v = x;\n         double w = x;\n+        double d = 0;\n         double e = 0;\n-        double fx = computeObjectiveValue(f, x);\n-        if (goalType == GoalType.MAXIMIZE) {\n+        double fx = computeObjectiveValue(x);\n+        if (!isMinim) {\n             fx = -fx;\n         }\n         double fv = fx;\n         double fw = fx;\n \n-        int count = 0;\n-        while (count < maximalIterationCount) {\n+        while (true) {\n             double m = 0.5 * (a + b);\n             final double tol1 = eps * Math.abs(x) + t;\n             final double tol2 = 2 * tol1;\n@@ -127,7 +124,6 @@ private double localMin(UnivariateRealFunction f,\n                 double p = 0;\n                 double q = 0;\n                 double r = 0;\n-                double d = 0;\n                 double u = 0;\n \n                 if (Math.abs(e) > tol1) { // Fit parabola.\n@@ -191,8 +187,8 @@ private double localMin(UnivariateRealFunction f,\n                     u = x + d;\n                 }\n \n-                double fu = computeObjectiveValue(f, u);\n-                if (goalType == GoalType.MAXIMIZE) {\n+                double fu = computeObjectiveValue(u);\n+                if (!isMinim) {\n                     fu = -fu;\n                 }\n \n@@ -229,16 +225,10 @@ private double localMin(UnivariateRealFunction f,\n                     }\n                 }\n             } else { // termination\n-                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n+                setFunctionValue(isMinim ? fx : -fx);\n                 return x;\n             }\n-            ++count;\n+            incrementIterationsCounter();\n         }\n-        throw new MaxIterationsExceededException(maximalIterationCount);\n-    }\n-\n-    /** Temporary workaround. */\n-    protected double doOptimize() {\n-        throw new UnsupportedOperationException();\n     }\n }\n",
        "project": "commons-math",
        "linesAdd": 20,
        "jira_id": "395",
        "nb_skipped": 0,
        "commit": "962315ba",
        "nb_failure": 4,
        "linesRem": 30,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 6075,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.geometry.euclidean.twod.hull.AklToussaintHeuristicTest",
            "org.apache.commons.math3.geometry.euclidean.twod.hull.MonotoneChainTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java\nindex 2ade7a69e..50fd6b752 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java\n@@ -160,9 +160,9 @@ private void updateHull(final Vector2D point, final List<Vector2D> hull) {\n                 } else {\n                     if (distanceToCurrent > distanceToLast) {\n                         hull.remove(size - 1);\n-                    }\n                         hull.add(point);\n                     }\n+                }\n                 return;\n             } else if (offset > 0) {\n                 hull.remove(size - 1);\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "1135",
        "nb_skipped": 3,
        "commit": "a7363a2a",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5821,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.util.ResizableDoubleArrayTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java b/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java\nindex 6377141a0..7d9547c0f 100644\n--- a/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math4/util/ResizableDoubleArray.java\n@@ -287,7 +287,7 @@ public ResizableDoubleArray(int initialCapacity,\n         numElements = 0;\n         startIndex = 0;\n \n-        if (data != null && data.length > 1) {\n+        if (data != null && data.length > 0) {\n             addElements(data);\n         }\n     }\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "1252",
        "nb_skipped": 3,
        "commit": "09fe956a",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 4901,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.ode.nonstiff.DormandPrince853IntegratorTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex 00827db20..6e0237f9f 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -338,11 +338,15 @@ public int compare(EventState es0, EventState es1) {\n                 interpolator.setSoftPreviousTime(previousT);\n                 interpolator.setSoftCurrentTime(eventT);\n \n-                // trigger the event\n+                // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n+\n+                // advance all event states to current time\n+                for (final EventState state : eventsStates) {\n+                    state.stepAccepted(eventT, eventY);\n+                    isLastStep = isLastStep || state.stop();\n+                }\n \n                 // handle the first part of the step, up to the event\n                 for (final StepHandler handler : stepHandlers) {\n@@ -352,21 +356,19 @@ public int compare(EventState es0, EventState es1) {\n                 if (isLastStep) {\n                     // the event asked to stop integration\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n                     return eventT;\n                 }\n \n-                if (currentEvent.reset(eventT, eventY)) {\n+                boolean needReset = false;\n+                for (final EventState state : eventsStates) {\n+                    needReset =  needReset || state.reset(eventT, eventY);\n+                }\n+                if (needReset) {\n                     // some event handler has triggered changes that\n                     // invalidate the derivatives, we need to recompute them\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n                     return eventT;\n                 }\n \n@@ -383,6 +385,7 @@ public int compare(EventState es0, EventState es1) {\n \n             }\n \n+            // last part of the step, after the last event\n             interpolator.setInterpolatedTime(currentT);\n             final double[] currentY = interpolator.getInterpolatedState();\n             for (final EventState state : eventsStates) {\n",
        "project": "commons-math",
        "linesAdd": 10,
        "jira_id": "950",
        "nb_skipped": 4,
        "commit": "424cbd20",
        "nb_failure": 1,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2354,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\nindex b73ac9d3e..e09bbc357 100644\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n@@ -172,7 +172,7 @@ public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy e\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+            double sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "546",
        "nb_skipped": 1,
        "commit": "b6bf8f41",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4261,
        "nb_error": 28,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.special.BetaTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/special/Beta.java b/src/main/java/org/apache/commons/math3/special/Beta.java\nindex 242079189..6e15fa380 100644\n--- a/src/main/java/org/apache/commons/math3/special/Beta.java\n+++ b/src/main/java/org/apache/commons/math3/special/Beta.java\n@@ -16,12 +16,38 @@\n  */\n package org.apache.commons.math3.special;\n \n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.util.ContinuedFraction;\n import org.apache.commons.math3.util.FastMath;\n \n /**\n+ * <p>\n  * This is a utility class that provides computation methods related to the\n  * Beta family of functions.\n+ * </p>\n+ * <p>\n+ * Implementation of {@link #logBeta(double, double)} is based on the\n+ * algorithms described in\n+ * <ul>\n+ * <li><a href=\"http://dx.doi.org/10.1145/22721.23109\">Didonato and Morris\n+ *     (1986)</a>, <em>Computation of the Incomplete Gamma Function Ratios\n+ *     and their Inverse</em>, TOMS 12(4), 377-393,</li>\n+ * <li><a href=\"http://dx.doi.org/10.1145/131766.131776\">Didonato and Morris\n+ *     (1992)</a>, <em>Algorithm 708: Significant Digit Computation of the\n+ *     Incomplete Beta Function Ratios</em>, TOMS 18(3), 360-373,</li>\n+ * </ul>\n+ * and implemented in the\n+ * <a href=\"http://www.dtic.mil/docs/citations/ADA476840\">NSWC Library of Mathematical Functions</a>,\n+ * available\n+ * <a href=\"http://www.ualberta.ca/CNS/RESEARCH/Software/NumericalNSWC/site.html\">here</a>.\n+ * This library is \"approved for public release\", and the\n+ * <a href=\"http://www.dtic.mil/dtic/pdf/announcements/CopyrightGuidance.pdf\">Copyright guidance</a>\n+ * indicates that unless otherwise stated in the code, all FORTRAN functions in\n+ * this library are license free. Since no such notice appears in the code these\n+ * functions can safely be ported to Commons-Math.\n+ * </p>\n+ *\n  *\n  * @version $Id$\n  */\n@@ -29,6 +55,47 @@\n     /** Maximum allowed numerical error. */\n     private static final double DEFAULT_EPSILON = 1E-14;\n \n+    /** The constant value of \u00bdlog 2\u03c0. */\n+    private static final double HALF_LOG_TWO_PI = .9189385332046727;\n+\n+    /**\n+     * <p>\n+     * The coefficients of the series expansion of the \u0394 function. This function\n+     * is defined as follows\n+     * </p>\n+     * <center>\u0394(x) = log \u0393(x) - (x - 0.5) log a + a - 0.5 log 2\u03c0,</center>\n+     * <p>\n+     * see equation (23) in Didonato and Morris (1992). The series expansion,\n+     * which applies for x \u2265 10, reads\n+     * </p>\n+     * <pre>\n+     *                 14\n+     *                ====\n+     *             1  \\                2 n\n+     *     \u0394(x) = ---  >    d  (10 / x)\n+     *             x  /      n\n+     *                ====\n+     *                n = 0\n+     * <pre>\n+     */\n+    private static final double[] DELTA = {\n+        .833333333333333333333333333333E-01,\n+        -.277777777777777777777777752282E-04,\n+        .793650793650793650791732130419E-07,\n+        -.595238095238095232389839236182E-09,\n+        .841750841750832853294451671990E-11,\n+        -.191752691751854612334149171243E-12,\n+        .641025640510325475730918472625E-14,\n+        -.295506514125338232839867823991E-15,\n+        .179643716359402238723287696452E-16,\n+        -.139228964661627791231203060395E-17,\n+        .133802855014020915603275339093E-18,\n+        -.154246009867966094273710216533E-19,\n+        .197701992980957427278370133333E-20,\n+        -.234065664793997056856992426667E-21,\n+        .171348014966398575409015466667E-22\n+    };\n+\n     /**\n      * Default constructor.  Prohibit instantiation.\n      */\n@@ -159,17 +226,6 @@ protected double getA(int n, double x) {\n         return ret;\n     }\n \n-    /**\n-     * Returns the natural logarithm of the beta function B(a, b).\n-     *\n-     * @param a Parameter {@code a}.\n-     * @param b Parameter {@code b}.\n-     * @return log(B(a, b)).\n-     */\n-    public static double logBeta(double a, double b) {\n-        return logBeta(a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n-    }\n-\n     /**\n      * Returns the natural logarithm of the beta function B(a, b).\n      *\n@@ -181,27 +237,272 @@ public static double logBeta(double a, double b) {\n      *\n      * @param a Parameter {@code a}.\n      * @param b Parameter {@code b}.\n-     * @param epsilon When the absolute value of the nth item in the\n-     * series is less than epsilon the approximation ceases to calculate\n-     * further elements in the series.\n-     * @param maxIterations Maximum number of \"iterations\" to complete.\n+     * @param epsilon This parameter is ignored.\n+     * @param maxIterations This parameter is ignored.\n      * @return log(B(a, b)).\n+     * @deprecated as of version 3.1, this method is deprecated as the\n+     * computation of the beta function is no longer iterative. This method\n+     * internally calls {@link #logBeta(double, double)}.\n      */\n+    @Deprecated\n     public static double logBeta(double a, double b,\n                                  double epsilon,\n                                  int maxIterations) {\n-        double ret;\n \n-        if (Double.isNaN(a) ||\n-            Double.isNaN(b) ||\n-            a <= 0.0 ||\n-            b <= 0.0) {\n-            ret = Double.NaN;\n+        return logBeta(a, b);\n+    }\n+\n+\n+    /**\n+     * Returns the value of log \u0393(a + b) for 1 \u2264 a, b \u2264 2. Based on the\n+     * <em>NSWC Library of Mathematics Subroutines</em> double precision\n+     * implementation, {@code DGSMLN}.\n+     *\n+     * @param a First argument.\n+     * @param b Second argument.\n+     * @return the value of {@code log(Gamma(a + b))}.\n+     * @throws OutOfRangeException if {@code a} or {@code b} is lower than\n+     * {@code 1.0} or greater than {@code 2.0}.\n+     */\n+    private static double logGammaSum(final double a, final double b)\n+        throws OutOfRangeException {\n+\n+        if ((a < 1.0) || (a > 2.0)) {\n+            throw new OutOfRangeException(a, 1.0, 2.0);\n+        }\n+        if ((b < 1.0) || (b > 2.0)) {\n+            throw new OutOfRangeException(b, 1.0, 2.0);\n+        }\n+\n+        final double x = (a - 1.0) + (b - 1.0);\n+        if (x <= 0.5) {\n+            return Gamma.logGamma1p(1.0 + x);\n+        } else if (x <= 1.5) {\n+            return Gamma.logGamma1p(x) + FastMath.log1p(x);\n         } else {\n-            ret = Gamma.logGamma(a) + Gamma.logGamma(b) -\n-                Gamma.logGamma(a + b);\n+            return Gamma.logGamma1p(x - 1.0) + FastMath.log(x * (1.0 + x));\n+        }\n     }\n \n-        return ret;\n+    /**\n+     * Returns the value of log[\u0393(b) / \u0393(a + b)] for a \u2265 0 and b \u2265 10. Based on\n+     * the <em>NSWC Library of Mathematics Subroutines</em> double precision\n+     * implementation, {@code DLGDIV}.\n+     *\n+     * @param a First argument.\n+     * @param b Second argument.\n+     * @return the value of {@code log(Gamma(b) / Gamma(a + b))}.\n+     * @throws NumberIsTooSmallException if {@code a < 0.0} or {@code b < 10.0}.\n+     */\n+    private static double logGammaMinusLogGammaSum(final double a,\n+                                                   final double b)\n+        throws NumberIsTooSmallException {\n+\n+        if (a < 0.0) {\n+            throw new NumberIsTooSmallException(a, 0.0, true);\n+        }\n+        if (b < 10.0) {\n+            throw new NumberIsTooSmallException(b, 10.0, true);\n+        }\n+\n+        /*\n+         * p = a / (a + b), q = b / (a + b), d = a + b - 0.5\n+         */\n+        final double p;\n+        final double q;\n+        final double d;\n+        final double w;\n+        if (a <= b) {\n+            d = b + (a - 0.5);\n+            w = deltaMinusDeltaSum(a, b);\n+        } else {\n+            d = a + (b - 0.5);\n+            w = deltaMinusDeltaSum(b, a);\n+        }\n+\n+        final double u = d * FastMath.log1p(a / b);\n+        final double v = a * (FastMath.log(b) - 1.0);\n+\n+        return u <= v ? (w - u) - v : (w - v) - u;\n+    }\n+\n+    /**\n+     * Returns the value of \u0394(b) - \u0394(a + b), with 0 \u2264 a \u2264 b and b \u2265 10. Based\n+     * on equations (26), (27) and (28) in Didonato and Morris (1992).\n+     *\n+     * @param a First argument.\n+     * @param b Second argument.\n+     * @return the value of {@code Delta(b) - Delta(a + b)}\n+     * @throws OutOfRangeException if {@code a < 0} or {@code a > b}\n+     * @throws NumberIsTooSmallException if {@code b < 10}\n+     */\n+    private static double deltaMinusDeltaSum(final double a,\n+                                             final double b)\n+        throws OutOfRangeException, NumberIsTooSmallException {\n+\n+        if ((a < 0) || (a > b)) {\n+            throw new OutOfRangeException(a, 0, b);\n+        }\n+        if (b < 10) {\n+            throw new NumberIsTooSmallException(b, 10, true);\n+        }\n+\n+        final double h = a / b;\n+        final double p = h / (1.0 + h);\n+        final double q = 1.0 / (1.0 + h);\n+        final double q2 = q * q;\n+        /*\n+         * s[i] = 1 + q + ... - q**(2 * i)\n+         */\n+        final double[] s = new double[DELTA.length];\n+        s[0] = 1.0;\n+        for (int i = 1; i < s.length; i++) {\n+            s[i] = 1.0 + (q + q2 * s[i - 1]);\n+        }\n+        /*\n+         * w = Delta(b) - Delta(a + b)\n+         */\n+        final double sqrtT = 10.0 / b;\n+        final double t = sqrtT * sqrtT;\n+        double w = DELTA[DELTA.length - 1] * s[s.length - 1];\n+        for (int i = DELTA.length - 2; i >= 0; i--) {\n+            w = t * w + DELTA[i] * s[i];\n+        }\n+        return w * p / b;\n+    }\n+\n+    /**\n+     * Returns the value of \u0394(p) + \u0394(q) - \u0394(p + q), with p, q \u2265 10. Based on\n+     * the <em>NSWC Library of Mathematics Subroutines</em> double precision\n+     * implementation, {@code DBCORR}.\n+     *\n+     * @param p First argument.\n+     * @param q Second argument.\n+     * @return the value of {@code Delta(p) + Delta(q) - Delta(p + q)}.\n+     * @throws NumberIsTooSmallException if {@code p < 10.0} or {@code q < 10.0}.\n+     */\n+    private static double sumDeltaMinusDeltaSum(final double p,\n+                                                final double q) {\n+\n+        if (p < 10.0) {\n+            throw new NumberIsTooSmallException(p, 10.0, true);\n+        }\n+        if (q < 10.0) {\n+            throw new NumberIsTooSmallException(q, 10.0, true);\n+        }\n+\n+        final double a = FastMath.min(p, q);\n+        final double b = FastMath.max(p, q);\n+        final double sqrtT = 10.0 / a;\n+        final double t = sqrtT * sqrtT;\n+        double z = DELTA[DELTA.length - 1];\n+        for (int i = DELTA.length - 2; i >= 0; i--) {\n+            z = t * z + DELTA[i];\n+        }\n+        return z / a + deltaMinusDeltaSum(a, b);\n+    }\n+\n+    /**\n+     * Returns the value of log B(p, q) for 0 \u2264 x \u2264 1 and p, q > 0. Based on the\n+     * <em>NSWC Library of Mathematics Subroutines</em> implementation,\n+     * {@code DBETLN}.\n+     *\n+     * @param p First argument.\n+     * @param q Second argument.\n+     * @return the value of {@code log(Beta(p, q))}, {@code NaN} if\n+     * {@code p <= 0} or {@code q <= 0}.\n+     */\n+    public static final double logBeta(final double p, final double q) {\n+\n+        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n+            return Double.NaN;\n+        }\n+\n+        final double a = FastMath.min(p, q);\n+        final double b = FastMath.max(p, q);\n+        if (a >= 10.0) {\n+            final double w = sumDeltaMinusDeltaSum(a, b);\n+            final double h = a / b;\n+            final double c = h / (1.0 + h);\n+            final double u = -(a - 0.5) * FastMath.log(c);\n+            final double v = b * FastMath.log1p(h);\n+            if (u <= v) {\n+                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - u) - v;\n+            } else {\n+                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n+            }\n+        } else if (a > 2.0) {\n+            if (b > 1000.0) {\n+                final int n = (int) FastMath.floor(a - 1.0);\n+                double prod = 1.0;\n+                double ared = a;\n+                for (int i = 0; i < n; i++) {\n+                    ared -= 1.0;\n+                    prod *= ared / (1.0 + ared / b);\n+                }\n+                return (FastMath.log(prod) - n * FastMath.log(b)) +\n+                        (Gamma.logGamma(ared) +\n+                         logGammaMinusLogGammaSum(ared, b));\n+            } else {\n+                double prod1 = 1.0;\n+                double ared = a;\n+                while (ared > 2.0) {\n+                    ared -= 1.0;\n+                    final double h = ared / b;\n+                    prod1 *= h / (1.0 + h);\n+                }\n+                if (b < 10.0) {\n+                    double prod2 = 1.0;\n+                    double bred = b;\n+                    while (bred > 2.0) {\n+                        bred -= 1.0;\n+                        prod2 *= bred / (ared + bred);\n+                    }\n+                    return FastMath.log(prod1) +\n+                           FastMath.log(prod2) +\n+                           (Gamma.logGamma(ared) +\n+                           (Gamma.logGamma(bred) -\n+                            logGammaSum(ared, bred)));\n+                } else {\n+                    return FastMath.log(prod1) +\n+                           Gamma.logGamma(ared) +\n+                           logGammaMinusLogGammaSum(ared, b);\n+                }\n+            }\n+        } else if (a >= 1.0) {\n+            if (b > 2.0) {\n+                if (b < 10.0) {\n+                    double prod = 1.0;\n+                    double bred = b;\n+                    while (bred > 2.0) {\n+                        bred -= 1.0;\n+                        prod *= bred / (a + bred);\n+                    }\n+                    return FastMath.log(prod) +\n+                           (Gamma.logGamma(a) +\n+                            (Gamma.logGamma(bred) -\n+                             logGammaSum(a, bred)));\n+                } else {\n+                    return Gamma.logGamma(a) +\n+                           logGammaMinusLogGammaSum(a, b);\n+                }\n+            } else {\n+                return Gamma.logGamma(a) +\n+                       Gamma.logGamma(b) -\n+                       logGammaSum(a, b);\n+            }\n+        } else {\n+            if (b >= 10.0) {\n+                return Gamma.logGamma(a) +\n+                       logGammaMinusLogGammaSum(a, b);\n+            } else {\n+                // The following command is the original NSWC implementation.\n+                // return Gamma.logGamma(a) +\n+                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n+                // The following command turns out to be more accurate.\n+                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n+                                    Gamma.gamma(a + b));\n+            }\n+        }\n     }\n }\n",
        "project": "commons-math",
        "linesAdd": 211,
        "jira_id": "738",
        "nb_skipped": 4,
        "commit": "f64b6a90",
        "nb_failure": 1,
        "linesRem": 13,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2949,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.complex.ComplexTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex 137765c85..dd0b00a5b 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -256,7 +256,8 @@ public Complex divide(Complex divisor)\n         }\n \n         if (divisor.isZero) {\n-            return isZero ? NaN : INF;\n+            // return isZero ? NaN : INF; // See MATH-657\n+            return NaN;\n         }\n \n         if (divisor.isInfinite() && !isInfinite()) {\n@@ -292,7 +293,8 @@ public Complex divide(double divisor) {\n             return NaN;\n         }\n         if (divisor == 0d) {\n-            return isZero ? NaN : INF;\n+            // return isZero ? NaN : INF; // See MATH-657\n+            return NaN;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;\n",
        "project": "commons-math",
        "linesAdd": 2,
        "jira_id": "657",
        "nb_skipped": 1,
        "commit": "97b440fc",
        "nb_failure": 2,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3145,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.stat.descriptive.moment.VarianceTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\nindex e5518e31a..1de139f3e 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n@@ -517,7 +517,7 @@ public double evaluate(final double[] values, final double[] weights,\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+                for (int i = begin; i < begin + length; i++) {\n                     sumWts += weights[i];\n                 }\n \n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "704",
        "nb_skipped": 1,
        "commit": "3f645310",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2356,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizerTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\nindex aa14ce6c1..952e56569 100644\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java\n@@ -143,18 +143,22 @@ public UnivariateRealPointValuePair optimize(final FUNC f,\n                                                  final GoalType goal,\n                                                  final double min, final double max)\n         throws FunctionEvaluationException {\n+        return optimize(f, goal, min, max, min + 0.5 * (max - min));\n+    }\n \n+    /** {@inheritDoc} */\n+    public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n+                                                 final double min, final double max,\n+                                                 final double startValue)\n+        throws FunctionEvaluationException {\n         optima = new UnivariateRealPointValuePair[starts];\n         totalEvaluations = 0;\n \n         // Multi-start loop.\n         for (int i = 0; i < starts; ++i) {\n             try {\n-                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n-                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goal,\n-                                               FastMath.min(bound1, bound2),\n-                                               FastMath.max(bound1, bound2));\n+                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);\n+                optima[i] = optimizer.optimize(f, goal, min, max, s);\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {\n@@ -177,16 +181,6 @@ public UnivariateRealPointValuePair optimize(final FUNC f,\n         return optima[0];\n     }\n \n-    /** {@inheritDoc} */\n-    public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goalType,\n-                                                 final double min, final double max,\n-                                                 final double startValue)\n-            throws FunctionEvaluationException {\n-        // XXX Main code should be here, using \"startValue\" for the first start.\n-        // XXX This method should set \"startValue\" to min + 0.5 * (max - min)\n-        return optimize(f, goalType, min, max);\n-    }\n-\n     /**\n      * Sort the optima from best to worst, followed by {@code null} elements.\n      *\n",
        "project": "commons-math",
        "linesAdd": 8,
        "jira_id": "413",
        "nb_skipped": 1,
        "commit": "51aa6e6c",
        "nb_failure": 1,
        "linesRem": 12,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5866,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.util.FastMathTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/util/FastMath.java b/src/main/java/org/apache/commons/math4/util/FastMath.java\nindex 3d6d27d27..2532c6269 100644\n--- a/src/main/java/org/apache/commons/math4/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math4/util/FastMath.java\n@@ -968,6 +968,13 @@ full double precision (52 bits).  Since z < 2^-10, we will have\n        much larger than the others.  If there are extra bits specified from the\n        pow() function, use them. */\n         final double tempC = tempB + tempA;\n+\n+        // If tempC is positive infinite, the evaluation below could result in NaN,\n+        // because z could be negative at the same time.\n+        if (tempC == Double.POSITIVE_INFINITY) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+\n         final double result;\n         if (extra != 0.0) {\n             result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n",
        "project": "commons-math",
        "linesAdd": 5,
        "jira_id": "1269",
        "nb_skipped": 3,
        "commit": "a94ff90a",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2949,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.complex.ComplexTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex ac31e4b1b..137765c85 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -78,6 +78,8 @@\n     private final transient boolean isNaN;\n     /** Record whether this complex number is infinite. */\n     private final transient boolean isInfinite;\n+    /** Record whether this complex number is zero. */\n+    private final transient boolean isZero;\n \n     /**\n      * Create a complex number given only the real part.\n@@ -101,6 +103,7 @@ public Complex(double real, double imaginary) {\n         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n         isInfinite = !isNaN &&\n             (Double.isInfinite(real) || Double.isInfinite(imaginary));\n+        isZero = real == 0 && imaginary == 0;\n     }\n \n     /**\n@@ -222,7 +225,10 @@ public Complex conjugate() {\n      *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\n      *   in either part, {@link #NaN} is returned.\n      *  </li>\n-     *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.\n+     *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},\n+     *   {@link #NaN} is returned.\n+     *  </li>\n+     *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.\n      *  </li>\n      *  <li>If {@code this} and {@code divisor} are both infinite,\n      *   {@link #NaN} is returned.\n@@ -249,16 +255,17 @@ public Complex divide(Complex divisor)\n             return NaN;\n         }\n \n-        final double c = divisor.getReal();\n-        final double d = divisor.getImaginary();\n-        if (c == 0.0 && d == 0.0) {\n-            return NaN;\n+        if (divisor.isZero) {\n+            return isZero ? NaN : INF;\n         }\n \n         if (divisor.isInfinite() && !isInfinite()) {\n             return ZERO;\n         }\n \n+        final double c = divisor.getReal();\n+        final double d = divisor.getImaginary();\n+\n         if (FastMath.abs(c) < FastMath.abs(d)) {\n             double q = c / d;\n             double denominator = c * q + d;\n@@ -285,7 +292,7 @@ public Complex divide(double divisor) {\n             return NaN;\n         }\n         if (divisor == 0d) {\n-            return NaN;\n+            return isZero ? NaN : INF;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;\n",
        "project": "commons-math",
        "linesAdd": 8,
        "jira_id": "657",
        "nb_skipped": 1,
        "commit": "32b0f733",
        "nb_failure": 2,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3489,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.fraction.BigFractionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/fraction/BigFraction.java b/src/main/java/org/apache/commons/math/fraction/BigFraction.java\nindex e93d76d46..a6672e426 100644\n--- a/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n@@ -682,7 +682,16 @@ public BigFraction divide(final BigFraction fraction) {\n      */\n     @Override\n     public double doubleValue() {\n-        return numerator.doubleValue() / denominator.doubleValue();\n+        double result = numerator.doubleValue() / denominator.doubleValue();\n+        if (Double.isNaN(result)) {\n+            // Numerator and/or denominator must be out of range:\n+            // Calculate how far to shift them to put them in range.\n+            int shift = Math.max(numerator.bitLength(),\n+                                 denominator.bitLength()) - Double.MAX_EXPONENT;\n+            result = numerator.shiftRight(shift).doubleValue() /\n+                denominator.shiftRight(shift).doubleValue();\n+        }\n+        return result;\n     }\n \n     /**\n@@ -726,7 +735,16 @@ public boolean equals(final Object other) {\n      */\n     @Override\n     public float floatValue() {\n-        return numerator.floatValue() / denominator.floatValue();\n+        float result = numerator.floatValue() / denominator.floatValue();\n+        if (Double.isNaN(result)) {\n+            // Numerator and/or denominator must be out of range:\n+            // Calculate how far to shift them to put them in range.\n+            int shift = Math.max(numerator.bitLength(),\n+                                 denominator.bitLength()) - Float.MAX_EXPONENT;\n+            result = numerator.shiftRight(shift).floatValue() /\n+                denominator.shiftRight(shift).floatValue();\n+        }\n+        return result;\n     }\n \n     /**\n",
        "project": "commons-math",
        "linesAdd": 16,
        "jira_id": "744",
        "nb_skipped": 1,
        "commit": "8a83581e",
        "nb_failure": 2,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4157,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.optimization.direct.CMAESOptimizerTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\nindex 866c8fdf8..388d1dfd4 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -123,13 +123,11 @@\n     private boolean isActiveCMA;\n     /**\n      * Determines how often a new random offspring is generated in case it is\n-     * not feasible / beyond the defined limits, default is 0. Only relevant if\n-     * boundaries != null.\n+     * not feasible / beyond the defined limits, default is 0.\n      */\n     private int checkFeasableCount;\n     /**\n-     * Lower and upper boundaries of the objective variables. boundaries == null\n-     * means no boundaries.\n+     * Lower and upper boundaries of the objective variables.\n      */\n     private double[][] boundaries;\n     /**\n@@ -357,7 +355,7 @@ protected PointValuePair doOptimize() {\n          // -------------------- Initialization --------------------------------\n         isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n         final FitnessFunction fitfun = new FitnessFunction();\n-        final double[] guess = fitfun.encode(getStartPoint());\n+        final double[] guess = getStartPoint();\n         // number of objective variables/problem dimension\n         dimension = guess.length;\n         initializeCMA(guess);\n@@ -422,7 +420,7 @@ protected PointValuePair doOptimize() {\n                     bestValue = bestFitness;\n                     lastResult = optimum;\n                     optimum = new PointValuePair(\n-                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n+                            fitfun.repair(bestArx.getColumn(0)),\n                             isMinimize ? bestFitness : -bestFitness);\n                     if (getConvergenceChecker() != null && lastResult != null) {\n                         if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n@@ -506,56 +504,11 @@ private void checkParameters() {\n         final double[] lB = getLowerBound();\n         final double[] uB = getUpperBound();\n \n-        // Checks whether there is at least one finite bound value.\n-        boolean hasFiniteBounds = false;\n-        for (int i = 0; i < lB.length; i++) {\n-            if (!Double.isInfinite(lB[i]) ||\n-                !Double.isInfinite(uB[i])) {\n-                hasFiniteBounds = true;\n-                break;\n-            }\n-        }\n-        // Checks whether there is at least one infinite bound value.\n-        boolean hasInfiniteBounds = false;\n-        if (hasFiniteBounds) {\n-            for (int i = 0; i < lB.length; i++) {\n-                if (Double.isInfinite(lB[i]) ||\n-                    Double.isInfinite(uB[i])) {\n-                    hasInfiniteBounds = true;\n-                    break;\n-                }\n-            }\n-\n-            if (hasInfiniteBounds) {\n-                // If there is at least one finite bound, none can be infinite,\n-                // because mixed cases are not supported by the current code.\n-                throw new MathUnsupportedOperationException();\n-            } else {\n         // Convert API to internal handling of boundaries.\n         boundaries = new double[2][];\n         boundaries[0] = lB;\n         boundaries[1] = uB;\n \n-                // Abort early if the normalization will overflow (cf. \"encode\" method).\n-                for (int i = 0; i < lB.length; i++) {\n-                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n-                        final double max = Double.MAX_VALUE + boundaries[0][i];\n-                        final NumberIsTooLargeException e\n-                            = new NumberIsTooLargeException(boundaries[1][i],\n-                                                            max,\n-                                                            true);\n-                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n-                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n-\n-                        throw e;\n-                    }\n-                }\n-            }\n-        } else {\n-            // Convert API to internal handling of boundaries.\n-            boundaries = null;\n-        }\n-\n         if (inputSigma != null) {\n             if (inputSigma.length != init.length) {\n                 throw new DimensionMismatchException(inputSigma.length, init.length);\n@@ -564,14 +517,12 @@ private void checkParameters() {\n                 if (inputSigma[i] < 0) {\n                     throw new NotPositiveException(inputSigma[i]);\n                 }\n-                if (boundaries != null) {\n                 if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                     throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                 }\n             }\n         }\n     }\n-    }\n \n     /**\n      * Initialization of the dynamic search parameters\n@@ -585,8 +536,7 @@ private void initializeCMA(double[] guess) {\n         // initialize sigma\n         double[][] sigmaArray = new double[guess.length][1];\n         for (int i = 0; i < guess.length; i++) {\n-            final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\n-            sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;\n+            sigmaArray[i][0] = inputSigma == null ? 0.3 : inputSigma[i];\n         }\n         RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\n         sigma = max(insigma); // overall standard deviation\n@@ -918,62 +868,20 @@ public FitnessFunction() {\n             isRepairMode = true;\n         }\n \n-        /**\n-         * @param x Original objective variables.\n-         * @return the normalized objective variables.\n-         */\n-        public double[] encode(final double[] x) {\n-            if (boundaries == null) {\n-                return x;\n-            }\n-            double[] res = new double[x.length];\n-            for (int i = 0; i < x.length; i++) {\n-                double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = x[i] / diff;\n-            }\n-            return res;\n-        }\n-\n-        /**\n-         * @param x Normalized objective variables.\n-         * @return the original objective variables, possibly repaired.\n-         */\n-        public double[] repairAndDecode(final double[] x) {\n-            return boundaries != null && isRepairMode ?\n-                decode(repair(x)) :\n-                decode(x);\n-        }\n-\n-        /**\n-         * @param x Normalized objective variables.\n-         * @return the original objective variables.\n-         */\n-        public double[] decode(final double[] x) {\n-            if (boundaries == null) {\n-                return x;\n-            }\n-            double[] res = new double[x.length];\n-            for (int i = 0; i < x.length; i++) {\n-                double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = diff * x[i];\n-            }\n-            return res;\n-        }\n-\n         /**\n          * @param point Normalized objective variables.\n          * @return the objective value + penalty for violated bounds.\n          */\n         public double value(final double[] point) {\n             double value;\n-            if (boundaries != null && isRepairMode) {\n+            if (isRepairMode) {\n                 double[] repaired = repair(point);\n                 value = CMAESOptimizer.this\n-                        .computeObjectiveValue(decode(repaired)) +\n+                        .computeObjectiveValue(repaired) +\n                         penalty(point, repaired);\n             } else {\n                 value = CMAESOptimizer.this\n-                        .computeObjectiveValue(decode(point));\n+                        .computeObjectiveValue(point);\n             }\n             return isMinimize ? value : -value;\n         }\n@@ -983,18 +891,11 @@ public double value(final double[] point) {\n          * @return {@code true} if in bounds.\n          */\n         public boolean isFeasible(final double[] x) {\n-            if (boundaries == null) {\n-                return true;\n-            }\n-\n-            final double[] bLoEnc = encode(boundaries[0]);\n-            final double[] bHiEnc = encode(boundaries[1]);\n-\n             for (int i = 0; i < x.length; i++) {\n-                if (x[i] < bLoEnc[i]) {\n+                if (x[i] < boundaries[0][i]) {\n                     return false;\n                 }\n-                if (x[i] > bHiEnc[i]) {\n+                if (x[i] > boundaries[1][i]) {\n                     return false;\n                 }\n             }\n@@ -1013,12 +914,12 @@ public void setValueRange(double valueRange) {\n          * @return the repaired objective variables - all in bounds.\n          */\n         private double[] repair(final double[] x) {\n-            double[] repaired = new double[x.length];\n+            final double[] repaired = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n-                if (x[i] < 0) {\n-                    repaired[i] = 0;\n-                } else if (x[i] > 1.0) {\n-                    repaired[i] = 1.0;\n+                if (x[i] < boundaries[0][i]) {\n+                    repaired[i] = boundaries[0][i];\n+                } else if (x[i] > boundaries[1][i]) {\n+                    repaired[i] = boundaries[1][i];\n                 } else {\n                     repaired[i] = x[i];\n                 }\n",
        "project": "commons-math",
        "linesAdd": 13,
        "jira_id": "867",
        "nb_skipped": 4,
        "commit": "bfbb156d",
        "nb_failure": 1,
        "linesRem": 92,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4153,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.optimization.direct.CMAESOptimizerTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\nindex b54cb3744..f6a4f2820 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -24,8 +24,8 @@\n import org.apache.commons.math3.analysis.MultivariateFunction;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n-import org.apache.commons.math3.exception.MathIllegalStateException;\n import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n@@ -78,6 +78,12 @@\n  *  <li><a href=\"http://en.wikipedia.org/wiki/CMA-ES\">Wikipedia</a></li>\n  * </ul>\n  *\n+ * When simple constraints (boundaries) are used, care must be taken that the\n+ * difference between the upper and lower bounds does not overflow; should it\n+ * be the case, a {@link NumberIsTooLargeException} will be thrown by the\n+ * {@link BaseAbstractMultivariateSimpleBoundsOptimizer#optimize(int,\n+ * MultivariateFunction,GoalType,double[],double[],double[]) optimize} method.\n+ *\n  * @version $Id$\n  * @since 3.0\n  */\n@@ -529,6 +535,21 @@ private void checkParameters() {\n                 boundaries = new double[2][];\n                 boundaries[0] = lB;\n                 boundaries[1] = uB;\n+\n+                // Abort early if the normalization will overflow (cf. \"encode\" method).\n+                for (int i = 0; i < lB.length; i++) {\n+                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n+                        final double max = Double.MAX_VALUE + boundaries[0][i];\n+                        final NumberIsTooLargeException e\n+                            = new NumberIsTooLargeException(boundaries[1][i],\n+                                                            max,\n+                                                            true);\n+                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n+                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n+\n+                        throw e;\n+                    }\n+                }\n             }\n         } else {\n             // Convert API to internal handling of boundaries.\n",
        "project": "commons-math",
        "linesAdd": 15,
        "jira_id": "865",
        "nb_skipped": 4,
        "commit": "b55e0206",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4528,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.distribution.MultivariateNormalDistributionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java b/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\nindex 15706811b..fd18c281b 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\n@@ -180,7 +180,7 @@ public double density(final double[] vals) throws DimensionMismatchException {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "929",
        "nb_skipped": 4,
        "commit": "cedf0d27",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3751,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.linear.RealVectorTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/linear/RealVector.java b/src/main/java/org/apache/commons/math3/linear/RealVector.java\nindex 89611c34c..f05ea4d77 100644\n--- a/src/main/java/org/apache/commons/math3/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RealVector.java\n@@ -642,27 +642,20 @@ public RealVector mapDivideToSelf(double d){\n      * @return the matrix outer product between this instance and {@code v}.\n      */\n     public RealMatrix outerProduct(RealVector v) {\n-        RealMatrix product;\n+        final int m = this.getDimension();\n+        final int n = v.getDimension();\n+        final RealMatrix product;\n         if (v instanceof SparseRealVector || this instanceof SparseRealVector) {\n-            product = new OpenMapRealMatrix(this.getDimension(),\n-                                            v.getDimension());\n+            product = new OpenMapRealMatrix(m, n);\n         } else {\n-            product = new Array2DRowRealMatrix(this.getDimension(),\n-                                               v.getDimension());\n+            product = new Array2DRowRealMatrix(m, n);\n         }\n-        Iterator<Entry> thisIt = sparseIterator();\n-        while (thisIt.hasNext()) {\n-            final Entry thisE = thisIt.next();\n-            Iterator<Entry> otherIt = v.sparseIterator();\n-            while (otherIt.hasNext()) {\n-                final Entry otherE = otherIt.next();\n-                product.setEntry(thisE.getIndex(), otherE.getIndex(),\n-                                 thisE.getValue() * otherE.getValue());\n+        for (int i = 0; i < m; i++) {\n+            for (int j = 0; j < n; j++) {\n+                product.setEntry(i, j, this.getEntry(i) * v.getEntry(j));\n             }\n         }\n-\n         return product;\n-\n     }\n \n     /**\n",
        "project": "commons-math",
        "linesAdd": 8,
        "jira_id": "812",
        "nb_skipped": 3,
        "commit": "607c9ec6",
        "nb_failure": 2,
        "linesRem": 15,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5847,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.util.FastMathTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/util/FastMath.java b/src/main/java/org/apache/commons/math4/util/FastMath.java\nindex a4a9a1b10..46c8752a0 100644\n--- a/src/main/java/org/apache/commons/math4/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math4/util/FastMath.java\n@@ -1711,7 +1711,7 @@ public Split reciprocal() {\n         }\n \n         /** Computes this^e.\n-         * @param e exponent (beware, here it MUST be > 0)\n+         * @param e exponent (beware, here it MUST be > 0; the only exclusion is Long.MIN_VALUE)\n          * @return d^e, split in high and low bits\n          * @since 4.0\n          */\n@@ -1723,7 +1723,7 @@ private Split pow(final long e) {\n             // d^(2p)\n             Split d2p = new Split(full, high, low);\n \n-            for (long p = e; p != 0; p >>= 1) {\n+            for (long p = e; p != 0; p >>>= 1) {\n \n                 if ((p & 0x1) != 0) {\n                     // accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "1272",
        "nb_skipped": 3,
        "commit": "26e878ab",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5813,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.special.GammaTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/special/Gamma.java b/src/main/java/org/apache/commons/math4/special/Gamma.java\nindex eb3fb5b2e..aa0e90c23 100644\n--- a/src/main/java/org/apache/commons/math4/special/Gamma.java\n+++ b/src/main/java/org/apache/commons/math4/special/Gamma.java\n@@ -442,6 +442,10 @@ protected double getB(int n, double x) {\n      * @since 2.0\n      */\n     public static double digamma(double x) {\n+        if (Double.isNaN(x) || Double.isInfinite(x)) {\n+            return x;\n+        }\n+\n         if (x > 0 && x <= S_LIMIT) {\n             // use method 5 from Bernardo AS103\n             // accurate to O(x)\n@@ -472,6 +476,10 @@ public static double digamma(double x) {\n      * @since 2.0\n      */\n     public static double trigamma(double x) {\n+        if (Double.isNaN(x) || Double.isInfinite(x)) {\n+            return x;\n+        }\n+\n         if (x > 0 && x <= S_LIMIT) {\n             return 1 / (x * x);\n         }\n",
        "project": "commons-math",
        "linesAdd": 8,
        "jira_id": "1241",
        "nb_skipped": 3,
        "commit": "471e6b07",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 4,
        "nb_test": 2152,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest",
            "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\nindex 935bb8ba3..6ee9bd56c 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n@@ -271,7 +271,15 @@ public double integrate(final FirstOrderDifferentialEquations equations,\n                     if (manager.evaluateStep(interpolatorTmp)) {\n                         final double dt = manager.getEventTime() - stepStart;\n                         if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                            // rejecting the step would lead to a too small next step, we accept it\n+                            // we cannot simply truncate the step, reject the current computation\n+                            // and let the loop compute another state with the truncated step.\n+                            // it is so small (much probably exactly 0 due to limited accuracy)\n+                            // that the code above would fail handling it.\n+                            // So we set up an artificial 0 size step by copying states\n+                            interpolator.storeTime(stepStart);\n+                            System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                            hNew     = 0;\n+                            stepSize = 0;\n                             loop     = false;\n                         } else {\n                             // reject the step to match exactly the next switch time\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\nindex 27ade7b07..e0e2f0d2c 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n@@ -289,7 +289,15 @@ public double integrate(final FirstOrderDifferentialEquations equations,\n                     if (manager.evaluateStep(interpolatorTmp)) {\n                         final double dt = manager.getEventTime() - stepStart;\n                         if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                            // rejecting the step would lead to a too small next step, we accept it\n+                            // we cannot simply truncate the step, reject the current computation\n+                            // and let the loop compute another state with the truncated step.\n+                            // it is so small (much probably exactly 0 due to limited accuracy)\n+                            // that the code above would fail handling it.\n+                            // So we set up an artificial 0 size step by copying states\n+                            interpolator.storeTime(stepStart);\n+                            System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                            hNew     = 0;\n+                            stepSize = 0;\n                             loop     = false;\n                         } else {\n                             // reject the step to match exactly the next switch time\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 34b3dc1ca..e03be9ed0 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -292,7 +292,15 @@ public double integrate(final FirstOrderDifferentialEquations equations,\n           if (manager.evaluateStep(interpolator)) {\n               final double dt = manager.getEventTime() - stepStart;\n               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                  // rejecting the step would lead to a too small next step, we accept it\n+                  // we cannot simply truncate the step, reject the current computation\n+                  // and let the loop compute another state with the truncated step.\n+                  // it is so small (much probably exactly 0 due to limited accuracy)\n+                  // that the code above would fail handling it.\n+                  // So we set up an artificial 0 size step by copying states\n+                  interpolator.storeTime(stepStart);\n+                  System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                  hNew     = 0;\n+                  stepSize = 0;\n                   loop     = false;\n               } else {\n                   // reject the step to match exactly the next switch time\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\nindex 3227b9808..b61b0b1a4 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n@@ -172,7 +172,14 @@ public double integrate(final FirstOrderDifferentialEquations equations,\n         if (manager.evaluateStep(interpolator)) {\n             final double dt = manager.getEventTime() - stepStart;\n             if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                // rejecting the step would lead to a too small next step, we accept it\n+                // we cannot simply truncate the step, reject the current computation\n+                // and let the loop compute another state with the truncated step.\n+                // it is so small (much probably exactly 0 due to limited accuracy)\n+                // that the code above would fail handling it.\n+                // So we set up an artificial 0 size step by copying states\n+                interpolator.storeTime(stepStart);\n+                System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                stepSize = 0;\n                 loop     = false;\n             } else {\n                 // reject the step to match exactly the next switch time\n",
        "project": "commons-math",
        "linesAdd": 15,
        "jira_id": "358",
        "nb_skipped": 0,
        "commit": "061f5017",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5393,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.linear.EigenSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java b/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\nindex 4d4d794a2..2bb8fd754 100644\n--- a/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/EigenDecomposition.java\n@@ -513,8 +513,12 @@ public RealMatrix solve(RealMatrix b) {\n          * @return true if the decomposed matrix is non-singular.\n          */\n         public boolean isNonSingular() {\n-            // The eigenvalues are sorted by size, descending\n-            double largestEigenvalueNorm = eigenvalueNorm(0);\n+            double largestEigenvalueNorm = 0.0;\n+            // Looping over all values (in case they are not sorted in decreasing\n+            // order of their norm).\n+            for (int i = 0; i < realEigenvalues.length; ++i) {\n+                largestEigenvalueNorm = FastMath.max(largestEigenvalueNorm, eigenvalueNorm(i));\n+            }\n             // Corner case: zero matrix, all exactly 0 eigenvalues\n             if (largestEigenvalueNorm == 0.0) {\n                 return false;\n",
        "project": "commons-math",
        "linesAdd": 4,
        "jira_id": "1045",
        "nb_skipped": 4,
        "commit": "c979a6f0",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 6005,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.exception.util.LocalizedFormatsTest",
            "org.apache.commons.math4.ode.nonstiff.AdamsBashforthIntegratorTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/exception/util/LocalizedFormats.java b/src/main/java/org/apache/commons/math4/exception/util/LocalizedFormats.java\nindex 1b589f198..dabe9a751 100644\n--- a/src/main/java/org/apache/commons/math4/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math4/exception/util/LocalizedFormats.java\n@@ -162,6 +162,7 @@\n     LOWER_BOUND_NOT_BELOW_UPPER_BOUND(\"lower bound ({0}) must be strictly less than upper bound ({1})\"), /* keep */\n     LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT(\"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\"),\n     MAP_MODIFIED_WHILE_ITERATING(\"map has been modified while iterating\"),\n+    MULTISTEP_STARTER_STOPPED_EARLY(\"multistep integrator starter stopped early, maybe too large step size\"),\n     EVALUATIONS(\"evaluations\"), /* keep */\n     MAX_COUNT_EXCEEDED(\"maximal count ({0}) exceeded\"), /* keep */\n     MAX_ITERATIONS_EXCEEDED(\"maximal number of iterations ({0}) exceeded\"),\ndiff --git a/src/main/java/org/apache/commons/math4/ode/MultistepIntegrator.java b/src/main/java/org/apache/commons/math4/ode/MultistepIntegrator.java\nindex b415dd1ab..354db491e 100644\n--- a/src/main/java/org/apache/commons/math4/ode/MultistepIntegrator.java\n+++ b/src/main/java/org/apache/commons/math4/ode/MultistepIntegrator.java\n@@ -18,6 +18,7 @@\n package org.apache.commons.math4.ode;\n \n import org.apache.commons.math4.exception.DimensionMismatchException;\n+import org.apache.commons.math4.exception.MathIllegalStateException;\n import org.apache.commons.math4.exception.MaxCountExceededException;\n import org.apache.commons.math4.exception.NoBracketingException;\n import org.apache.commons.math4.exception.NumberIsTooSmallException;\n@@ -248,6 +249,9 @@ public void computeDerivatives(double t, double[] y, double[] yDot) {\n                 }, t0, y0, t, new double[y0.length]);\n             }\n \n+            // we should not reach this step\n+            throw new MathIllegalStateException(LocalizedFormats.MULTISTEP_STARTER_STOPPED_EARLY);\n+\n         } catch (InitializationCompletedMarkerException icme) { // NOPMD\n             // this is the expected nominal interruption of the start integrator\n \n",
        "project": "commons-math",
        "linesAdd": 4,
        "jira_id": "1297",
        "nb_skipped": 4,
        "commit": "56434517",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3145,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.distribution.AbstractRealDistributionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java b/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java\nindex a37d2d2b5..d83837d71 100644\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java\n@@ -20,7 +20,6 @@\n \n import org.apache.commons.math.analysis.UnivariateFunction;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n-import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.OutOfRangeException;\n@@ -74,45 +72,76 @@ public double inverseCumulativeProbability(final double p) throws OutOfRangeExce\n             throw new OutOfRangeException(p, 0, 1);\n         }\n \n-        // by default, do simple root finding using bracketing and default solver.\n-        // subclasses can override if there is a better method.\n-        UnivariateFunction rootFindingFunction =\n-            new UnivariateFunction() {\n-            public double value(double x) {\n+        double lowerBound = getSupportLowerBound();\n+        if (p == 0.0) {\n+            return lowerBound;\n+        }\n+\n+        double upperBound = getSupportUpperBound();\n+        if (p == 1.0) {\n+            return upperBound;\n+        }\n+\n+        final double mu = getNumericalMean();\n+        final double sig = FastMath.sqrt(getNumericalVariance());\n+        final boolean chebyshevApplies;\n+        chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n+                             Double.isInfinite(sig) || Double.isNaN(sig));\n+\n+        if (lowerBound == Double.NEGATIVE_INFINITY) {\n+            if (chebyshevApplies) {\n+                lowerBound = mu - sig * FastMath.sqrt((1. - p) / p);\n+            } else {\n+                lowerBound = -1.0;\n+                while (cumulativeProbability(lowerBound) >= p) {\n+                    lowerBound *= 2.0;\n+                }\n+            }\n+        }\n+\n+        if (upperBound == Double.POSITIVE_INFINITY) {\n+            if (chebyshevApplies) {\n+                upperBound = mu + sig * FastMath.sqrt(p / (1. - p));\n+            } else {\n+                upperBound = 1.0;\n+                while (cumulativeProbability(upperBound) < p) {\n+                    upperBound *= 2.0;\n+                }\n+            }\n+        }\n+\n+        final UnivariateFunction toSolve = new UnivariateFunction() {\n+\n+            public double value(final double x) {\n                 return cumulativeProbability(x) - p;\n             }\n         };\n \n-        // Try to bracket root, test domain endpoints if this fails\n-        double lowerBound = getDomainLowerBound(p);\n-        double upperBound = getDomainUpperBound(p);\n-        double[] bracket = null;\n-        try {\n-            bracket = UnivariateRealSolverUtils.bracket(\n-                    rootFindingFunction, getInitialDomain(p),\n-                    lowerBound, upperBound);\n-        } catch (NumberIsTooLargeException ex) {\n-            /*\n-             * Check domain endpoints to see if one gives value that is within\n-             * the default solver's defaultAbsoluteAccuracy of 0 (will be the\n-             * case if density has bounded support and p is 0 or 1).\n-             */\n-            if (FastMath.abs(rootFindingFunction.value(lowerBound)) < getSolverAbsoluteAccuracy()) {\n-                return lowerBound;\n+        double x = UnivariateRealSolverUtils.solve(toSolve,\n+                                                   lowerBound,\n+                                                   upperBound,\n+                                                   getSolverAbsoluteAccuracy());\n+\n+        if (!isSupportConnected()) {\n+            /* Test for plateau. */\n+            final double dx = getSolverAbsoluteAccuracy();\n+            if (x - dx >= getSupportLowerBound()) {\n+                double px = cumulativeProbability(x);\n+                if (cumulativeProbability(x - dx) == px) {\n+                    upperBound = x;\n+                    while (upperBound - lowerBound > dx) {\n+                        final double midPoint = 0.5 * (lowerBound + upperBound);\n+                        if (cumulativeProbability(midPoint) < px) {\n+                            lowerBound = midPoint;\n+                        } else {\n+                            upperBound = midPoint;\n+                        }\n                     }\n-            if (FastMath.abs(rootFindingFunction.value(upperBound)) < getSolverAbsoluteAccuracy()) {\n                     return upperBound;\n                 }\n-            // Failed bracket convergence was not because of corner solution\n-            throw new MathInternalError(ex);\n             }\n-\n-        // find root\n-        double root = UnivariateRealSolverUtils.solve(rootFindingFunction,\n-                // override getSolverAbsoluteAccuracy() to use a Brent solver with\n-                // absolute accuracy different from the default.\n-                bracket[0],bracket[1], getSolverAbsoluteAccuracy());\n-        return root;\n+        }\n+        return x;\n     }\n \n     /**\n",
        "project": "commons-math",
        "linesAdd": 61,
        "jira_id": "699",
        "nb_skipped": 1,
        "commit": "b2e24119",
        "nb_failure": 0,
        "linesRem": 20,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2372,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.geometry.Vector3DTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/geometry/Vector3D.java b/src/main/java/org/apache/commons/math/geometry/Vector3D.java\nindex 0a4adb840..2d915e570 100644\n--- a/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n+++ b/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n@@ -454,10 +454,41 @@ public static double dotProduct(Vector3D v1, Vector3D v2) {\n    * @param v2 second vector\n    * @return the cross product v1 ^ v2 as a new Vector\n    */\n-  public static Vector3D crossProduct(Vector3D v1, Vector3D v2) {\n-    return new Vector3D(v1.y * v2.z - v1.z * v2.y,\n-                        v1.z * v2.x - v1.x * v2.z,\n-                        v1.x * v2.y - v1.y * v2.x);\n+  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n+\n+      final double n1 = v1.getNormSq();\n+      final double n2 = v2.getNormSq();\n+      if ((n1 * n2) < MathUtils.SAFE_MIN) {\n+          return ZERO;\n+      }\n+\n+      // rescale both vectors without losing precision,\n+      // to ensure their norm are the same order of magnitude\n+      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;\n+      final double x1    = FastMath.scalb(v1.x, -deltaExp);\n+      final double y1    = FastMath.scalb(v1.y, -deltaExp);\n+      final double z1    = FastMath.scalb(v1.z, -deltaExp);\n+      final double x2    = FastMath.scalb(v2.x,  deltaExp);\n+      final double y2    = FastMath.scalb(v2.y,  deltaExp);\n+      final double z2    = FastMath.scalb(v2.z,  deltaExp);\n+\n+      // we reduce cancellation errors by preconditioning,\n+      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n+      // v3 without loss of precision. See Kahan lecture\n+      // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n+      // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n+\n+      // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n+      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n+      final double rho   = FastMath.rint(256 * ratio) / 256;\n+\n+      final double x3 = x1 - rho * x2;\n+      final double y3 = y1 - rho * y2;\n+      final double z3 = z1 - rho * z2;\n+\n+      // compute cross product from v3 and v2 instead of v1 and v2\n+      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n+\n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n",
        "project": "commons-math",
        "linesAdd": 26,
        "jira_id": "554",
        "nb_skipped": 1,
        "commit": "fbbb96eb",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5808,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.ode.events.EventStateTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/ode/events/EventState.java b/src/main/java/org/apache/commons/math4/ode/events/EventState.java\nindex fe3039a4c..1908440ce 100644\n--- a/src/main/java/org/apache/commons/math4/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math4/ode/events/EventState.java\n@@ -296,7 +296,18 @@ public double value(final double t) throws LocalMaxCountExceededException {\n                             ta = forward ? ta + convergence : ta - convergence;\n                             ga = f.value(ta);\n                         } while ((g0Positive ^ (ga >= 0)) && (forward ^ (ta >= tb)));\n+\n+                        if (forward ^ (ta >= tb)) {\n+                            // we were able to skip this spurious root\n                             --i;\n+                        } else {\n+                            // we can't avoid this root before the end of the step,\n+                            // we have to handle it despite it is close to the former one\n+                            // maybe we have two very close roots\n+                            pendingEventTime = root;\n+                            pendingEvent = true;\n+                            return true;\n+                        }\n                     } else if (Double.isNaN(previousEventTime) ||\n                                (FastMath.abs(previousEventTime - root) > convergence)) {\n                         pendingEventTime = root;\n",
        "project": "commons-math",
        "linesAdd": 7,
        "jira_id": "1226",
        "nb_skipped": 3,
        "commit": "c44bfe00",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 5671,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.geometry.enclosing.WelzlEncloser3DTest",
            "org.apache.commons.math3.geometry.euclidean.threed.SphereGeneratorTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java b/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\nindex 1bacb2549..12a645f43 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\n@@ -100,7 +101,7 @@ public WelzlEncloser(final double tolerance, final SupportBallGenerator<S, P> ge\n             EnclosingBall<S, P> savedBall = ball;\n             ball = moveToFrontBall(extreme, extreme.size(), support);\n             if (ball.getRadius() < savedBall.getRadius()) {\n-                // TODO: fix this, it should never happen but it does!\n+                // this should never happen\n                 throw new MathInternalError();\n             }\n \ndiff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SphereGenerator.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SphereGenerator.java\nindex 03e445089..f5a6b7c95 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SphereGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SphereGenerator.java\n@@ -19,12 +19,13 @@\n import java.util.Arrays;\n import java.util.List;\n \n+import org.apache.commons.math3.fraction.BigFraction;\n import org.apache.commons.math3.geometry.enclosing.EnclosingBall;\n import org.apache.commons.math3.geometry.enclosing.SupportBallGenerator;\n import org.apache.commons.math3.geometry.euclidean.twod.DiskGenerator;\n import org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D;\n import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;\n-import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.util.FastMath;\n \n /** Class generating an enclosing ball from its support points.\n  * @version $Id$\n@@ -88,24 +89,39 @@\n                         //      z_0 = +m_14 / (2 m_11)\n                         // Note that the minors m_11, m_12, m_13 and m_14 all have the last column\n                         // filled with 1.0, hence simplifying the computation\n-                        final double[] c1 = new double[] {\n-                            vA.getNormSq(), vB.getNormSq(), vC.getNormSq(), vD.getNormSq()\n+                        final BigFraction[] c2 = new BigFraction[] {\n+                            new BigFraction(vA.getX()), new BigFraction(vB.getX()),\n+                            new BigFraction(vC.getX()), new BigFraction(vD.getX())\n                         };\n-                        final double[] c2 = new double[] {\n-                            vA.getX(), vB.getX(), vC.getX(), vD.getX()\n+                        final BigFraction[] c3 = new BigFraction[] {\n+                            new BigFraction(vA.getY()), new BigFraction(vB.getY()),\n+                            new BigFraction(vC.getY()), new BigFraction(vD.getY())\n                         };\n-                        final double[] c3 = new double[] {\n-                            vA.getY(), vB.getY(), vC.getY(), vD.getY()\n+                        final BigFraction[] c4 = new BigFraction[] {\n+                            new BigFraction(vA.getZ()), new BigFraction(vB.getZ()),\n+                            new BigFraction(vC.getZ()), new BigFraction(vD.getZ())\n                         };\n-                        final double[] c4 = new double[] {\n-                            vA.getZ(), vB.getZ(), vC.getZ(), vD.getZ()\n+                        final BigFraction[] c1 = new BigFraction[] {\n+                            c2[0].multiply(c2[0]).add(c3[0].multiply(c3[0])).add(c4[0].multiply(c4[0])),\n+                            c2[1].multiply(c2[1]).add(c3[1].multiply(c3[1])).add(c4[1].multiply(c4[1])),\n+                            c2[2].multiply(c2[2]).add(c3[2].multiply(c3[2])).add(c4[2].multiply(c4[2])),\n+                            c2[3].multiply(c2[3]).add(c3[3].multiply(c3[3])).add(c4[3].multiply(c4[3]))\n                         };\n-                        final double m11 = minor(c2, c3, c4);\n-                        final double m12 = minor(c1, c3, c4);\n-                        final double m13 = minor(c1, c2, c4);\n-                        final double m14 = minor(c1, c2, c3);\n-                        final Vector3D center = new Vector3D(0.5 * m12 / m11, -0.5 * m13 / m11, 0.5 * m14 / m11);\n-                        return new EnclosingBall<Euclidean3D, Vector3D>(center, center.distance(vA),\n+                        final BigFraction twoM11  = minor(c2, c3, c4).multiply(2);\n+                        final BigFraction m12     = minor(c1, c3, c4);\n+                        final BigFraction m13     = minor(c1, c2, c4);\n+                        final BigFraction m14     = minor(c1, c2, c3);\n+                        final BigFraction centerX = m12.divide(twoM11);\n+                        final BigFraction centerY = m13.divide(twoM11).negate();\n+                        final BigFraction centerZ = m14.divide(twoM11);\n+                        final BigFraction dx      = c2[0].subtract(centerX);\n+                        final BigFraction dy      = c3[0].subtract(centerY);\n+                        final BigFraction dz      = c4[0].subtract(centerZ);\n+                        final BigFraction r2      = dx.multiply(dx).add(dy.multiply(dy)).add(dz.multiply(dz));\n+                        return new EnclosingBall<Euclidean3D, Vector3D>(new Vector3D(centerX.doubleValue(),\n+                                                                                     centerY.doubleValue(),\n+                                                                                     centerZ.doubleValue()),\n+                                                                        FastMath.sqrt(r2.doubleValue()),\n                                                                         vA, vB, vC, vD);\n                     }\n                 }\n@@ -114,41 +130,24 @@\n     }\n \n     /** Compute a dimension 4 minor, when 4<sup>th</sup> column is known to be filled with 1.0.\n-     * <p>\n-     * The computation is performed using {@link MathArrays#linearCombination(double[], double[])\n-     * high accuracy sum of products}, trying to avoid cancellations effect. This should reduce\n-     * risks in case of near co-planar points.\n-     * </p>\n      * @param c1 first column\n      * @param c2 second column\n      * @param c3 third column\n-     * @return value of the minor computed to high accuracy\n+     * @return value of the minor computed has an exact fraction\n      */\n-    private double minor(final double[] c1, final double[] c2, final double[] c3) {\n-        final double m01 = c2[0] * c3[1];\n-        final double m02 = c2[0] * c3[2];\n-        final double m03 = c2[0] * c3[3];\n-        final double m10 = c2[1] * c3[0];\n-        final double m12 = c2[1] * c3[2];\n-        final double m13 = c2[1] * c3[3];\n-        final double m20 = c2[2] * c3[0];\n-        final double m21 = c2[2] * c3[1];\n-        final double m23 = c2[2] * c3[3];\n-        final double m30 = c2[3] * c3[0];\n-        final double m31 = c2[3] * c3[1];\n-        final double m32 = c2[3] * c3[2];\n-        return MathArrays.linearCombination(new double[] {\n-                                                c1[2], c1[1], c1[3], -c1[1], -c1[3], -c1[2],\n-                                                c1[0], c1[3], c1[2], -c1[3], -c1[0], -c1[2],\n-                                                c1[1], c1[0], c1[3], -c1[0], -c1[3], -c1[1],\n-                                                c1[0], c1[2], c1[1], -c1[2], -c1[0], -c1[1]\n-                                            },\n-                                            new double[] {\n-                                                m13, m32, m21, m23, m12, m31,\n-                                                m23, m02, m30, m20, m32, m03,\n-                                                m03, m31, m10, m13, m01, m30,\n-                                                m12, m01, m20, m10, m21, m02\n-                                            });\n+    private BigFraction minor(final BigFraction[] c1, final BigFraction[] c2, final BigFraction[] c3) {\n+        return      c2[0].multiply(c3[1]).multiply(c1[2].subtract(c1[3])).\n+                add(c2[0].multiply(c3[2]).multiply(c1[3].subtract(c1[1]))).\n+                add(c2[0].multiply(c3[3]).multiply(c1[1].subtract(c1[2]))).\n+                add(c2[1].multiply(c3[0]).multiply(c1[3].subtract(c1[2]))).\n+                add(c2[1].multiply(c3[2]).multiply(c1[0].subtract(c1[3]))).\n+                add(c2[1].multiply(c3[3]).multiply(c1[2].subtract(c1[0]))).\n+                add(c2[2].multiply(c3[0]).multiply(c1[1].subtract(c1[3]))).\n+                add(c2[2].multiply(c3[1]).multiply(c1[3].subtract(c1[0]))).\n+                add(c2[2].multiply(c3[3]).multiply(c1[0].subtract(c1[1]))).\n+                add(c2[3].multiply(c3[0]).multiply(c1[2].subtract(c1[1]))).\n+                add(c2[3].multiply(c3[1]).multiply(c1[0].subtract(c1[2]))).\n+                add(c2[3].multiply(c3[2]).multiply(c1[1].subtract(c1[0])));\n     }\n \n }\ndiff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/DiskGenerator.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/DiskGenerator.java\nindex 514df1458..d06c013cd 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/DiskGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/DiskGenerator.java\n@@ -18,9 +18,10 @@\n \n import java.util.List;\n \n+import org.apache.commons.math3.fraction.BigFraction;\n import org.apache.commons.math3.geometry.enclosing.EnclosingBall;\n import org.apache.commons.math3.geometry.enclosing.SupportBallGenerator;\n-import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.util.FastMath;\n \n /** Class generating an enclosing ball from its support points.\n  * @version $Id$\n@@ -66,42 +67,43 @@\n                     //      y_0 = -m_13 / (2 m_11)\n                     // Note that the minors m_11, m_12 and m_13 all have the last column\n                     // filled with 1.0, hence simplifying the computation\n-                    final double[] c1 = new double[] {\n-                        vA.getNormSq(), vB.getNormSq(), vC.getNormSq()\n+                    final BigFraction[] c2 = new BigFraction[] {\n+                        new BigFraction(vA.getX()), new BigFraction(vB.getX()), new BigFraction(vC.getX())\n                     };\n-                    final double[] c2 = new double[] {\n-                        vA.getX(), vB.getX(), vC.getX()\n+                    final BigFraction[] c3 = new BigFraction[] {\n+                        new BigFraction(vA.getY()), new BigFraction(vB.getY()), new BigFraction(vC.getY())\n                     };\n-                    final double[] c3 = new double[] {\n-                        vA.getY(), vB.getY(), vC.getY()\n+                    final BigFraction[] c1 = new BigFraction[] {\n+                        c2[0].multiply(c2[0]).add(c3[0].multiply(c3[0])),\n+                        c2[1].multiply(c2[1]).add(c3[1].multiply(c3[1])),\n+                        c2[2].multiply(c2[2]).add(c3[2].multiply(c3[2]))\n                     };\n-                    final double m11 = minor(c2, c3);\n-                    final double m12 = minor(c1, c3);\n-                    final double m13 = minor(c1, c2);\n-                    final Vector2D center = new Vector2D(0.5 * m12 / m11, -0.5 * m13 / m11);\n-                    return new EnclosingBall<Euclidean2D, Vector2D>(center, center.distance(vA), vA, vB, vC);\n+                    final BigFraction twoM11  = minor(c2, c3).multiply(2);\n+                    final BigFraction m12     = minor(c1, c3);\n+                    final BigFraction m13     = minor(c1, c2);\n+                    final BigFraction centerX = m12.divide(twoM11);\n+                    final BigFraction centerY = m13.divide(twoM11).negate();\n+                    final BigFraction dx      = c2[0].subtract(centerX);\n+                    final BigFraction dy      = c3[0].subtract(centerY);\n+                    final BigFraction r2      = dx.multiply(dx).add(dy.multiply(dy));\n+                    return new EnclosingBall<Euclidean2D, Vector2D>(new Vector2D(centerX.doubleValue(),\n+                                                                                 centerY.doubleValue()),\n+                                                                    FastMath.sqrt(r2.doubleValue()),\n+                                                                    vA, vB, vC);\n                 }\n             }\n         }\n     }\n \n     /** Compute a dimension 3 minor, when 3<sup>d</sup> column is known to be filled with 1.0.\n-     * <p>\n-     * The computation is performed using {@link MathArrays#linearCombination(double[], double[])\n-     * high accuracy sum of products}, trying to avoid cancellations effect. This should reduce\n-     * risks in case of near co-planar points.\n-     * </p>\n      * @param c1 first column\n      * @param c2 second column\n-     * @return value of the minor computed to high accuracy\n+     * @return value of the minor computed has an exact fraction\n      */\n-    private double minor(final double[] c1, final double[] c2) {\n-        return MathArrays.linearCombination(new double[] {\n-                                                c1[0], c1[2], c1[1], -c1[2], -c1[0], -c1[1]\n-                                            },\n-                                            new double[] {\n-                                                c2[1], c2[0], c2[2],  c2[1],  c2[2],  c2[0]\n-                                            });\n+    private BigFraction minor(final BigFraction[] c1, final BigFraction[] c2) {\n+        return      c2[0].multiply(c1[2].subtract(c1[1])).\n+                add(c2[1].multiply(c1[0].subtract(c1[2]))).\n+                add(c2[2].multiply(c1[1].subtract(c1[0])));\n     }\n \n }\n",
        "project": "commons-math",
        "linesAdd": 70,
        "jira_id": "1096",
        "nb_skipped": 5,
        "commit": "19c1c3bb",
        "nb_failure": 1,
        "linesRem": 59,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3197,
        "nb_error": 0,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.commons.math.random.ISAACTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/random/ISAACRandom.java b/src/main/java/org/apache/commons/math/random/ISAACRandom.java\nindex 3db6de1be..011a70454 100644\n--- a/src/main/java/org/apache/commons/math/random/ISAACRandom.java\n+++ b/src/main/java/org/apache/commons/math/random/ISAACRandom.java\n@@ -235,6 +235,7 @@ private void initState() {\n         }\n         isaac();\n         count = SIZE - 1;\n+        clear();\n     }\n \n     /** Shuffle array. */\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "723",
        "nb_skipped": 1,
        "commit": "1352a70f",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": true
    },
    {
        "files": 1,
        "nb_test": 4919,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.complex.ComplexTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/complex/Complex.java b/src/main/java/org/apache/commons/math3/complex/Complex.java\nindex 22b23f24e..ac8185b17 100644\n--- a/src/main/java/org/apache/commons/math3/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math3/complex/Complex.java\n@@ -302,7 +302,7 @@ public Complex reciprocal() {\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+            return INF;\n         }\n \n         if (isInfinite) {\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "934",
        "nb_skipped": 4,
        "commit": "724795b5",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 2209,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.distribution.NormalDistributionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\nindex 456555bf3..0d7ce7da3 100644\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n@@ -114,26 +114,20 @@ public double density(double x) {\n \n     /**\n      * For this distribution, {@code X}, this method returns {@code P(X < x)}.\n+     * If {@code x}is more than 40 standard deviations from the mean, 0 or 1 is returned,\n+     * as in these cases the actual value is within {@code Double.MIN_VALUE} of 0 or 1.\n      *\n      * @param x Value at which the CDF is evaluated.\n      * @return CDF evaluated at {@code x}.\n-     * @throws MathException if the algorithm fails to converge; unless\n-     * {@code x} is more than 20 standard deviations from the mean, in which\n-     * case the convergence exception is caught and 0 or 1 is returned.\n+     * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n-        try {\n-            return 0.5 * (1.0 + Erf.erf((x - mean) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n+        final double dev = x - mean;\n+        if (FastMath.abs(dev) > 40 * standardDeviation) { \n+            return dev < 0 ? 0.0d : 1.0d;\n         }\n+        return 0.5 * (1.0 + Erf.erf((dev) /\n+                    (standardDeviation * FastMath.sqrt(2.0))));\n     }\n \n     /**\n",
        "project": "commons-math",
        "linesAdd": 5,
        "jira_id": "414",
        "nb_skipped": 1,
        "commit": "5fe9b36c",
        "nb_failure": 0,
        "linesRem": 11,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5823,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math4.distribution.NormalDistributionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math4/distribution/NormalDistribution.java b/src/main/java/org/apache/commons/math4/distribution/NormalDistribution.java\nindex 6313ef04d..52168672a 100644\n--- a/src/main/java/org/apache/commons/math4/distribution/NormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math4/distribution/NormalDistribution.java\n@@ -193,7 +193,7 @@ public double cumulativeProbability(double x)  {\n         if (FastMath.abs(dev) > 40 * standardDeviation) {\n             return dev < 0 ? 0.0d : 1.0d;\n         }\n-        return 0.5 * (1 + Erf.erf(dev / (standardDeviation * SQRT2)));\n+        return 0.5 * Erf.erfc(-dev / (standardDeviation * SQRT2));\n     }\n \n     /** {@inheritDoc}\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "1257",
        "nb_skipped": 3,
        "commit": "03178c8b",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 6076,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.distribution.BinomialDistributionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/distribution/BinomialDistribution.java b/src/main/java/org/apache/commons/math3/distribution/BinomialDistribution.java\nindex 15747e13e..9a882a05b 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/BinomialDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/BinomialDistribution.java\n@@ -106,6 +106,9 @@ public double probability(int x) {\n     /** {@inheritDoc} **/\n     @Override\n     public double logProbability(int x) {\n+        if (numberOfTrials == 0) {\n+            return (x == 0) ? 0. : Double.NEGATIVE_INFINITY;\n+        }\n         double ret;\n         if (x < 0 || x > numberOfTrials) {\n             ret = Double.NEGATIVE_INFINITY;\n",
        "project": "commons-math",
        "linesAdd": 3,
        "jira_id": "1136",
        "nb_skipped": 3,
        "commit": "cc4ab51e",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 5478,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.optim.linear.SimplexSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/optim/linear/LinearConstraintSet.java b/src/main/java/org/apache/commons/math3/optim/linear/LinearConstraintSet.java\nindex cf5279a34..b2a120996 100644\n--- a/src/main/java/org/apache/commons/math3/optim/linear/LinearConstraintSet.java\n+++ b/src/main/java/org/apache/commons/math3/optim/linear/LinearConstraintSet.java\n@@ -16,10 +16,11 @@\n  */\n package org.apache.commons.math3.optim.linear;\n \n+import java.util.LinkedHashSet;\n import java.util.Set;\n-import java.util.HashSet;\n import java.util.Collection;\n import java.util.Collections;\n+\n import org.apache.commons.math3.optim.OptimizationData;\n \n /**\n@@ -30,8 +31,7 @@\n  */\n public class LinearConstraintSet implements OptimizationData {\n     /** Set of constraints. */\n-    private final Set<LinearConstraint> linearConstraints\n-        = new HashSet<LinearConstraint>();\n+    private final Set<LinearConstraint> linearConstraints = new LinkedHashSet<LinearConstraint>();\n \n     /**\n      * Creates a set containing the given constraints.\n",
        "project": "commons-math",
        "linesAdd": 3,
        "jira_id": "1080",
        "nb_skipped": 5,
        "commit": "b285f170",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2169,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.stat.correlation.SpearmansRankCorrelationTest",
            "org.apache.commons.math.stat.correlation.PearsonsCorrelationTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java b/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\nindex 83b4c4130..dc83314f6 100644\n--- a/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n@@ -168,7 +168,7 @@ public RealMatrix getCorrelationPValues() throws MathException {\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);\n                 }\n             }\n         }\n",
        "project": "commons-math",
        "linesAdd": 1,
        "jira_id": "371",
        "nb_skipped": 0,
        "commit": "bb005b56",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2040,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.optimization.linear.SimplexSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex c228ad62d..b38776718 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -270,8 +270,27 @@ protected static double getInvertedCoeffiecientSum(final RealVector coefficients\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n+        return getBasicRow(col, true);\n+    }\n+\n+    /**\n+     * Checks whether the given column is basic.\n+     * @param col index of the column to check\n+     * @return the row that the variable is basic in.  null if the column is not basic\n+     */\n+    private Integer getBasicRowForSolution(final int col) {\n+        return getBasicRow(col, false);\n+    }\n+    \n+    /**\n+     * Checks whether the given column is basic.\n+     * @param col index of the column to check\n+     * @return the row that the variable is basic in.  null if the column is not basic\n+     */\n+    private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\n         Integer row = null;\n-        for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n+        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;\n+        for (int i = start; i < getHeight(); i++) {\n             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;\n             } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n@@ -319,12 +338,11 @@ private void copyArray(final double[] src, final double[] dest,\n      */\n     protected RealPointValuePair getSolution() {\n       double[] coefficients = new double[getOriginalNumDecisionVariables()];\n-        Integer basicRow =\n-            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n-        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n+      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());\n+      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n       Set<Integer> basicRows = new HashSet<Integer>();\n       for (int i = 0; i < coefficients.length; i++) {\n-            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n+          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);\n           if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value \n               // then we choose the first and set the rest equal to 0\n@@ -431,6 +449,15 @@ protected final int getRhsOffset() {\n         return getWidth() - 1;\n     }\n     \n+    /**\n+     * Returns the offset of the extra decision variable added when there is a\n+     * negative decision variable in the original problem.\n+     * @return the offset of x-\n+     */\n+    protected final int getNegativeDecisionVariableOffset() {\n+      return getNumObjectiveFunctions() + getOriginalNumDecisionVariables();\n+    }\n+\n     /**\n      * Get the number of decision variables.\n      * <p>\n",
        "project": "commons-math",
        "linesAdd": 17,
        "jira_id": "286",
        "nb_skipped": 0,
        "commit": "dbdff075",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 5196,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.fraction.BigFractionTest",
            "org.apache.commons.math3.fraction.FractionTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/fraction/BigFraction.java b/src/main/java/org/apache/commons/math3/fraction/BigFraction.java\nindex 5b0a6b4ce..4ca33eb04 100644\n--- a/src/main/java/org/apache/commons/math3/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/BigFraction.java\n@@ -301,6 +301,11 @@ private BigFraction(final double value, final double epsilon,\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n             if ((p2 > overflow) || (q2 > overflow)) {\n+                // in maxDenominator mode, if the last fraction was very close to the actual value\n+                // q2 may overflow in the next iteration; in this case return the last one.\n+                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n+                    break;\n+                }\n                 throw new FractionConversionException(value, p2, q2);\n             }\n \ndiff --git a/src/main/java/org/apache/commons/math3/fraction/Fraction.java b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\nindex 08d3b9556..002dae934 100644\n--- a/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n@@ -83,6 +83,9 @@\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 3698073679419233275L;\n \n+    /** The default epsilon used for convergence. */\n+    private static final double DEFAULT_EPSILON = 1e-5;\n+\n     /** The denominator. */\n     private final int denominator;\n \n@@ -96,7 +99,7 @@\n      *         converge.\n      */\n     public Fraction(double value) throws FractionConversionException {\n-        this(value, 1.0e-5, 100);\n+        this(value, DEFAULT_EPSILON, 100);\n     }\n \n     /**\n@@ -182,8 +185,7 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             throw new FractionConversionException(value, a0, 1l);\n         }\n \n-        // check for (almost) integer arguments, which should not go\n-        // to iterations.\n+        // check for (almost) integer arguments, which should not go to iterations.\n         if (FastMath.abs(a0 - value) < epsilon) {\n             this.numerator = (int) a0;\n             this.denominator = 1;\n@@ -206,7 +208,13 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat\n             long a1 = (long)FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n+\n             if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n+                // in maxDenominator mode, if the last fraction was very close to the actual value\n+                // q2 may overflow in the next iteration; in this case return the last one.\n+                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n+                    break;\n+                }\n                 throw new FractionConversionException(value, p2, q2);\n             }\n \n",
        "project": "commons-math",
        "linesAdd": 10,
        "jira_id": "996",
        "nb_skipped": 4,
        "commit": "86545dab",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4170,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSetTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\nindex 9bd9daef6..9cb82def4 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n@@ -111,6 +111,20 @@ public PolygonsSet(final double xMin, final double xMax,\n      * constructor} using {@link SubHyperplane subhyperplanes}.</p>\n      * <p>If the list is empty, the region will represent the whole\n      * space.</p>\n+     * <p>\n+     * Polygons with thin pikes or dents are inherently difficult to handle because\n+     * they involve lines with almost opposite directions at some vertices. Polygons\n+     * whose vertices come from some physical measurement with noise are also\n+     * difficult because an edge that should be straight may be broken in lots of\n+     * different pieces with almost equal directions. In both cases, computing the\n+     * lines intersections is not numerically robust due to the almost 0 or almost\n+     * &pi; angle. Such cases need to carefully adjust the {@code hyperplaneThickness}\n+     * parameter. A too small value would often lead to completely wrong polygons\n+     * with large area wrongly identified as inside or outside. Large values are\n+     * often much safer. As a rule of thumb, a value slightly below the size of the\n+     * most accurate detail needed is a good value for the {@code hyperplaneThickness}\n+     * parameter.\n+     * </p>\n      * @param hyperplaneThickness tolerance below which points are considered to\n      * belong to the hyperplane (which is therefore more a slab)\n      * @param vertices vertices of the simple loop boundary\n@@ -157,20 +171,50 @@ public PolygonsSet(final double hyperplaneThickness, final Vector2D ... vertices\n     private static BSPTree<Euclidean2D> verticesToTree(final double hyperplaneThickness,\n                                                        final Vector2D ... vertices) {\n \n-        if (vertices.length == 0) {\n+        final int n = vertices.length;\n+        if (n == 0) {\n             // the tree represents the whole space\n             return new BSPTree<Euclidean2D>(Boolean.TRUE);\n         }\n \n-        // at start, none of the edges have been processed\n-        final BSPTree<Euclidean2D> tree = new BSPTree<Euclidean2D>();\n-        List<Vertex> list = new ArrayList<PolygonsSet.Vertex>(vertices.length);\n-        for (final Vector2D vertex : vertices) {\n-            list.add(new Vertex(vertex));\n+        // build the vertices\n+        final Vertex[] vArray = new Vertex[n];\n+        for (int i = 0; i < n; ++i) {\n+            vArray[i] = new Vertex(vertices[i]);\n+        }\n+\n+        // build the edges\n+        List<Edge> edges = new ArrayList<Edge>();\n+        for (int i = 0; i < n; ++i) {\n+\n+            // get the endpoints of the edge\n+            final Vertex start = vArray[i];\n+            final Vertex end   = vArray[(i + 1) % n];\n+\n+            // get the line supporting the edge, taking care not to recreate it\n+            // if it was already created earlier due to another edge being aligned\n+            // with the current one\n+            Line line = start.sharedLineWith(end);\n+            if (line == null) {\n+                line = new Line(start.getLocation(), end.getLocation());\n+            }\n+\n+            // create the edge and store it\n+            edges.add(new Edge(start, end, line));\n+\n+            // check if another vertex also happens to be on this line\n+            for (final Vertex vertex : vArray) {\n+                if (vertex != start && vertex != end &&\n+                    FastMath.abs(line.getOffset(vertex.getLocation())) <= hyperplaneThickness) {\n+                    vertex.bindWith(line);\n+                }\n+            }\n+\n         }\n \n         // build the tree top-down\n-        insertVertices(hyperplaneThickness, tree, list);\n+        final BSPTree<Euclidean2D> tree = new BSPTree<Euclidean2D>();\n+        insertEdges(hyperplaneThickness, tree, edges);\n \n         return tree;\n \n@@ -181,45 +225,32 @@ public PolygonsSet(final double hyperplaneThickness, final Vector2D ... vertices\n      * belong to the hyperplane (which is therefore more a slab)\n      * @param node current tree node (it is a leaf node at the beginning\n      * of the call)\n-     * @param vertices list of vertices belonging to the boundary of the\n-     * cell defined by the node\n+     * @param edges list of edges to insert in the cell defined by this node\n+     * (excluding edges not belonging to the cell defined by this node)\n      */\n-    private static void insertVertices(final double hyperplaneThickness,\n+    private static void insertEdges(final double hyperplaneThickness,\n                                     final BSPTree<Euclidean2D> node,\n-                                       final List<Vertex> vertices) {\n+                                    final List<Edge> edges) {\n \n-        Vertex current = vertices.get(vertices.size() - 1);\n+        // find an edge with an hyperplane that can be inserted in the node\n         int index = 0;\n-        Line inserted = null;\n-        while (inserted == null && index < vertices.size()) {\n-            final Vertex previous = current;\n-            current = vertices.get(index++);\n-            if (previous.outgoingNeedsProcessing() && current.incomingNeedsProcessing()) {\n-\n-                if (previous.shareNodeWith(current)) {\n-                    // both vertices are already handled by an existing node,\n-                    // closer to the tree root, they were probably created\n-                    // when split points were introduced\n-                    inserted = null;\n-                } else {\n-\n-                    inserted = new Line(previous.getLocation(), current.getLocation());\n-\n-                    if (node.insertCut(inserted)) {\n-                        previous.addNode(node);\n-                        previous.outgoingProcessed();\n-                        current.addNode(node);\n-                        current.incomingProcessed();\n+        Edge inserted =null;\n+        while (inserted == null && index < edges.size()) {\n+            inserted = edges.get(index++);\n+            if (inserted.getNode() == null) {\n+                if (node.insertCut(inserted.getLine())) {\n+                    inserted.setNode(node);\n                 } else {\n                     inserted = null;\n                 }\n-\n-                }\n-\n+            } else {\n+                inserted = null;\n             }\n         }\n \n-        if (node.getCut() == null) {\n+        if (inserted == null) {\n+            // no suitable edge was found, the node remains a leaf node\n+            // we need to set its inside/outside boolean indicator\n             final BSPTree<Euclidean2D> parent = node.getParent();\n             if (parent == null || node == parent.getMinus()) {\n                 node.setAttribute(Boolean.TRUE);\n@@ -229,67 +260,58 @@ private static void insertVertices(final double hyperplaneThickness,\n             return;\n         }\n \n-        // distribute the remaining vertices in the two sub-trees\n-        Side currentSide = Side.HYPER;\n-        final List<Vertex> plusList  = new ArrayList<Vertex>();\n-        plusList.add(current);\n-        int plusCount = 0;\n-        final List<Vertex> minusList = new ArrayList<Vertex>();\n-        minusList.add(current);\n-        int minusCount = 0;\n-        while (index < vertices.size()) {\n-            final Vertex previous = current;\n-            final Side previousSide = currentSide;\n-            current = vertices.get(index++);\n-            final double currentOffset = inserted.getOffset(current.getLocation());\n-            currentSide = (FastMath.abs(currentOffset) <= hyperplaneThickness) ?\n-                           Side.HYPER :\n-                           ((currentOffset < 0) ? Side.MINUS : Side.PLUS);\n-            switch (currentSide) {\n+        // we have split the node by inserted an edge as a cut sub-hyperplane\n+        // distribute the remaining edges in the two sub-trees\n+        final List<Edge> plusList  = new ArrayList<Edge>();\n+        final List<Edge> minusList = new ArrayList<Edge>();\n+        for (final Edge edge : edges) {\n+            if (edge != inserted) {\n+                final double startOffset = inserted.getLine().getOffset(edge.getStart().getLocation());\n+                final double endOffset   = inserted.getLine().getOffset(edge.getEnd().getLocation());\n+                Side startSide = (FastMath.abs(startOffset) <= hyperplaneThickness) ?\n+                                 Side.HYPER : ((startOffset < 0) ? Side.MINUS : Side.PLUS);\n+                Side endSide   = (FastMath.abs(endOffset) <= hyperplaneThickness) ?\n+                                 Side.HYPER : ((endOffset < 0) ? Side.MINUS : Side.PLUS);\n+                switch (startSide) {\n                     case PLUS:\n-                if (previousSide == Side.MINUS) {\n+                        if (endSide == Side.MINUS) {\n                             // we need to insert a split point on the hyperplane\n-                    final Line line = new Line(previous.getLocation(), current.getLocation());\n-                    final Vertex splitPoint = new Vertex(inserted.intersection(line));\n-                    splitPoint.addNode(node);\n-                    minusList.add(splitPoint);\n-                    plusList.add(splitPoint);\n-                }\n-                plusList.add(current);\n-                if (current.incomingNeedsProcessing() || current.outgoingNeedsProcessing()) {\n-                    ++plusCount;\n+                            final Vertex splitPoint = edge.split(inserted.getLine());\n+                            minusList.add(splitPoint.getOutgoing());\n+                            plusList.add(splitPoint.getIncoming());\n+                        } else {\n+                            plusList.add(edge);\n                         }\n                         break;\n                     case MINUS:\n-                if (previousSide == Side.PLUS) {\n+                        if (endSide == Side.PLUS) {\n                             // we need to insert a split point on the hyperplane\n-                    final Line line = new Line(previous.getLocation(), current.getLocation());\n-                    final Vertex splitPoint = new Vertex(inserted.intersection(line));\n-                    splitPoint.addNode(node);\n-                    minusList.add(splitPoint);\n-                    plusList.add(splitPoint);\n-                }\n-                minusList.add(current);\n-                if (current.incomingNeedsProcessing() || current.outgoingNeedsProcessing()) {\n-                    ++minusCount;\n+                            final Vertex splitPoint = edge.split(inserted.getLine());\n+                            minusList.add(splitPoint.getIncoming());\n+                            plusList.add(splitPoint.getOutgoing());\n+                        } else {\n+                            minusList.add(edge);\n                         }\n                         break;\n                     default:\n-                current.addNode(node);\n-                plusList.add(current);\n-                minusList.add(current);\n+                        if (endSide == Side.PLUS) {\n+                            plusList.add(edge);\n+                        } else if (endSide == Side.MINUS) {\n+                            minusList.add(edge);\n+                        }\n                         break;\n                 }\n             }\n+        }\n \n         // recurse through lower levels\n-        if (plusCount > 0) {\n-            insertVertices(hyperplaneThickness, node.getPlus(),  plusList);\n+        if (!plusList.isEmpty()) {\n+            insertEdges(hyperplaneThickness, node.getPlus(),  plusList);\n         } else {\n             node.getPlus().setAttribute(Boolean.FALSE);\n         }\n-        if (minusCount > 0) {\n-            insertVertices(hyperplaneThickness, node.getMinus(), minusList);\n+        if (!minusList.isEmpty()) {\n+            insertEdges(hyperplaneThickness, node.getMinus(), minusList);\n         } else {\n             node.getMinus().setAttribute(Boolean.TRUE);\n         }\n@@ -302,23 +324,23 @@ private static void insertVertices(final double hyperplaneThickness,\n         /** Vertex location. */\n         private final Vector2D location;\n \n-        /** Nodes associated with the hyperplane containing this vertex. */\n-        private final List<BSPTree<Euclidean2D>> nodes;\n+        /** Incoming edge. */\n+        private Edge incoming;\n \n-        /** Indicator for incoming edges that still need processing. */\n-        private boolean incomingNeedsProcessing;\n+        /** Outgoing edge. */\n+        private Edge outgoing;\n \n-        /** Indicator for outgoing edges that still need processing. */\n-        private boolean outgoingNeedsProcessing;\n+        /** Lines bound with this vertex. */\n+        private final List<Line> lines;\n \n         /** Build a non-processed vertex not owned by any node yet.\n          * @param location vertex location\n          */\n         public Vertex(final Vector2D location) {\n             this.location = location;\n-            this.nodes                   = new ArrayList<BSPTree<Euclidean2D>>();\n-            this.incomingNeedsProcessing = true;\n-            this.outgoingNeedsProcessing = true;\n+            this.incoming = null;\n+            this.outgoing = null;\n+            this.lines    = new ArrayList<Line>();\n         }\n \n         /** Get Vertex location.\n@@ -328,57 +350,160 @@ public Vector2D getLocation() {\n             return location;\n         }\n \n-        /** Check if the instance and another vertex share a node.\n+        /** Bind a line considered to contain this vertex.\n+         * @param line line to bind with this vertex\n+         */\n+        public void bindWith(final Line line) {\n+            lines.add(line);\n+        }\n+\n+        /** Get the common line bound with both the instance and another vertex, if any.\n          * <p>\n-         * When two vertices share a node, this means they are already handled\n-         * by the hyperplane of this node, so there is no need to create a cut\n-         * hyperplane for them.\n+         * When two vertices are both bound to the same line, this means they are\n+         * already handled by node associated with this line, so there is no need\n+         * to create a cut hyperplane for them.\n          * </p>\n          * @param vertex other vertex to check instance against\n-         * @return true if the instance and another vertex share a node\n+         * @return line bound with both the instance and another vertex, or null if the\n+         * two vertices do not share a line yet\n          */\n-        public boolean shareNodeWith(final Vertex vertex) {\n-            for (final BSPTree<Euclidean2D> node1 : nodes) {\n-                for (final BSPTree<Euclidean2D> node2 : vertex.nodes) {\n-                    if (node1 == node2) {\n-                        return true;\n+        public Line sharedLineWith(final Vertex vertex) {\n+            for (final Line line1 : lines) {\n+                for (final Line line2 : vertex.lines) {\n+                    if (line1 == line2) {\n+                        return line1;\n                     }\n                 }\n             }\n-            return false;\n+            return null;\n         }\n \n-        /** Add a node whose hyperplane contains this vertex.\n-         * @param node node whose hyperplane contains this vertex\n+        /** Set incoming edge.\n+         * <p>\n+         * The line supporting the incoming edge is automatically bound\n+         * with the instance.\n+         * </p>\n+         * @param incoming incoming edge\n+         */\n+        public void setIncoming(final Edge incoming) {\n+            this.incoming = incoming;\n+            bindWith(incoming.getLine());\n+        }\n+\n+        /** Get incoming edge.\n+         * @return incoming edge\n+         */\n+        public Edge getIncoming() {\n+            return incoming;\n+        }\n+\n+        /** Set outgoing edge.\n+         * <p>\n+         * The line supporting the outgoing edge is automatically bound\n+         * with the instance.\n+         * </p>\n+         * @param incoming outgoing edge\n+         */\n+        public void setOutgoing(final Edge outgoing) {\n+            this.outgoing = outgoing;\n+            bindWith(outgoing.getLine());\n+        }\n+\n+        /** Get outgoing edge.\n+         * @return outgoing edge\n+         */\n+        public Edge getOutgoing() {\n+            return outgoing;\n+        }\n+\n+    }\n+\n+    /** Internal class for holding edges while they are processed to build a BSP tree. */\n+    private static class Edge {\n+\n+        /** Start vertex. */\n+        private final Vertex start;\n+\n+        /** End vertex. */\n+        private final Vertex end;\n+\n+        /** Line supporting the edge. */\n+        private final Line line;\n+\n+        /** Node whose cut hyperplane contains this edge. */\n+        private BSPTree<Euclidean2D> node;\n+\n+        /** Build an edge not contained in any node yet.\n+         * @param start start vertex\n+         * @param end end vertex\n+         * @param line line supporting the edge\n          */\n-        public void addNode(final BSPTree<Euclidean2D> node) {\n-            nodes.add(node);\n+        public Edge(final Vertex start, final Vertex end, final Line line) {\n+\n+            this.start = start;\n+            this.end   = end;\n+            this.line  = line;\n+            this.node  = null;\n+\n+            // connect the vertices back to the edge\n+            start.setOutgoing(this);\n+            end.setIncoming(this);\n+\n         }\n \n-        /** Check incoming edge processed indicator.\n-         * @return true if incoming edge needs processing\n+        /** Get start vertex.\n+         * @return start vertex\n          */\n-        public boolean incomingNeedsProcessing() {\n-            return incomingNeedsProcessing;\n+        public Vertex getStart() {\n+            return start;\n         }\n \n-        /** Check outgoing edge processed indicator.\n-         * @return true if outgoing edge needs processing\n+        /** Get end vertex.\n+         * @return end vertex\n          */\n-        public boolean outgoingNeedsProcessing() {\n-            return outgoingNeedsProcessing;\n+        public Vertex getEnd() {\n+            return end;\n         }\n \n-        /** Mark the incoming edge as processed.\n+        /** Get the line supporting this edge.\n+         * @return line supporting this edge\n          */\n-        public void incomingProcessed() {\n-            incomingNeedsProcessing = false;\n+        public Line getLine() {\n+            return line;\n         }\n \n-        /** Mark the outgoing edge as processed.\n+        /** Set the node whose cut hyperplane contains this edge.\n+         * @param node node whose cut hyperplane contains this edge\n+         */\n+        public void setNode(final BSPTree<Euclidean2D> node) {\n+            this.node = node;\n+        }\n+\n+        /** Get the node whose cut hyperplane contains this edge.\n+         * @return node whose cut hyperplane contains this edge\n+         * (null if edge has not yet been inserted into the BSP tree)\n+         */\n+        public BSPTree<Euclidean2D> getNode() {\n+            return node;\n+        }\n+\n+        /** Split the edge.\n+         * <p>\n+         * Once split, this edge is not referenced anymore by the vertices,\n+         * it is replaced by the two half-edges and an intermediate splitting\n+         * vertex is introduced to connect these two halves.\n+         * </p>\n+         * @param splitLine line splitting the edge in two halves\n+         * @return split vertex (its incoming and outgoing edges are the two halves)\n          */\n-        public void outgoingProcessed() {\n-            outgoingNeedsProcessing = false;\n+        public Vertex split(final Line splitLine) {\n+            final Vertex splitVertex = new Vertex(line.intersection(splitLine));\n+            splitVertex.bindWith(splitLine);\n+            final Edge startHalf = new Edge(start, splitVertex, line);\n+            final Edge endHalf   = new Edge(splitVertex, end, line);\n+            startHalf.node = node;\n+            endHalf.node   = node;\n+            return splitVertex;\n         }\n \n     }\n",
        "project": "commons-math",
        "linesAdd": 151,
        "jira_id": "880",
        "nb_skipped": 4,
        "commit": "2a9cbbab",
        "nb_failure": 2,
        "linesRem": 95,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5905,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizerTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java b/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java\nindex 5f0527c33..864faae3e 100644\n--- a/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java\n@@ -506,7 +506,7 @@ public Optimum optimize(final LeastSquaresProblem problem) {\n \n                     // tests for convergence.\n                     if (checker != null && checker.converged(iterationCounter.getCount(), previous, current)) {\n-                        return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());\n+                        return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());\n                     }\n                 } else {\n                     // failed iteration, reset the previous values\n@@ -527,7 +527,7 @@ public Optimum optimize(final LeastSquaresProblem problem) {\n                      preRed <= costRelativeTolerance &&\n                      ratio <= 2.0) ||\n                     delta <= parRelativeTolerance * xNorm) {\n-                    return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());\n+                    return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());\n                 }\n \n                 // tests for termination and stringent tolerances\n",
        "project": "commons-math",
        "linesAdd": 2,
        "jira_id": "1106",
        "nb_skipped": 3,
        "commit": "e2dc384d",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3150,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest"
        ],
        "patch": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\nindex 93dd3bbdd..59dc4617b 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n@@ -232,10 +232,16 @@ protected double doSolve() {\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n+                final int p = agingA - MAXIMAL_AGING;\n+                final double weightA = (1 << p) - 1;\n+                final double weightB = p + 1;\n+                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);\n             } else if (agingB >= MAXIMAL_AGING) {\n                 // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+                final int p = agingB - MAXIMAL_AGING;\n+                final double weightA = p + 1;\n+                final double weightB = (1 << p) - 1;\n+                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n",
        "project": "commons-math",
        "linesAdd": 8,
        "jira_id": "716",
        "nb_skipped": 1,
        "commit": "faa77857",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4735,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.CBRPredicateBeanThrowExceptionTest",
            "org.apache.camel.component.vm.VmMultipleConsumersRemoteRouteTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java\nindex 0310c9a02d..44f4b109ca 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java\n@@ -30,6 +30,10 @@\n import org.apache.camel.util.AsyncProcessorConverterHelper;\n import org.apache.camel.util.AsyncProcessorHelper;\n import org.apache.camel.util.ServiceHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.camel.processor.PipelineHelper.continueProcessing;\n \n /**\n  * Implements a Choice structure where one or more predicates are used which if\n@@ -39,6 +43,7 @@\n  * @version \n  */\n public class ChoiceProcessor extends ServiceSupport implements AsyncProcessor, Navigate<Processor>, Traceable {\n+    private static final Logger LOG = LoggerFactory.getLogger(ChoiceProcessor.class);\n     private final List<Processor> filters;\n     private final Processor otherwise;\n \n@@ -84,13 +89,16 @@ public void done(boolean doneSync) {\n                 try {\n                     matches = filter.getPredicate().matches(exchange);\n                     exchange.setProperty(Exchange.FILTER_MATCHED, matches);\n+                    // as we have pre evaluated the predicate then use its processor directly when routing\n+                    processor = filter.getProcessor();\n                 } catch (Throwable e) {\n                     exchange.setException(e);\n-                    choiceCallback.done(true);\n-                    return true;\n                 }\n-                // as we have pre evaluated the predicate then use its processor directly when routing\n-                processor = filter.getProcessor();\n+            }\n+\n+            // check for error if so we should break out\n+            if (!continueProcessing(exchange, \"so breaking out of choice\", LOG)) {\n+                break;\n             }\n \n             // if we did not match then continue to next filter\n",
        "project": "camel",
        "linesAdd": 10,
        "jira_id": "6889",
        "nb_skipped": 1,
        "commit": "cd40b712",
        "nb_failure": 2,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5096,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.validator.ValidatorIncludeEncodingRouteTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/validator/DefaultLSResourceResolver.java b/camel-core/src/main/java/org/apache/camel/component/validator/DefaultLSResourceResolver.java\nindex 622e257172..38fa7041be 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/validator/DefaultLSResourceResolver.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/validator/DefaultLSResourceResolver.java\n@@ -117,8 +117,7 @@ private String getInputUri() {\n         \n         @Override\n         public Reader getCharacterStream() {\n-            InputStream is = getByteStream();\n-            return camelContext.getTypeConverter().convertTo(Reader.class, is);\n+            return null;\n         }\n \n         @Override\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "7883",
        "nb_skipped": 3,
        "commit": "d57f402b",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4744,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.vm.VmMultipleConsumersRemoteRouteTest",
            "org.apache.camel.management.ManagedThrottlerTest",
            "org.apache.camel.component.seda.SedaErrorTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java\nindex b7d3c3c101..6ba6fc84d9 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java\n@@ -107,7 +107,10 @@ public boolean process(Exchange exchange, final AsyncCallback callback) {\n \n             EventHelper.notifyExchangeSending(exchange.getContext(), target, destination);\n             LOG.debug(\">>>> {} {}\", destination, exchange);\n-            return producer.process(exchange, new AsyncCallback() {\n+\n+            boolean sync = true;\n+            try {\n+                sync = producer.process(exchange, new AsyncCallback() {\n                     @Override\n                     public void done(boolean doneSync) {\n                         try {\n@@ -121,6 +124,14 @@ public void done(boolean doneSync) {\n                         }\n                     }\n                 });\n+            } catch (Throwable throwable) {\n+                if (exchange != null) {\n+                    exchange.setException(throwable);\n+                }\n+\n+            }\n+\n+            return sync;\n         }\n \n         // send the exchange to the destination using the producer cache for the non optimized producers\n",
        "project": "camel",
        "linesAdd": 12,
        "jira_id": "6918",
        "nb_skipped": 1,
        "commit": "5761250c",
        "nb_failure": 3,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3008,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.builder.PredicateBuilderTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java\nindex 5f73fe310b..db029ec912 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java\n@@ -935,12 +935,16 @@ public String toString() {\n     public static Expression convertToExpression(final Expression expression, final Class type) {\n         return new ExpressionAdapter() {\n             public Object evaluate(Exchange exchange) {\n+                if (type != null) {\n                     return expression.evaluate(exchange, type);\n+                } else {\n+                    return expression;\n+                }\n             }\n \n             @Override\n             public String toString() {\n-                return \"\" + expression + \".convertTo(\" + type.getCanonicalName() + \".class)\";\n+                return \"\" + expression;\n             }\n         };\n     }\n@@ -952,12 +956,17 @@ public String toString() {\n     public static Expression convertToExpression(final Expression expression, final Expression type) {\n         return new ExpressionAdapter() {\n             public Object evaluate(Exchange exchange) {\n-                return expression.evaluate(exchange, type.evaluate(exchange, Object.class).getClass());\n+                Object result = type.evaluate(exchange, Object.class);\n+                if (result != null) {\n+                    return expression.evaluate(exchange, result.getClass());\n+                } else {\n+                    return expression;\n+                }\n             }\n \n             @Override\n             public String toString() {\n-                return \"\" + expression + \".convertToEvaluatedType(\" + type + \")\";\n+                return \"\" + expression;\n             }\n         };\n     }\n",
        "project": "camel",
        "linesAdd": 12,
        "jira_id": "3433",
        "nb_skipped": 0,
        "commit": "e76d23b0",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3736,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.file.FromFileMoveDoneCustomHeaderTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java b/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\nindex 69b15d5aef..ead41ea3c3 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\n@@ -18,6 +18,7 @@\n \n import java.io.File;\n import java.util.Date;\n+import java.util.Map;\n \n import org.apache.camel.Exchange;\n import org.apache.camel.util.FileUtil;\n@@ -93,10 +94,25 @@ public void copyFromPopulateAdditional(GenericFile<T> source, GenericFile<T> res\n      * Bind this GenericFile to an Exchange\n      */\n     public void bindToExchange(Exchange exchange) {\n+        Map<String, Object> headers;\n+\n         exchange.setProperty(FileComponent.FILE_EXCHANGE_FILE, this);\n-        GenericFileMessage<T> in = new GenericFileMessage<T>(this);\n-        exchange.setIn(in);\n-        populateHeaders(in);\n+        GenericFileMessage<T> msg = new GenericFileMessage<T>(this);\n+        if (exchange.hasOut()) {\n+            headers = exchange.getOut().hasHeaders() ? exchange.getOut().getHeaders() : null;\n+            exchange.setOut(msg);\n+        } else {\n+            headers = exchange.getIn().hasHeaders() ? exchange.getIn().getHeaders() : null;\n+            exchange.setIn(msg);\n+        }\n+\n+        // preserve any existing (non file) headers, before we re-populate headers\n+        if (headers != null) {\n+            msg.setHeaders(headers);\n+            // remove any file related headers, as we will re-populate file headers\n+            msg.removeHeaders(\"CamelFile*\");\n+        }\n+        populateHeaders(msg);\n     }\n \n     /**\n",
        "project": "camel",
        "linesAdd": 17,
        "jira_id": "4370",
        "nb_skipped": 0,
        "commit": "7345fefc",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4980,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.issues.AdviceWithCBRTest",
            "org.apache.camel.model.ProcessorDefinitionHelperTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinitionHelper.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinitionHelper.java\nindex 5575d36453..2ae283b34c 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinitionHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinitionHelper.java\n@@ -198,9 +198,6 @@ public static String getRouteId(ProcessorDefinition<?> node) {\n         }\n \n         for (ProcessorDefinition out : outputs) {\n-            if (type.isInstance(out)) {\n-                found.add((T)out);\n-            }\n \n             // send is much common\n             if (out instanceof SendDefinition) {\n@@ -222,6 +219,9 @@ public static String getRouteId(ProcessorDefinition<?> node) {\n                     List<ProcessorDefinition<?>> children = choice.getOtherwise().getOutputs();\n                     doFindType(children, type, found);\n                 }\n+\n+                // do not check children as we already did that\n+                continue;\n             }\n \n             // special for try ... catch ... finally\n@@ -253,6 +253,10 @@ public static String getRouteId(ProcessorDefinition<?> node) {\n                 continue;\n             }\n \n+            if (type.isInstance(out)) {\n+                found.add((T)out);\n+            }\n+\n             // try children as well\n             List<ProcessorDefinition<?>> children = out.getOutputs();\n             doFindType(children, type, found);\n",
        "project": "camel",
        "linesAdd": 6,
        "jira_id": "7562",
        "nb_skipped": 3,
        "commit": "689147e9",
        "nb_failure": 2,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 5131,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.builder.ErrorHandlerBuilderRefTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/ErrorHandlerBuilderRef.java b/camel-core/src/main/java/org/apache/camel/builder/ErrorHandlerBuilderRef.java\nindex 0cf9d5790b..4d06b7f978 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/ErrorHandlerBuilderRef.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/ErrorHandlerBuilderRef.java\n@@ -51,6 +51,18 @@ public void addErrorHandlers(RouteContext routeContext, OnExceptionDefinition ex\n         super.addErrorHandlers(routeContext, exception);\n     }\n     \n+    @Override\n+    public boolean removeOnExceptionList(String id) {\n+        for (RouteContext routeContext : handlers.keySet()) {\n+            if (getRouteId(routeContext).equals(id)) {\n+                handlers.remove(routeContext);\n+                break;\n+            }\n+        }\n+        return super.removeOnExceptionList(id);\n+    }\n+    \n+\n     public Processor createErrorHandler(RouteContext routeContext, Processor processor) throws Exception {\n         ErrorHandlerBuilder handler = handlers.get(routeContext);\n         if (handler == null) {\ndiff --git a/camel-core/src/main/java/org/apache/camel/builder/ErrorHandlerBuilderSupport.java b/camel-core/src/main/java/org/apache/camel/builder/ErrorHandlerBuilderSupport.java\nindex 747a6ddd38..365ebc0ea3 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/ErrorHandlerBuilderSupport.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/ErrorHandlerBuilderSupport.java\n@@ -21,6 +21,7 @@\n import java.util.List;\n import java.util.Map;\n \n+import org.apache.camel.CamelContext;\n import org.apache.camel.model.OnExceptionDefinition;\n import org.apache.camel.processor.ErrorHandler;\n import org.apache.camel.processor.ErrorHandlerSupport;\n@@ -94,4 +95,28 @@ public void setExceptionPolicyStrategy(ExceptionPolicyStrategy exceptionPolicySt\n         ObjectHelper.notNull(exceptionPolicyStrategy, \"ExceptionPolicyStrategy\");\n         this.exceptionPolicyStrategy = exceptionPolicyStrategy;\n     }\n+    \n+    /**\n+     * Remove the OnExceptionList by look up the route id from the ErrorHandlerBuilder internal map\n+     * @param id the route id\n+     * @return true if the route context is found and removed\n+     */\n+    public boolean removeOnExceptionList(String id) {\n+        for (RouteContext routeContext : onExceptions.keySet()) {\n+            if (getRouteId(routeContext).equals(id)) {\n+                onExceptions.remove(routeContext);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    protected String getRouteId(RouteContext routeContext) {\n+        CamelContext context = routeContext.getCamelContext();\n+        if (context != null) {\n+            return routeContext.getRoute().idOrCreate(context.getNodeIdFactory());\n+        } else {\n+            return routeContext.getRoute().getId();\n+        }\n+    }\n }\ndiff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\nindex deba649ad4..bd4488cbaf 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n@@ -71,6 +71,7 @@\n import org.apache.camel.TypeConverter;\n import org.apache.camel.VetoCamelContextStartException;\n import org.apache.camel.builder.ErrorHandlerBuilder;\n+import org.apache.camel.builder.ErrorHandlerBuilderSupport;\n import org.apache.camel.component.properties.PropertiesComponent;\n import org.apache.camel.impl.converter.BaseTypeConverterRegistry;\n import org.apache.camel.impl.converter.DefaultTypeConverter;\n@@ -928,6 +928,11 @@ public synchronized void shutdownRoute(String routeId, long timeout, TimeUnit ti\n     }\n \n     public synchronized boolean removeRoute(String routeId) throws Exception {\n+        // remove the route from ErrorHandlerBuilder if possible\n+        if (getErrorHandlerBuilder() instanceof ErrorHandlerBuilderSupport) {\n+            ErrorHandlerBuilderSupport builder = (ErrorHandlerBuilderSupport)getErrorHandlerBuilder();\n+            builder.removeOnExceptionList(routeId);\n+        }\n         RouteService routeService = routeServices.get(routeId);\n         if (routeService != null) {\n             if (getRouteStatus(routeId).isStopped()) {\n",
        "project": "camel",
        "linesAdd": 37,
        "jira_id": "8053",
        "nb_skipped": 3,
        "commit": "cac72b14",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5441,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.properties.PropertiesComponentOnExceptionDelayPatternTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/RedeliveryPolicyDefinition.java b/camel-core/src/main/java/org/apache/camel/model/RedeliveryPolicyDefinition.java\nindex 41e53e9c98..f695d265b0 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/RedeliveryPolicyDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/RedeliveryPolicyDefinition.java\n@@ -156,13 +156,13 @@ public RedeliveryPolicy createRedeliveryPolicy(CamelContext context, RedeliveryP\n                 }\n             }\n             if (delayPattern != null) {\n-                answer.setDelayPattern(delayPattern);\n+                answer.setDelayPattern(CamelContextHelper.parseText(context, delayPattern));\n             }\n             if (allowRedeliveryWhileStopping != null) {\n                 answer.setAllowRedeliveryWhileStopping(CamelContextHelper.parseBoolean(context, allowRedeliveryWhileStopping));\n             }\n             if (exchangeFormatterRef != null) {\n-                answer.setExchangeFormatterRef(exchangeFormatterRef);\n+                answer.setExchangeFormatterRef(CamelContextHelper.parseText(context, exchangeFormatterRef));\n             }\n         } catch (Exception e) {\n             throw ObjectHelper.wrapRuntimeCamelException(e);\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "9124",
        "nb_skipped": 4,
        "commit": "9da2c05a",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5030,
        "nb_error": 5,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.vm.VmMultipleConsumersMultipleContextTest",
            "org.apache.camel.component.vm.VmMultipleContextsStartStopTest",
            "org.apache.camel.management.ManagedThrottlerTest",
            "org.apache.camel.component.properties.PropertiesComponentLoadPropertiesFromFileTest",
            "org.apache.camel.component.properties.PropertiesComponentTest",
            "org.apache.camel.component.vm.VmShouldNotUseSameThreadTest",
            "org.apache.camel.component.vm.VmQueueTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/properties/PropertiesComponent.java b/camel-core/src/main/java/org/apache/camel/component/properties/PropertiesComponent.java\nindex 7d0e75cc6a..3a7c13d280 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/properties/PropertiesComponent.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/properties/PropertiesComponent.java\n@@ -204,6 +204,9 @@ public String getPropertyPrefix() {\n \n     public void setPropertyPrefix(String propertyPrefix) {\n         this.propertyPrefix = propertyPrefix;\n+        if (ObjectHelper.isNotEmpty(this.propertyPrefix)) {\n+            this.propertyPrefix = FilePathResolver.resolvePath(this.propertyPrefix);\n+        }\n     }\n \n     public String getPropertySuffix() {\n@@ -212,6 +215,9 @@ public String getPropertySuffix() {\n \n     public void setPropertySuffix(String propertySuffix) {\n         this.propertySuffix = propertySuffix;\n+        if (ObjectHelper.isNotEmpty(this.propertySuffix)) {\n+            this.propertySuffix = FilePathResolver.resolvePath(this.propertySuffix);\n+        }\n     }\n \n     public boolean isFallbackToUnaugmentedProperty() {\n",
        "project": "camel",
        "linesAdd": 6,
        "jira_id": "7456",
        "nb_skipped": 3,
        "commit": "02da984a",
        "nb_failure": 3,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5040,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.routingslip.RoutingSlipCreateProducerFailedTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\nindex 94a352fabd..4ece29fa6e 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n@@ -267,20 +267,31 @@ public Exchange send(Endpoint endpoint, ExchangePattern pattern, Processor proce\n      */\n     public boolean doInAsyncProducer(final Endpoint endpoint, final Exchange exchange, final ExchangePattern pattern,\n                                      final AsyncCallback callback, final AsyncProducerCallback producerCallback) {\n-        boolean sync = true;\n \n+        Producer target;\n+        try {\n             // get the producer and we do not mind if its pooled as we can handle returning it back to the pool\n-        final Producer producer = doGetProducer(endpoint, true);\n+            target = doGetProducer(endpoint, true);\n \n-        if (producer == null) {\n+            if (target == null) {\n                 if (isStopped()) {\n                     LOG.warn(\"Ignoring exchange sent after processor is stopped: \" + exchange);\n-                return false;\n+                    callback.done(true);\n+                    return true;\n                 } else {\n-                throw new IllegalStateException(\"No producer, this processor has not been started: \" + this);\n+                    exchange.setException(new IllegalStateException(\"No producer, this processor has not been started: \" + this));\n+                    callback.done(true);\n+                    return true;\n+                }\n             }\n+        } catch (Throwable e) {\n+            exchange.setException(e);\n+            callback.done(true);\n+            return true;\n         }\n \n+        final Producer producer = target;\n+\n         // record timing for sending the exchange using the producer\n         final StopWatch watch = eventNotifierEnabled && exchange != null ? new StopWatch() : null;\n \n@@ -290,7 +301,7 @@ public boolean doInAsyncProducer(final Endpoint endpoint, final Exchange exchang\n             }\n             // invoke the callback\n             AsyncProcessor asyncProcessor = AsyncProcessorConverterHelper.convert(producer);\n-            sync = producerCallback.doInAsyncProducer(producer, asyncProcessor, exchange, pattern, new AsyncCallback() {\n+            return producerCallback.doInAsyncProducer(producer, asyncProcessor, exchange, pattern, new AsyncCallback() {\n                 @Override\n                 public void done(boolean doneSync) {\n                     try {\n@@ -322,9 +333,9 @@ public void done(boolean doneSync) {\n             if (exchange != null) {\n                 exchange.setException(e);\n             }\n+            callback.done(true);\n+            return true;\n         }\n-\n-        return sync;\n     }\n \n     protected Exchange sendExchange(final Endpoint endpoint, ExchangePattern pattern,\n",
        "project": "camel",
        "linesAdd": 19,
        "jira_id": "7736",
        "nb_skipped": 3,
        "commit": "7ad36e3d",
        "nb_failure": 1,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4322,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.aggregator.AggregateTimeoutWithExecutorServiceTest",
            "org.apache.camel.builder.NotifyBuilderWhenDoneByIndexTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/NotifyBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/NotifyBuilder.java\nindex 547efaba79..d5a346c721 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/NotifyBuilder.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/NotifyBuilder.java\n@@ -444,7 +444,7 @@ public boolean onExchangeCreated(Exchange exchange) {\n             @Override\n             public boolean onExchangeCompleted(Exchange exchange) {\n                 if (exchange.getExchangeId().equals(id)) {\n-                    done.set(false);\n+                    done.set(true);\n                 }\n                 return true;\n             }\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "5707",
        "nb_skipped": 1,
        "commit": "3f70d612",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 3733,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.management.EventNotifierRedeliveryEventsTest",
            "org.apache.camel.processor.async.AsyncEndpointEventNotifierTest",
            "org.apache.camel.management.JmxInstrumentationWithConnectorTest",
            "org.apache.camel.management.EventNotifierFailureHandledEventsTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\nindex e9093a4ccf..c8304d6365 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n@@ -259,11 +259,12 @@ public Exchange send(Endpoint endpoint, ExchangePattern pattern, Processor proce\n      * @param producerCallback the producer template callback to be executed\n      * @return (doneSync) <tt>true</tt> to continue execute synchronously, <tt>false</tt> to continue being executed asynchronously\n      */\n-    public boolean doInAsyncProducer(Endpoint endpoint, Exchange exchange, ExchangePattern pattern, AsyncCallback callback, AsyncProducerCallback producerCallback) {\n+    public boolean doInAsyncProducer(final Endpoint endpoint, final Exchange exchange, final ExchangePattern pattern,\n+                                     final AsyncCallback callback, final AsyncProducerCallback producerCallback) {\n         boolean sync = true;\n \n         // get the producer and we do not mind if its pooled as we can handle returning it back to the pool\n-        Producer producer = doGetProducer(endpoint, true);\n+        final Producer producer = doGetProducer(endpoint, true);\n \n         if (producer == null) {\n             if (isStopped()) {\n@@ -274,23 +275,17 @@ public boolean doInAsyncProducer(Endpoint endpoint, Exchange exchange, ExchangeP\n             }\n         }\n \n-        StopWatch watch = null;\n-        if (exchange != null) {\n         // record timing for sending the exchange using the producer\n-            watch = new StopWatch();\n-        }\n+        final StopWatch watch = exchange != null ? new StopWatch() : null;\n \n         try {\n             // invoke the callback\n             AsyncProcessor asyncProcessor = AsyncProcessorTypeConverter.convert(producer);\n-            sync = producerCallback.doInAsyncProducer(producer, asyncProcessor, exchange, pattern, callback);\n-        } catch (Throwable e) {\n-            // ensure exceptions is caught and set on the exchange\n-            if (exchange != null) {\n-                exchange.setException(e);\n-            }\n-        } finally {\n-            if (exchange != null && exchange.getException() == null) {\n+            sync = producerCallback.doInAsyncProducer(producer, asyncProcessor, exchange, pattern, new AsyncCallback() {\n+                @Override\n+                public void done(boolean doneSync) {\n+                    try {\n+                        if (watch != null) {\n                             long timeTaken = watch.stop();\n                             // emit event that the exchange was sent to the endpoint\n                             EventHelper.notifyExchangeSent(exchange.getContext(), exchange, endpoint, timeTaken);\n@@ -307,6 +303,16 @@ public boolean doInAsyncProducer(Endpoint endpoint, Exchange exchange, ExchangeP\n                                 LOG.warn(\"Error stopping producer: \" + producer, e);\n                             }\n                         }\n+                    } finally {\n+                        callback.done(doneSync);\n+                    }\n+                }\n+            });\n+        } catch (Throwable e) {\n+            // ensure exceptions is caught and set on the exchange\n+            if (exchange != null) {\n+                exchange.setException(e);\n+            }\n         }\n \n         return sync;\n",
        "project": "camel",
        "linesAdd": 18,
        "jira_id": "4354",
        "nb_skipped": 0,
        "commit": "96e40c3c",
        "nb_failure": 4,
        "linesRem": 13,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4848,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.validator.ValidatorRouteTest",
            "org.apache.camel.management.ManagedThrottlerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/validation/ValidatingProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/validation/ValidatingProcessor.java\nindex bcbc6710f3..2d9fa8e163 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/validation/ValidatingProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/validation/ValidatingProcessor.java\n@@ -62,9 +64,9 @@\n     private static final Logger LOG = LoggerFactory.getLogger(ValidatingProcessor.class);\n     private XmlConverter converter = new XmlConverter();\n     private String schemaLanguage = XMLConstants.W3C_XML_SCHEMA_NS_URI;\n-    private Schema schema;\n+    private volatile Schema schema;\n     private Source schemaSource;\n-    private SchemaFactory schemaFactory;\n+    private volatile SchemaFactory schemaFactory;\n     private URL schemaUrl;\n     private File schemaFile;\n     private byte[] schemaAsByteArray;\n@@ -189,9 +191,13 @@ public void loadSchema() throws Exception {\n     // -----------------------------------------------------------------------\n \n     public Schema getSchema() throws IOException, SAXException {\n+        if (schema == null) {\n+            synchronized (this) {\n                 if (schema == null) {\n                     schema = createSchema();\n                 }\n+            }\n+        }\n         return schema;\n     }\n \n@@ -243,9 +249,13 @@ public void setSchemaAsByteArray(byte[] schemaAsByteArray) {\n     }\n \n     public SchemaFactory getSchemaFactory() {\n+        if (schemaFactory == null) {\n+            synchronized (this) {\n                 if (schemaFactory == null) {\n                     schemaFactory = createSchemaFactory();\n                 }\n+            }\n+        }\n         return schemaFactory;\n     }\n \n@@ -336,22 +346,30 @@ protected Schema createSchema() throws SAXException, IOException {\n \n         URL url = getSchemaUrl();\n         if (url != null) {\n+            synchronized (this) {\n                 return factory.newSchema(url);\n             }\n+        }\n \n         File file = getSchemaFile();\n         if (file != null) {\n+            synchronized (this) {\n                 return factory.newSchema(file);\n             }\n+        }\n \n         byte[] bytes = getSchemaAsByteArray();\n         if (bytes != null) {\n+            synchronized (this) {\n                 return factory.newSchema(new StreamSource(new ByteArrayInputStream(schemaAsByteArray)));\n             }\n+        }\n \n         Source source = getSchemaSource();\n+        synchronized (this) {\n             return factory.newSchema(source);\n         }\n+    }\n \n     /**\n      * Checks whether we need an {@link InputStream} to access the message body or header.\n",
        "project": "camel",
        "linesAdd": 18,
        "jira_id": "7239",
        "nb_skipped": 3,
        "commit": "ae419224",
        "nb_failure": 2,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4755,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.aggregator.AggregateTimeoutTest",
            "org.apache.camel.management.ManagedBrowsableEndpointAsXmlFileTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/util/MessageHelper.java b/camel-core/src/main/java/org/apache/camel/util/MessageHelper.java\nindex 3e38d23588..c81b53b815 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/MessageHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/MessageHelper.java\n@@ -223,9 +223,11 @@ public static String extractBodyForLogging(Message message, String prepend, bool\n             } else if (obj instanceof Writer) {\n                 return prepend + \"[Body is instance of java.io.Writer]\";\n             } else if (obj instanceof WrappedFile || obj instanceof File) {\n+                if (!allowFiles) {\n                     return prepend + \"[Body is file based: \" + obj + \"]\";\n                 }\n             }\n+        }\n \n         if (!allowFiles) {\n             if (obj instanceof WrappedFile || obj instanceof File) {\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "6987",
        "nb_skipped": 1,
        "commit": "37e0e6bb",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4621,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.WireTapTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\nindex ff1615098b..9b93a1a7d1 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n@@ -1027,7 +1028,12 @@ public Type id(String id) {\n                     }\n                 }\n             }\n+            if (!getOutputs().isEmpty()) {\n                 outputs.get(outputs.size() - 1).setId(id);\n+            } else {\n+                // the output could be empty\n+                setId(id);\n+            }\n         }\n \n         return (Type) this;\n",
        "project": "camel",
        "linesAdd": 4,
        "jira_id": "6610",
        "nb_skipped": 1,
        "commit": "ed7e7c9f",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4300,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.aggregator.AggregateTimeoutTest",
            "org.apache.camel.language.simple.SimpleTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\nindex 4a8ddef91a..880c4007aa 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n@@ -52,8 +52,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.apache.camel.util.ExchangeHelper.convertToType;\n-\n /**\n  * Represents the metadata about a bean type created via a combination of\n  * introspection and annotations together with some useful sensible defaults\n@@ -572,7 +570,8 @@ private MethodInfo chooseBestPossibleMethodInfo(Exchange exchange, Collection<Me\n                     return methodInfo;\n                 }\n \n-                Object value = convertToType(exchange, methodInfo.getBodyParameterType(), body);\n+                // we should only try to convert, as we are looking for best match\n+                Object value = exchange.getContext().getTypeConverter().tryConvertTo(methodInfo.getBodyParameterType(), exchange, body);\n                 if (value != null) {\n                     if (LOG.isTraceEnabled()) {\n                         LOG.trace(\"Converted body from: {} to: {}\",\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "5644",
        "nb_skipped": 1,
        "commit": "15d0fd9b",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 3841,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.management.ManagedCustomPolicyTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/WrapProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/WrapProcessor.java\nindex 4b3b7c882e..adb508ab65 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/WrapProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/WrapProcessor.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.camel.processor;\n \n+import java.util.List;\n+\n import org.apache.camel.Processor;\n import org.apache.camel.util.ServiceHelper;\n \n@@ -37,6 +39,14 @@ public String toString() {\n         return \"Wrap[\" + wrapped + \"] -> \" + processor;\n     }\n \n+    @Override\n+    public List<Processor> next() {\n+        // must include wrapped in navigate\n+        List<Processor> list = super.next();\n+        list.add(wrapped);\n+        return list;\n+    }\n+\n     @Override\n     protected void doStart() throws Exception {\n         ServiceHelper.startService(wrapped);\ndiff --git a/camel-core/src/main/java/org/apache/camel/util/AsyncProcessorConverterHelper.java b/camel-core/src/main/java/org/apache/camel/util/AsyncProcessorConverterHelper.java\nindex 7a5a6f2444..656136c157 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/AsyncProcessorConverterHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/AsyncProcessorConverterHelper.java\n@@ -41,9 +41,8 @@ private AsyncProcessorConverterHelper() {\n     }\r\n \r\n     /**\r\n-     * Creates a AsnycProcossor that delegates to the given processor.\r\n-     * It is important that this implements DelegateProcessor\r\n-     *\r\n+     * Creates a {@link AsyncProcessor} that delegates to the given processor.\r\n+     * It is important that this implements {@link DelegateProcessor}\r\n      */\r\n     private static final class ProcessorToAsyncProcessorBridge implements DelegateProcessor, AsyncProcessor, Navigate<Processor>, Service {\r\n         protected Processor processor;\r\n",
        "project": "camel",
        "linesAdd": 9,
        "jira_id": "4536",
        "nb_skipped": 0,
        "commit": "df9f4a6a",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4353,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.intercept.TransactedPropertyPlaceholderIssueTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\nindex 2db4f13f28..38989d18f4 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n@@ -367,9 +367,29 @@ protected Processor createOutputsProcessor(RouteContext routeContext, Collection\n         List<Processor> list = new ArrayList<Processor>();\n         for (ProcessorDefinition<?> output : outputs) {\n \n+            // allow any custom logic before we create the processor\n+            output.preCreateProcessor();\n+\n             // resolve properties before we create the processor\n             resolvePropertyPlaceholders(routeContext, output);\n \n+            // resolve constant fields (eg Exchange.FILE_NAME)\n+            resolveKnownConstantFields(output);\n+\n+            // also resolve properties and constant fields on embedded expressions\n+            ProcessorDefinition<?> me = (ProcessorDefinition<?>) output;\n+            if (me instanceof ExpressionNode) {\n+                ExpressionNode exp = (ExpressionNode) me;\n+                ExpressionDefinition expressionDefinition = exp.getExpression();\n+                if (expressionDefinition != null) {\n+                    // resolve properties before we create the processor\n+                    resolvePropertyPlaceholders(routeContext, expressionDefinition);\n+\n+                    // resolve constant fields (eg Exchange.FILE_NAME)\n+                    resolveKnownConstantFields(expressionDefinition);\n+                }\n+            }\n+\n             Processor processor = null;\n             // at first use custom factory\n             if (routeContext.getCamelContext().getProcessorFactory() != null) {\n@@ -472,10 +492,9 @@ protected void resolvePropertyPlaceholders(RouteContext routeContext, Object def\n         // include additional properties which have the Camel placeholder QName\n         // and when the definition parameter is this (otherAttributes belong to this)\n         if (processorDefinition != null && processorDefinition.getOtherAttributes() != null) {\n-            for (Object key : processorDefinition.getOtherAttributes().keySet()) {\n-                QName qname = (QName) key;\n-                if (Constants.PLACEHOLDER_QNAME.equals(qname.getNamespaceURI())) {\n-                    String local = qname.getLocalPart();\n+            for (QName key : processorDefinition.getOtherAttributes().keySet()) {\n+                if (Constants.PLACEHOLDER_QNAME.equals(key.getNamespaceURI())) {\n+                    String local = key.getLocalPart();\n                     Object value = processorDefinition.getOtherAttributes().get(key);\n                     if (value != null && value instanceof String) {\n                         // value must be enclosed with placeholder tokens\n",
        "project": "camel",
        "linesAdd": 18,
        "jira_id": "5796",
        "nb_skipped": 1,
        "commit": "de6dd425",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4801,
        "nb_error": 1,
        "classification": {
            "singleLine": true
        },
        "failing_tests": [
            "org.apache.camel.converter.jaxp.XmlConverterTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java b/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\nindex 9a2b60a846..0bf08ac554 100644\n--- a/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\n+++ b/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\n@@ -99,6 +99,7 @@ public static ByteBuffer toByteBuffer(String value, Exchange exchange) {\n             bytes = value.getBytes();\n         }\n         buf.put(bytes);\n+        buf.flip();\n         return buf;\n     }\n \n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "7209",
        "nb_skipped": 3,
        "commit": "5f78c646",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": true,
        "rtElixir": true
    },
    {
        "files": 1,
        "nb_test": 4358,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.SplitTokenizerNamespaceTest",
            "org.apache.camel.component.file.FileConsumeSingleDirectoryOnlyTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/support/TokenXMLPairExpressionIterator.java b/camel-core/src/main/java/org/apache/camel/support/TokenXMLPairExpressionIterator.java\nindex da5afaa639..9ae147737c 100644\n--- a/camel-core/src/main/java/org/apache/camel/support/TokenXMLPairExpressionIterator.java\n+++ b/camel-core/src/main/java/org/apache/camel/support/TokenXMLPairExpressionIterator.java\n@@ -41,6 +41,7 @@\n \n     private static final Pattern NAMESPACE_PATTERN = Pattern.compile(\"xmlns(:\\\\w+|)=\\\\\\\"(.*?)\\\\\\\"\");\n     private static final String SCAN_TOKEN_REGEX = \"(\\\\s+.*?|)>\";\n+    private static final String SCAN_TOKEN_NS_PREFIX_REGEX = \"(.{1,15}?:|)\";\n     protected final String inheritNamespaceToken;\n \n     public TokenXMLPairExpressionIterator(String startToken, String endToken, String inheritNamespaceToken) {\n@@ -81,15 +82,22 @@ public TokenXMLPairExpressionIterator(String startToken, String endToken, String\n         XMLTokenPairIterator(String startToken, String endToken, String inheritNamespaceToken, InputStream in, String charset) {\n             super(startToken, endToken, true, in, charset);\n \n-            // remove any ending > as we need to support attributes on the tags, so we need to use a reg exp pattern\n-            String token = startToken.substring(0, startToken.length() - 1) + SCAN_TOKEN_REGEX;\n-            this.startTokenPattern = Pattern.compile(token);\n-            this.scanEndToken = endToken.substring(0, endToken.length() - 1) + SCAN_TOKEN_REGEX;\n+            // remove any beginning < and ending > as we need to support ns prefixes and attributes, so we use a reg exp patterns\n+            StringBuilder tokenSb = new StringBuilder(\"<\").append(SCAN_TOKEN_NS_PREFIX_REGEX).\n+                                append(startToken.substring(1, startToken.length() - 1)).append(SCAN_TOKEN_REGEX);\n+            this.startTokenPattern = Pattern.compile(tokenSb.toString());\n+            \n+            tokenSb = new StringBuilder(\"</\").append(SCAN_TOKEN_NS_PREFIX_REGEX).\n+                                append(endToken.substring(2, endToken.length() - 1)).append(SCAN_TOKEN_REGEX);\n+            this.scanEndToken = tokenSb.toString();\n+            \n             this.inheritNamespaceToken = inheritNamespaceToken;\n             if (inheritNamespaceToken != null) {\n-                token = inheritNamespaceToken.substring(0, inheritNamespaceToken.length() - 1) + SCAN_TOKEN_REGEX;\n+                // the inherit namespace token may itself have a namespace prefix\n+                tokenSb = new StringBuilder(\"<\").append(SCAN_TOKEN_NS_PREFIX_REGEX).\n+                                append(inheritNamespaceToken.substring(1, inheritNamespaceToken.length() - 1)).append(SCAN_TOKEN_REGEX);  \n                 // the namespaces on the parent tag can be in multi line, so we need to instruct the dot to support multilines\n-                this.inheritNamespaceTokenPattern = Pattern.compile(token, Pattern.MULTILINE | Pattern.DOTALL);\n+                this.inheritNamespaceTokenPattern = Pattern.compile(tokenSb.toString(), Pattern.MULTILINE | Pattern.DOTALL);\n             }\n         }\n \n@@ -125,17 +133,26 @@ String getNext(boolean first) {\n                 next = next.substring(index);\n             }\n \n+            // make sure the end tag matches the begin tag if the tag has a namespace prefix\n+            String tag = ObjectHelper.before(next, \">\");\n+            StringBuilder endTagSb = new StringBuilder(\"</\");\n+            int firstSpaceIndex = tag.indexOf(\" \");\n+            if (firstSpaceIndex > 0) {\n+                endTagSb.append(tag.substring(1, firstSpaceIndex)).append(\">\");\n+            } else {\n+                endTagSb.append(tag.substring(1, tag.length())).append(\">\");\n+            }\n+            \n             // build answer accordingly to whether namespaces should be inherited or not\n             StringBuilder sb = new StringBuilder();\n             if (inheritNamespaceToken != null && rootTokenNamespaces != null) {\n                 // append root namespaces to local start token\n-                String tag = ObjectHelper.before(next, \">\");\n                 // grab the text\n                 String text = ObjectHelper.after(next, \">\");\n                 // build result with inherited namespaces\n-                next = sb.append(tag).append(rootTokenNamespaces).append(\">\").append(text).append(endToken).toString();\n+                next = sb.append(tag).append(rootTokenNamespaces).append(\">\").append(text).append(endTagSb.toString()).toString();\n             } else {\n-                next = sb.append(next).append(endToken).toString();\n+                next = sb.append(next).append(endTagSb.toString()).toString();\n             }\n \n             return next;\n",
        "project": "camel",
        "linesAdd": 23,
        "jira_id": "5826",
        "nb_skipped": 1,
        "commit": "a04674f2",
        "nb_failure": 2,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5287,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.bean.issues.TransformerIssueTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\nindex d33eb7f782..67a08932e5 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n@@ -759,6 +759,7 @@ private MethodInfo chooseBestPossibleMethodInfo(Exchange exchange, Collection<Me\n             MethodInfo matched = null;\n             int matchCounter = 0;\n             for (MethodInfo methodInfo : operationList) {\n+                if (methodInfo.getBodyParameterType() != null) {\n                     if (methodInfo.getBodyParameterType().isInstance(body)) {\n                         return methodInfo;\n                     }\n@@ -775,6 +776,7 @@ private MethodInfo chooseBestPossibleMethodInfo(Exchange exchange, Collection<Me\n                         matched = methodInfo;\n                     }\n                 }\n+            }\n             if (matchCounter > 1) {\n                 throw new AmbiguousMethodCallException(exchange, Arrays.asList(matched, matched));\n             }\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "8624",
        "nb_skipped": 4,
        "commit": "597883fa",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5570,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.seda.SedaDiscardIfNoConsumerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java b/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\nindex a87ddf38e6..1e28eaa7e0 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\n@@ -122,7 +122,8 @@ public String toString() {\n \n             log.trace(\"Adding Exchange to queue: {}\", copy);\n             try {\n-                addToQueue(copy);\n+                // do not copy as we already did the copy\n+                addToQueue(copy, false);\n             } catch (SedaConsumerNotAvailableException e) {\n                 exchange.setException(e);\n                 callback.done(true);\n@@ -160,11 +161,8 @@ public String toString() {\n             }\n         } else {\n             // no wait, eg its a InOnly then just add to queue and return\n-            // handover the completion so its the copy which performs that, as we do not wait\n-            Exchange copy = prepareCopy(exchange, true);\n-            log.trace(\"Adding Exchange to queue: {}\", copy);\n             try {\n-                addToQueue(copy);\n+                addToQueue(exchange, true);\n             } catch (SedaConsumerNotAvailableException e) {\n                 exchange.setException(e);\n                 callback.done(true);\n@@ -205,8 +203,9 @@ protected void doStop() throws Exception {\n      * simply add which will throw exception if the queue is full\n      * \n      * @param exchange the exchange to add to the queue\n+     * @param copy     whether to create a copy of the exchange to use for adding to the queue\n      */\n-    protected void addToQueue(Exchange exchange) throws SedaConsumerNotAvailableException {\n+    protected void addToQueue(Exchange exchange, boolean copy) throws SedaConsumerNotAvailableException {\n         BlockingQueue<Exchange> queue = null;\n         QueueReference queueReference = endpoint.getQueueReference();\n         if (queueReference != null) {\n@@ -226,15 +225,23 @@ protected void addToQueue(Exchange exchange) throws SedaConsumerNotAvailableExce\n             }\n         }\n \n+        Exchange target = exchange;\n+\n+        // handover the completion so its the copy which performs that, as we do not wait\n+        if (copy) {\n+            target = prepareCopy(exchange, true);\n+        }\n+\n+        log.trace(\"Adding Exchange to queue: {}\", target);\n         if (blockWhenFull) {\n             try {\n-                queue.put(exchange);\n+                queue.put(target);\n             } catch (InterruptedException e) {\n                 // ignore\n                 log.debug(\"Put interrupted, are we stopping? {}\", isStopping() || isStopped());\n             }\n         } else {\n-            queue.add(exchange);\n+            queue.add(target);\n         }\n     }\n \n",
        "project": "camel",
        "linesAdd": 12,
        "jira_id": "9700",
        "nb_skipped": 4,
        "commit": "4d03e9de",
        "nb_failure": 1,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4795,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.SplitTokenizerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/support/TokenXMLExpressionIterator.java b/camel-core/src/main/java/org/apache/camel/support/TokenXMLExpressionIterator.java\nindex 3048c64e65..ba21a717fc 100644\n--- a/camel-core/src/main/java/org/apache/camel/support/TokenXMLExpressionIterator.java\n+++ b/camel-core/src/main/java/org/apache/camel/support/TokenXMLExpressionIterator.java\n@@ -47,7 +47,7 @@\n public class TokenXMLExpressionIterator extends ExpressionAdapter {\n     private static final Pattern NAMESPACE_PATTERN = Pattern.compile(\"xmlns(:\\\\w+|)\\\\s*=\\\\s*('[^']+'|\\\"[^\\\"]+\\\")\");\n     private static final String SCAN_TOKEN_NS_PREFIX_REGEX = \"([^:<>]{1,15}?:|)\";\n-    private static final String SCAN_BLOCK_TOKEN_REGEX_TEMPLATE = \"<{0}(\\\\s+[^/^>]*)?/>|<{0}(\\\\s+[^>]*)?>(?:(?!(</{0}\\\\s*>)).)*</{0}\\\\s*>\";\n+    private static final String SCAN_BLOCK_TOKEN_REGEX_TEMPLATE = \"<{0}(\\\\s+[^>]*)?/>|<{0}(\\\\s+[^>]*)?>(?:(?!(</{0}\\\\s*>)).)*</{0}\\\\s*>\";\n     private static final String SCAN_PARENT_TOKEN_REGEX_TEMPLATE = \"<{0}(\\\\s+[^>]*\\\\s*)?>\";\n     \n     protected final String tagToken;\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "7125",
        "nb_skipped": 3,
        "commit": "6641f182",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5145,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.support.XMLTokenExpressionIteratorInvalidXMLTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/support/XMLTokenExpressionIterator.java b/camel-core/src/main/java/org/apache/camel/support/XMLTokenExpressionIterator.java\nindex f233281f78..19cc2a62b7 100644\n--- a/camel-core/src/main/java/org/apache/camel/support/XMLTokenExpressionIterator.java\n+++ b/camel-core/src/main/java/org/apache/camel/support/XMLTokenExpressionIterator.java\n@@ -575,7 +575,8 @@ public Object next() {\n             try {\n                 nextToken = getNextToken();\n             } catch (XMLStreamException e) {\n-                //\n+                nextToken = null;\n+                throw new RuntimeException(e);\n             }\n             return o;\n         }\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "8106",
        "nb_skipped": 3,
        "commit": "39ccf5d6",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5464,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.vm.VmQueueTest",
            "org.apache.camel.component.vm.VmShouldNotUseSameThreadTest",
            "org.apache.camel.component.vm.VmMultipleConsumersMultipleContextTest",
            "org.apache.camel.component.vm.VmMultipleContextsStartStopTest",
            "org.apache.camel.component.bean.BeanHandlerMethodTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\nindex d3c72141a1..a2f6ce8243 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n@@ -987,7 +987,9 @@ private void removeAllAbstractMethods(List<MethodInfo> methods) {\n         Iterator<MethodInfo> it = methods.iterator();\n         while (it.hasNext()) {\n             MethodInfo info = it.next();\n-            if (Modifier.isAbstract(info.getMethod().getModifiers())) {\n+            // if the class is an interface then keep the method\n+            boolean isFromInterface = Modifier.isInterface(info.getMethod().getDeclaringClass().getModifiers());\n+            if (!isFromInterface && Modifier.isAbstract(info.getMethod().getModifiers())) {\n                 // we cannot invoke an abstract method\n                 it.remove();\n             }\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "9243",
        "nb_skipped": 4,
        "commit": "1957a828",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4182,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.aggregator.AggregateTimeoutWithExecutorServiceTest",
            "org.apache.camel.component.file.FilerConsumerDoneFileNoopTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileOnCompletion.java b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileOnCompletion.java\nindex 58c825f1a1..726df83661 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileOnCompletion.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileOnCompletion.java\n@@ -109,8 +109,8 @@ protected void processStrategyCommit(GenericFileProcessStrategy<T> processStrate\n             endpoint.getIdempotentRepository().add(absoluteFileName);\n         }\n \n-        // delete done file if used\n-        if (endpoint.getDoneFileName() != null) {\n+        // delete done file if used (and not noop=true)\n+        if (endpoint.getDoneFileName() != null && !endpoint.isNoop()) {\n             // done file must be in same path as the original input file\n             String doneFileName = endpoint.createDoneFileName(absoluteFileName);\n             ObjectHelper.notEmpty(doneFileName, \"doneFileName\", endpoint);\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "5224",
        "nb_skipped": 1,
        "commit": "2db5570f",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 5552,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.management.ManagedInterceptFromTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementObjectStrategy.java b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementObjectStrategy.java\nindex d30e4fef60..c53cffb53f 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementObjectStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementObjectStrategy.java\n@@ -96,6 +96,7 @@\n import org.apache.camel.management.mbean.ManagedValidate;\n import org.apache.camel.management.mbean.ManagedWeightedLoadBalancer;\n import org.apache.camel.management.mbean.ManagedWireTapProcessor;\n+import org.apache.camel.model.ExpressionNode;\n import org.apache.camel.model.LoadBalanceDefinition;\n import org.apache.camel.model.ModelCamelContext;\n import org.apache.camel.model.ProcessDefinition;\n@@ -307,7 +308,7 @@ public Object getManagedObjectForProcessor(CamelContext context, Processor proce\n             } else if (target instanceof RoutingSlip) {\n                 answer = new ManagedRoutingSlip(context, (RoutingSlip) target, (org.apache.camel.model.RoutingSlipDefinition) definition);\n             } else if (target instanceof FilterProcessor) {\n-                answer = new ManagedFilter(context, (FilterProcessor) target, (org.apache.camel.model.FilterDefinition) definition);\n+                answer = new ManagedFilter(context, (FilterProcessor) target, (ExpressionNode)definition);\n             } else if (target instanceof LogProcessor) {\n                 answer = new ManagedLog(context, (LogProcessor) target, definition);\n             } else if (target instanceof LoopProcessor) {\ndiff --git a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedFilter.java b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedFilter.java\nindex 9d9ae5a8be..2d253b6dfe 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedFilter.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedFilter.java\n@@ -19,7 +19,7 @@\n import org.apache.camel.CamelContext;\n import org.apache.camel.api.management.ManagedResource;\n import org.apache.camel.api.management.mbean.ManagedFilterMBean;\n-import org.apache.camel.model.FilterDefinition;\n+import org.apache.camel.model.ExpressionNode;\n import org.apache.camel.processor.FilterProcessor;\n \n /**\n@@ -29,14 +29,14 @@\n public class ManagedFilter extends ManagedProcessor implements ManagedFilterMBean {\n     private final FilterProcessor processor;\n \n-    public ManagedFilter(CamelContext context, FilterProcessor processor, FilterDefinition definition) {\n+    public ManagedFilter(CamelContext context, FilterProcessor processor, ExpressionNode definition) {\n         super(context, processor, definition);\n         this.processor = processor;\n     }\n \n     @Override\n-    public FilterDefinition getDefinition() {\n-        return (FilterDefinition) super.getDefinition();\n+    public ExpressionNode getDefinition() {\n+        return (ExpressionNode) super.getDefinition();\n     }\n \n     @Override\n",
        "project": "camel",
        "linesAdd": 6,
        "jira_id": "9672",
        "nb_skipped": 4,
        "commit": "84922699",
        "nb_failure": 0,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4147,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.aggregator.AggregateTimeoutWithExecutorServiceTest",
            "org.apache.camel.component.timer.TimerSuspendCamelContextTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/timer/TimerConsumer.java b/camel-core/src/main/java/org/apache/camel/component/timer/TimerConsumer.java\nindex a2cf79ec71..13be49594e 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/timer/TimerConsumer.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/timer/TimerConsumer.java\n@@ -50,6 +50,11 @@ protected void doStart() throws Exception {\n \n             @Override\n             public void run() {\n+                if (!isTaskRunAllowed()) {\n+                    // do not run timer task as it was not allowed\n+                    return;\n+                }\n+\n                 try {\n                     long count = counter.incrementAndGet();\n \n@@ -80,6 +85,14 @@ protected void doStop() throws Exception {\n         task = null;\n     }\n \n+    /**\n+     * Whether the timer task is allow to run or not\n+     */\n+    protected boolean isTaskRunAllowed() {\n+        // only allow running the timer task if we can run and are not suspended\n+        return isRunAllowed() && !isSuspended();\n+    }\n+\n     protected void configureTask(TimerTask task, Timer timer) {\n         if (endpoint.isFixedRate()) {\n             if (endpoint.getTime() != null) {\n",
        "project": "camel",
        "linesAdd": 8,
        "jira_id": "5137",
        "nb_skipped": 0,
        "commit": "afa1d132",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4289,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.aggregator.AggregateTimeoutTest",
            "org.apache.camel.issues.RedeliveryPolicyOnExceptionWhileRedeliveringIssueTest",
            "org.apache.camel.component.file.AntPathMatcherGenericFileFilterTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/OnExceptionDefinition.java b/camel-core/src/main/java/org/apache/camel/model/OnExceptionDefinition.java\nindex 50a41a3125..f8e42b9b7f 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/OnExceptionDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/OnExceptionDefinition.java\n@@ -144,7 +144,7 @@ public RedeliveryPolicy createRedeliveryPolicy(CamelContext context, RedeliveryP\n             return CamelContextHelper.mandatoryLookup(context, redeliveryPolicyRef, RedeliveryPolicy.class);\n         } else if (redeliveryPolicy != null) {\n             return redeliveryPolicy.createRedeliveryPolicy(context, parentPolicy);\n-        } else if (!outputs.isEmpty() && parentPolicy.getMaximumRedeliveries() > 0) {\n+        } else if (!outputs.isEmpty() && parentPolicy.getMaximumRedeliveries() != 0) {\n             // if we have outputs, then do not inherit parent maximumRedeliveries\n             // as you would have to explicit configure maximumRedeliveries on this onException to use it\n             // this is the behavior Camel has always had\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "5570",
        "nb_skipped": 1,
        "commit": "a57830ed",
        "nb_failure": 3,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 5015,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.management.ManagedCamelContextNewProxyTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/api/management/mbean/ManagedCamelContextMBean.java b/camel-core/src/main/java/org/apache/camel/api/management/mbean/ManagedCamelContextMBean.java\nindex 700ae2266c..9a58c0db86 100644\n--- a/camel-core/src/main/java/org/apache/camel/api/management/mbean/ManagedCamelContextMBean.java\n+++ b/camel-core/src/main/java/org/apache/camel/api/management/mbean/ManagedCamelContextMBean.java\n@@ -80,9 +80,6 @@\n     @ManagedAttribute(description = \"Tracing\")\n     void setTracing(Boolean tracing);\n \n-    @ManagedAttribute(description = \"Message History\")\n-    Boolean getMessageHistory();\n-\n     @ManagedAttribute(description = \"Current number of inflight Exchanges\")\n     Integer getInflightExchanges();\n \ndiff --git a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedCamelContext.java b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedCamelContext.java\nindex a641b685b4..19a58c04c5 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedCamelContext.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedCamelContext.java\n@@ -127,10 +127,6 @@ public void setTracing(Boolean tracing) {\n         context.setTracing(tracing);\n     }\n \n-    public Boolean getMessageHistory() {\n-        return context.isMessageHistory();\n-    }\n-\n     public Integer getInflightExchanges() {\n         return context.getInflightRepository().size();\n     }\n@@ -212,7 +208,7 @@ public boolean isAllowUseOriginalMessage() {\n     }\n \n     public boolean isMessageHistory() {\n-        return context.isMessageHistory();\n+        return context.isMessageHistory() != null ? context.isMessageHistory() : false;\n     }\n \n     public boolean isUseMDCLogging() {\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "7586",
        "nb_skipped": 3,
        "commit": "1f92fa42",
        "nb_failure": 0,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 0,
        "nb_test": 5519,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.issues.RecipientListShareUnitOfWorkOnExceptionHandledFalseIssueTest",
            "org.apache.camel.processor.SplitSubUnitOfWorkWithMDCLoggingTest",
            "org.apache.camel.processor.SplitTwoSubUnitOfWorkTest",
            "org.apache.camel.processor.SplitSubUnitOfWorkTest"
        ],
        "patch": "",
        "project": "camel",
        "linesAdd": 0,
        "jira_id": "9444",
        "nb_skipped": 4,
        "commit": "baece126",
        "nb_failure": 4,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 4665,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.async.AsyncNestedTripleChoiceIssueTest",
            "org.apache.camel.processor.TripleNestedChoiceIssueTest",
            "org.apache.camel.processor.NestedChoiceIssueTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\nindex 45889c37d0..9998e51c62 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n@@ -1295,8 +1295,13 @@ public AOPDefinition aop() {\n      * @return the builder\n      */\n     public ChoiceDefinition endChoice() {\n-        // are we already a choice?\n+        // are we nested choice?\n         ProcessorDefinition<?> def = this;\n+        if (def.getParent() instanceof WhenDefinition) {\n+            return (ChoiceDefinition) def.getParent().getParent();\n+        }\n+\n+        // are we already a choice?\n         if (def instanceof ChoiceDefinition) {\n             return (ChoiceDefinition) def;\n         }\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java\nindex 5af8b360fd..0310c9a02d 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/ChoiceProcessor.java\n@@ -30,10 +30,6 @@\n import org.apache.camel.util.AsyncProcessorConverterHelper;\n import org.apache.camel.util.AsyncProcessorHelper;\n import org.apache.camel.util.ServiceHelper;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static org.apache.camel.processor.PipelineHelper.continueProcessing;\n \n /**\n  * Implements a Choice structure where one or more predicates are used which if\n@@ -43,7 +39,6 @@\n  * @version \n  */\n public class ChoiceProcessor extends ServiceSupport implements AsyncProcessor, Navigate<Processor>, Traceable {\n-    private static final Logger LOG = LoggerFactory.getLogger(ChoiceProcessor.class);\n     private final List<Processor> filters;\n     private final Processor otherwise;\n \n@@ -56,91 +51,61 @@ public void process(Exchange exchange) throws Exception {\n         AsyncProcessorHelper.process(this, exchange);\n     }\n \n-    public boolean process(Exchange exchange, AsyncCallback callback) {\n+    public boolean process(final Exchange exchange, final AsyncCallback callback) {\n         Iterator<Processor> processors = next().iterator();\n \n-        exchange.setProperty(Exchange.FILTER_MATCHED, false);\n-        while (continueRouting(processors, exchange)) {\n-            // get the next processor\n-            Processor processor = processors.next();\n-\n-            AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);\n-            boolean sync = process(exchange, callback, processors, async);\n-\n-            // continue as long its being processed synchronously\n-            if (!sync) {\n-                LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n-                // the remainder of the CBR will be completed async\n-                // so we break out now, then the callback will be invoked which then continue routing from where we left here\n-                return false;\n-            }\n-\n-            LOG.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\n-\n-            // check for error if so we should break out\n-            if (!continueProcessing(exchange, \"so breaking out of content based router\", LOG)) {\n-                break;\n+        // callback to restore existing FILTER_MATCHED property on the Exchange\n+        final Object existing = exchange.getProperty(Exchange.FILTER_MATCHED);\n+        final AsyncCallback choiceCallback = new AsyncCallback() {\n+            @Override\n+            public void done(boolean doneSync) {\n+                if (existing != null) {\n+                    exchange.setProperty(Exchange.FILTER_MATCHED, existing);\n+                } else {\n+                    exchange.removeProperty(Exchange.FILTER_MATCHED);\n                 }\n+                callback.done(doneSync);\n             }\n+        };\n \n-        LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n+        // as we only pick one processor to process, then no need to have async callback that has a while loop as well\n+        // as this should not happen, eg we pick the first filter processor that matches, or the otherwise (if present)\n+        // and if not, we just continue without using any processor\n+        while (processors.hasNext()) {\n+            // get the next processor\n+            Processor processor = processors.next();\n \n-        callback.done(true);\n+            // evaluate the predicate on filter predicate early to be faster\n+            // and avoid issues when having nested choices\n+            // as we should only pick one processor\n+            boolean matches = true;\n+            if (processor instanceof FilterProcessor) {\n+                FilterProcessor filter = (FilterProcessor) processor;\n+                try {\n+                    matches = filter.getPredicate().matches(exchange);\n+                    exchange.setProperty(Exchange.FILTER_MATCHED, matches);\n+                } catch (Throwable e) {\n+                    exchange.setException(e);\n+                    choiceCallback.done(true);\n                     return true;\n                 }\n-\n-    protected boolean continueRouting(Iterator<Processor> it, Exchange exchange) {\n-        boolean answer = it.hasNext();\n-        if (answer) {\n-            Object matched = exchange.getProperty(Exchange.FILTER_MATCHED);\n-            if (matched != null) {\n-                boolean hasMatched = exchange.getContext().getTypeConverter().convertTo(Boolean.class, matched);\n-                if (hasMatched) {\n-                    LOG.debug(\"ExchangeId: {} has been matched: {}\", exchange.getExchangeId(), exchange);\n-                    answer = false;\n+                // as we have pre evaluated the predicate then use its processor directly when routing\n+                processor = filter.getProcessor();\n             }\n-            }\n-        }\n-        LOG.trace(\"ExchangeId: {} should continue matching: {}\", exchange.getExchangeId(), answer);\n-        return answer;\n-    }\n-\n-    private boolean process(final Exchange exchange, final AsyncCallback callback,\n-                            final Iterator<Processor> processors, final AsyncProcessor asyncProcessor) {\n-        // this does the actual processing so log at trace level\n-        LOG.trace(\"Processing exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n-\n-        // implement asynchronous routing logic in callback so we can have the callback being\n-        // triggered and then continue routing where we left\n-        boolean sync = asyncProcessor.process(exchange, new AsyncCallback() {\n-            public void done(boolean doneSync) {\n-                // we only have to handle async completion of the pipeline\n-                if (doneSync) {\n-                    return;\n-                }\n-\n-                // continue processing the pipeline asynchronously\n-                while (continueRouting(processors, exchange)) {\n-                    AsyncProcessor processor = AsyncProcessorConverterHelper.convert(processors.next());\n \n-                    // check for error if so we should break out\n-                    if (!continueProcessing(exchange, \"so breaking out of pipeline\", LOG)) {\n-                        break;\n+            // if we did not match then continue to next filter\n+            if (!matches) {\n+                continue;\n             }\n \n-                    doneSync = process(exchange, callback, processors, processor);\n-                    if (!doneSync) {\n-                        LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n-                        return;\n-                    }\n-                }\n-\n-                LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n-                callback.done(false);\n+            // okay we found a filter or its the otherwise we are processing\n+            AsyncProcessor async = AsyncProcessorConverterHelper.convert(processor);\n+            return async.process(exchange, choiceCallback);\n         }\n-        });\n \n-        return sync;\n+        // when no filter matches and there is no otherwise, then just continue\n+        choiceCallback.done(true);\n+        return true;\n     }\n \n     @Override\n",
        "project": "camel",
        "linesAdd": 33,
        "jira_id": "6447",
        "nb_skipped": 1,
        "commit": "020c451a",
        "nb_failure": 8,
        "linesRem": 65,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4675,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.AsyncLoopCopyTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/LoopProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/LoopProcessor.java\nindex df2baed383..89649b15be 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/LoopProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/LoopProcessor.java\n@@ -61,6 +61,10 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n             return true;\n         }\n         \n+        // we hold on to the original Exchange in case it's needed for copies\n+        final Exchange original = exchange;\n+        \n+        // per-iteration exchange\n         Exchange target = exchange;\n \n         // set the size before we start\n@@ -70,8 +74,9 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n         while (index.get() < count.get()) {\n \n             // and prepare for next iteration\n-            target = prepareExchange(exchange, index.get());\n-            boolean sync = process(target, callback, index, count);\n+            // if (!copy) target = exchange; else copy of original\n+            target = prepareExchange(exchange, index.get(), original);\n+            boolean sync = process(target, callback, index, count, original);\n \n             if (!sync) {\n                 LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", target.getExchangeId());\n@@ -94,7 +99,8 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n     }\n \n     protected boolean process(final Exchange exchange, final AsyncCallback callback,\n-                              final AtomicInteger index, final AtomicInteger count) {\n+                              final AtomicInteger index, final AtomicInteger count,\n+                              final Exchange original) {\n \n         // set current index as property\n         LOG.debug(\"LoopProcessor: iteration #{}\", index.get());\n@@ -116,10 +122,10 @@ public void done(boolean doneSync) {\n                 while (index.get() < count.get()) {\n \n                     // and prepare for next iteration\n-                    target = prepareExchange(exchange, index.get());\n+                    target = prepareExchange(exchange, index.get(), original);\n \n                     // process again\n-                    boolean sync = process(target, callback, index, count);\n+                    boolean sync = process(target, callback, index, count, original);\n                     if (!sync) {\n                         LOG.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", target.getExchangeId());\n                         // the remainder of the routing slip will be completed async\n@@ -148,10 +154,11 @@ public void done(boolean doneSync) {\n      * @param index the index of the next iteration\n      * @return the exchange to use\n      */\n-    protected Exchange prepareExchange(Exchange exchange, int index) {\n+    protected Exchange prepareExchange(Exchange exchange, int index, Exchange original) {\n         if (copy) {\n             // use a copy but let it reuse the same exchange id so it appear as one exchange\n-            return ExchangeHelper.createCopy(exchange, true);\n+            // use the original exchange rather than the looping exchange (esp. with the async routing engine)\n+            return ExchangeHelper.createCopy(original, true);\n         } else {\n             ExchangeHelper.prepareOutToIn(exchange);\n             return exchange;\n",
        "project": "camel",
        "linesAdd": 10,
        "jira_id": "6667",
        "nb_skipped": 1,
        "commit": "1fc7bd7a",
        "nb_failure": 1,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4714,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.converter.jaxp.StaxConverterTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/converter/jaxp/StaxConverter.java b/camel-core/src/main/java/org/apache/camel/converter/jaxp/StaxConverter.java\nindex 1cd33ae38c..5469df590b 100644\n--- a/camel-core/src/main/java/org/apache/camel/converter/jaxp/StaxConverter.java\n+++ b/camel-core/src/main/java/org/apache/camel/converter/jaxp/StaxConverter.java\n@@ -167,7 +167,7 @@ public XMLStreamReader createXMLStreamReader(InputStream in) throws XMLStreamExc\n     public XMLStreamReader createXMLStreamReader(InputStream in, Exchange exchange) throws XMLStreamException {\n         XMLInputFactory factory = getInputFactory();\n         try {\n-            return factory.createXMLStreamReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange));\n+            return factory.createXMLStreamReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange, false));\n         } finally {\n             returnXMLInputFactory(factory);\n         }\n@@ -236,7 +236,7 @@ public XMLEventReader createXMLEventReader(InputStream in) throws XMLStreamExcep\n     public XMLEventReader createXMLEventReader(InputStream in, Exchange exchange) throws XMLStreamException {\n         XMLInputFactory factory = getInputFactory();\n         try {\n-            return factory.createXMLEventReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange));\n+            return factory.createXMLEventReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange, false));\n         } finally {\n             returnXMLInputFactory(factory);\n         }\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "6779",
        "nb_skipped": 1,
        "commit": "f412d744",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 3043,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.issues.TwoRouteScopedOnExceptionWithInterceptSendToEndpointIssueWithPredicateTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/ErrorHandlerSupport.java b/camel-core/src/main/java/org/apache/camel/processor/ErrorHandlerSupport.java\nindex aa00fbb1eb..a7904e8b63 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/ErrorHandlerSupport.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/ErrorHandlerSupport.java\n@@ -24,6 +24,8 @@\n import org.apache.camel.Processor;\n import org.apache.camel.impl.ServiceSupport;\n import org.apache.camel.model.OnExceptionDefinition;\n+import org.apache.camel.model.ProcessorDefinitionHelper;\n+import org.apache.camel.model.RouteDefinition;\n import org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategy;\n import org.apache.camel.processor.exceptionpolicy.ExceptionPolicyKey;\n import org.apache.camel.processor.exceptionpolicy.ExceptionPolicyStrategy;\n@@ -49,7 +51,9 @@ public void addExceptionPolicy(OnExceptionDefinition exceptionType) {\n         List<Class> list = exceptionType.getExceptionClasses();\n \n         for (Class clazz : list) {\n-            ExceptionPolicyKey key = new ExceptionPolicyKey(clazz, exceptionType.getOnWhen());\n+            RouteDefinition route = ProcessorDefinitionHelper.getRoute(exceptionType);\n+            String routeId = route != null ? route.getId() : null;\n+            ExceptionPolicyKey key = new ExceptionPolicyKey(routeId, clazz, exceptionType.getOnWhen());\n             exceptionPolicies.put(key, exceptionType);\n         }\n     }\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/DefaultExceptionPolicyStrategy.java b/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/DefaultExceptionPolicyStrategy.java\nindex 01d86e3127..d727e1745f 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/DefaultExceptionPolicyStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/DefaultExceptionPolicyStrategy.java\n@@ -17,6 +17,7 @@\n package org.apache.camel.processor.exceptionpolicy;\n \n import java.util.Iterator;\n+import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Set;\n import java.util.TreeMap;\n@@ -61,17 +62,29 @@ public OnExceptionDefinition getExceptionPolicy(Map<ExceptionPolicyKey, OnExcept\n                                                     Exchange exchange, Throwable exception) {\n \n         Map<Integer, OnExceptionDefinition> candidates = new TreeMap<Integer, OnExceptionDefinition>();\n+        Map<ExceptionPolicyKey, OnExceptionDefinition> routeScoped = new LinkedHashMap<ExceptionPolicyKey, OnExceptionDefinition>();\n+        Map<ExceptionPolicyKey, OnExceptionDefinition> contextScoped = new LinkedHashMap<ExceptionPolicyKey, OnExceptionDefinition>();\n \n+        // split policies into route and context scoped\n+        initRouteAndContextScopedExceptionPolicies(exceptionPolicies, routeScoped, contextScoped);\n+\n+        // at first check route scoped as we prefer them over context scoped\n         // recursive up the tree using the iterator\n         boolean exactMatch = false;\n         Iterator<Throwable> it = createExceptionIterator(exception);\n         while (!exactMatch && it.hasNext()) {\n             // we should stop looking if we have found an exact match\n-            exactMatch = findMatchedExceptionPolicy(exceptionPolicies, exchange, it.next(), candidates);\n+            exactMatch = findMatchedExceptionPolicy(routeScoped, exchange, it.next(), candidates);\n         }\n \n-        // now go through the candidates and find the best\n+        // fallback to check context scoped (only do this if there was no exact match)\n+        it = createExceptionIterator(exception);\n+        while (!exactMatch && it.hasNext()) {\n+            // we should stop looking if we have found an exact match\n+            exactMatch = findMatchedExceptionPolicy(contextScoped, exchange, it.next(), candidates);\n+        }\n \n+        // now go through the candidates and find the best\n         if (LOG.isTraceEnabled()) {\n             LOG.trace(\"Found \" + candidates.size() + \" candidates\");\n         }\n@@ -80,11 +93,26 @@ public OnExceptionDefinition getExceptionPolicy(Map<ExceptionPolicyKey, OnExcept\n             // no type found\n             return null;\n         } else {\n-            // return the first in the map as its sorted and\n+            // return the first in the map as its sorted and we checked route scoped first, which we prefer\n             return candidates.values().iterator().next();\n         }\n     }\n \n+    private void initRouteAndContextScopedExceptionPolicies(Map<ExceptionPolicyKey, OnExceptionDefinition> exceptionPolicies,\n+                                                            Map<ExceptionPolicyKey, OnExceptionDefinition> routeScoped,\n+                                                            Map<ExceptionPolicyKey, OnExceptionDefinition> contextScoped) {\n+\n+        // loop through all the entries and split into route and context scoped\n+        Set<Map.Entry<ExceptionPolicyKey, OnExceptionDefinition>> entries = exceptionPolicies.entrySet();\n+        for (Map.Entry<ExceptionPolicyKey, OnExceptionDefinition> entry : entries) {\n+            if (entry.getKey().getRouteId() != null) {\n+                routeScoped.put(entry.getKey(), entry.getValue());\n+            } else {\n+                contextScoped.put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+    }\n+\n \n     private boolean findMatchedExceptionPolicy(Map<ExceptionPolicyKey, OnExceptionDefinition> exceptionPolicies,\n                                                Exchange exchange, Throwable exception,\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/ExceptionPolicyKey.java b/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/ExceptionPolicyKey.java\nindex cbd1fa16fe..3c79baa7a0 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/ExceptionPolicyKey.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/exceptionpolicy/ExceptionPolicyKey.java\n@@ -20,16 +20,30 @@\n \n /**\n  * Exception policy key is a compound key for storing:\n- * <b>exception class</b> + <b>when</b> => <b>exception type</b>.\n+ * <b>route id </b> + <b>exception class</b> + <b>when</b> => <b>exception type</b>.\n  * <p/>\n  * This is used by Camel to store the onException types configured that has or has not predicates attached (when).\n  */\n public final class ExceptionPolicyKey {\n \n+    private final String routeId;\n     private final Class exceptionClass;\n     private final WhenDefinition when;\n \n+    @Deprecated\n     public ExceptionPolicyKey(Class exceptionClass, WhenDefinition when) {\n+        this(null, exceptionClass, when);\n+    }\n+\n+    /**\n+     * Key for exception clause\n+     *\n+     * @param routeId          the route, or use <tt>null</tt> for a global scoped\n+     * @param exceptionClass   the exception class\n+     * @param when             optional predicate when the exception clause should trigger\n+     */\n+    public ExceptionPolicyKey(String routeId, Class exceptionClass, WhenDefinition when) {\n+        this.routeId = routeId;\n         this.exceptionClass = exceptionClass;\n         this.when = when;\n     }\n@@ -42,10 +56,16 @@ public WhenDefinition getWhen() {\n         return when;\n     }\n \n+    public String getRouteId() {\n+        return routeId;\n+    }\n+\n+    @Deprecated\n     public static ExceptionPolicyKey newInstance(Class exceptionClass) {\n         return new ExceptionPolicyKey(exceptionClass, null);\n     }\n \n+    @Deprecated\n     public static ExceptionPolicyKey newInstance(Class exceptionClass, WhenDefinition when) {\n         return new ExceptionPolicyKey(exceptionClass, when);\n     }\n@@ -61,7 +81,10 @@ public boolean equals(Object o) {\n \n         ExceptionPolicyKey that = (ExceptionPolicyKey) o;\n \n-        if (!exceptionClass.equals(that.exceptionClass)) {\n+        if (exceptionClass != null ? !exceptionClass.equals(that.exceptionClass) : that.exceptionClass != null) {\n+            return false;\n+        }\n+        if (routeId != null ? !routeId.equals(that.routeId) : that.routeId != null) {\n             return false;\n         }\n         if (when != null ? !when.equals(that.when) : that.when != null) {\n@@ -73,13 +96,14 @@ public boolean equals(Object o) {\n \n     @Override\n     public int hashCode() {\n-        int result = exceptionClass.hashCode();\n+        int result = routeId != null ? routeId.hashCode() : 0;\n+        result = 31 * result + (exceptionClass != null ? exceptionClass.hashCode() : 0);\n         result = 31 * result + (when != null ? when.hashCode() : 0);\n         return result;\n     }\n \n     @Override\n     public String toString() {\n-        return \"ExceptionPolicyKey[\" + exceptionClass + (when != null ? \" \" + when : \"\") + \"]\";\n+        return \"ExceptionPolicyKey[route: \" + (routeId != null ? routeId : \"<global>\") + \", \" + exceptionClass + (when != null ? \" \" + when : \"\") + \"]\";\n     }\n }\n",
        "project": "camel",
        "linesAdd": 49,
        "jira_id": "3448",
        "nb_skipped": 0,
        "commit": "b345dd82",
        "nb_failure": 0,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4839,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.aggregator.AggregateTimeoutTest",
            "org.apache.camel.component.file.FileConsumerIdempotentTest",
            "org.apache.camel.converter.NIOConverterTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java b/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\nindex 41273b6b56..e1cf6d6796 100644\n--- a/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\n+++ b/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\n@@ -54,7 +54,7 @@ private NIOConverter() {\n \n     @Converter\n     public static String toString(ByteBuffer buffer, Exchange exchange) throws IOException {\n-        return IOConverter.toString(buffer.array(), exchange);\n+        return IOConverter.toString(toByteArray(buffer), exchange);\n     }\n \n     @Converter\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "7241",
        "nb_skipped": 3,
        "commit": "18c23fa8",
        "nb_failure": 3,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4887,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.language.simple.SimpleTest",
            "org.apache.camel.management.ManagedThrottlerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java b/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\nindex d02f050919..32a22b2019 100644\n--- a/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\n+++ b/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\n@@ -195,9 +195,11 @@ private Expression createSimpleExpressionBodyOrHeader(String function, boolean s\n         String remainder = ifStartsWithReturnRemainder(\"bodyAs\", function);\n         if (remainder != null) {\n             String type = ObjectHelper.between(remainder, \"(\", \")\");\n-            if (type == null) {\n+            remainder = ObjectHelper.after(remainder, \")\");\n+            if (type == null || ObjectHelper.isNotEmpty(remainder)) {\n                 throw new SimpleParserException(\"Valid syntax: ${bodyAs(type)} was: \" + function, token.getIndex());\n             }\n+            \n             type = StringHelper.removeQuotes(type);\n             return ExpressionBuilder.bodyExpression(type);\n         }\n@@ -205,7 +207,8 @@ private Expression createSimpleExpressionBodyOrHeader(String function, boolean s\n         remainder = ifStartsWithReturnRemainder(\"mandatoryBodyAs\", function);\n         if (remainder != null) {\n             String type = ObjectHelper.between(remainder, \"(\", \")\");\n-            if (type == null) {\n+            remainder = ObjectHelper.after(remainder, \")\");\n+            if (type == null || ObjectHelper.isNotEmpty(remainder)) {\n                 throw new SimpleParserException(\"Valid syntax: ${mandatoryBodyAs(type)} was: \" + function, token.getIndex());\n             }\n             type = StringHelper.removeQuotes(type);\n",
        "project": "camel",
        "linesAdd": 5,
        "jira_id": "7359",
        "nb_skipped": 3,
        "commit": "e6fbbf04",
        "nb_failure": 3,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2992,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.bean.BeanWithHeadersAndBodyInject3Test"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java\nindex cdcfa6adde..5f73fe310b 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/ExpressionBuilder.java\n@@ -254,12 +254,18 @@ public String toString() {\n     /**\n      * Returns an expression for the outbound message headers\n      *\n-     * @return an expression object which will return the headers\n+     * @return an expression object which will return the headers, will be <tt>null</tt> if the\n+     * exchange is not out capable.\n      */\n     public static Expression outHeadersExpression() {\n         return new ExpressionAdapter() {\n             public Object evaluate(Exchange exchange) {\n+                // only get out headers if the MEP is out capable\n+                if (ExchangeHelper.isOutCapable(exchange)) {\n                     return exchange.getOut().getHeaders();\n+                } else {\n+                    return null;\n+                }\n             }\n \n             @Override\n",
        "project": "camel",
        "linesAdd": 4,
        "jira_id": "3388",
        "nb_skipped": 0,
        "commit": "0919a0f6",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4772,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.DataFormatStreamingTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/converter/stream/CachedOutputStream.java b/camel-core/src/main/java/org/apache/camel/converter/stream/CachedOutputStream.java\nindex c5f3b49b01..0e3540c75a 100644\n--- a/camel-core/src/main/java/org/apache/camel/converter/stream/CachedOutputStream.java\n+++ b/camel-core/src/main/java/org/apache/camel/converter/stream/CachedOutputStream.java\n@@ -71,11 +71,10 @@ public CachedOutputStream(Exchange exchange) {\n         this(exchange, true);\n     }\n \n-    public CachedOutputStream(Exchange exchange, boolean closedOnCompletion) {\n+    public CachedOutputStream(Exchange exchange, final boolean closedOnCompletion) {\n         this.strategy = exchange.getContext().getStreamCachingStrategy();\n         currentStream = new CachedByteArrayOutputStream(strategy.getBufferSize());\n         \n-        if (closedOnCompletion) {\n         // add on completion so we can cleanup after the exchange is done such as deleting temporary files\n         exchange.addOnCompletion(new SynchronizationAdapter() {\n             @Override\n@@ -84,9 +83,16 @@ public void onDone(Exchange exchange) {\n                     if (fileInputStreamCache != null) {\n                         fileInputStreamCache.close();\n                     }\n+                    if (closedOnCompletion) {\n                         close();\n+                    }\n                 } catch (Exception e) {\n-                        LOG.warn(\"Error deleting temporary cache file: \" + tempFile, e);\n+                    LOG.warn(\"Error closing streams. This exception will be ignored.\", e);\n+                }\n+                try {\n+                    cleanUpTempFile();\n+                } catch (Exception e) {\n+                    LOG.warn(\"Error deleting temporary cache file: \" + tempFile + \". This exception will be ignored.\", e);\n                 }\n             }\n     \n@@ -96,7 +102,6 @@ public String toString() {\n             }\n         });\n     }\n-    }\n \n     public void flush() throws IOException {\n         currentStream.flush();       \n@@ -104,7 +109,6 @@ public void flush() throws IOException {\n \n     public void close() throws IOException {\n         currentStream.close();\n-        cleanUpTempFile();\n     }\n \n     public boolean equals(Object obj) {\n",
        "project": "camel",
        "linesAdd": 9,
        "jira_id": "7055",
        "nb_skipped": 1,
        "commit": "15e1077d",
        "nb_failure": 0,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4742,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.file.FileConsumerIdempotentTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConsumer.java b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConsumer.java\nindex c8452fd4e9..02130d286e 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConsumer.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConsumer.java\n@@ -484,22 +484,32 @@ protected boolean isValidFile(GenericFile<T> file, boolean isDirectory, List<T>\n             return false;\n         }\n \n+        boolean answer = true;\n+        String key = null;\n+        try {\n             // if its a file then check we have the file in the idempotent registry already\n             if (!isDirectory && endpoint.isIdempotent()) {\n                 // use absolute file path as default key, but evaluate if an expression key was configured\n-            String key = file.getAbsoluteFilePath();\n+                key = file.getAbsoluteFilePath();\n                 if (endpoint.getIdempotentKey() != null) {\n                     Exchange dummy = endpoint.createExchange(file);\n                     key = endpoint.getIdempotentKey().evaluate(dummy, String.class);\n                 }\n                 if (key != null && endpoint.getIdempotentRepository().contains(key)) {\n                     log.trace(\"This consumer is idempotent and the file has been consumed before. Will skip this file: {}\", file);\n-                return false;\n+                    answer = false;\n+                }\n+            }\n+        } finally {\n+            // ensure to run this in finally block in case of runtime exceptions being thrown\n+            if (!answer) {\n+                // remove file from the in progress list as its no longer in progress\n+                endpoint.getInProgressRepository().remove(key);\n             }\n         }\n \n         // file matched\n-        return true;\n+        return answer;\n     }\n \n     /**\n@@ -607,6 +617,7 @@ protected boolean isMatched(GenericFile<T> file, boolean isDirectory, List<T> fi\n      */\n     protected boolean isInProgress(GenericFile<T> file) {\n         String key = file.getAbsoluteFilePath();\n+        // must use add, to have operation as atomic\n         return !endpoint.getInProgressRepository().add(key);\n     }\n \n",
        "project": "camel",
        "linesAdd": 11,
        "jira_id": "6936",
        "nb_skipped": 1,
        "commit": "4954d573",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4766,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.management.ManagedRouteUpdateRouteFromXmlTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRoute.java b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRoute.java\nindex b1cc984484..51ce287665 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRoute.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRoute.java\n@@ -230,6 +230,16 @@ public void updateRouteFromXml(String xml) throws Exception {\n             return;\n         }\n \n+        // if the xml does not contain the route-id then we fix this by adding the actual route id\n+        // this may be needed if the route-id was auto-generated, as the intend is to update this route\n+        // and not add a new route, adding a new route, use the MBean operation on ManagedCamelContext instead.\n+        if (ObjectHelper.isEmpty(def.getId())) {\n+            def.setId(getRouteId());\n+        } else if (!def.getId().equals(getRouteId())) {\n+            throw new IllegalArgumentException(\"Cannot update route from XML as routeIds does not match. routeId: \"\n+                    + getRouteId() + \", routeId from XML: \" + def.getId());\n+        }\n+\n         // add will remove existing route first\n         context.addRouteDefinition(def);\n     }\n",
        "project": "camel",
        "linesAdd": 7,
        "jira_id": "7016",
        "nb_skipped": 1,
        "commit": "4ed448c7",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 4774,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.SplitterWithScannerIoExceptionTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\nindex a9dd334fd3..d1a0f646c0 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n@@ -192,19 +192,20 @@ public void remove() {\n \n         @Override\n         public void close() throws IOException {\n-            if (value instanceof Closeable) {\n-                IOHelper.close((Closeable) value, value.getClass().getName(), LOG);\n-            } else if (value instanceof Scanner) {\n-                // special for Scanner as it does not implement Closeable\n+            if (value instanceof Scanner) {\n+                // special for Scanner which implement the Closeable since JDK7 \n                 Scanner scanner = (Scanner) value;\n                 scanner.close();\n-\n                 IOException ioException = scanner.ioException();\n                 if (ioException != null) {\n                     throw ioException;\n                 }\n+            } else if (value instanceof Closeable) {\n+                // we should throw out the exception here   \n+                IOHelper.closeWithException((Closeable) value);\n             }\n         }\n+       \n     }\n \n     private Iterable<ProcessorExchangePair> createProcessorExchangePairsList(Exchange exchange, Object value) {\ndiff --git a/camel-core/src/main/java/org/apache/camel/util/GroupIterator.java b/camel-core/src/main/java/org/apache/camel/util/GroupIterator.java\nindex 95a5a1e2a2..158dbed4e2 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/GroupIterator.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/GroupIterator.java\n@@ -65,17 +65,25 @@ public GroupIterator(CamelContext camelContext, Iterator<?> it, String token, in\n \n     @Override\n     public void close() throws IOException {\n-        if (it instanceof Closeable) {\n-            IOHelper.close((Closeable) it);\n-        } else if (it instanceof Scanner) {\n-            // special for Scanner as it does not implement Closeable\n-            ((Scanner) it).close();\n-        }\n+        try {\n+            if (it instanceof Scanner) {\n+                // special for Scanner which implement the Closeable since JDK7 \n+                Scanner scanner = (Scanner) it;\n+                scanner.close();\n+                IOException ioException = scanner.ioException();\n+                if (ioException != null) {\n+                    throw ioException;\n+                }\n+            } else if (it instanceof Closeable) {\n+                IOHelper.closeWithException((Closeable) it);\n+            }\n+        } finally {\n             // close the buffer as well\n             bos.close();\n             // we are now closed\n             closed = true;\n         }\n+    }\n \n     @Override\n     public boolean hasNext() {\ndiff --git a/camel-core/src/main/java/org/apache/camel/util/IOHelper.java b/camel-core/src/main/java/org/apache/camel/util/IOHelper.java\nindex efd8b56d71..ed2f7932a6 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/IOHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/IOHelper.java\n@@ -338,6 +338,23 @@ public static void close(Closeable closeable, String name, Logger log) {\n         }\n     }\n     \n+    /**\n+     * Closes the given resource if it is available and don't catch the exception\n+     *\n+     * @param closeable the object to close\n+     * @throws IOException\n+      */\n+    public static void closeWithException(Closeable closeable) throws IOException {\n+        if (closeable != null) {\n+            try {\n+                closeable.close();\n+            } catch (IOException e) {\n+                // don't catch the exception here\n+                throw e;\n+            }\n+        }\n+    }\n+\n     /**\n      * Closes the given channel if it is available, logging any closing exceptions to the given log.\n      * The file's channel can optionally be forced to disk.\n",
        "project": "camel",
        "linesAdd": 27,
        "jira_id": "7100",
        "nb_skipped": 1,
        "commit": "00a9b02b",
        "nb_failure": 1,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4758,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.file.FilerConsumerMoveFailedDoneFileNameTest",
            "org.apache.camel.management.ManagedThrottlerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileOnCompletion.java b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileOnCompletion.java\nindex 5bedc00910..db16a666e4 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileOnCompletion.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileOnCompletion.java\n@@ -117,27 +117,7 @@ protected void processStrategyCommit(GenericFileProcessStrategy<T> processStrate\n             }\n         }\n \n-        // must be last in batch to delete the done file name\n-        // delete done file if used (and not noop=true)\n-        boolean complete = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class);\n-        if (endpoint.getDoneFileName() != null && !endpoint.isNoop()) {\n-            // done file must be in same path as the original input file\n-            String doneFileName = endpoint.createDoneFileName(absoluteFileName);\n-            ObjectHelper.notEmpty(doneFileName, \"doneFileName\", endpoint);\n-            // we should delete the dynamic done file \n-            if (endpoint.getDoneFileName().indexOf(\"{file:name\") > 0 || complete) { \n-                try {\n-                    // delete done file\n-                    boolean deleted = operations.deleteFile(doneFileName);\n-                    log.trace(\"Done file: {} was deleted: {}\", doneFileName, deleted);\n-                    if (!deleted) {\n-                        log.warn(\"Done file: \" + doneFileName + \" could not be deleted\");\n-                    }\n-                } catch (Exception e) {\n-                    handleException(\"Error deleting done file: \" + doneFileName, exchange, e);\n-                }\n-            }\n-        }\n+        handleDoneFile(exchange);\n \n         try {\n             log.trace(\"Commit file strategy: {} for file: {}\", processStrategy, file);\n@@ -160,6 +140,13 @@ protected void processStrategyRollback(GenericFileProcessStrategy<T> processStra\n         if (log.isWarnEnabled()) {\n             log.warn(\"Rollback file strategy: \" + processStrategy + \" for file: \" + file);\n         }\n+\n+        // only delete done file if moveFailed option is enabled, as otherwise on rollback,\n+        // we should leave the done file so we can retry\n+        if (endpoint.getMoveFailed() != null) {\n+            handleDoneFile(exchange);\n+        }\n+\n         try {\n             processStrategy.rollback(operations, endpoint, exchange, file);\n         } catch (Exception e) {\n@@ -167,6 +154,30 @@ protected void processStrategyRollback(GenericFileProcessStrategy<T> processStra\n         }\n     }\n \n+    protected void handleDoneFile(Exchange exchange) {\n+        // must be last in batch to delete the done file name\n+        // delete done file if used (and not noop=true)\n+        boolean complete = exchange.getProperty(Exchange.BATCH_COMPLETE, false, Boolean.class);\n+        if (endpoint.getDoneFileName() != null && !endpoint.isNoop()) {\n+            // done file must be in same path as the original input file\n+            String doneFileName = endpoint.createDoneFileName(absoluteFileName);\n+            ObjectHelper.notEmpty(doneFileName, \"doneFileName\", endpoint);\n+            // we should delete the dynamic done file\n+            if (endpoint.getDoneFileName().indexOf(\"{file:name\") > 0 || complete) {\n+                try {\n+                    // delete done file\n+                    boolean deleted = operations.deleteFile(doneFileName);\n+                    log.trace(\"Done file: {} was deleted: {}\", doneFileName, deleted);\n+                    if (!deleted) {\n+                        log.warn(\"Done file: \" + doneFileName + \" could not be deleted\");\n+                    }\n+                } catch (Exception e) {\n+                    handleException(\"Error deleting done file: \" + doneFileName, exchange, e);\n+                }\n+            }\n+        }\n+    }\n+\n     protected void handleException(String message, Exchange exchange, Throwable t) {\n         Throwable newt = (t == null) ? new IllegalArgumentException(\"Handling [null] exception\") : t;\n         getExceptionHandler().handleException(message, exchange, newt);\n",
        "project": "camel",
        "linesAdd": 25,
        "jira_id": "6964",
        "nb_skipped": 1,
        "commit": "6b2ffb30",
        "nb_failure": 2,
        "linesRem": 16,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 4675,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.util.DumpModelAsXmlChoiceFilterRouteTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/ExpressionNode.java b/camel-core/src/main/java/org/apache/camel/model/ExpressionNode.java\nindex 41f97cead4..ef64c2d76d 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/ExpressionNode.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/ExpressionNode.java\n@@ -143,5 +143,14 @@ protected void preCreateProcessor() {\n                 expression = clause.getExpressionType();\n             }\n         }\n+\n+        if (expression != null && expression.getExpression() == null) {\n+            // use toString from predicate or expression so we have some information to show in the route model\n+            if (expression.getPredicate() != null) {\n+                expression.setExpression(expression.getPredicate().toString());\n+            } else if (expression.getExpressionValue() != null) {\n+                expression.setExpression(expression.getExpressionValue().toString());\n+            }\n+        }\n     }\n }\ndiff --git a/camel-core/src/main/java/org/apache/camel/model/language/ExpressionDefinition.java b/camel-core/src/main/java/org/apache/camel/model/language/ExpressionDefinition.java\nindex b423afafcb..52b0d1c430 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/language/ExpressionDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/language/ExpressionDefinition.java\n@@ -243,8 +243,6 @@ public boolean isTrim() {\n      * Returns some descriptive text to describe this node\n      */\n     public String getLabel() {\n-        String language = getExpression();\n-        if (ObjectHelper.isEmpty(language)) {\n         Predicate predicate = getPredicate();\n         if (predicate != null) {\n             return predicate.toString();\n@@ -253,10 +251,9 @@ public String getLabel() {\n         if (expressionValue != null) {\n             return expressionValue.toString();\n         }\n-        } else {\n-            return language;\n-        }\n-        return \"\";\n+\n+        String exp = getExpression();\n+        return exp != null ? exp : \"\";\n     }\n \n     /**\n",
        "project": "camel",
        "linesAdd": 11,
        "jira_id": "6593",
        "nb_skipped": 1,
        "commit": "7f8a295a",
        "nb_failure": 1,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4160,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.management.DefaultManagementAgentMockTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementAgent.java b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementAgent.java\nindex d59c492f2d..c9aa47df98 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementAgent.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementAgent.java\n@@ -22,9 +22,9 @@\n import java.net.UnknownHostException;\n import java.rmi.RemoteException;\n import java.rmi.registry.LocateRegistry;\n-import java.util.HashSet;\n+import java.util.HashMap;\n import java.util.List;\n-import java.util.Set;\n+import java.util.Map;\n import java.util.concurrent.ExecutorService;\n import javax.management.JMException;\n import javax.management.MBeanServer;\n@@ -60,7 +60,8 @@\n     private CamelContext camelContext;\n     private ExecutorService executorService;\n     private MBeanServer server;\n-    private final Set<ObjectName> mbeansRegistered = new HashSet<ObjectName>();\n+    // need a name -> actual name mapping as some servers changes the names (suc as WebSphere)\n+    private final Map<ObjectName, ObjectName> mbeansRegistered = new HashMap<ObjectName, ObjectName>();\n     private JMXConnectorServer cs;\n \n     private Integer registryPort;\n@@ -240,15 +241,17 @@ public void register(Object obj, ObjectName name, boolean forceRegistration) thr\n     }\n \n     public void unregister(ObjectName name) throws JMException {\n-        if (server.isRegistered(name)) {\n-            server.unregisterMBean(name);\n+        if (isRegistered(name)) {\n+            server.unregisterMBean(mbeansRegistered.get(name));\n             LOG.debug(\"Unregistered MBean with ObjectName: {}\", name);\n         }\n         mbeansRegistered.remove(name);\n     }\n \n     public boolean isRegistered(ObjectName name) {\n-        return server.isRegistered(name);\n+        return (mbeansRegistered.containsKey(name) \n+                && server.isRegistered(mbeansRegistered.get(name))) \n+                || server.isRegistered(name);\n     }\n \n     protected void doStart() throws Exception {\n@@ -280,11 +283,10 @@ protected void doStop() throws Exception {\n         }\n \n         // Using the array to hold the busMBeans to avoid the CurrentModificationException\n-        ObjectName[] mBeans = mbeansRegistered.toArray(new ObjectName[mbeansRegistered.size()]);\n+        ObjectName[] mBeans = mbeansRegistered.keySet().toArray(new ObjectName[mbeansRegistered.size()]);\n         int caught = 0;\n         for (ObjectName name : mBeans) {\n             try {\n-                mbeansRegistered.remove(name);\n                 unregister(name);\n             } catch (Exception e) {\n                 LOG.info(\"Exception unregistering MBean with name \" + name, e);\n@@ -302,7 +304,7 @@ private void registerMBeanWithServer(Object obj, ObjectName name, boolean forceR\n         throws JMException {\n \n         // have we already registered the bean, there can be shared instances in the camel routes\n-        boolean exists = server.isRegistered(name);\n+        boolean exists = isRegistered(name);\n         if (exists) {\n             if (forceRegistration) {\n                 LOG.info(\"ForceRegistration enabled, unregistering existing MBean with ObjectName: {}\", name);\n@@ -324,7 +326,7 @@ private void registerMBeanWithServer(Object obj, ObjectName name, boolean forceR\n         if (instance != null) {\n             ObjectName registeredName = instance.getObjectName();\n             LOG.debug(\"Registered MBean with ObjectName: {}\", registeredName);\n-            mbeansRegistered.add(registeredName);\n+            mbeansRegistered.put(name, registeredName);\n         }\n     }\n \n",
        "project": "camel",
        "linesAdd": 11,
        "jira_id": "5187",
        "nb_skipped": 0,
        "commit": "8cadc344",
        "nb_failure": 1,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 4307,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.builder.ProxyBuilderSkipJavaLangObjectMethodsTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/AbstractCamelInvocationHandler.java b/camel-core/src/main/java/org/apache/camel/component/bean/AbstractCamelInvocationHandler.java\nindex 953d60efe9..21e407b786 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/AbstractCamelInvocationHandler.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/AbstractCamelInvocationHandler.java\n@@ -19,6 +19,9 @@\n import java.lang.reflect.InvocationHandler;\n import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n@@ -41,10 +44,16 @@\n public abstract class AbstractCamelInvocationHandler implements InvocationHandler {\n \n     private static final transient Logger LOG = LoggerFactory.getLogger(CamelInvocationHandler.class);\n+    private static final List<Method> EXCLUDED_METHODS = new ArrayList<Method>();\n     private static ExecutorService executorService;\n     protected final Endpoint endpoint;\n     protected final Producer producer;\n \n+    static {\n+        // exclude all java.lang.Object methods as we dont want to invoke them\n+        EXCLUDED_METHODS.addAll(Arrays.asList(Object.class.getMethods()));\n+    }\n+\n     public AbstractCamelInvocationHandler(Endpoint endpoint, Producer producer) {\n         this.endpoint = endpoint;\n         this.producer = producer;\n@@ -67,7 +76,26 @@ private static Object getBody(Exchange exchange, Class<?> type) throws InvalidPa\n         }\n     }\n \n-    protected Object invokeWithbody(final Method method, Object body, final ExchangePattern pattern) throws InterruptedException, Throwable {\n+    @Override\n+    public final Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n+        if (isValidMethod(method)) {\n+            return doInvokeProxy(proxy, method, args);\n+        } else {\n+            // invalid method then invoke methods on this instead\n+            if (\"toString\".equals(method.getName())) {\n+                return this.toString();\n+            } else if (\"hashCode\".equals(method.getName())) {\n+                return this.hashCode();\n+            } else if (\"equals\".equals(method.getName())) {\n+                return Boolean.FALSE;\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public abstract Object doInvokeProxy(final Object proxy, final Method method, final Object[] args) throws Throwable;\n+\n+    protected Object invokeWithBody(final Method method, Object body, final ExchangePattern pattern) throws Throwable {\n         final Exchange exchange = new DefaultExchange(endpoint, pattern);\n         exchange.getIn().setBody(body);\n \n@@ -214,4 +242,15 @@ protected Throwable findSuitableException(Throwable cause, Method method) {\n         return null;\n     }\n \n+    protected boolean isValidMethod(Method method) {\n+        // must not be in the excluded list\n+        for (Method excluded : EXCLUDED_METHODS) {\n+            if (ObjectHelper.isOverridingMethod(excluded, method)) {\n+                // the method is overriding an excluded method so its not valid\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n }\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/bean/CamelInvocationHandler.java b/camel-core/src/main/java/org/apache/camel/component/bean/CamelInvocationHandler.java\nindex b78dcd3754..55b993b51b 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/CamelInvocationHandler.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/CamelInvocationHandler.java\n@@ -37,11 +37,12 @@ public CamelInvocationHandler(Endpoint endpoint, Producer producer, MethodInfoCa\n         this.methodInfoCache = methodInfoCache;\n     }\n \n-    public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n+    @Override\n+    public Object doInvokeProxy(Object proxy, Method method, Object[] args) throws Throwable {\n         BeanInvocation invocation = new BeanInvocation(method, args);\n         MethodInfo methodInfo = methodInfoCache.getMethodInfo(method);\n         final ExchangePattern pattern = methodInfo != null ? methodInfo.getPattern() : ExchangePattern.InOut;\n-        return invokeWithbody(method, invocation, pattern);\n+        return invokeWithBody(method, invocation, pattern);\n     }\n \n }\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/bean/PojoMessageInvocationHandler.java b/camel-core/src/main/java/org/apache/camel/component/bean/PojoMessageInvocationHandler.java\nindex 906ad71ea3..b97865a26a 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/PojoMessageInvocationHandler.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/PojoMessageInvocationHandler.java\n@@ -24,7 +24,7 @@\n import org.apache.camel.RuntimeCamelException;\n \n /**\n- * Special InvocationHandler for methods that have only one parameter. This\n+ * Special {@link java.lang.reflect.InvocationHandler} for methods that have only one parameter. This\n  * parameter is directly sent to as the body of the message. The idea is to use\n  * that as a very open message format especially when combined with e.g. JAXB\n  * serialization.\n@@ -34,7 +35,8 @@ public PojoMessageInvocationHandler(Endpoint endpoint, Producer producer) {\n         super(endpoint, producer);\n     }\n \n-    public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n+    @Override\n+    public Object doInvokeProxy(Object proxy, Method method, Object[] args) throws Throwable {\n         int argsLength = (args == null) ? 0 : args.length;\n         if (argsLength != 1) {\n             throw new RuntimeCamelException(String.format(\"Error creating proxy for %s.%s Number of arguments must be 1 but is %d\", \n@@ -42,7 +44,7 @@ public Object invoke(final Object proxy, final Method method, final Object[] arg\n                                                           method.getName(), argsLength));\n         }\n         final ExchangePattern pattern = method.getReturnType() != Void.TYPE ? ExchangePattern.InOut : ExchangePattern.InOnly;\n-        return invokeWithbody(method, args[0], pattern);\n+        return invokeWithBody(method, args[0], pattern);\n     }\n \n }\n",
        "project": "camel",
        "linesAdd": 42,
        "jira_id": "5571",
        "nb_skipped": 1,
        "commit": "0e87b84f",
        "nb_failure": 0,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3872,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.vm.VMSplitterTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/language/MethodCallExpression.java b/camel-core/src/main/java/org/apache/camel/model/language/MethodCallExpression.java\nindex 796cbdd73f..2ac12c322c 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/language/MethodCallExpression.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/language/MethodCallExpression.java\n@@ -170,7 +170,7 @@ public Expression createExpression(CamelContext camelContext) {\n             BeanHolder holder = new RegistryBean(camelContext, ref);\n             // get the bean which will check that it exists\n             instance = holder.getBean();\n-            answer = new BeanExpression(ref, getMethod());\n+            answer = new BeanExpression(instance, getMethod());\n         }\n \n         validateHasMethod(camelContext, instance, beanType, getMethod());\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "4542",
        "nb_skipped": 0,
        "commit": "c408c3ed",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4915,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.issues.EndpointWithRawUriParameterTest",
            "org.apache.camel.management.ManagedThrottlerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/util/URISupport.java b/camel-core/src/main/java/org/apache/camel/util/URISupport.java\nindex 4b06a13e39..0f37a2c2dc 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/URISupport.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/URISupport.java\n@@ -155,7 +155,7 @@ public static String sanitizePath(String path) {\n                 char ch = uri.charAt(i);\n                 // look ahead of the next char\n                 char next;\n-                if (i < uri.length() - 2) {\n+                if (i <= uri.length() - 2) {\n                     next = uri.charAt(i + 1);\n                 } else {\n                     next = '\\u0000';\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "7459",
        "nb_skipped": 3,
        "commit": "57ba1bde",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 3243,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.interceptor.AdviceWithMockEndpointsHavingParameterTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/AdviceWithRouteBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/AdviceWithRouteBuilder.java\nindex cf6cf02b3b..fb472a7a0b 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/AdviceWithRouteBuilder.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/AdviceWithRouteBuilder.java\n@@ -68,7 +68,6 @@ public RouteDefinition getOriginalRoute() {\n      * @throws Exception can be thrown if error occurred\n      */\n     public void mockEndpoints() throws Exception {\n-        getContext().removeEndpoints(\"*\");\n         getContext().addRegisterEndpointCallback(new InterceptSendToMockEndpointStrategy(null));\n     }\n \n@@ -80,7 +79,6 @@ public void mockEndpoints() throws Exception {\n      * @see org.apache.camel.util.EndpointHelper#matchEndpoint(String, String)\n      */\n     public void mockEndpoints(String pattern) throws Exception {\n-        getContext().removeEndpoints(pattern);\n         getContext().addRegisterEndpointCallback(new InterceptSendToMockEndpointStrategy(pattern));\n     }\n \ndiff --git a/camel-core/src/main/java/org/apache/camel/impl/InterceptSendToEndpoint.java b/camel-core/src/main/java/org/apache/camel/impl/InterceptSendToEndpoint.java\nindex bd97de1f2e..80c5b11be8 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/InterceptSendToEndpoint.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/InterceptSendToEndpoint.java\n@@ -114,6 +114,7 @@ public void process(Exchange exchange) throws Exception {\n                 if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Sending to endpoint: \" + getEndpointUri() + \" is intercepted and detoured to: \" + detour + \" for exchange: \" + exchange);\n                 }\n+                LOG.info(\"Sending to endpoint: \" + getEndpointUri() + \" is intercepted and detoured to: \" + detour + \" for exchange: \" + exchange);\n                 // add header with the real endpoint uri\n                 exchange.getIn().setHeader(Exchange.INTERCEPTED_ENDPOINT, delegate.getEndpointUri());\n \ndiff --git a/camel-core/src/main/java/org/apache/camel/impl/InterceptSendToMockEndpointStrategy.java b/camel-core/src/main/java/org/apache/camel/impl/InterceptSendToMockEndpointStrategy.java\nindex e0b168c860..e1d52d1b0e 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/InterceptSendToMockEndpointStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/InterceptSendToMockEndpointStrategy.java\n@@ -21,6 +21,7 @@\n import org.apache.camel.component.mock.MockEndpoint;\n import org.apache.camel.spi.EndpointStrategy;\n import org.apache.camel.util.EndpointHelper;\n+import org.apache.camel.util.ObjectHelper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -73,6 +74,10 @@ public Endpoint registerEndpoint(String uri, Endpoint endpoint) {\n             // create mock endpoint which we will use as interceptor\n             // replace :// from scheme to make it easy to lookup the mock endpoint without having double :// in uri\n             String key = \"mock:\" + endpoint.getEndpointKey().replaceFirst(\"://\", \":\");\n+            // strip off parameters as well\n+            if (key.contains(\"?\")) {\n+                key = ObjectHelper.before(key, \"?\");\n+            }\n             LOG.info(\"Adviced endpoint [\" + uri + \"] with mock endpoint [\" + key + \"]\");\n \n             MockEndpoint mock = endpoint.getCamelContext().getEndpoint(key, MockEndpoint.class);\n",
        "project": "camel",
        "linesAdd": 5,
        "jira_id": "3757",
        "nb_skipped": 0,
        "commit": "c1b2f2f8",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3847,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.RoutingSlipNoSuchEndpointExceptionTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/RoutingSlip.java b/camel-core/src/main/java/org/apache/camel/processor/RoutingSlip.java\nindex 2c994257fc..24bcf3600f 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/RoutingSlip.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/RoutingSlip.java\n@@ -170,7 +170,7 @@ public Object next(Exchange exchange) {\n         };\n     }\n \n-    private boolean doRoutingSlip(Exchange exchange, AsyncCallback callback) {\n+    private boolean doRoutingSlip(final Exchange exchange, final AsyncCallback callback) {\n         Exchange current = exchange;\n         RoutingSlipIterator iter;\n         try {\n@@ -196,8 +196,8 @@ private boolean doRoutingSlip(Exchange exchange, AsyncCallback callback) {\n                 }\n             } catch (Exception e) {\n                 // error resolving endpoint so we should break out\n-                exchange.setException(e);\n-                return true;\n+                current.setException(e);\n+                break;\n             }\n \n             // prepare and process the routing slip\n",
        "project": "camel",
        "linesAdd": 3,
        "jira_id": "4486",
        "nb_skipped": 0,
        "commit": "f98ac676",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 4199,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.issues.AdviceWithUrlIssueTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/seda/SedaComponent.java b/camel-core/src/main/java/org/apache/camel/component/seda/SedaComponent.java\nindex ed0f0665df..23c70bd0b3 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/seda/SedaComponent.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/seda/SedaComponent.java\n@@ -53,7 +53,7 @@ public int getConcurrentConsumers() {\n         return defaultConcurrentConsumers;\n     }\n \n-    public synchronized BlockingQueue<Exchange> createQueue(String uri, Map<String, Object> parameters) {\n+    public synchronized BlockingQueue<Exchange> getOrCreateQueue(String uri, Integer size) {\n         String key = getQueueKey(uri);\n \n         QueueReference ref = getQueues().get(key);\n@@ -65,7 +65,6 @@ public int getConcurrentConsumers() {\n \n         // create queue\n         BlockingQueue<Exchange> queue;\n-        Integer size = getAndRemoveParameter(parameters, \"size\", Integer.class);\n         if (size != null && size > 0) {\n             queue = new LinkedBlockingQueue<Exchange>(size);\n         } else {\n@@ -96,7 +95,8 @@ protected Endpoint createEndpoint(String uri, String remaining, Map<String, Obje\n             throw new IllegalArgumentException(\"The limitConcurrentConsumers flag in set to true. ConcurrentConsumers cannot be set at a value greater than \"\n                     + maxConcurrentConsumers + \" was \" + consumers);\n         }\n-        SedaEndpoint answer = new SedaEndpoint(uri, this, createQueue(uri, parameters), consumers);\n+        Integer size = getAndRemoveParameter(parameters, \"size\", Integer.class);\n+        SedaEndpoint answer = new SedaEndpoint(uri, this, getOrCreateQueue(uri, size), consumers);\n         answer.configureProperties(parameters);\n         return answer;\n     }\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java b/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\nindex 2095a93b27..5b2d8724b7 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\n@@ -94,15 +94,27 @@ public Consumer createConsumer(Processor processor) throws Exception {\n \n     public synchronized BlockingQueue<Exchange> getQueue() {\n         if (queue == null) {\n-            if (size > 0) {\n-                queue = new LinkedBlockingQueue<Exchange>(size);\n+            // prefer to lookup queue from component, so if this endpoint is re-created or re-started\n+            // then the existing queue from the component can be used, so new producers and consumers\n+            // can use the already existing queue referenced from the component\n+            if (getComponent() != null) {\n+                queue = getComponent().getOrCreateQueue(getEndpointUri(), getSize());\n             } else {\n-                queue = new LinkedBlockingQueue<Exchange>();\n+                // fallback and create queue (as this endpoint has no component)\n+                queue = createQueue();\n             }\n         }\n         return queue;\n     }\n \n+    protected BlockingQueue<Exchange> createQueue() {\n+        if (size > 0) {\n+            return new LinkedBlockingQueue<Exchange>(size);\n+        } else {\n+            return new LinkedBlockingQueue<Exchange>();\n+        }\n+    }\n+\n     protected synchronized MulticastProcessor getConsumerMulticastProcessor() throws Exception {\n         if (!multicastStarted && consumerMulticastProcessor != null) {\n             // only start it on-demand to avoid starting it during stopping\n@@ -363,6 +375,10 @@ protected void doShutdown() throws Exception {\n             getCamelContext().getExecutorServiceManager().shutdownNow(multicastExecutor);\n             multicastExecutor = null;\n         }\n+\n+        // clear queue, as we are shutdown, so if re-created then the queue must be updated\n+        queue = null;\n+\n         super.doShutdown();\n     }\n }\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java b/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\nindex 1067042ccf..d39e39f722 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\n@@ -27,7 +27,6 @@\n import org.apache.camel.impl.DefaultAsyncProducer;\n import org.apache.camel.support.SynchronizationAdapter;\n import org.apache.camel.util.ExchangeHelper;\n-import org.apache.camel.util.URISupport;\n \n /**\n  * @version \n",
        "project": "camel",
        "linesAdd": 17,
        "jira_id": "5261",
        "nb_skipped": 1,
        "commit": "55c2e2d8",
        "nb_failure": 0,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5022,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.issues.AdviceWithOnExceptionTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/AdviceWithTasks.java b/camel-core/src/main/java/org/apache/camel/builder/AdviceWithTasks.java\nindex 69f5a0a81a..694841ceda 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/AdviceWithTasks.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/AdviceWithTasks.java\n@@ -312,7 +312,7 @@ public void task() throws Exception {\n     /**\n      * Gets the outputs from the given parent.\n      * <p/>\n-     * This implementation deals with that outputs can be abstract and retrieves the correct non-nested output.\n+     * This implementation deals with that outputs can be abstract and retrieves the <i>correct</i> parent output.\n      *\n      * @param parent the parent\n      * @return <tt>null</tt> if no parent\n@@ -323,13 +323,10 @@ public void task() throws Exception {\n             return null;\n         }\n         List<ProcessorDefinition> outputs = parent.getOutputs();\n-        if (outputs.size() >= 1) {\n-            // if the 1st output is abstract, then its onException,transacted,intercept etc so we should\n-            // get the 'actual' outputs from that\n-            if (outputs.get(0).isAbstract()) {\n+        if (outputs.size() == 1 && outputs.get(0).isAbstract()) {\n+            // if the output is abstract then get its output, as\n             outputs = outputs.get(0).getOutputs();\n         }\n-        }\n         return outputs;\n     }\n \n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "7622",
        "nb_skipped": 3,
        "commit": "faa20255",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2924,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.properties.PropertiesComponentEIPChoiceConvertBodyToTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\nindex a270651..67d135a 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n@@ -345,6 +345,10 @@ public abstract class ProcessorDefinition<Type extends ProcessorDefinition<Type>\n     protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorDefinition> outputs) throws Exception {\n         List<Processor> list = new ArrayList<Processor>();\n         for (ProcessorDefinition<?> output : outputs) {\n+\n+            // resolve properties before we create the processor\n+            resolvePropertyPlaceholders(routeContext, output);\n+\n             Processor processor = null;\n             // at first use custom factory\n             if (routeContext.getCamelContext().getProcessorFactory() != null) {\n@@ -383,7 +387,7 @@ public abstract class ProcessorDefinition<Type extends ProcessorDefinition<Type>\n         Processor processor = null;\n \n         // resolve properties before we create the processor\n-        resolvePropertyPlaceholders(routeContext);\n+        resolvePropertyPlaceholders(routeContext, this);\n \n         // at first use custom factory\n         if (routeContext.getCamelContext().getProcessorFactory() != null) {\n@@ -402,28 +406,29 @@ public abstract class ProcessorDefinition<Type extends ProcessorDefinition<Type>\n     }\n \n     /**\n-     * Inspects this processor definition and resolves any property placeholders from its properties.\n+     * Inspects the given processor definition and resolves any property placeholders from its properties.\n      * <p/>\n      * This implementation will check all the getter/setter pairs on this instance and for all the values\n      * (which is a String type) will be property placeholder resolved.\n      *\n      * @param routeContext the route context\n+     * @param definition   the processor definition\n      * @throws Exception is thrown if property placeholders was used and there was an error resolving them\n      * @see org.apache.camel.CamelContext#resolvePropertyPlaceholders(String)\n      * @see org.apache.camel.component.properties.PropertiesComponent\n      */\n-    protected void resolvePropertyPlaceholders(RouteContext routeContext) throws Exception {\n+    protected void resolvePropertyPlaceholders(RouteContext routeContext, ProcessorDefinition definition) throws Exception {\n         if (log.isTraceEnabled()) {\n-            log.trace(\"Resolving property placeholders for: \" + this);\n+            log.trace(\"Resolving property placeholders for: \" + definition);\n         }\n \n         // find all String getter/setter\n         Map<Object, Object> properties = new HashMap<Object, Object>();\n-        IntrospectionSupport.getProperties(this, properties, null);\n+        IntrospectionSupport.getProperties(definition, properties, null);\n \n         if (!properties.isEmpty()) {\n             if (log.isTraceEnabled()) {\n-                log.trace(\"There are \" + properties.size() + \" properties on: \" + this);\n+                log.trace(\"There are \" + properties.size() + \" properties on: \" + definition);\n             }\n \n             // lookup and resolve properties for String based properties\n@@ -437,7 +442,7 @@ public abstract class ProcessorDefinition<Type extends ProcessorDefinition<Type>\n                     text = routeContext.getCamelContext().resolvePropertyPlaceholders(text);\n                     if (text != value) {\n                         // invoke setter as the text has changed\n-                        IntrospectionSupport.setProperty(this, name, text);\n+                        IntrospectionSupport.setProperty(definition, name, text);\n                         if (log.isDebugEnabled()) {\n                             log.debug(\"Changed property [\" + name + \"] from: \" + value + \" to: \" + text);\n                         }\n",
        "project": "camel",
        "linesAdd": 9,
        "jira_id": "3314",
        "nb_skipped": 0,
        "commit": "4badd9c5",
        "nb_failure": 0,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3226,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.intercept.InterceptFromEndpointNotUriTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/FromDefinition.java b/camel-core/src/main/java/org/apache/camel/model/FromDefinition.java\nindex 63e4710256..7fb66669eb 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/FromDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/FromDefinition.java\n@@ -77,8 +77,15 @@ public Endpoint resolveEndpoint(RouteContext context) {\n \n     // Properties\n     // -----------------------------------------------------------------------\n+\n     public String getUri() {\n+        if (uri != null) {\n             return uri;\n+        } else if (endpoint != null) {\n+            return endpoint.getEndpointUri();\n+        } else {\n+            return null;\n+        }\n     }\n \n     /**\n",
        "project": "camel",
        "linesAdd": 7,
        "jira_id": "3709",
        "nb_skipped": 0,
        "commit": "4c37e773",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5063,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.vm.VmQueueTest",
            "org.apache.camel.component.vm.VmShouldNotUseSameThreadTest",
            "org.apache.camel.component.vm.VmMultipleConsumersMultipleContextTest",
            "org.apache.camel.component.vm.VmMultipleContextsStartStopTest",
            "org.apache.camel.issues.OnCompletionIssueTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/OnCompletionProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/OnCompletionProcessor.java\nindex abbdcd07b3..6575cb27e7 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/OnCompletionProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/OnCompletionProcessor.java\n@@ -131,6 +131,8 @@ protected static void doProcess(Processor processor, Exchange exchange) {\n         Object failureHandled = exchange.removeProperty(Exchange.FAILURE_HANDLED);\n         Object caught = exchange.removeProperty(Exchange.EXCEPTION_CAUGHT);\n         Object errorhandlerHandled = exchange.removeProperty(Exchange.ERRORHANDLER_HANDLED);\n+        Object rollbackOnly = exchange.removeProperty(Exchange.ROLLBACK_ONLY);\n+        Object rollbackOnlyLast = exchange.removeProperty(Exchange.ROLLBACK_ONLY_LAST);\n \n         Exception cause = exchange.getException();\n         exchange.setException(null);\n@@ -153,6 +155,12 @@ protected static void doProcess(Processor processor, Exchange exchange) {\n             if (errorhandlerHandled != null) {\n                 exchange.setProperty(Exchange.ERRORHANDLER_HANDLED, errorhandlerHandled);\n             }\n+            if (rollbackOnly != null) {\n+                exchange.setProperty(Exchange.ROLLBACK_ONLY, rollbackOnly);\n+            }\n+            if (rollbackOnlyLast != null) {\n+                exchange.setProperty(Exchange.ROLLBACK_ONLY, rollbackOnlyLast);\n+            }\n             if (cause != null) {\n                 exchange.setException(cause);\n             }\n",
        "project": "camel",
        "linesAdd": 8,
        "jira_id": "7568",
        "nb_skipped": 3,
        "commit": "b3377b16",
        "nb_failure": 3,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5545,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.impl.DefaultExchangeTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java\nindex e1f83f67c2..923c0d8494 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java\n@@ -98,6 +98,7 @@ public Exchange copy(boolean safeCopy) {\n \n         if (safeCopy) {\n             exchange.getIn().setBody(getIn().getBody());\n+            exchange.getIn().setFault(getIn().isFault());\n             if (getIn().hasHeaders()) {\n                 exchange.getIn().setHeaders(safeCopyHeaders(getIn().getHeaders()));\n                 // just copy the attachments here\n@@ -105,6 +106,7 @@ public Exchange copy(boolean safeCopy) {\n             }\n             if (hasOut()) {\n                 exchange.getOut().setBody(getOut().getBody());\n+                exchange.getOut().setFault(getOut().isFault());\n                 if (getOut().hasHeaders()) {\n                     exchange.getOut().setHeaders(safeCopyHeaders(getOut().getHeaders()));\n                 }\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "9666",
        "nb_skipped": 4,
        "commit": "da035952",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 3091,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.language.BeanLanguageInvalidOGNLTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/MethodNotFoundException.java b/camel-core/src/main/java/org/apache/camel/component/bean/MethodNotFoundException.java\nindex 8dceafdd89..e0ecab3bd1 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/MethodNotFoundException.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/MethodNotFoundException.java\n@@ -30,10 +30,12 @@\n     private final Object bean;\n     private final String methodName;\n     @SuppressWarnings(\"rawtypes\")\n-    private final List<Class> parameterTypes;\n+    private List<Class> parameterTypes;\n \n     public MethodNotFoundException(Exchange exchange, Object pojo, String methodName) {\n-        this(exchange, pojo, methodName, null);\n+        super(\"Method with name: \" + methodName + \" not found on bean: \" + pojo, exchange);\n+        this.methodName = methodName;\n+        this.bean = pojo;\n     }\n     \n     @SuppressWarnings(\"rawtypes\")\n@@ -44,6 +46,12 @@ public MethodNotFoundException(Exchange exchange, Object pojo, String methodName\n         this.parameterTypes = parameterTypes;\n     }\n \n+    public MethodNotFoundException(Object pojo, String methodName, Throwable cause) {\n+        super(\"Method with name: \" + methodName + \" not found on bean: \" + pojo, null, cause);\n+        this.methodName = methodName;\n+        this.bean = pojo;\n+    }\n+\n     public String getMethodName() {\n         return methodName;\n     }\ndiff --git a/camel-core/src/main/java/org/apache/camel/model/language/MethodCallExpression.java b/camel-core/src/main/java/org/apache/camel/model/language/MethodCallExpression.java\nindex 511b5add6a..46aa7b702a 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/language/MethodCallExpression.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/language/MethodCallExpression.java\n@@ -27,13 +27,16 @@\n \n import org.apache.camel.CamelContext;\n import org.apache.camel.Expression;\n+import org.apache.camel.ExpressionIllegalSyntaxException;\n import org.apache.camel.Predicate;\n import org.apache.camel.component.bean.BeanHolder;\n import org.apache.camel.component.bean.BeanInfo;\n import org.apache.camel.component.bean.MethodNotFoundException;\n import org.apache.camel.component.bean.RegistryBean;\n import org.apache.camel.language.bean.BeanExpression;\n+import org.apache.camel.language.bean.RuntimeBeanExpressionException;\n import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.OgnlHelper;\n \n /**\n  * For expressions and predicates using the\n@@ -127,22 +130,23 @@ public void setParameterType(Class parameterType) {\n     \n     @Override\n     public Expression createExpression(CamelContext camelContext) {\n+        Expression answer;\n         if (beanType != null) {\n             instance = ObjectHelper.newInstance(beanType);\n-            return new BeanExpression(instance, getMethod(), parameterType);\n+            answer = new BeanExpression(instance, getMethod(), parameterType);\n         } else if (instance != null) {\n-            return new BeanExpression(instance, getMethod(), parameterType);\n+            answer = new BeanExpression(instance, getMethod(), parameterType);\n         } else {\n             String ref = beanName();\n             // if its a ref then check that the ref exists\n             BeanHolder holder = new RegistryBean(camelContext, ref);\n             // get the bean which will check that it exists\n             instance = holder.getBean();\n-            // only validate when it was a ref for a bean, so we can eager check\n-            // this on startup of Camel\n-            validateHasMethod(camelContext, instance, getMethod(), parameterType);\n-            return new BeanExpression(ref, getMethod(), parameterType);\n+            answer = new BeanExpression(ref, getMethod(), parameterType);\n         }\n+\n+        validateHasMethod(camelContext, instance, getMethod(), parameterType);\n+        return answer;\n     }\n \n     @Override\n@@ -151,7 +155,9 @@ public Predicate createPredicate(CamelContext camelContext) {\n     }\n \n     /**\n-     * Validates the given bean has the method\n+     * Validates the given bean has the method.\n+     * <p/>\n+     * This implementation will skip trying to validate OGNL method name expressions.\n      *\n      * @param context  camel context\n      * @param bean     the bean instance\n@@ -164,6 +170,17 @@ protected void validateHasMethod(CamelContext context, Object bean, String metho\n             return;\n         }\n \n+        // do not try to validate ognl methods\n+        if (OgnlHelper.isValidOgnlExpression(method)) {\n+            return;\n+        }\n+\n+        // if invalid OGNL then fail\n+        if (OgnlHelper.isInvalidValidOgnlExpression(method)) {\n+            ExpressionIllegalSyntaxException cause = new ExpressionIllegalSyntaxException(method);\n+            throw ObjectHelper.wrapRuntimeCamelException(new MethodNotFoundException(bean, method, cause));\n+        }\n+\n         BeanInfo info = new BeanInfo(context, bean.getClass());\n         List<Class> parameterTypes = new ArrayList<Class>();\n         if (parameterType != null) {\n",
        "project": "camel",
        "linesAdd": 29,
        "jira_id": "3545",
        "nb_skipped": 0,
        "commit": "050c542e",
        "nb_failure": 1,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4324,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.aggregator.AggregateExpressionSizeOverrideFixedTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\nindex a5c592bc95..00cb744018 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\n@@ -313,6 +313,9 @@ protected String isCompleted(String key, Exchange exchange) {\n                 int size = exchange.getProperty(Exchange.AGGREGATED_SIZE, 1, Integer.class);\n                 if (size >= value) {\n                     return \"size\";\n+                } else {\n+                    // not completed yet\n+                    return null;\n                 }\n             }\n         }\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "5720",
        "nb_skipped": 1,
        "commit": "4a05eccf",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 5361,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.vm.VmMultipleConsumersMultipleContextTest",
            "org.apache.camel.component.vm.VmMultipleContextsStartStopTest",
            "CamelReceivedTimestamp",
            "org.apache.camel.component.file.MarkerFileExclusiveReadLockStrategyUnlockTest",
            "org.apache.camel.component.file.FileConsumeMultipleDirectoriesTest",
            "org.apache.camel.component.vm.VmShouldNotUseSameThreadTest",
            "org.apache.camel.component.vm.VmQueueTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java b/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\nindex 343d836109..907de21817 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\n@@ -35,6 +35,7 @@\n public class GenericFile<T> implements WrappedFile<T>  {\n     private static final Logger LOG = LoggerFactory.getLogger(GenericFile.class);\n \n+    private String copyFromAbsoluteFilePath;\n     private String endpointPath;\n     private String fileName;\n     private String fileNameOnly;\n@@ -66,6 +67,7 @@ public char getFileSeparator() {\n         } catch (Exception e) {\n             throw ObjectHelper.wrapRuntimeCamelException(e);\n         }\n+        result.setCopyFromAbsoluteFilePath(source.getAbsoluteFilePath());\n         result.setEndpointPath(source.getEndpointPath());\n         result.setAbsolute(source.isAbsolute());\n         result.setDirectory(source.isDirectory());\n@@ -365,6 +367,14 @@ public void setDirectory(boolean directory) {\n         this.directory = directory;\n     }\n \n+    public String getCopyFromAbsoluteFilePath() {\n+        return copyFromAbsoluteFilePath;\n+    }\n+\n+    public void setCopyFromAbsoluteFilePath(String copyFromAbsoluteFilePath) {\n+        this.copyFromAbsoluteFilePath = copyFromAbsoluteFilePath;\n+    }\n+\n     /**\n      * Fixes the path separator to be according to the protocol\n      */\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/strategy/FileLockExclusiveReadLockStrategy.java b/camel-core/src/main/java/org/apache/camel/component/file/strategy/FileLockExclusiveReadLockStrategy.java\nindex 8fd94f580c..de5101f107 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/strategy/FileLockExclusiveReadLockStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/strategy/FileLockExclusiveReadLockStrategy.java\n@@ -127,10 +127,11 @@ public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations,\n             }\n         }\n \n-        // we grabbed the lock\n-        exchange.setProperty(Exchange.FILE_LOCK_EXCLUSIVE_LOCK, lock);\n-        exchange.setProperty(Exchange.FILE_LOCK_RANDOM_ACCESS_FILE, randomAccessFile);\n+        // store read-lock state\n+        exchange.setProperty(asReadLockKey(file, Exchange.FILE_LOCK_EXCLUSIVE_LOCK), lock);\n+        exchange.setProperty(asReadLockKey(file, Exchange.FILE_LOCK_RANDOM_ACCESS_FILE), randomAccessFile);\n \n+        // we grabbed the lock\n         return true;\n     }\n \n@@ -140,10 +141,10 @@ protected void doReleaseExclusiveReadLock(GenericFileOperations<File> operations\n         // must call super\n         super.doReleaseExclusiveReadLock(operations, file, exchange);\n \n-        String target = file.getFileName();\n-        FileLock lock = exchange.getProperty(Exchange.FILE_LOCK_EXCLUSIVE_LOCK, FileLock.class);\n-        RandomAccessFile rac = exchange.getProperty(Exchange.FILE_LOCK_RANDOM_ACCESS_FILE, RandomAccessFile.class);\n+        FileLock lock = exchange.getProperty(asReadLockKey(file, Exchange.FILE_LOCK_EXCLUSIVE_LOCK), FileLock.class);\n+        RandomAccessFile rac = exchange.getProperty(asReadLockKey(file, Exchange.FILE_LOCK_EXCLUSIVE_LOCK), RandomAccessFile.class);\n \n+        String target = file.getFileName();\n         if (lock != null) {\n             Channel channel = lock.acquiredBy();\n             try {\n@@ -186,4 +187,12 @@ public void setReadLockLoggingLevel(LoggingLevel readLockLoggingLevel) {\n         this.readLockLoggingLevel = readLockLoggingLevel;\n     }\n \n+    private static String asReadLockKey(GenericFile file, String key) {\n+        // use the copy from absolute path as that was the original path of the file when the lock was acquired\n+        // for example if the file consumer uses preMove then the file is moved and therefore has another name\n+        // that would no longer match\n+        String path = file.getCopyFromAbsoluteFilePath() != null ? file.getCopyFromAbsoluteFilePath() : file.getAbsoluteFilePath();\n+        return path + \"-\" + key;\n+    }\n+\n }\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java b/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java\nindex ceabd013dc..1c92bbdb8b 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java\n@@ -73,8 +73,10 @@ public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations,\n \n         // create a plain file as marker filer for locking (do not use FileLock)\n         boolean acquired = FileUtil.createNewFile(new File(lockFileName));\n-        exchange.setProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, acquired);\n-        exchange.setProperty(Exchange.FILE_LOCK_FILE_NAME, lockFileName);\n+\n+        // store read-lock state\n+        exchange.setProperty(asReadLockKey(file, Exchange.FILE_LOCK_FILE_ACQUIRED), acquired);\n+        exchange.setProperty(asReadLockKey(file, Exchange.FILE_LOCK_FILE_NAME), lockFileName);\n \n         return acquired;\n     }\n@@ -101,9 +103,11 @@ protected void doReleaseExclusiveReadLock(GenericFileOperations<File> operations\n             return;\n         }\n \n+        boolean acquired = exchange.getProperty(asReadLockKey(file, Exchange.FILE_LOCK_FILE_ACQUIRED), false, Boolean.class);\n+\n         // only release the file if camel get the lock before\n-        if (exchange.getProperty(Exchange.FILE_LOCK_FILE_ACQUIRED, false, Boolean.class)) {\n-            String lockFileName = exchange.getProperty(Exchange.FILE_LOCK_FILE_NAME, getLockFileName(file), String.class);\n+        if (acquired) {\n+            String lockFileName = exchange.getProperty(asReadLockKey(file, Exchange.FILE_LOCK_FILE_NAME), String.class);\n             File lock = new File(lockFileName);\n \n             if (lock.exists()) {\n@@ -162,4 +166,12 @@ private static String getLockFileName(GenericFile<File> file) {\n         return file.getAbsoluteFilePath() + FileComponent.DEFAULT_LOCK_FILE_POSTFIX;\n     }\n \n+    private static String asReadLockKey(GenericFile file, String key) {\n+        // use the copy from absolute path as that was the original path of the file when the lock was acquired\n+        // for example if the file consumer uses preMove then the file is moved and therefore has another name\n+        // that would no longer match\n+        String path = file.getCopyFromAbsoluteFilePath() != null ? file.getCopyFromAbsoluteFilePath() : file.getAbsoluteFilePath();\n+        return path + \"-\" + key;\n+    }\n+\n }\n",
        "project": "camel",
        "linesAdd": 32,
        "jira_id": "8954",
        "nb_skipped": 4,
        "commit": "7b1253db",
        "nb_failure": 4,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4618,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.StreamCachingRoutingSlipTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/RoutingSlip.java b/camel-core/src/main/java/org/apache/camel/processor/RoutingSlip.java\nindex cd4a864963..bde0f42f8e 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/RoutingSlip.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/RoutingSlip.java\n@@ -36,6 +36,7 @@\n import org.apache.camel.support.ServiceSupport;\n import org.apache.camel.util.AsyncProcessorHelper;\n import org.apache.camel.util.ExchangeHelper;\n+import org.apache.camel.util.MessageHelper;\n import org.apache.camel.util.ObjectHelper;\n import org.apache.camel.util.ServiceHelper;\n import org.slf4j.Logger;\n@@ -268,6 +269,10 @@ protected Exchange prepareExchangeForRoutingSlip(Exchange current, Endpoint endp\n         // exchange being routed.\n         copy.setExchangeId(current.getExchangeId());\n         copyOutToIn(copy, current);\n+\n+        // ensure stream caching is reset\n+        MessageHelper.resetStreamCache(copy.getIn());\n+\n         return copy;\n     }\n \n",
        "project": "camel",
        "linesAdd": 4,
        "jira_id": "6604",
        "nb_skipped": 1,
        "commit": "55751402",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4805,
        "nb_error": 5,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.converter.NIOConverterTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java b/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\nindex 0bf08ac554..41273b6b56 100644\n--- a/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\n+++ b/camel-core/src/main/java/org/apache/camel/converter/NIOConverter.java\n@@ -107,6 +107,7 @@ public static ByteBuffer toByteBuffer(String value, Exchange exchange) {\n     public static ByteBuffer toByteBuffer(Short value) {\n         ByteBuffer buf = ByteBuffer.allocate(2);\n         buf.putShort(value);\n+        buf.flip();\n         return buf;\n     }\n \n@@ -114,6 +115,7 @@ public static ByteBuffer toByteBuffer(Short value) {\n     public static ByteBuffer toByteBuffer(Integer value) {\n         ByteBuffer buf = ByteBuffer.allocate(4);\n         buf.putInt(value);\n+        buf.flip();\n         return buf;\n     }\n \n@@ -121,6 +123,7 @@ public static ByteBuffer toByteBuffer(Integer value) {\n     public static ByteBuffer toByteBuffer(Long value) {\n         ByteBuffer buf = ByteBuffer.allocate(8);\n         buf.putLong(value);\n+        buf.flip();\n         return buf;\n     }\n \n@@ -128,6 +131,7 @@ public static ByteBuffer toByteBuffer(Long value) {\n     public static ByteBuffer toByteBuffer(Float value) {\n         ByteBuffer buf = ByteBuffer.allocate(4);\n         buf.putFloat(value);\n+        buf.flip();\n         return buf;\n     }\n \n@@ -135,6 +139,7 @@ public static ByteBuffer toByteBuffer(Float value) {\n     public static ByteBuffer toByteBuffer(Double value) {\n         ByteBuffer buf = ByteBuffer.allocate(8);\n         buf.putDouble(value);\n+        buf.flip();\n         return buf;\n     }\n \n",
        "project": "camel",
        "linesAdd": 5,
        "jira_id": "7213",
        "nb_skipped": 3,
        "commit": "336663c9",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 3000,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.issues.SplitterCorrelationIdIssueTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\nindex 1f5113477f..97e5178a49 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n@@ -137,7 +137,7 @@ public boolean hasNext() {\n \n                     public Object next() {\n                         Object part = iterator.next();\n-                        Exchange newExchange = exchange.copy();\n+                        Exchange newExchange = ExchangeHelper.createCopy(exchange, true);\n                         if (part instanceof Message) {\n                             newExchange.setIn((Message)part);\n                         } else {\ndiff --git a/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java b/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\nindex 03ce98e0c8..606a69ad3c 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\n@@ -168,6 +168,8 @@ public static Object getMandatoryOutBody(Exchange exchange) throws InvalidPayloa\n      * @param handover whether the on completion callbacks should be handed over to the new copy.\n      */\n     public static Exchange createCorrelatedCopy(Exchange exchange, boolean handover) {\n+        String id = exchange.getExchangeId();\n+\n         Exchange copy = exchange.copy();\n         // do not share the unit of work\n         copy.setUnitOfWork(null);\n@@ -177,7 +179,23 @@ public static Exchange createCorrelatedCopy(Exchange exchange, boolean handover)\n             uow.handoverSynchronization(copy);\n         }\n         // set a correlation id so we can track back the original exchange\n-        copy.setProperty(Exchange.CORRELATION_ID, exchange.getExchangeId());\n+        copy.setProperty(Exchange.CORRELATION_ID, id);\n+        return copy;\n+    }\n+\n+    /**\n+     * Creates a new instance and copies from the current message exchange so that it can be\n+     * forwarded to another destination as a new instance.\n+     *\n+     * @param exchange original copy of the exchange\n+     * @param preserveExchangeId whether or not the exchange id should be preserved\n+     * @return the copy\n+     */\n+    public static Exchange createCopy(Exchange exchange, boolean preserveExchangeId) {\n+        Exchange copy = exchange.copy();\n+        if (preserveExchangeId) {\n+            copy.setExchangeId(exchange.getExchangeId());\n+        }\n         return copy;\n     }\n \n",
        "project": "camel",
        "linesAdd": 12,
        "jira_id": "3395",
        "nb_skipped": 0,
        "commit": "8433e6db",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3842,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.onexception.OnExceptionWhenSimpleOgnlTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/language/bean/BeanExpression.java b/camel-core/src/main/java/org/apache/camel/language/bean/BeanExpression.java\nindex 98ac1c5539..f79e041ba3 100644\n--- a/camel-core/src/main/java/org/apache/camel/language/bean/BeanExpression.java\n+++ b/camel-core/src/main/java/org/apache/camel/language/bean/BeanExpression.java\n@@ -154,6 +154,9 @@ public void process(Exchange exchange) throws Exception {\n             try {\n                 // copy the original exchange to avoid side effects on it\n                 Exchange resultExchange = exchange.copy();\n+                // remove any existing exception in case we do OGNL on the exception\n+                resultExchange.setException(null);\n+\n                 // force to use InOut to retrieve the result on the OUT message\n                 resultExchange.setPattern(ExchangePattern.InOut);\n                 processor.process(resultExchange);\n@@ -195,6 +198,8 @@ public OgnlInvokeProcessor(BeanHolder beanHolder, String ognl) {\n         public void process(Exchange exchange) throws Exception {\n             // copy the original exchange to avoid side effects on it\n             Exchange resultExchange = exchange.copy();\n+            // remove any existing exception in case we do OGNL on the exception\n+            resultExchange.setException(null);\n             // force to use InOut to retrieve the result on the OUT message\n             resultExchange.setPattern(ExchangePattern.InOut);\n             // do not propagate any method name when using OGNL, as with OGNL we\n",
        "project": "camel",
        "linesAdd": 3,
        "jira_id": "4513",
        "nb_skipped": 0,
        "commit": "9e05f77f",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3065,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.SplitterStreamingErrorHandlingTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\nindex 97e5178a49..6d585fb7fa 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n@@ -109,6 +109,9 @@ public boolean process(Exchange exchange, final AsyncCallback callback) {\n     private Iterable<ProcessorExchangePair> createProcessorExchangePairsIterable(final Exchange exchange, final Object value) {\n         final Iterator iterator = ObjectHelper.createIterator(value);\n         return new Iterable() {\n+            // create a copy which we use as master to copy during splitting\n+            // this avoids any side effect reflected upon the incoming exchange\n+            private final Exchange copy = ExchangeHelper.createCopy(exchange, true);\n \n             public Iterator iterator() {\n                 return new Iterator() {\n@@ -137,7 +140,8 @@ public boolean hasNext() {\n \n                     public Object next() {\n                         Object part = iterator.next();\n-                        Exchange newExchange = ExchangeHelper.createCopy(exchange, true);\n+                        // create a copy as the new exchange to be routed in the splitter from the copy\n+                        Exchange newExchange = ExchangeHelper.createCopy(copy, true);\n                         if (part instanceof Message) {\n                             newExchange.setIn((Message)part);\n                         } else {\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "3498",
        "nb_skipped": 0,
        "commit": "b4606700",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 4318,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.impl.DefaultProducerCacheTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/ConsumerCache.java b/camel-core/src/main/java/org/apache/camel/impl/ConsumerCache.java\nindex 16be6ab378..cadb98a1ea 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ConsumerCache.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ConsumerCache.java\n@@ -27,7 +27,6 @@\n import org.apache.camel.support.ServiceSupport;\n import org.apache.camel.util.CamelContextHelper;\n import org.apache.camel.util.LRUCache;\n-import org.apache.camel.util.LRUSoftCache;\n import org.apache.camel.util.ServiceHelper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -60,14 +59,17 @@ public ConsumerCache(Object source, CamelContext camelContext, Map<String, Polli\n     /**\n      * Creates the {@link LRUCache} to be used.\n      * <p/>\n-     * This implementation returns a {@link org.apache.camel.util.LRUSoftCache} instance.\n+     * This implementation returns a {@link LRUCache} instance.\n \n      * @param cacheSize the cache size\n      * @return the cache\n      */\n     protected static LRUCache<String, PollingConsumer> createLRUCache(int cacheSize) {\n-        // We use a soft reference cache to allow the JVM to re-claim memory if it runs low on memory.\n-        return new LRUSoftCache<String, PollingConsumer>(cacheSize);\n+        // Use a regular cache as we want to ensure that the lifecycle of the consumers\n+        // being cache is properly handled, such as they are stopped when being evicted\n+        // or when this cache is stopped. This is needed as some consumers requires to\n+        // be stopped so they can shutdown internal resources that otherwise may cause leaks\n+        return new LRUCache<String, PollingConsumer>(cacheSize);\n     }\n \n     public synchronized PollingConsumer getConsumer(Endpoint endpoint) {\ndiff --git a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\nindex 89fadb0881..8c5f97688c 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n@@ -37,7 +37,6 @@\n import org.apache.camel.util.CamelContextHelper;\n import org.apache.camel.util.EventHelper;\n import org.apache.camel.util.LRUCache;\n-import org.apache.camel.util.LRUSoftCache;\n import org.apache.camel.util.ServiceHelper;\n import org.apache.camel.util.StopWatch;\n import org.slf4j.Logger;\n@@ -78,14 +77,17 @@ public ProducerCache(Object source, CamelContext camelContext, ServicePool<Endpo\n     /**\n      * Creates the {@link LRUCache} to be used.\n      * <p/>\n-     * This implementation returns a {@link LRUSoftCache} instance.\n+     * This implementation returns a {@link LRUCache} instance.\n \n      * @param cacheSize the cache size\n      * @return the cache\n      */\n     protected static LRUCache<String, Producer> createLRUCache(int cacheSize) {\n-        // We use a soft reference cache to allow the JVM to re-claim memory if it runs low on memory.\n-        return new LRUSoftCache<String, Producer>(cacheSize);\n+        // Use a regular cache as we want to ensure that the lifecycle of the producers\n+        // being cache is properly handled, such as they are stopped when being evicted\n+        // or when this cache is stopped. This is needed as some producers requires to\n+        // be stopped so they can shutdown internal resources that otherwise may cause leaks\n+        return new LRUCache<String, Producer>(cacheSize);\n     }\n \n     public CamelContext getCamelContext() {\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "5683",
        "nb_skipped": 1,
        "commit": "0c3c7d1b",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5054,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.issues.OnCompletionIssueTest",
            "org.apache.camel.processor.ThrottlerNullEvalTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/Throttler.java b/camel-core/src/main/java/org/apache/camel/processor/Throttler.java\nindex f70325de76..c986bf7dae 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/Throttler.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/Throttler.java\n@@ -108,7 +108,7 @@ public void setTimePeriodMillis(long timePeriodMillis) {\n     protected long calculateDelay(Exchange exchange) {\n         // evaluate as Object first to see if we get any result at all\n         Object result = maxRequestsPerPeriodExpression.evaluate(exchange, Object.class);\n-        if (result == null) {\n+        if (maximumRequestsPerPeriod == 0 && result == null) {\n             throw new RuntimeExchangeException(\"The max requests per period expression was evaluated as null: \" + maxRequestsPerPeriodExpression, exchange);\n         }\n \n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "7448",
        "nb_skipped": 3,
        "commit": "35bde2b2",
        "nb_failure": 3,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5014,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.util.KeyValueHolderTest",
            "org.apache.camel.management.ManagedThrottlerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/util/KeyValueHolder.java b/camel-core/src/main/java/org/apache/camel/util/KeyValueHolder.java\nindex 3cf5bf9b49..a9baf00eaf 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/KeyValueHolder.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/KeyValueHolder.java\n@@ -53,6 +53,8 @@ public boolean equals(Object o) {\n \n         if (key != null ? !key.equals(that.key) : that.key != null) {\n             return false;\n+        } else if (value != null ? !value.equals(that.value) : that.value != null) {\n+            return false;\n         }\n \n         return true;\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "7611",
        "nb_skipped": 3,
        "commit": "e30f1c53",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 4790,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.management.BacklogDebuggerTest",
            "org.apache.camel.management.ManagedThrottlerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/api/management/mbean/ManagedBacklogDebuggerMBean.java b/camel-core/src/main/java/org/apache/camel/api/management/mbean/ManagedBacklogDebuggerMBean.java\nindex 02d2d966f1..036ef3da8e 100644\n--- a/camel-core/src/main/java/org/apache/camel/api/management/mbean/ManagedBacklogDebuggerMBean.java\n+++ b/camel-core/src/main/java/org/apache/camel/api/management/mbean/ManagedBacklogDebuggerMBean.java\n@@ -53,11 +53,23 @@\n     @ManagedOperation(description = \"Resume running from the suspended breakpoint at the given node id\")\n     void resumeBreakpoint(String nodeId);\n \n-    @ManagedOperation(description = \"Updates the message body on the suspended breakpoint at the given node id\")\n-    void setMessageBodyOnBreakpoint(String nodeId, String body);\n+    @ManagedOperation(description = \"Updates the message body (uses same type as old body) on the suspended breakpoint at the given node id\")\n+    void setMessageBodyOnBreakpoint(String nodeId, Object body);\n \n-    @ManagedOperation(description = \"Updates/adds the message header on the suspended breakpoint at the given node id\")\n-    void setMessageHeaderOnBreakpoint(String nodeId, String headerName, String value);\n+    @ManagedOperation(description = \"Updates the message body (with a new type) on the suspended breakpoint at the given node id\")\n+    void setMessageBodyOnBreakpoint(String nodeId, Object body, String type);\n+\n+    @ManagedOperation(description = \"Removes the message body on the suspended breakpoint at the given node id\")\n+    void removeMessageBodyOnBreakpoint(String nodeId);\n+\n+    @ManagedOperation(description = \"Updates/adds the message header (uses same type as old header value) on the suspended breakpoint at the given node id\")\n+    void setMessageHeaderOnBreakpoint(String nodeId, String headerName, Object value);\n+\n+    @ManagedOperation(description = \"Removes the message header on the suspended breakpoint at the given node id\")\n+    void removeMessageHeaderOnBreakpoint(String nodeId, String headerName);\n+\n+    @ManagedOperation(description = \"Updates/adds the message header (with a new type) on the suspended breakpoint at the given node id\")\n+    void setMessageHeaderOnBreakpoint(String nodeId, String headerName, Object value, String type);\n \n     @ManagedOperation(description = \"Resume running any suspended breakpoints, and exits step mode\")\n     void resumeAll();\ndiff --git a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedBacklogDebugger.java b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedBacklogDebugger.java\nindex 33f13105f0..9f3a94cf9a 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedBacklogDebugger.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedBacklogDebugger.java\n@@ -19,10 +19,12 @@\n import java.util.Set;\n \n import org.apache.camel.CamelContext;\n+import org.apache.camel.NoTypeConversionAvailableException;\n import org.apache.camel.api.management.ManagedResource;\n import org.apache.camel.api.management.mbean.ManagedBacklogDebuggerMBean;\n import org.apache.camel.processor.interceptor.BacklogDebugger;\n import org.apache.camel.spi.ManagementStrategy;\n+import org.apache.camel.util.ObjectHelper;\n \n @ManagedResource(description = \"Managed BacklogDebugger\")\n public class ManagedBacklogDebugger implements ManagedBacklogDebuggerMBean {\n@@ -91,12 +93,42 @@ public void resumeBreakpoint(String nodeId) {\n         backlogDebugger.resumeBreakpoint(nodeId);\n     }\n \n-    public void setMessageBodyOnBreakpoint(String nodeId, String body) {\n+    public void setMessageBodyOnBreakpoint(String nodeId, Object body) {\n         backlogDebugger.setMessageBodyOnBreakpoint(nodeId, body);\n     }\n \n-    public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, String value) {\n+    public void setMessageBodyOnBreakpoint(String nodeId, Object body, String type) {\n+        try {\n+            Class<?> classType = camelContext.getClassResolver().resolveMandatoryClass(type);\n+            backlogDebugger.setMessageBodyOnBreakpoint(nodeId, body, classType);\n+        } catch (ClassNotFoundException e) {\n+            throw ObjectHelper.wrapRuntimeCamelException(e);\n+        }\n+    }\n+\n+    public void removeMessageBodyOnBreakpoint(String nodeId) {\n+        backlogDebugger.removeMessageBodyOnBreakpoint(nodeId);\n+    }\n+\n+    public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, Object value) {\n+        try {\n             backlogDebugger.setMessageHeaderOnBreakpoint(nodeId, headerName, value);\n+        } catch (NoTypeConversionAvailableException e) {\n+            throw ObjectHelper.wrapRuntimeCamelException(e);\n+        }\n+    }\n+\n+    public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, Object value, String type) {\n+        try {\n+            Class<?> classType = camelContext.getClassResolver().resolveMandatoryClass(type);\n+            backlogDebugger.setMessageHeaderOnBreakpoint(nodeId, headerName, value, classType);\n+        } catch (Exception e) {\n+            throw ObjectHelper.wrapRuntimeCamelException(e);\n+        }\n+    }\n+\n+    public void removeMessageHeaderOnBreakpoint(String nodeId, String headerName) {\n+        backlogDebugger.removeMessageHeaderOnBreakpoint(nodeId, headerName);\n     }\n \n     public void resumeAll() {\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/interceptor/BacklogDebugger.java b/camel-core/src/main/java/org/apache/camel/processor/interceptor/BacklogDebugger.java\nindex 3c2e290c88..571b174d0c 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/interceptor/BacklogDebugger.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/interceptor/BacklogDebugger.java\n@@ -31,6 +31,7 @@\n import org.apache.camel.CamelContext;\n import org.apache.camel.Exchange;\n import org.apache.camel.LoggingLevel;\n+import org.apache.camel.NoTypeConversionAvailableException;\n import org.apache.camel.Predicate;\n import org.apache.camel.Processor;\n import org.apache.camel.api.management.mbean.BacklogTracerEventMessage;\n@@ -268,29 +269,108 @@ private void resumeBreakpoint(String nodeId, boolean stepMode) {\n         }\n     }\n \n-    public void setMessageBodyOnBreakpoint(String nodeId, String body) {\n+    public void setMessageBodyOnBreakpoint(String nodeId, Object body) {\n         SuspendedExchange se = suspendedBreakpoints.get(nodeId);\n         if (se != null) {\n+            boolean remove = body == null;\n+            if (remove) {\n+                removeMessageBodyOnBreakpoint(nodeId);\n+            } else {\n+                Class oldType;\n+                if (se.getExchange().hasOut()) {\n+                    oldType = se.getExchange().getOut().getBody() != null ? se.getExchange().getOut().getBody().getClass() : null;\n+                } else {\n+                    oldType = se.getExchange().getIn().getBody() != null ? se.getExchange().getIn().getBody().getClass() : null;\n+                }\n+                setMessageBodyOnBreakpoint(nodeId, body, oldType);\n+            }\n+        }\n+    }\n+\n+    public void setMessageBodyOnBreakpoint(String nodeId, Object body, Class type) {\n+        SuspendedExchange se = suspendedBreakpoints.get(nodeId);\n+        if (se != null) {\n+            boolean remove = body == null;\n+            if (remove) {\n+                removeMessageBodyOnBreakpoint(nodeId);\n+            } else {\n                 logger.log(\"Breakpoint at node \" + nodeId + \" is updating message body on exchangeId: \" + se.getExchange().getExchangeId() + \" with new body: \" + body);\n                 if (se.getExchange().hasOut()) {\n+                    // preserve type\n+                    if (type != null) {\n+                        se.getExchange().getOut().setBody(body, type);\n+                    } else {\n                         se.getExchange().getOut().setBody(body);\n+                    }\n+                } else {\n+                    if (type != null) {\n+                        se.getExchange().getIn().setBody(body, type);\n                     } else {\n                         se.getExchange().getIn().setBody(body);\n                     }\n                 }\n             }\n+        }\n+    }\n+\n+    public void removeMessageBodyOnBreakpoint(String nodeId) {\n+        SuspendedExchange se = suspendedBreakpoints.get(nodeId);\n+        if (se != null) {\n+            logger.log(\"Breakpoint at node \" + nodeId + \" is removing message body on exchangeId: \" + se.getExchange().getExchangeId());\n+            if (se.getExchange().hasOut()) {\n+                se.getExchange().getOut().setBody(null);\n+            } else {\n+                se.getExchange().getIn().setBody(null);\n+            }\n+        }\n+    }\n \n-    public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, String value) {\n+    public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, Object value) throws NoTypeConversionAvailableException {\n+        SuspendedExchange se = suspendedBreakpoints.get(nodeId);\n+        if (se != null) {\n+            Class oldType;\n+            if (se.getExchange().hasOut()) {\n+                oldType = se.getExchange().getOut().getHeader(headerName) != null ? se.getExchange().getOut().getHeader(headerName).getClass() : null;\n+            } else {\n+                oldType = se.getExchange().getIn().getHeader(headerName) != null ? se.getExchange().getIn().getHeader(headerName).getClass() : null;\n+            }\n+            setMessageHeaderOnBreakpoint(nodeId, headerName, value, oldType);\n+        }\n+    }\n+\n+    public void setMessageHeaderOnBreakpoint(String nodeId, String headerName, Object value, Class type) throws NoTypeConversionAvailableException {\n         SuspendedExchange se = suspendedBreakpoints.get(nodeId);\n         if (se != null) {\n             logger.log(\"Breakpoint at node \" + nodeId + \" is updating message header on exchangeId: \" + se.getExchange().getExchangeId() + \" with header: \" + headerName + \" and value: \" + value);\n             if (se.getExchange().hasOut()) {\n+                if (type != null) {\n+                    Object convertedValue = se.getExchange().getContext().getTypeConverter().mandatoryConvertTo(type, se.getExchange(), value);\n+                    se.getExchange().getOut().setHeader(headerName, convertedValue);\n+                } else {\n                     se.getExchange().getOut().setHeader(headerName, value);\n+                }\n+            } else {\n+                if (type != null) {\n+                    Object convertedValue = se.getExchange().getContext().getTypeConverter().mandatoryConvertTo(type, se.getExchange(), value);\n+                    se.getExchange().getIn().setHeader(headerName, convertedValue);\n                 } else {\n                     se.getExchange().getIn().setHeader(headerName, value);\n                 }\n             }\n         }\n+    }\n+\n+    public void removeMessageHeaderOnBreakpoint(String nodeId, String headerName) {\n+        SuspendedExchange se = suspendedBreakpoints.get(nodeId);\n+        if (se != null) {\n+            logger.log(\"Breakpoint at node \" + nodeId + \" is removing message header on exchangeId: \" + se.getExchange().getExchangeId() + \" with header: \" + headerName);\n+            if (se.getExchange().hasOut()) {\n+                se.getExchange().getOut().removeHeader(headerName);\n+            } else {\n+                se.getExchange().getIn().removeHeader(headerName);\n+            }\n+        }\n+    }\n \n     public void resumeAll() {\n         logger.log(\"Resume all\");\n",
        "project": "camel",
        "linesAdd": 131,
        "jira_id": "7163",
        "nb_skipped": 3,
        "commit": "5f726d0b",
        "nb_failure": 1,
        "linesRem": 8,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3836,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.file.FileConsumerAutoCreateDirectoryTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/FileEndpoint.java b/camel-core/src/main/java/org/apache/camel/component/file/FileEndpoint.java\nindex 8109971d73..b8aaff39f7 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/FileEndpoint.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/FileEndpoint.java\n@@ -49,14 +49,8 @@ public FileConsumer createConsumer(Processor processor) throws Exception {\n         ObjectHelper.notNull(operations, \"operations\");\n         ObjectHelper.notNull(file, \"file\");\n \n-        // we assume its a file if the name has a dot in it (eg foo.txt)\n-        boolean isDirectory = file.isDirectory();\n-        if (!isDirectory && file.getName().contains(\".\")) {\n-            throw new IllegalArgumentException(\"Only directory is supported. Endpoint must be configured with a valid starting directory: \" + file);\n-        }\n-\n         // auto create starting directory if needed\n-        if (!file.exists() && !isDirectory) {\n+        if (!file.exists() && !file.isDirectory()) {\n             if (isAutoCreate()) {\n                 log.debug(\"Creating non existing starting directory: {}\", file);\n                 boolean absolute = FileUtil.isAbsolute(file);\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "4474",
        "nb_skipped": 0,
        "commit": "06a8489a",
        "nb_failure": 0,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4979,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.aggregator.AggregationStrategyBeanAdapterAllowNullTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregationStrategyBeanInfo.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregationStrategyBeanInfo.java\nindex f898be7db0..ed93a96ef4 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregationStrategyBeanInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregationStrategyBeanInfo.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.camel.processor.aggregate;\n \n+import java.lang.annotation.Annotation;\n import java.lang.reflect.Method;\n import java.util.ArrayList;\n import java.util.List;\n@@ -62,10 +63,11 @@ protected AggregationStrategyMethodInfo createMethodInfo() {\n         }\n \n         // must not have annotations as they are not supported (yet)\n-        for (int i = 0; i < size; i++) {\n-            Class<?> type = parameterTypes[i];\n-            if (type.getAnnotations().length > 0) {\n-                throw new IllegalArgumentException(\"Parameter annotations at index \" + i + \" is not supported on method: \" + method);\n+        Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n+        for (int i = 0; i < parameterAnnotations.length; i++) {\n+            Annotation[] annotations = parameterAnnotations[i];\n+            if (annotations.length > 0) {\n+                throw new IllegalArgumentException(\"Method parameter annotation: \" + annotations[0] + \" at index: \" + i + \" is not supported on method: \" + method);\n             }\n         }\n \n",
        "project": "camel",
        "linesAdd": 6,
        "jira_id": "7513",
        "nb_skipped": 3,
        "commit": "85ced066",
        "nb_failure": 0,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3167,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.impl.EndpointShutdownOnceTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\nindex a8b9c80de7..f1dd98d19d 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n@@ -891,7 +891,8 @@ public void addService(Object object) throws Exception {\n             if (service instanceof IsSingleton) {\n                 singleton = ((IsSingleton) service).isSingleton();\n             }\n-            if (singleton) {\n+            // do not add endpoints as they have their own list\n+            if (singleton && !(service instanceof Endpoint)) {\n                 servicesToClose.add(service);\n             }\n         }\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "3690",
        "nb_skipped": 0,
        "commit": "2a3f3392",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4887,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.language.simple.SimpleTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java b/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\nindex 32a22b2019..4eedcba8a4 100644\n--- a/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\n+++ b/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\n@@ -238,7 +238,8 @@ private Expression createSimpleExpressionBodyOrHeader(String function, boolean s\n \n             String key = ObjectHelper.before(keyAndType, \",\");\n             String type = ObjectHelper.after(keyAndType, \",\");\n-            if (ObjectHelper.isEmpty(key) || ObjectHelper.isEmpty(type)) {\n+            remainder = ObjectHelper.after(remainder, \")\");\n+            if (ObjectHelper.isEmpty(key) || ObjectHelper.isEmpty(type) || ObjectHelper.isNotEmpty(remainder)) {\n                 throw new SimpleParserException(\"Valid syntax: ${headerAs(key, type)} was: \" + function, token.getIndex());\n             }\n             key = StringHelper.removeQuotes(key);\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "7359",
        "nb_skipped": 3,
        "commit": "9cb09d14",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 3855,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.DeadLetterChannelUnmarshalSetHeaderTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MarshalProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MarshalProcessor.java\nindex b4e328972d..9a01a552cc 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MarshalProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MarshalProcessor.java\n@@ -55,9 +55,15 @@ public void process(Exchange exchange) throws Exception {\n         Message out = exchange.getOut();\n         out.copyFrom(in);\n \n+        try {\n             dataFormat.marshal(exchange, body, buffer);\n             byte[] data = buffer.toByteArray();\n             out.setBody(data);\n+        } catch (Exception e) {\n+            // remove OUT message, as an exception occurred\n+            exchange.setOut(null);\n+            throw e;\n+        }\n     }\n \n     @Override\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/UnmarshalProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/UnmarshalProcessor.java\nindex 414b088006..b8c5e5f6eb 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/UnmarshalProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/UnmarshalProcessor.java\n@@ -27,6 +27,7 @@\n import org.apache.camel.spi.DataFormat;\n import org.apache.camel.support.ServiceSupport;\n import org.apache.camel.util.ExchangeHelper;\n+import org.apache.camel.util.IOHelper;\n import org.apache.camel.util.ObjectHelper;\n import org.apache.camel.util.ServiceHelper;\n \n@@ -56,10 +57,12 @@ public void process(Exchange exchange) throws Exception {\n \n             Object result = dataFormat.unmarshal(exchange, stream);\n             out.setBody(result);\n+        } catch (Exception e) {\n+            // remove OUT message, as an exception occurred\n+            exchange.setOut(null);\n+            throw e;\n         } finally {\n-            if (stream != null) {\n-                stream.close();\n-            }\n+            IOHelper.close(stream, \"input stream\");\n         }\n     }\n \n",
        "project": "camel",
        "linesAdd": 10,
        "jira_id": "4509",
        "nb_skipped": 0,
        "commit": "8e3450f4",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 4762,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.management.ManagedResourceTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java b/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\nindex 9d4ade2d90..ffe2f6dbba 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\n@@ -308,6 +308,7 @@ public void setPurgeWhenStopping(boolean purgeWhenStopping) {\n         this.purgeWhenStopping = purgeWhenStopping;\n     }\n \n+    @ManagedAttribute(description = \"Singleton\")\n     public boolean isSingleton() {\n         return true;\n     }\n@@ -425,6 +426,11 @@ public String getCamelManagementName() {\n         return getCamelContext().getManagementName();\n     }\n \n+    @ManagedAttribute(description = \"Endpoint URI\", mask = true)\n+    public String getEndpointUri() {\n+        return super.getEndpointUri();\n+    }\n+\n     @ManagedAttribute(description = \"Endpoint service state\")\n     public String getState() {\n         return getStatus().name();\ndiff --git a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementMBeanAssembler.java b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementMBeanAssembler.java\nindex 262b520567..fde3592137 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementMBeanAssembler.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementMBeanAssembler.java\n@@ -60,7 +60,7 @@ public ModelMBean assemble(MBeanServer mBeanServer, Object obj, ObjectName name)\n             if (custom != null && ObjectHelper.hasAnnotation(custom.getClass().getAnnotations(), ManagedResource.class)) {\n                 LOG.trace(\"Assembling MBeanInfo for: {} from custom @ManagedResource object: {}\", name, custom);\n                 // get the mbean info from the custom managed object\n-                mbi = assembler.getMBeanInfo(obj, custom, name.toString());\n+                mbi = assembler.getMBeanInfo(null, custom, name.toString());\n                 // and let the custom object be registered in JMX\n                 obj = custom;\n             }\ndiff --git a/camel-core/src/main/java/org/apache/camel/management/MBeanInfoAssembler.java b/camel-core/src/main/java/org/apache/camel/management/MBeanInfoAssembler.java\nindex 56b5a14427..84f0470eb9 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/MBeanInfoAssembler.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/MBeanInfoAssembler.java\n@@ -97,7 +97,7 @@ public void stop() throws Exception {\n      */\n     public ModelMBeanInfo getMBeanInfo(Object defaultManagedBean, Object customManagedBean, String objectName) throws JMException {\n         // skip proxy classes\n-        if (Proxy.isProxyClass(defaultManagedBean.getClass())) {\n+        if (defaultManagedBean != null && Proxy.isProxyClass(defaultManagedBean.getClass())) {\n             LOG.trace(\"Skip creating ModelMBeanInfo due proxy class {}\", defaultManagedBean.getClass());\n             return null;\n         }\n@@ -110,10 +110,12 @@ public ModelMBeanInfo getMBeanInfo(Object defaultManagedBean, Object customManag\n         Set<ModelMBeanNotificationInfo> mBeanNotifications = new LinkedHashSet<ModelMBeanNotificationInfo>();\n \n         // extract details from default managed bean\n+        if (defaultManagedBean != null) {\n             extractAttributesAndOperations(defaultManagedBean.getClass(), attributes, operations);\n             extractMbeanAttributes(defaultManagedBean, attributes, mBeanAttributes, mBeanOperations);\n             extractMbeanOperations(defaultManagedBean, operations, mBeanOperations);\n             extractMbeanNotifications(defaultManagedBean, mBeanNotifications);\n+        }\n \n         // extract details from custom managed bean\n         if (customManagedBean != null) {\n",
        "project": "camel",
        "linesAdd": 10,
        "jira_id": "7018",
        "nb_skipped": 1,
        "commit": "3244c1e5",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3243,
        "nb_error": 5,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.management.DualManagedThreadPoolProfileTest",
            "org.apache.camel.management.DualManagedThreadPoolWithIdTest",
            "org.apache.camel.management.ManagedThreadPoolProfileTest",
            "org.apache.camel.management.ManagedThreadPoolWithIdTest",
            "org.apache.camel.management.ManagedThreadPoolTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementNamingStrategy.java b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementNamingStrategy.java\nindex 473c07fe69..ef21e26f90 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementNamingStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementNamingStrategy.java\n@@ -254,11 +254,13 @@ public ObjectName getObjectNameForThreadPool(CamelContext context, ThreadPoolExe\n         buffer.append(domainName).append(\":\");\n         buffer.append(KEY_CONTEXT + \"=\").append(getContextId(context)).append(\",\");\n         buffer.append(KEY_TYPE + \"=\" + TYPE_THREAD_POOL + \",\");\n-        buffer.append(KEY_NAME + \"=\").append(id);\n+\n+        String name = id;\n         if (sourceId != null) {\n             // provide source id if we know it, this helps end user to know where the pool is used\n-            buffer.append(\"(\").append(sourceId).append(\")\");\n+            name = name + \"(\" + sourceId + \")\";\n         }\n+        buffer.append(KEY_NAME + \"=\").append(ObjectName.quote(name));\n         return createObjectName(buffer);\n     }\n \n",
        "project": "camel",
        "linesAdd": 4,
        "jira_id": "3760",
        "nb_skipped": 0,
        "commit": "5225e6e3",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3083,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.aggregator.BeanBeforeAggregateIssueTest",
            "org.apache.camel.issues.MulticastParallelStopOnExceptionWithOnExceptionIssueTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\nindex f2f09c00af..78ab290e0d 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\n@@ -177,12 +177,16 @@ public void process(Exchange exchange) throws Exception {\n             throw new ClosedCorrelationKeyException(key, exchange);\n         }\n \n+        // copy exchange, and do not share the unit of work\n+        // the aggregated output runs in another unit of work\n+        Exchange copy = ExchangeHelper.createCorrelatedCopy(exchange, false);\n+\n         // when memory based then its fast using synchronized, but if the aggregation repository is IO\n         // bound such as JPA etc then concurrent aggregation per correlation key could\n         // improve performance as we can run aggregation repository get/add in parallel\n         lock.lock();\n         try {\n-            doAggregation(key, exchange);\n+            doAggregation(key, copy);\n         } finally {\n             lock.unlock();\n         }\n",
        "project": "camel",
        "linesAdd": 3,
        "jira_id": "3535",
        "nb_skipped": 0,
        "commit": "b56d2962",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5437,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.file.FileConsumerPathWithAmpersandTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultComponent.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultComponent.java\nindex c7ab7ff8a7..c6492ea2a6 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultComponent.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultComponent.java\n@@ -196,12 +196,6 @@ protected void validateParameters(String uri, Map<String, Object> parameters, St\n      * @throws ResolveEndpointFailedException should be thrown if the URI validation failed\n      */\n     protected void validateURI(String uri, String path, Map<String, Object> parameters) {\n-        // check for uri containing & but no ? marker\n-        if (uri.contains(\"&\") && !uri.contains(\"?\")) {\n-            throw new ResolveEndpointFailedException(uri, \"Invalid uri syntax: no ? marker however the uri \"\n-                + \"has & parameter separators. Check the uri if its missing a ? marker.\");\n-        }\n-\n         // check for uri containing double && markers without include by RAW\n         if (uri.contains(\"&&\")) {\n             Pattern pattern = Pattern.compile(\"RAW(.*&&.*)\");\n",
        "project": "camel",
        "linesAdd": 0,
        "jira_id": "9217",
        "nb_skipped": 4,
        "commit": "e7ac45b6",
        "nb_failure": 0,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5134,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.MulticastParallelAllTimeoutAwareTest",
            "org.apache.camel.processor.MulticastParallelTwoTimeoutMiddleTest",
            "org.apache.camel.management.ManagedThrottlerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex 1d579cdfb5..38e70bb04c 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -442,10 +442,7 @@ private void aggregateOnTheFly() throws InterruptedException, ExecutionException\n                     }\n                 }\n \n-                if (future == null && timedOut) {\n-                    // we are timed out and no more tasks complete so break out\n-                    break;\n-                } else if (future == null) {\n+                if (future == null) {\n                     // timeout occurred\n                     AggregationStrategy strategy = getAggregationStrategy(null);\n                     if (strategy instanceof TimeoutAwareAggregationStrategy) {\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "8081",
        "nb_skipped": 3,
        "commit": "2e985f9b",
        "nb_failure": 3,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5551,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.TrySetFaultFinallyTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/FinallyProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/FinallyProcessor.java\nindex b04e1721ba..4fe21a6a5f 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/FinallyProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/FinallyProcessor.java\n@@ -41,26 +41,80 @@ public FinallyProcessor(Processor processor) {\n \n     @Override\n     public boolean process(final Exchange exchange, final AsyncCallback callback) {\n-        // clear exception so finally block can be executed\n-        final Exception e = exchange.getException();\n+        // clear exception and fault so finally block can be executed\n+        final boolean fault;\n+        if (exchange.hasOut()) {\n+            fault = exchange.getOut().isFault();\n+            exchange.getOut().setFault(false);\n+        } else {\n+            fault = exchange.getIn().isFault();\n+            exchange.getIn().setFault(false);\n+        }\n+\n+        final Exception exception = exchange.getException();\n         exchange.setException(null);\n         // but store the caught exception as a property\n-        if (e != null) {\n-            exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);\n+        if (exception != null) {\n+            exchange.setProperty(Exchange.EXCEPTION_CAUGHT, exception);\n         }\n+\n         // store the last to endpoint as the failure endpoint\n         if (exchange.getProperty(Exchange.FAILURE_ENDPOINT) == null) {\n             exchange.setProperty(Exchange.FAILURE_ENDPOINT, exchange.getProperty(Exchange.TO_ENDPOINT));\n         }\n \n-        boolean sync = processor.process(exchange, new AsyncCallback() {\n+        // continue processing\n+        return processor.process(exchange, new FinallyAsyncCallback(exchange, callback, exception, fault));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Finally{\" + getProcessor() + \"}\";\n+    }\n+\n+    public String getTraceLabel() {\n+        return \"finally\";\n+    }\n+\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public void setId(String id) {\n+        this.id = id;\n+    }\n+\n+    private static final class FinallyAsyncCallback implements AsyncCallback {\n+\n+        private final Exchange exchange;\n+        private final AsyncCallback callback;\n+        private final Exception exception;\n+        private final boolean fault;\n+\n+        public FinallyAsyncCallback(Exchange exchange, AsyncCallback callback, Exception exception, boolean fault) {\n+            this.exchange = exchange;\n+            this.callback = callback;\n+            this.exception = exception;\n+            this.fault = fault;\n+        }\n+\n+        @Override\n         public void done(boolean doneSync) {\n-                if (e == null) {\n+            try {\n+                if (exception == null) {\n                     exchange.removeProperty(Exchange.FAILURE_ENDPOINT);\n                 } else {\n                     // set exception back on exchange\n-                    exchange.setException(e);\n-                    exchange.setProperty(Exchange.EXCEPTION_CAUGHT, e);\n+                    exchange.setException(exception);\n+                    exchange.setProperty(Exchange.EXCEPTION_CAUGHT, exception);\n+                }\n+                // set fault flag back\n+                if (fault) {\n+                    if (exchange.hasOut()) {\n+                        exchange.getOut().setFault(true);\n+                    } else {\n+                        exchange.getIn().setFault(true);\n+                    }\n                 }\n \n                 if (!doneSync) {\n@@ -68,26 +122,16 @@ public void done(boolean doneSync) {\n                     ExchangeHelper.prepareOutToIn(exchange);\n                     LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n                 }\n+            } finally {\n+                // callback must always be called\n                 callback.done(doneSync);\n             }\n-        });\n-        return sync;\n         }\n \n         @Override\n         public String toString() {\n-        return \"Finally{\" + getProcessor() + \"}\";\n+            return \"FinallyAsyncCallback\";\n         }\n-\n-    public String getTraceLabel() {\n-        return \"finally\";\n-    }\n-\n-    public String getId() {\n-        return id;\n     }\n \n-    public void setId(String id) {\n-        this.id = id;\n-    }\n }\n",
        "project": "camel",
        "linesAdd": 61,
        "jira_id": "9673",
        "nb_skipped": 4,
        "commit": "7944093f",
        "nb_failure": 1,
        "linesRem": 20,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5294,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.aggregator.CustomListAggregationStrategyEmptySplitTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AbstractListAggregationStrategy.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AbstractListAggregationStrategy.java\nindex ad2ec8ed6a..d4ff93f1ae 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AbstractListAggregationStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AbstractListAggregationStrategy.java\n@@ -62,7 +62,7 @@ public boolean isStoreAsBodyOnCompletion() {\n \n     @SuppressWarnings(\"unchecked\")\n     public void onCompletion(Exchange exchange) {\n-        if (isStoreAsBodyOnCompletion()) {\n+        if (exchange != null && isStoreAsBodyOnCompletion()) {\n             List<V> list = (List<V>) exchange.removeProperty(Exchange.GROUPED_EXCHANGE);\n             if (list != null) {\n                 exchange.getIn().setBody(list);\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "8592",
        "nb_skipped": 4,
        "commit": "57f72cd9",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 5358,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.impl.RouteSedaSuspendResumeTest",
            "org.apache.camel.management.ManagedThrottlerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\nindex c24674e0a9..0ed913a75e 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n@@ -984,6 +984,9 @@ public synchronized void resumeRoute(String routeId) throws Exception {\n         RouteService routeService = routeServices.get(routeId);\n         if (routeService != null) {\n             resumeRouteService(routeService);\n+            // must resume the route as well\n+            Route route = getRoute(routeId);\n+            ServiceHelper.resumeService(route);\n         }\n     }\n \n@@ -1125,12 +1128,15 @@ public synchronized void suspendRoute(String routeId) throws Exception {\n         RouteService routeService = routeServices.get(routeId);\n         if (routeService != null) {\n             List<RouteStartupOrder> routes = new ArrayList<RouteStartupOrder>(1);\n-            RouteStartupOrder order = new DefaultRouteStartupOrder(1, routeService.getRoutes().iterator().next(), routeService);\n+            Route route = routeService.getRoutes().iterator().next();\n+            RouteStartupOrder order = new DefaultRouteStartupOrder(1, route, routeService);\n             routes.add(order);\n \n             getShutdownStrategy().suspend(this, routes);\n             // must suspend route service as well\n             suspendRouteService(routeService);\n+            // must suspend the route as well\n+            ServiceHelper.suspendService(route);\n         }\n     }\n \n@@ -1143,12 +1149,15 @@ public synchronized void suspendRoute(String routeId, long timeout, TimeUnit tim\n         RouteService routeService = routeServices.get(routeId);\n         if (routeService != null) {\n             List<RouteStartupOrder> routes = new ArrayList<RouteStartupOrder>(1);\n-            RouteStartupOrder order = new DefaultRouteStartupOrder(1, routeService.getRoutes().iterator().next(), routeService);\n+            Route route = routeService.getRoutes().iterator().next();\n+            RouteStartupOrder order = new DefaultRouteStartupOrder(1, route, routeService);\n             routes.add(order);\n \n             getShutdownStrategy().suspend(this, routes, timeout, timeUnit);\n             // must suspend route service as well\n             suspendRouteService(routeService);\n+            // must suspend the route as well\n+            ServiceHelper.suspendService(route);\n         }\n     }\n \ndiff --git a/camel-core/src/main/java/org/apache/camel/util/ServiceHelper.java b/camel-core/src/main/java/org/apache/camel/util/ServiceHelper.java\nindex 0a7df51821..90b5ce95b3 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/ServiceHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/ServiceHelper.java\n@@ -260,7 +260,7 @@ public static void stopAndShutdownServices(Collection<?> services) throws Except\n      * If there's any exception being thrown while resuming the elements one after the\n      * other this method would rethrow the <b>first</b> such exception being thrown.\n      * \n-     * @see #resumeService(Service)\n+     * @see #resumeService(Object)\n      */\n     public static void resumeServices(Collection<?> services) throws Exception {\n         if (services == null) {\n@@ -308,7 +308,7 @@ public static void resumeServices(Collection<?> services) throws Exception {\n      * @throws Exception is thrown if error occurred\n      * @see #startService(Service)\n      */\n-    public static boolean resumeService(Service service) throws Exception {\n+    public static boolean resumeService(Object service) throws Exception {\n         if (service instanceof SuspendableService) {\n             SuspendableService ss = (SuspendableService) service;\n             if (ss.isSuspended()) {\n@@ -331,7 +331,7 @@ public static boolean resumeService(Service service) throws Exception {\n      * If there's any exception being thrown while suspending the elements one after the\n      * other this method would rethrow the <b>first</b> such exception being thrown.\n      * \n-     * @see #suspendService(Service)\n+     * @see #suspendService(Object)\n      */\n     public static void suspendServices(Collection<?> services) throws Exception {\n         if (services == null) {\n@@ -379,7 +379,7 @@ public static void suspendServices(Collection<?> services) throws Exception {\n      * @throws Exception is thrown if error occurred\n      * @see #stopService(Object)\n      */\n-    public static boolean suspendService(Service service) throws Exception {\n+    public static boolean suspendService(Object service) throws Exception {\n         if (service instanceof SuspendableService) {\n             SuspendableService ss = (SuspendableService) service;\n             if (!ss.isSuspended()) {\n",
        "project": "camel",
        "linesAdd": 10,
        "jira_id": "8964",
        "nb_skipped": 4,
        "commit": "ea8ee025",
        "nb_failure": 2,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5540,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.language.simple.SimpleTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java b/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\nindex be5e4acad4..5110ae95cb 100644\n--- a/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\n+++ b/camel-core/src/main/java/org/apache/camel/language/simple/ast/SimpleFunctionExpression.java\n@@ -141,8 +141,8 @@ private Expression createSimpleExpression(String function, boolean strict) {\n         // file: prefix\n         remainder = ifStartsWithReturnRemainder(\"file:\", function);\n         if (remainder != null) {\n-            Expression fileExpression = createSimpleFileExpression(remainder);\n-            if (function != null) {\n+            Expression fileExpression = createSimpleFileExpression(remainder, strict);\n+            if (fileExpression != null) {\n                 return fileExpression;\n             }\n         }\n@@ -388,7 +388,7 @@ private Expression createSimpleExpressionDirectly(String expression) {\n         return null;\n     }\n \n-    private Expression createSimpleFileExpression(String remainder) {\n+    private Expression createSimpleFileExpression(String remainder, boolean strict) {\n         if (ObjectHelper.equal(remainder, \"name\")) {\n             return ExpressionBuilder.fileNameExpression();\n         } else if (ObjectHelper.equal(remainder, \"name.noext\")) {\n@@ -418,8 +418,11 @@ private Expression createSimpleFileExpression(String remainder) {\n         } else if (ObjectHelper.equal(remainder, \"modified\")) {\n             return ExpressionBuilder.fileLastModifiedExpression();\n         }\n+        if (strict) {\n             throw new SimpleParserException(\"Unknown file language syntax: \" + remainder, token.getIndex());\n         }\n+        return null;\n+    }\n \n     private String ifStartsWithReturnRemainder(String prefix, String text) {\n         if (text.startsWith(prefix)) {\n",
        "project": "camel",
        "linesAdd": 6,
        "jira_id": "9641",
        "nb_skipped": 4,
        "commit": "9a6e6d8a",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 0,
        "nb_test": 5008,
        "nb_error": 76,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.model.LoadRouteFromXmlWithOnExceptionTest",
            "org.apache.camel.management.ManagedCamelContextDumpRoutesAsXmlTest",
            "org.apache.camel.management.ManagedThrottlerTest",
            "org.apache.camel.model.GenerateXmlTest",
            "org.apache.camel.management.ManagedRouteUpdateRouteFromXmlTest",
            "org.apache.camel.management.ManagedCamelContextUpdateRoutesFromXmlTest",
            "org.apache.camel.management.ManagedFromRestGetTest",
            "org.apache.camel.management.ManagedRouteDumpRouteAsXmlTest",
            "org.apache.camel.model.LoadRouteFromXmlWithPolicyTest",
            "org.apache.camel.util.DumpModelAsXmlTransformRouteTest",
            "org.apache.camel.model.XmlParseTest",
            "org.apache.camel.component.rest.FromRestConfigurationTest",
            "org.apache.camel.impl.CamelContextAddRouteDefinitionsFromXmlTest",
            "org.apache.camel.model.LoadRouteFromXmlWithInterceptTest",
            "org.apache.camel.util.DumpModelAsXmlAggregateRouteTest",
            "org.apache.camel.util.DumpModelAsXmlChoiceFilterRouteTest",
            "org.apache.camel.util.DumpModelAsXmlRoutePredicateTest",
            "org.apache.camel.model.GenerateXmFromCamelContextTest",
            "org.apache.camel.util.DumpModelAsXmlRouteExpressionTest",
            "org.apache.camel.management.ManagedCamelContextUpdateRoutesWithPropertyPlaceholdersFromXmlPTest",
            "org.apache.camel.model.LoadRouteFromXmlTest"
        ],
        "patch": "",
        "project": "camel",
        "linesAdd": 0,
        "jira_id": "7364",
        "nb_skipped": 3,
        "commit": "7bbb88ba",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5412,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "",
            "org.apache.camel.component.bean.BeanInfoTest",
            "org.apache.camel.component.bean.BeanPrivateClassWithInterfaceMethodTest",
            "org.apache.camel.language.simple.SimpleOverrideMethodTest",
            "org.apache.camel.component.bean.issues.BeanInfoSingleMethodServiceTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\nindex 1b346224ce..d3c72141a1 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n@@ -557,6 +557,12 @@ protected MethodInfo chooseMethod(Object pojo, Exchange exchange, String name) t\n         final List<MethodInfo> localOperationsWithCustomAnnotation = new ArrayList<MethodInfo>(operationsWithCustomAnnotation);\n         final List<MethodInfo> localOperationsWithHandlerAnnotation = new ArrayList<MethodInfo>(operationsWithHandlerAnnotation);\n \n+        // remove all abstract methods\n+        removeAllAbstractMethods(localOperationsWithBody);\n+        removeAllAbstractMethods(localOperationsWithNoBody);\n+        removeAllAbstractMethods(localOperationsWithCustomAnnotation);\n+        removeAllAbstractMethods(localOperationsWithHandlerAnnotation);\n+\n         if (name != null) {\n             // filter all lists to only include methods with this name\n             removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name);\n@@ -831,11 +837,6 @@ protected boolean isValidMethod(Class<?> clazz, Method method) {\n             return false;\n         }\n \n-        // must not be abstract\n-        if (Modifier.isAbstract(method.getModifiers())) {\n-            return false;\n-        }\n-\n         // return type must not be an Exchange and it should not be a bridge method\n         if ((method.getReturnType() != null && Exchange.class.isAssignableFrom(method.getReturnType())) || method.isBridge()) {\n             return false;\n@@ -982,6 +983,17 @@ private void removeNonMatchingMethods(List<MethodInfo> methods, String name) {\n         }\n     }\n \n+    private void removeAllAbstractMethods(List<MethodInfo> methods) {\n+        Iterator<MethodInfo> it = methods.iterator();\n+        while (it.hasNext()) {\n+            MethodInfo info = it.next();\n+            if (Modifier.isAbstract(info.getMethod().getModifiers())) {\n+                // we cannot invoke an abstract method\n+                it.remove();\n+            }\n+        }\n+    }\n+\n     private boolean matchMethod(Method method, String methodName) {\n         if (methodName == null) {\n             return true;\n",
        "project": "camel",
        "linesAdd": 15,
        "jira_id": "9032",
        "nb_skipped": 4,
        "commit": "108d94f7",
        "nb_failure": 5,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4146,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.bean.BeanHandlerMethodPredicateTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanProcessor.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanProcessor.java\nindex 536a07fbfa..f3e54851d4 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanProcessor.java\n@@ -89,9 +89,10 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n         }\n \n         // do we have a custom adapter for this POJO to a Processor\n-        // should not be invoked if an explicit method has been set\n+        // but only do this if allowed\n+        if (allowProcessor(explicitMethodName, beanInfo)) {\n             Processor processor = getProcessor();\n-        if (explicitMethodName == null && processor != null) {\n+            if (processor != null) {\n                 LOG.trace(\"Using a custom adapter as bean invocation: {}\", processor);\n                 try {\n                     processor.process(exchange);\n@@ -101,6 +102,7 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n                 callback.done(true);\n                 return true;\n             }\n+        }\n \n         Message in = exchange.getIn();\n \n@@ -253,4 +255,23 @@ protected void doStart() throws Exception {\n     protected void doStop() throws Exception {\n         ServiceHelper.stopService(getProcessor());\n     }\n+\n+    private boolean allowProcessor(String explicitMethodName, BeanInfo info) {\n+        if (explicitMethodName != null) {\n+            // don't allow if explicit method name is given, as we then must invoke this method\n+            return false;\n+        }\n+\n+        // don't allow if any of the methods has a @Handler annotation\n+        // as the @Handler annotation takes precedence and is supposed to trigger invocation\n+        // of the given method\n+        for (MethodInfo method : info.getMethods()) {\n+            if (method.hasHandlerAnnotation()) {\n+                return false;\n+            }\n+        }\n+\n+        // fallback and allow using the processor\n+        return true;\n+    }\n }\n",
        "project": "camel",
        "linesAdd": 17,
        "jira_id": "5140",
        "nb_skipped": 0,
        "commit": "8898d491",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3253,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.impl.TypeConverterRegistryMissesThenAddTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/converter/BaseTypeConverterRegistry.java b/camel-core/src/main/java/org/apache/camel/impl/converter/BaseTypeConverterRegistry.java\nindex ec766af44c..b3de5e6db0 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/converter/BaseTypeConverterRegistry.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/converter/BaseTypeConverterRegistry.java\n@@ -223,9 +223,7 @@ protected Object doConvertTo(final Class type, final Exchange exchange, final Ob\n         }\n \n         // Could not find suitable conversion, so remember it\n-        synchronized (misses) {\n         misses.put(key, key);\n-        }\n \n         // Could not find suitable conversion, so return Void to indicate not found\n         return Void.TYPE;\n@@ -243,6 +241,8 @@ public void addTypeConverter(Class<?> toType, Class<?> fromType, TypeConverter t\n                     log.warn(\"Overriding type converter from: \" + converter + \" to: \" + typeConverter);\n                 }\n                 typeMappings.put(key, typeConverter);\n+                // remove any previous misses, as we added the new type converter\n+                misses.remove(key);\n             }\n         }\n     }\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "3847",
        "nb_skipped": 0,
        "commit": "de9399f3",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 4,
        "nb_test": 3269,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.file.strategy.MarkerFileExclusiveReadLockStrategyTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java b/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java\nindex 206bb98562..1c2834579b 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java\n@@ -106,14 +106,19 @@ public boolean buildDirectory(String directory, boolean absolute) throws Generic\n             }\n         }\n \n+        // We need to make sure that this is thread-safe and only one thread tries to create the path directory at the same time.\n+        synchronized (this) {\n             if (path.isDirectory() && path.exists()) {\n                 // the directory already exists\n                 return true;\n             } else {\n-            LOG.trace(\"Building directory: {}\", path);\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"Building directory: \" + path);\n+                }\n                 return path.mkdirs();\n             }\n         }\n+    }\n \n     public List<File> listFiles() throws GenericFileOperationFailedException {\n         // noop\n@@ -152,7 +157,9 @@ public boolean storeFile(String fileName, Exchange exchange) throws GenericFileO\n         if (file.exists()) {\n             if (endpoint.getFileExist() == GenericFileExist.Ignore) {\n                 // ignore but indicate that the file was written\n-                LOG.trace(\"An existing file already exists: {}. Ignore and do not override it.\", file);\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"An existing file already exists: \" + file + \". Ignore and do not override it.\");\n+                }\n                 return true;\n             } else if (endpoint.getFileExist() == GenericFileExist.Fail) {\n                 throw new GenericFileOperationFailedException(\"File already exist: \" + file + \". Cannot write new file.\");\n@@ -222,13 +229,17 @@ private void keepLastModified(Exchange exchange, File file) {\n             }\n             if (last != null) {\n                 boolean result = file.setLastModified(last);\n-                LOG.trace(\"Keeping last modified timestamp: {} on file: {} with result: {}\", new Object[]{last, file, result});\n+                if (LOG.isTraceEnabled()) {\n+                    LOG.trace(\"Keeping last modified timestamp: \" + last + \" on file: \" + file + \" with result: \" + result);\n+                }\n             }\n         }\n     }\n \n     private boolean writeFileByLocalWorkPath(File source, File file) {\n-        LOG.trace(\"Using local work file being renamed from: {} to: {}\", source, file);\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Using local work file being renamed from: \" + source + \" to: \" + file);\n+        }\n \n         return FileUtil.renameFile(source, file);\n     }\n@@ -239,7 +250,9 @@ private void writeFileByFile(File source, File target) throws IOException {\n         try {\n             out = prepareOutputFileChannel(target, out);\n \n-            LOG.trace(\"Using FileChannel to transfer from: {} to: {}\", in, out);\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Using FileChannel to transfer from: \" + in + \" to: \" + out);\n+            }\n \n             long size = in.size();\n             long position = 0;\n@@ -257,7 +270,9 @@ private void writeFileByStream(InputStream in, File target) throws IOException {\n         try {\n             out = prepareOutputFileChannel(target, out);\n \n-            LOG.trace(\"Using InputStream to transfer from: {} to: {}\", in, out);\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Using InputStream to transfer from: \" + in + \" to: \" + out);\n+            }\n             int size = endpoint.getBufferSize();\n             byte[] buffer = new byte[size];\n             ByteBuffer byteBuffer = ByteBuffer.wrap(buffer);\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileDeleteProcessStrategy.java b/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileDeleteProcessStrategy.java\nindex 9235dccf26..8f5ff7b7a8 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileDeleteProcessStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileDeleteProcessStrategy.java\n@@ -29,19 +29,22 @@\n \n     @Override\n     public boolean begin(GenericFileOperations<T> operations, GenericFileEndpoint<T> endpoint, Exchange exchange, GenericFile<T> file) throws Exception {\n-        // must invoke super\n-        boolean result = super.begin(operations, endpoint, exchange, file);\n-        if (!result) {\n-            return false;\n-        }\n+\n+        // We need to invoke super, but to the file that we are going to use for processing, so we do super after renaming.\n+        GenericFile<T> to = file;\n \n         if (beginRenamer != null) {\n             GenericFile<T> newName = beginRenamer.renameFile(exchange, file);\n-            GenericFile<T> to = renameFile(operations, file, newName);\n+            to = renameFile(operations, file, newName);\n             if (to != null) {\n                 to.bindToExchange(exchange);\n             }\n         }\n+        // must invoke super\n+        boolean result = super.begin(operations, endpoint, exchange, to);\n+        if (!result) {\n+            return false;\n+        }\n \n         return true;\n     }\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileRenameProcessStrategy.java b/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileRenameProcessStrategy.java\nindex 1e32688f0d..943e71f731 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileRenameProcessStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/strategy/GenericFileRenameProcessStrategy.java\n@@ -31,19 +31,22 @@ public GenericFileRenameProcessStrategy() {\n \n     @Override\n     public boolean begin(GenericFileOperations<T> operations, GenericFileEndpoint<T> endpoint, Exchange exchange, GenericFile<T> file) throws Exception {\n-        // must invoke super\n-        boolean result = super.begin(operations, endpoint, exchange, file);\n-        if (!result) {\n-            return false;\n-        }\n+\n+        // We need to invoke super, but to the file that we are going to use for processing, so we do super after renaming.\n+        GenericFile<T> to = file;\n \n         if (beginRenamer != null) {\n             GenericFile<T> newName = beginRenamer.renameFile(exchange, file);\n-            GenericFile<T> to = renameFile(operations, file, newName);\n+            to = renameFile(operations, file, newName);\n             if (to != null) {\n                 to.bindToExchange(exchange);\n             }\n         }\n+        // must invoke super\n+        boolean result = super.begin(operations, endpoint, exchange, to);\n+        if (!result) {\n+            return false;\n+        }\n \n         return true;\n     }\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java b/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java\nindex 6d72d19a2a..734a6542a0 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/strategy/MarkerFileExclusiveReadLockStrategy.java\n@@ -34,8 +34,6 @@\n  */\n public class MarkerFileExclusiveReadLockStrategy implements GenericFileExclusiveReadLockStrategy<File> {\n     private static final transient Logger LOG = LoggerFactory.getLogger(MarkerFileExclusiveReadLockStrategy.class);\n-    private File lock;\n-    private String lockFileName;\n \n     public void prepareOnStartup(GenericFileOperations<File> operations, GenericFileEndpoint<File> endpoint) {\n         String dir = endpoint.getConfiguration().getDirectory();\n@@ -50,29 +48,26 @@ public void prepareOnStartup(GenericFileOperations<File> operations, GenericFile\n \n     public boolean acquireExclusiveReadLock(GenericFileOperations<File> operations,\n                                             GenericFile<File> file, Exchange exchange) throws Exception {\n-        lockFileName = file.getAbsoluteFilePath() + FileComponent.DEFAULT_LOCK_FILE_POSTFIX;\n+        String lockFileName = getLockFileName(file);\n         LOG.trace(\"Locking the file: {} using the lock file name: {}\", file, lockFileName);\n \n         // create a plain file as marker filer for locking (do not use FileLock)\n-        lock = new File(lockFileName);\n+        File lock = new File(lockFileName);\n         boolean acquired = lock.createNewFile();\n-        if (!acquired) {\n-            lock = null;\n-\n-        }\n \n         return acquired;\n     }\n \n     public void releaseExclusiveReadLock(GenericFileOperations<File> operations,\n                                          GenericFile<File> file, Exchange exchange) throws Exception {\n-        if (lock != null) {\n+        String lockFileName = getLockFileName(file);\n+        File lock = new File(lockFileName);\n+\n         LOG.trace(\"Unlocking file: {}\", lockFileName);\n \n         boolean deleted = FileUtil.deleteFile(lock);\n         LOG.trace(\"Lock file: {} was deleted: {}\", lockFileName, deleted);\n     }\n-    }\n \n     public void setTimeout(long timeout) {\n         // noop\n@@ -101,4 +96,8 @@ private static void deleteLockFiles(File dir, boolean recursive) {\n         }\n     }\n \n+    private static String getLockFileName(GenericFile<File> file) {\n+        return file.getAbsoluteFilePath() + FileComponent.DEFAULT_LOCK_FILE_POSTFIX;\n+    }\n+\n }\n",
        "project": "camel",
        "linesAdd": 43,
        "jira_id": "3789",
        "nb_skipped": 0,
        "commit": "9319e139",
        "nb_failure": 1,
        "linesRem": 26,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4788,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.ThrottlerTest",
            "org.apache.camel.management.ManagedThrottlerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/Throttler.java b/camel-core/src/main/java/org/apache/camel/processor/Throttler.java\nindex ae6bc26391..6b51a2ce09 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/Throttler.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/Throttler.java\n@@ -116,6 +116,9 @@ protected long calculateDelay(Exchange exchange) {\n             if (maximumRequestsPerPeriod > 0 && longValue.longValue() != maximumRequestsPerPeriod) {\n                 log.debug(\"Throttler changed maximum requests per period from {} to {}\", maximumRequestsPerPeriod, longValue);\n             }\n+            if (maximumRequestsPerPeriod > longValue) {\n+                slot.capacity = 0;\n+            }\n             maximumRequestsPerPeriod = longValue;\n         }\n \n@@ -139,7 +142,7 @@ protected synchronized TimeSlot nextSlot() {\n         if (slot == null) {\n             slot = new TimeSlot();\n         }\n-        if (slot.isFull() || !slot.isActive()) {\n+        if (slot.isFull() || !slot.isPast()) {\n             slot = slot.next();\n         }\n         slot.assign();\n@@ -175,6 +178,11 @@ protected TimeSlot next() {\n             return new TimeSlot(Math.max(System.currentTimeMillis(), this.startTime + this.duration));\n         }\n \n+        protected boolean isPast() {\n+            long current = System.currentTimeMillis();\n+            return current < (startTime + duration);\n+        }\n+\n         protected boolean isActive() {\n             long current = System.currentTimeMillis();\n             return startTime <= current && current < (startTime + duration);\n",
        "project": "camel",
        "linesAdd": 9,
        "jira_id": "7160",
        "nb_skipped": 3,
        "commit": "095fa2b4",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 4794,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.vm.VmMultipleConsumersMultipleContextTest",
            "org.apache.camel.component.vm.VmMultipleContextsStartStopTest",
            "org.apache.camel.management.ManagedThrottlerTest",
            "org.apache.camel.processor.aggregator.AggregateCompletionOnlyOneTest",
            "org.apache.camel.component.file.FileProducerFileExistIgnoreTest",
            "org.apache.camel.component.vm.VmShouldNotUseSameThreadTest",
            "org.apache.camel.component.vm.VmQueueTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\nindex 8fe24c5855..e7a094f4a3 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregateProcessor.java\n@@ -481,8 +481,12 @@ protected Exchange onCompletion(final String key, final Exchange original, final\n         }\n         aggregated.setProperty(Exchange.AGGREGATED_CORRELATION_KEY, key);\n \n+        // only remove if we have previous added (as we could potentially complete with only 1 exchange)\n+        // (if we have previous added then we have that as the original exchange)\n+        if (original != null) {\n             // remove from repository as its completed, we do this first as to trigger any OptimisticLockingException's\n             aggregationRepository.remove(aggregated.getContext(), key, original);\n+        }\n \n         if (!fromTimeout && timeoutMap != null) {\n             // cleanup timeout map if it was a incoming exchange which triggered the timeout (and not the timeout checker)\ndiff --git a/camel-core/src/main/java/org/apache/camel/spi/AggregationRepository.java b/camel-core/src/main/java/org/apache/camel/spi/AggregationRepository.java\nindex 669a956550..ba1de6a334 100644\n--- a/camel-core/src/main/java/org/apache/camel/spi/AggregationRepository.java\n+++ b/camel-core/src/main/java/org/apache/camel/spi/AggregationRepository.java\n@@ -32,6 +32,9 @@\n      * Add the given {@link Exchange} under the correlation key.\n      * <p/>\n      * Will replace any existing exchange.\n+     * <p/>\n+     * <b>Important:</b> This method is <b>not</b> invoked if only one exchange was completed, and therefore\n+     * the exchange does not need to be added to a repository, as its completed immediately.\n      *\n      * @param camelContext   the current CamelContext\n      * @param key            the correlation key\n@@ -42,6 +45,8 @@\n \n     /**\n      * Gets the given exchange with the correlation key\n+     * <p/>\n+     * This method is always invoked for any incoming exchange in the aggregator.\n      *\n      * @param camelContext   the current CamelContext\n      * @param key            the correlation key\n@@ -52,6 +57,9 @@\n     /**\n      * Removes the exchange with the given correlation key, which should happen\n      * when an {@link Exchange} is completed\n+     * <p/>\n+     * <b>Important:</b> This method is <b>not</b> invoked if only one exchange was completed, and therefore\n+     * the exchange does not need to be added to a repository, as its completed immediately.\n      *\n      * @param camelContext   the current CamelContext\n      * @param key            the correlation key\n@@ -61,6 +69,8 @@\n \n     /**\n      * Confirms the completion of the {@link Exchange}.\n+     * <p/>\n+     * This method is always invoked.\n      *\n      * @param camelContext  the current CamelContext\n      * @param exchangeId    exchange id to confirm\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "7146",
        "nb_skipped": 3,
        "commit": "b6981cfd",
        "nb_failure": 4,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 4857,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.file.FileConsumerRelativeFileNameTest",
            "org.apache.camel.processor.TryCatchRecipientListTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/Exchange.java b/camel-core/src/main/java/org/apache/camel/Exchange.java\nindex 506ba29580..f9f3fe384b 100644\n--- a/camel-core/src/main/java/org/apache/camel/Exchange.java\n+++ b/camel-core/src/main/java/org/apache/camel/Exchange.java\n@@ -194,6 +194,7 @@\n     String TRACE_EVENT_NODE_ID   = \"CamelTraceEventNodeId\";\n     String TRACE_EVENT_TIMESTAMP = \"CamelTraceEventTimestamp\";\n     String TRACE_EVENT_EXCHANGE  = \"CamelTraceEventExchange\";\n+    String TRY_ROUTE_BLOCK       = \"TryRouteBlock\";\n     String TRANSFER_ENCODING     = \"Transfer-Encoding\";\n \n     String UNIT_OF_WORK_EXHAUSTED    = \"CamelUnitOfWorkExhausted\";\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex 69e4667cef..697ae329c1 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -885,7 +885,10 @@ protected ProcessorExchangePair createProcessorExchangePair(int index, Processor\n     protected Processor createErrorHandler(RouteContext routeContext, Exchange exchange, Processor processor) {\n         Processor answer;\n \n-        if (routeContext != null) {\n+        boolean tryBlock = exchange.getProperty(Exchange.TRY_ROUTE_BLOCK, false, boolean.class);\n+\n+        // do not wrap in error handler if we are inside a try block\n+        if (!tryBlock && routeContext != null) {\n             // wrap the producer in error handler so we have fine grained error handling on\n             // the output side instead of the input side\n             // this is needed to support redelivery on that output alone and not doing redelivery\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java\nindex 1bfe5dd8e2..b53a14e195 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java\n@@ -73,6 +73,7 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n         exchange.setProperty(Exchange.EXCEPTION_HANDLED, null);\n \n         while (continueRouting(processors, exchange)) {\n+            exchange.setProperty(Exchange.TRY_ROUTE_BLOCK, true);\n             ExchangeHelper.prepareOutToIn(exchange);\n \n             // process the next processor\n@@ -92,6 +93,7 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n         }\n \n         ExchangeHelper.prepareOutToIn(exchange);\n+        exchange.removeProperty(Exchange.TRY_ROUTE_BLOCK);\n         exchange.setProperty(Exchange.EXCEPTION_HANDLED, lastHandled);\n         LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n         callback.done(true);\n@@ -115,6 +117,7 @@ public void done(boolean doneSync) {\n \n                 // continue processing the try .. catch .. finally asynchronously\n                 while (continueRouting(processors, exchange)) {\n+                    exchange.setProperty(Exchange.TRY_ROUTE_BLOCK, true);\n                     ExchangeHelper.prepareOutToIn(exchange);\n \n                     // process the next processor\n@@ -130,6 +133,7 @@ public void done(boolean doneSync) {\n                 }\n \n                 ExchangeHelper.prepareOutToIn(exchange);\n+                exchange.removeProperty(Exchange.TRY_ROUTE_BLOCK);\n                 exchange.setProperty(Exchange.EXCEPTION_HANDLED, lastHandled);\n                 LOG.trace(\"Processing complete for exchangeId: {} >>> {}\", exchange.getExchangeId(), exchange);\n                 callback.done(false);\n",
        "project": "camel",
        "linesAdd": 8,
        "jira_id": "7275",
        "nb_skipped": 3,
        "commit": "44cad623",
        "nb_failure": 3,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4976,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.properties.PropertiesComponentConcatenatePropertiesTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/properties/DefaultPropertiesParser.java b/camel-core/src/main/java/org/apache/camel/component/properties/DefaultPropertiesParser.java\nindex f7bffa7274..1ee227af62 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/properties/DefaultPropertiesParser.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/properties/DefaultPropertiesParser.java\n@@ -16,19 +16,17 @@\n  */\n package org.apache.camel.component.properties;\n \n-import java.util.ArrayList;\n-import java.util.List;\n+import java.util.HashSet;\n import java.util.Properties;\n+import java.util.Set;\n \n-import org.apache.camel.util.ObjectHelper;\n-import org.apache.camel.util.StringHelper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static java.lang.String.format;\n+\n /**\n  * A parser to parse a string which contains property placeholders\n- *\n- * @version \n  */\n public class DefaultPropertiesParser implements AugmentedPropertyNameAwarePropertiesParser {\n     protected final Logger log = LoggerFactory.getLogger(getClass());\n@@ -38,167 +36,258 @@ public String parseUri(String text, Properties properties, String prefixToken, S\n         return parseUri(text, properties, prefixToken, suffixToken, null, null, false);\n     }\n \n-    public String parseUri(String text, Properties properties, String prefixToken, String suffixToken,\n-                           String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) throws IllegalArgumentException {\n-        String answer = text;\n-        boolean done = false;\n+    public String parseUri(String text, Properties properties, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix,\n+                           boolean fallbackToUnaugmentedProperty) throws IllegalArgumentException {\n+        ParsingContext context = new ParsingContext(properties, prefixToken, suffixToken, propertyPrefix, propertySuffix, fallbackToUnaugmentedProperty);\n+        return context.parse(text);\n+    }\n \n-        // the placeholders can contain nested placeholders so we need to do recursive parsing\n-        // we must therefore also do circular reference check and must keep a list of visited keys\n-        List<String> visited = new ArrayList<String>();\n-        while (!done) {\n-            List<String> replaced = new ArrayList<String>();\n-            answer = doParseUri(answer, properties, replaced, prefixToken, suffixToken, propertyPrefix, propertySuffix, fallbackToUnaugmentedProperty);\n+    public String parseProperty(String key, String value, Properties properties) {\n+        return value;\n+    }\n+\n+    /**\n+     * This inner class helps replacing properties.\n+     */\n+    private final class ParsingContext {\n+        private final Properties properties;\n+        private final String prefixToken;\n+        private final String suffixToken;\n+        private final String propertyPrefix;\n+        private final String propertySuffix;\n+        private final boolean fallbackToUnaugmentedProperty;\n+\n+        public ParsingContext(Properties properties, String prefixToken, String suffixToken, String propertyPrefix, String propertySuffix,\n+                              boolean fallbackToUnaugmentedProperty) {\n+            this.properties = properties;\n+            this.prefixToken = prefixToken;\n+            this.suffixToken = suffixToken;\n+            this.propertyPrefix = propertyPrefix;\n+            this.propertySuffix = propertySuffix;\n+            this.fallbackToUnaugmentedProperty = fallbackToUnaugmentedProperty;\n+        }\n \n-            // check the replaced with the visited to avoid circular reference\n-            for (String replace : replaced) {\n-                if (visited.contains(replace)) {\n-                    throw new IllegalArgumentException(\"Circular reference detected with key [\" + replace + \"] from text: \" + text);\n+        /**\n+         * Parses the given input string and replaces all properties\n+         *\n+         * @param input Input string\n+         * @return Evaluated string\n+         */\n+        public String parse(String input) {\n+            return doParse(input, new HashSet<String>());\n         }\n+\n+        /**\n+         * Recursively parses the given input string and replaces all properties\n+         *\n+         * @param input                Input string\n+         * @param replacedPropertyKeys Already replaced property keys used for tracking circular references\n+         * @return Evaluated string\n+         */\n+        private String doParse(String input, Set<String> replacedPropertyKeys) {\n+            String answer = input;\n+            Property property;\n+            while ((property = readProperty(answer)) != null) {\n+                // Check for circular references\n+                if (replacedPropertyKeys.contains(property.getKey())) {\n+                    throw new IllegalArgumentException(\"Circular reference detected with key [\" + property.getKey() + \"] from text: \" + input);\n                 }\n-            // okay all okay so add the replaced as visited\n-            visited.addAll(replaced);\n \n-            // we are done when we can no longer find any prefix tokens in the answer\n-            done = findTokenPosition(answer, 0, prefixToken) == -1;\n+                Set<String> newReplaced = new HashSet<String>(replacedPropertyKeys);\n+                newReplaced.add(property.getKey());\n+\n+                String before = answer.substring(0, property.getBeginIndex());\n+                String after = answer.substring(property.getEndIndex());\n+                answer = before + doParse(property.getValue(), newReplaced) + after;\n             }\n             return answer;\n         }\n \n-    public String parseProperty(String key, String value, Properties properties) {\n-        return value;\n+        /**\n+         * Finds a property in the given string. It returns {@code null} if there's no property defined.\n+         *\n+         * @param input Input string\n+         * @return A property in the given string or {@code null} if not found\n+         */\n+        private Property readProperty(String input) {\n+            // Find the index of the first valid suffix token\n+            int suffix = getSuffixIndex(input);\n+\n+            // If not found, ensure that there is no valid prefix token in the string\n+            if (suffix == -1) {\n+                if (getMatchingPrefixIndex(input, input.length()) != -1) {\n+                    throw new IllegalArgumentException(format(\"Missing %s from the text: %s\", suffixToken, input));\n+                }\n+                return null;\n             }\n \n-    private String doParseUri(String uri, Properties properties, List<String> replaced, String prefixToken, String suffixToken,\n-                              String propertyPrefix, String propertySuffix, boolean fallbackToUnaugmentedProperty) {\n-        StringBuilder sb = new StringBuilder();\n+            // Find the index of the prefix token that matches the suffix token\n+            int prefix = getMatchingPrefixIndex(input, suffix);\n+            if (prefix == -1) {\n+                throw new IllegalArgumentException(format(\"Missing %s from the text: %s\", prefixToken, input));\n+            }\n \n-        int pivot = 0;\n-        int size = uri.length();\n-        while (pivot < size) {\n-            int idx = findTokenPosition(uri, pivot, prefixToken);\n-            if (idx < 0) {\n-                sb.append(createConstantPart(uri, pivot, size));\n-                break;\n-            } else {\n-                if (pivot < idx) {\n-                    sb.append(createConstantPart(uri, pivot, idx));\n+            String key = input.substring(prefix + prefixToken.length(), suffix);\n+            String value = getPropertyValue(key, input);\n+            return new Property(prefix, suffix + suffixToken.length(), key, value);\n         }\n-                pivot = idx + prefixToken.length();\n-                int endIdx = findTokenPosition(uri, pivot, suffixToken);\n-                if (endIdx < 0) {\n-                    throw new IllegalArgumentException(\"Expecting \" + suffixToken + \" but found end of string from text: \" + uri);\n+\n+        /**\n+         * Gets the first index of the suffix token that is not surrounded by quotes\n+         *\n+         * @param input Input string\n+         * @return First index of the suffix token that is not surrounded by quotes\n+         */\n+        private int getSuffixIndex(String input) {\n+            int index = -1;\n+            do {\n+                index = input.indexOf(suffixToken, index + 1);\n+            } while (index != -1 && isQuoted(input, index, suffixToken));\n+            return index;\n         }\n-                String key = uri.substring(pivot, endIdx);\n-                String augmentedKey = key;\n \n-                if (propertyPrefix != null) {\n-                    log.debug(\"Augmenting property key [{}] with prefix: {}\", key, propertyPrefix);\n-                    augmentedKey = propertyPrefix + augmentedKey;\n+        /**\n+         * Gets the index of the prefix token that matches the suffix at the given index and that is not surrounded by quotes\n+         *\n+         * @param input       Input string\n+         * @param suffixIndex Index of the suffix token\n+         * @return Index of the prefix token that matches the suffix at the given index and that is not surrounded by quotes\n+         */\n+        private int getMatchingPrefixIndex(String input, int suffixIndex) {\n+            int index = suffixIndex;\n+            do {\n+                index = input.lastIndexOf(prefixToken, index - 1);\n+            } while (index != -1 && isQuoted(input, index, prefixToken));\n+            return index;\n         }\n \n-                if (propertySuffix != null) {\n-                    log.debug(\"Augmenting property key [{}] with suffix: {}\", key, propertySuffix);\n-                    augmentedKey = augmentedKey + propertySuffix;\n+        /**\n+         * Indicates whether or not the token at the given index is surrounded by single or double quotes\n+         *\n+         * @param input Input string\n+         * @param index Index of the token\n+         * @param token Token\n+         * @return {@code true}\n+         */\n+        private boolean isQuoted(String input, int index, String token) {\n+            int beforeIndex = index - 1;\n+            int afterIndex = index + token.length();\n+            if (beforeIndex >= 0 && afterIndex < input.length()) {\n+                char before = input.charAt(beforeIndex);\n+                char after = input.charAt(afterIndex);\n+                return (before == after) && (before == '\\'' || before == '\"');\n+            }\n+            return false;\n         }\n \n-                String part = createPlaceholderPart(augmentedKey, properties, replaced, prefixToken, suffixToken);\n+        /**\n+         * Gets the value of the property with given key\n+         *\n+         * @param key   Key of the property\n+         * @param input Input string (used for exception message if value not found)\n+         * @return Value of the property with the given key\n+         */\n+        private String getPropertyValue(String key, String input) {\n+            String augmentedKey = getAugmentedKey(key);\n+            boolean shouldFallback = fallbackToUnaugmentedProperty && !key.equals(augmentedKey);\n \n-                // Note: Only fallback to unaugmented when the original key was actually augmented\n-                if (part == null && fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {\n-                    log.debug(\"Property wth key [{}] not found, attempting with unaugmented key: {}\", augmentedKey, key);\n-                    part = createPlaceholderPart(key, properties, replaced, prefixToken, suffixToken);\n+            String value = doGetPropertyValue(augmentedKey);\n+            if (value == null && shouldFallback) {\n+                log.debug(\"Property with key [{}] not found, attempting with unaugmented key: {}\", augmentedKey, key);\n+                value = doGetPropertyValue(key);\n             }\n \n-                if (part == null) {\n+            if (value == null) {\n                 StringBuilder esb = new StringBuilder();\n                 esb.append(\"Property with key [\").append(augmentedKey).append(\"] \");\n-                    if (fallbackToUnaugmentedProperty && (propertyPrefix != null || propertySuffix != null)) {\n+                if (shouldFallback) {\n                     esb.append(\"(and original key [\").append(key).append(\"]) \");\n                 }\n-                    esb.append(\"not found in properties from text: \").append(uri);\n+                esb.append(\"not found in properties from text: \").append(input);\n                 throw new IllegalArgumentException(esb.toString());\n             }\n-                sb.append(part);\n-                pivot = endIdx + suffixToken.length();\n-            }\n-        }\n-        return sb.toString();\n-    }\n \n-    private int findTokenPosition(String uri, int pivot, String token) {\n-        int idx = uri.indexOf(token, pivot);\n-        while (idx > 0) {\n-            // grab part as the previous char + token + next char, to test if the token is quoted\n-            String part = null;\n-            int len = idx + token.length() + 1;\n-            if (uri.length() >= len) {\n-                part = uri.substring(idx - 1, len);\n+            return value;\n         }\n-            if (StringHelper.isQuoted(part)) {\n-                // the token was quoted, so regard it as a literal\n-                // and then try to find from next position\n-                pivot = idx + token.length() + 1;\n-                idx = uri.indexOf(token, pivot);\n-            } else {\n-                // found token\n-                return idx;\n+\n+        /**\n+         * Gets the augmented key of the given base key\n+         *\n+         * @param key Base key\n+         * @return Augmented key\n+         */\n+        private String getAugmentedKey(String key) {\n+            String augmentedKey = key;\n+            if (propertyPrefix != null) {\n+                log.debug(\"Augmenting property key [{}] with prefix: {}\", key, propertyPrefix);\n+                augmentedKey = propertyPrefix + augmentedKey;\n             }\n+            if (propertySuffix != null) {\n+                log.debug(\"Augmenting property key [{}] with suffix: {}\", key, propertySuffix);\n+                augmentedKey = augmentedKey + propertySuffix;\n             }\n-        return idx;\n+            return augmentedKey;\n         }\n \n-    private boolean isNestProperty(String uri, String prefixToken, String suffixToken) {\n-        if (ObjectHelper.isNotEmpty(uri)) {\n-            uri = uri.trim();\n-            if (uri.startsWith(prefixToken) && uri.endsWith(suffixToken)) {\n-                return true;\n+        /**\n+         * Gets the property with the given key, it returns {@code null} if the property is not found\n+         *\n+         * @param key Key of the property\n+         * @return Value of the property or {@code null} if not found\n+         */\n+        private String doGetPropertyValue(String key) {\n+            String value = System.getProperty(key);\n+            if (value != null) {\n+                log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, value);\n+            } else if (properties != null) {\n+                value = properties.getProperty(key);\n             }\n+            return value;\n         }\n-        return false;\n     }\n \n-    private String takeOffNestTokes(String uri, String prefixToken, String suffixToken) {\n-        int start = prefixToken.length(); \n-        int end = uri.length() - suffixToken.length();\n-        return uri.substring(start, end); \n-    }\n+    /**\n+     * This inner class is the definition of a property used in a string\n+     */\n+    private static final class Property {\n+        private final int beginIndex;\n+        private final int endIndex;\n+        private final String key;\n+        private final String value;\n \n-    private String createConstantPart(String uri, int start, int end) {\n-        return uri.substring(start, end);\n+        private Property(int beginIndex, int endIndex, String key, String value) {\n+            this.beginIndex = beginIndex;\n+            this.endIndex = endIndex;\n+            this.key = key;\n+            this.value = value;\n         }\n \n-    private String createPlaceholderPart(String key, Properties properties, List<String> replaced, String prefixToken, String suffixToken) {\n-        // keep track of which parts we have replaced\n-        replaced.add(key);\n-        \n-        String propertyValue = System.getProperty(key);\n-        if (propertyValue != null) {\n-            log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\n-        } else if (properties != null) {\n-            propertyValue = properties.getProperty(key);\n-        }\n-        \n-        // we need to check if the propertyValue is nested\n-        // we need to check if there is cycle dependency of the nested properties\n-        List<String> visited = new ArrayList<String>();\n-        while (isNestProperty(propertyValue, prefixToken, suffixToken)) {\n-            visited.add(key);\n-            // need to take off the token first\n-            String value = takeOffNestTokes(propertyValue, prefixToken, suffixToken);\n-            key = parseUri(value, properties, prefixToken, suffixToken);\n-            if (visited.contains(key)) {\n-                throw new IllegalArgumentException(\"Circular reference detected with key [\" + key + \"] from text: \" + propertyValue);\n-            }\n-            propertyValue = System.getProperty(key);\n-            if (propertyValue != null) {\n-                log.debug(\"Found a JVM system property: {} with value: {} to be used.\", key, propertyValue);\n-            } else if (properties != null) {\n-                propertyValue = properties.getProperty(key);\n+        /**\n+         * Gets the begin index of the property (including the prefix token).\n+         */\n+        public int getBeginIndex() {\n+            return beginIndex;\n         }\n+\n+        /**\n+         * Gets the end index of the property (including the suffix token).\n+         */\n+        public int getEndIndex() {\n+            return endIndex;\n         }\n \n-        return parseProperty(key, propertyValue, properties);\n+        /**\n+         * Gets the key of the property.\n+         */\n+        public String getKey() {\n+            return key;\n         }\n \n+        /**\n+         * Gets the value of the property.\n+         */\n+        public String getValue() {\n+            return value;\n+        }\n+    }\n }\n",
        "project": "camel",
        "linesAdd": 131,
        "jira_id": "7429",
        "nb_skipped": 3,
        "commit": "43956f93",
        "nb_failure": 0,
        "linesRem": 107,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5297,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.management.ManagedInflightStatisticsTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRoute.java b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRoute.java\nindex d31e4e551c..c4b6d85d67 100644\n--- a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRoute.java\n+++ b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRoute.java\n@@ -417,8 +417,8 @@ public String getOldestInflightExchangeId() {\n \n     @Override\n     public void init(ManagementStrategy strategy) {\n-        super.init(strategy);\n         exchangesInFlightStartTimestamps.clear();\n+        super.init(strategy);\n     }\n \n     @Override\n@@ -438,14 +438,23 @@ public synchronized void completedExchange(Exchange exchange, long time) {\n         super.completedExchange(exchange, time);\n     }\n \n+    @Override\n+    public synchronized void failedExchange(Exchange exchange) {\n+        InFlightKey key = exchangesInFlightKeys.remove(exchange.getExchangeId());\n+        if (key != null) {\n+            exchangesInFlightStartTimestamps.remove(key);\n+        }\n+        super.failedExchange(exchange);\n+    }\n+\n     private static class InFlightKey implements Comparable<InFlightKey> {\n \n         private final Long timeStamp;\n         private final String exchangeId;\n \n         InFlightKey(Long timeStamp, String exchangeId) {\n-            this.exchangeId = exchangeId;\n             this.timeStamp = timeStamp;\n+            this.exchangeId = exchangeId;\n         }\n \n         @Override\n",
        "project": "camel",
        "linesAdd": 11,
        "jira_id": "8626",
        "nb_skipped": 4,
        "commit": "d063f471",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 4,
        "nb_test": 5161,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.aggregator.AggregateTimeoutTest",
            "org.apache.camel.impl.CamelPostProcessorHelperTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/CamelPostProcessorHelper.java b/camel-core/src/main/java/org/apache/camel/impl/CamelPostProcessorHelper.java\nindex 04dbc4d4f7..817a2f969c 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/CamelPostProcessorHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/CamelPostProcessorHelper.java\n@@ -22,6 +22,7 @@\n \n import org.apache.camel.CamelContext;\n import org.apache.camel.CamelContextAware;\n+import org.apache.camel.Component;\n import org.apache.camel.Consume;\n import org.apache.camel.Consumer;\n import org.apache.camel.ConsumerTemplate;\n@@ -37,7 +38,6 @@\n import org.apache.camel.component.bean.BeanInfo;\n import org.apache.camel.component.bean.BeanProcessor;\n import org.apache.camel.component.bean.ProxyHelper;\n-import org.apache.camel.component.properties.PropertiesComponent;\n import org.apache.camel.processor.CamelInternalProcessor;\n import org.apache.camel.processor.UnitOfWorkProducer;\n import org.apache.camel.util.CamelContextHelper;\n@@ -227,17 +227,13 @@ public Object getInjectionValue(Class<?> type, String endpointUri, String endpoi\n     public Object getInjectionPropertyValue(Class<?> type, String propertyName, String propertyDefaultValue,\n                                             String injectionPointName, Object bean, String beanName) {\n         try {\n+            // enforce a properties component to be created if none existed\n+            CamelContextHelper.lookupPropertiesComponent(getCamelContext(), true);\n+\n             String key;\n             String prefix = getCamelContext().getPropertyPrefixToken();\n             String suffix = getCamelContext().getPropertySuffixToken();\n-\n-            if (prefix == null && suffix == null) {\n-                // if no custom prefix/suffix then use defaults\n-                prefix = PropertiesComponent.DEFAULT_PREFIX_TOKEN;\n-                suffix = PropertiesComponent.DEFAULT_SUFFIX_TOKEN;\n-            }\n-\n-            if (!propertyName.startsWith(prefix)) {\n+            if (!propertyName.contains(prefix)) {\n                 // must enclose the property name with prefix/suffix to have it resolved\n                 key = prefix + propertyName + suffix;\n             } else {\ndiff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\nindex 256fc8cb7b..7eb7fe6285 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n@@ -1458,23 +1457,8 @@ public String resolvePropertyPlaceholders(String text) throws Exception {\n         if (text != null && !text.startsWith(\"properties:\")) {\n             // No component, assume default tokens.\n             if (pc == null && text.contains(PropertiesComponent.DEFAULT_PREFIX_TOKEN)) {\n-\n-                // try to lookup component, as we may be initializing CamelContext itself\n-                Component existing = lookupPropertiesComponent();\n-                if (existing != null) {\n-                    if (existing instanceof PropertiesComponent) {\n-                        pc = (PropertiesComponent) existing;\n-                    } else {\n-                        // properties component must be expected type\n-                        throw new IllegalArgumentException(\"Found properties component of type: \" + existing.getClass() + \" instead of expected: \" + PropertiesComponent.class);\n-                    }\n-                }\n-\n-                if (pc == null) {\n-                    // create a default properties component to be used as there may be default values we can use\n-                    log.info(\"No existing PropertiesComponent has been configured, creating a new default PropertiesComponent with name: properties\");\n-                    pc = getComponent(\"properties\", PropertiesComponent.class);\n-                }\n+                // lookup existing properties component, or force create a new default component\n+                pc = (PropertiesComponent) CamelContextHelper.lookupPropertiesComponent(this, true);\n             }\n \n             if (pc != null && text.contains(pc.getPrefixToken())) {\n@@ -2111,7 +2095,7 @@ private void doStartCamel() throws Exception {\n \n         // eager lookup any configured properties component to avoid subsequent lookup attempts which may impact performance\n         // due we use properties component for property placeholder resolution at runtime\n-        Component existing = lookupPropertiesComponent();\n+        Component existing = CamelContextHelper.lookupPropertiesComponent(this, false);\n         if (existing != null) {\n             // store reference to the existing properties component\n             if (existing instanceof PropertiesComponent) {\n@@ -3075,16 +3059,12 @@ public DataFormatDefinition resolveDataFormatDefinition(String name) {\n         }\n     }\n \n+    /**\n+     * @deprecated use {@link org.apache.camel.util.CamelContextHelper#lookupPropertiesComponent(org.apache.camel.CamelContext, boolean)}\n+     */\n+    @Deprecated\n     protected Component lookupPropertiesComponent() {\n-        // no existing properties component so lookup and add as component if possible\n-        PropertiesComponent answer = (PropertiesComponent) hasComponent(\"properties\");\n-        if (answer == null) {\n-            answer = getRegistry().lookupByNameAndType(\"properties\", PropertiesComponent.class);\n-            if (answer != null) {\n-                addComponent(\"properties\", answer);\n-            }\n-        }\n-        return answer;\n+        return CamelContextHelper.lookupPropertiesComponent(this, false);\n     }\n \n     public ShutdownStrategy getShutdownStrategy() {\ndiff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinitionHelper.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinitionHelper.java\nindex 87689a312f..5ba236b5d1 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinitionHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinitionHelper.java\n@@ -31,6 +31,7 @@\n import org.apache.camel.Exchange;\n import org.apache.camel.spi.ExecutorServiceManager;\n import org.apache.camel.spi.RouteContext;\n+import org.apache.camel.util.CamelContextHelper;\n import org.apache.camel.util.IntrospectionSupport;\n import org.apache.camel.util.ObjectHelper;\n import org.slf4j.Logger;\n@@ -524,6 +525,9 @@ public static void resolvePropertyPlaceholders(RouteContext routeContext, Object\n                     String local = key.getLocalPart();\n                     Object value = processorDefinition.getOtherAttributes().get(key);\n                     if (value != null && value instanceof String) {\n+                        // enforce a properties component to be created if none existed\n+                        CamelContextHelper.lookupPropertiesComponent(routeContext.getCamelContext(), true);\n+\n                         // value must be enclosed with placeholder tokens\n                         String s = (String) value;\n                         String prefixToken = routeContext.getCamelContext().getPropertyPrefixToken();\ndiff --git a/camel-core/src/main/java/org/apache/camel/util/CamelContextHelper.java b/camel-core/src/main/java/org/apache/camel/util/CamelContextHelper.java\nindex ab829f6166..097ed29e76 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/CamelContextHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/CamelContextHelper.java\n@@ -35,6 +35,7 @@\n import org.apache.camel.Exchange;\n import org.apache.camel.NoSuchBeanException;\n import org.apache.camel.NoSuchEndpointException;\n+import org.apache.camel.component.properties.PropertiesComponent;\n import org.apache.camel.spi.ClassResolver;\n import org.apache.camel.spi.RouteStartupOrder;\n import org.slf4j.Logger;\n@@ -477,4 +478,30 @@ public static int getRouteStartupOrder(CamelContext camelContext, String routeId\n         return 0;\n     }\n \n+    /**\n+     * Lookup the {@link org.apache.camel.component.properties.PropertiesComponent} from the {@link org.apache.camel.CamelContext}.\n+     * <p/>\n+     * @param camelContext the camel context\n+     * @param autoCreate whether to automatic create a new default {@link org.apache.camel.component.properties.PropertiesComponent} if no custom component\n+     *                   has been configured.\n+     * @return the properties component, or <tt>null</tt> if none has been defined, and auto create is <tt>false</tt>.\n+     */\n+    public static Component lookupPropertiesComponent(CamelContext camelContext, boolean autoCreate) {\n+        // no existing properties component so lookup and add as component if possible\n+        PropertiesComponent answer = (PropertiesComponent) camelContext.hasComponent(\"properties\");\n+        if (answer == null) {\n+            answer = camelContext.getRegistry().lookupByNameAndType(\"properties\", PropertiesComponent.class);\n+            if (answer != null) {\n+                camelContext.addComponent(\"properties\", answer);\n+            }\n+        }\n+        if (answer == null && autoCreate) {\n+            // create a default properties component to be used as there may be default values we can use\n+            LOG.info(\"No existing PropertiesComponent has been configured, creating a new default PropertiesComponent with name: properties\");\n+            answer = camelContext.getComponent(\"properties\", PropertiesComponent.class);\n+        }\n+        return answer;\n+    }\n+\n+\n }\n",
        "project": "camel",
        "linesAdd": 28,
        "jira_id": "8125",
        "nb_skipped": 4,
        "commit": "36e7b668",
        "nb_failure": 1,
        "linesRem": 31,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3826,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.impl.LifecycleStrategyServiceTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\nindex c5dbd5ccc2..ee33f8ef14 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n@@ -1415,6 +1415,7 @@ private void doStartCamel() throws Exception {\n         getManagementStrategy().start();\n \n         // start lifecycle strategies\n+        ServiceHelper.startServices(lifecycleStrategies);\n         Iterator<LifecycleStrategy> it = lifecycleStrategies.iterator();\n         while (it.hasNext()) {\n             LifecycleStrategy strategy = it.next();\n@@ -1526,6 +1527,8 @@ protected synchronized void doStop() throws Exception {\n \n         // shutdown management as the last one\n         shutdownServices(managementStrategy);\n+        shutdownServices(lifecycleStrategies);\n+        lifecycleStrategies.clear();\n \n         // stop the lazy created so they can be re-created on restart\n         forceStopLazyInitialization();\n",
        "project": "camel",
        "linesAdd": 3,
        "jira_id": "4467",
        "nb_skipped": 0,
        "commit": "79168a23",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4910,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.MulticastGroupedExchangeExceptionTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/GroupedExchangeAggregationStrategy.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/GroupedExchangeAggregationStrategy.java\nindex 84b375dd78..2906270d68 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/GroupedExchangeAggregationStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/GroupedExchangeAggregationStrategy.java\n@@ -19,6 +19,7 @@\n import java.util.List;\n \n import org.apache.camel.Exchange;\n+import org.apache.camel.impl.DefaultExchange;\n \n /**\n  * Aggregate all exchanges into a single combined Exchange holding all the aggregated exchanges\n@@ -43,13 +43,12 @@ public void onCompletion(Exchange exchange) {\n \n     @Override\n     public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\n-        Exchange answer = super.aggregate(oldExchange, newExchange);\n         if (oldExchange == null) {\n-            // for the first time we must do a copy as the answer, so the outgoing\n-            // exchange is not one of the grouped exchanges, as that causes a endless circular reference\n-            answer = answer.copy();\n+            // for the first time we must create a new empty exchange as the holder, as the outgoing exchange\n+            // must not be one of the grouped exchanges, as that causes a endless circular reference\n+            oldExchange = new DefaultExchange(newExchange);\n         }\n-        return answer;\n+        return super.aggregate(oldExchange, newExchange);\n     }\n \n     @Override\n",
        "project": "camel",
        "linesAdd": 3,
        "jira_id": "7271",
        "nb_skipped": 3,
        "commit": "a5a2f750",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4792,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.xslt.XsltDTDTest",
            "org.apache.camel.management.ManagedThrottlerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/xml/XsltBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/xml/XsltBuilder.java\nindex 3a7b9a4fff..d4291b2361 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/xml/XsltBuilder.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/xml/XsltBuilder.java\n@@ -452,9 +452,6 @@ protected Source getSource(Exchange exchange, Object body) {\n             return (Source) body;\n         }\n         Source source = null;\n-        if (body instanceof InputStream) {\n-            return new StreamSource((InputStream)body);\n-        }\n         if (body != null) {\n             if (isAllowStAX()) {\n                 source = exchange.getContext().getTypeConverter().tryConvertTo(StAXSource.class, exchange, body);\n",
        "project": "camel",
        "linesAdd": 0,
        "jira_id": "7130",
        "nb_skipped": 2,
        "commit": "cc192f87",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5103,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.IdempotentConsumerNoMessageIdTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentConsumer.java b/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentConsumer.java\nindex 100a660ead..d3afe7a732 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentConsumer.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentConsumer.java\n@@ -80,7 +80,9 @@ public void process(Exchange exchange) throws Exception {\n     public boolean process(Exchange exchange, AsyncCallback callback) {\n         final String messageId = messageIdExpression.evaluate(exchange, String.class);\n         if (messageId == null) {\n-            throw new NoMessageIdException(exchange, messageIdExpression);\n+            exchange.setException(new NoMessageIdException(exchange, messageIdExpression));\n+            callback.done(true);\n+            return true;\n         }\n \n         boolean newKey;\n",
        "project": "camel",
        "linesAdd": 3,
        "jira_id": "7990",
        "nb_skipped": 3,
        "commit": "d581c4a4",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3743,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.LogEipPropagateExceptionTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/LogProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/LogProcessor.java\nindex 94a4246caf..ced8977ea8 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/LogProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/LogProcessor.java\n@@ -43,8 +43,15 @@ public void process(Exchange exchange) throws Exception {\n \n     @Override\n     public boolean process(Exchange exchange, AsyncCallback callback) {\n+        try {\n             String msg = expression.evaluate(exchange, String.class);\n             logger.log(msg);\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+        } finally {\n+            // callback must be invoked\n+            callback.done(true);\n+        }\n         return true;\n     }\n \n",
        "project": "camel",
        "linesAdd": 6,
        "jira_id": "4388",
        "nb_skipped": 0,
        "commit": "f39bc60d",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3006,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.impl.DefaultCamelContextTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\nindex 751e35b48c..545444243a 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.camel.impl;\n \n+import static java.lang.String.format;\n+\n import java.io.IOException;\n import java.io.InputStream;\n import java.util.ArrayList;\n@@ -465,7 +467,9 @@ public Endpoint getEndpoint(String uri) {\n \n     public <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType) {\n         Endpoint endpoint = getEndpoint(name);\n-\n+        if(endpoint == null){\n+        \tthrow new IllegalArgumentException(\"No endpoint found with name: \" + name);\n+        }\n         if (endpoint instanceof InterceptSendToEndpoint) {\n             endpoint = ((InterceptSendToEndpoint) endpoint).getDelegate();\n         }\n",
        "project": "camel",
        "linesAdd": 5,
        "jira_id": "3428",
        "nb_skipped": 0,
        "commit": "320545cd",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2911,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.vm.VmWaitForTaskCompleteTest",
            "org.apache.camel.component.seda.SedaWaitForTaskCompleteTest",
            "org.apache.camel.issues.MulticastPipelineAggregateIssueTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java b/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\nindex 0aa9501..7b59811 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\n@@ -208,11 +208,15 @@ public static void copyResults(Exchange result, Exchange source) {\n                 // have created any OUT; such as a mock:endpoint\n                 // so lets assume the last IN is the OUT\n                 if (result.getPattern().isOutCapable()) {\n-                    // only set OUT if its OUT capable\n+                    // only set OUT if its OUT capable or already has OUT\n                     result.getOut().copyFrom(source.getIn());\n                 } else {\n                     // if not replace IN instead to keep the MEP\n                     result.getIn().copyFrom(source.getIn());\n+                    // clear any existing OUT as the result is on the IN\n+                    if (result.hasOut()) {\n+                        result.setOut(null);\n+                    }\n                 }\n             }\n \n",
        "project": "camel",
        "linesAdd": 3,
        "jira_id": "3276",
        "nb_skipped": 0,
        "commit": "205420e2",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4152,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.language.simple.SimpleTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\nindex 43f40f57a8..4a8ddef91a 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n@@ -71,6 +71,7 @@\n     // shared state with details of operations introspected from the bean, created during the constructor\n     private Map<String, List<MethodInfo>> operations = new HashMap<String, List<MethodInfo>>();\n     private List<MethodInfo> operationsWithBody = new ArrayList<MethodInfo>();\n+    private List<MethodInfo> operationsWithNoBody = new ArrayList<MethodInfo>();\n     private List<MethodInfo> operationsWithCustomAnnotation = new ArrayList<MethodInfo>();\n     private List<MethodInfo> operationsWithHandlerAnnotation = new ArrayList<MethodInfo>();\n     private Map<Method, MethodInfo> methodMap = new HashMap<Method, MethodInfo>();\n@@ -130,6 +131,7 @@ public BeanInfo(CamelContext camelContext, Class<?> type, Method explicitMethod,\n         // to keep this code thread safe\n         operations = Collections.unmodifiableMap(operations);\n         operationsWithBody = Collections.unmodifiableList(operationsWithBody);\n+        operationsWithNoBody = Collections.unmodifiableList(operationsWithNoBody);\n         operationsWithCustomAnnotation = Collections.unmodifiableList(operationsWithCustomAnnotation);\n         operationsWithHandlerAnnotation = Collections.unmodifiableList(operationsWithHandlerAnnotation);\n         methodMap = Collections.unmodifiableMap(methodMap);\n@@ -311,6 +313,8 @@ private MethodInfo introspect(Class<?> clazz, Method method) {\n             operationsWithCustomAnnotation.add(methodInfo);\n         } else if (methodInfo.hasBodyParameter()) {\n             operationsWithBody.add(methodInfo);\n+        } else {\n+            operationsWithNoBody.add(methodInfo);\n         }\n \n         if (methodInfo.hasHandlerAnnotation()) {\n@@ -442,6 +446,7 @@ protected MethodInfo chooseMethod(Object pojo, Exchange exchange, String name) t\n         // must use defensive copy, to avoid altering the shared lists\n         // and we want to remove unwanted operations from these local lists\n         final List<MethodInfo> localOperationsWithBody = new ArrayList<MethodInfo>(operationsWithBody);\n+        final List<MethodInfo> localOperationsWithNoBody = new ArrayList<MethodInfo>(operationsWithNoBody);\n         final List<MethodInfo> localOperationsWithCustomAnnotation = new ArrayList<MethodInfo>(operationsWithCustomAnnotation);\n         final List<MethodInfo> localOperationsWithHandlerAnnotation = new ArrayList<MethodInfo>(operationsWithHandlerAnnotation);\n \n@@ -450,11 +455,13 @@ protected MethodInfo chooseMethod(Object pojo, Exchange exchange, String name) t\n             removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name);\n             removeNonMatchingMethods(localOperationsWithCustomAnnotation, name);\n             removeNonMatchingMethods(localOperationsWithBody, name);\n+            removeNonMatchingMethods(localOperationsWithNoBody, name);\n         } else {\n             // remove all getter/setter as we do not want to consider these methods\n             removeAllSetterOrGetterMethods(localOperationsWithHandlerAnnotation);\n             removeAllSetterOrGetterMethods(localOperationsWithCustomAnnotation);\n             removeAllSetterOrGetterMethods(localOperationsWithBody);\n+            removeAllSetterOrGetterMethods(localOperationsWithNoBody);\n         }\n \n         if (localOperationsWithHandlerAnnotation.size() > 1) {\n@@ -468,6 +475,13 @@ protected MethodInfo chooseMethod(Object pojo, Exchange exchange, String name) t\n         } else if (localOperationsWithCustomAnnotation.size() == 1) {\n             // if there is one method with an annotation then use that one\n             return localOperationsWithCustomAnnotation.get(0);\n+        }\n+\n+        // named method and with no parameters\n+        boolean noParameters = name != null && name.endsWith(\"()\");\n+        if (noParameters && localOperationsWithNoBody.size() == 1) {\n+            // if there was a method name configured and it has no parameters, then use the method with no body (eg no parameters)\n+            return localOperationsWithNoBody.get(0);\n         } else if (localOperationsWithBody.size() == 1) {\n             // if there is one method with body then use that one\n             return localOperationsWithBody.get(0);\n",
        "project": "camel",
        "linesAdd": 12,
        "jira_id": "5154",
        "nb_skipped": 0,
        "commit": "a8586a69",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4699,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.vm.VmMultipleConsumersRemoteRouteTest",
            "org.apache.camel.component.bean.BeanWithExpressionInjectionPredicateTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/DefaultAnnotationExpressionFactory.java b/camel-core/src/main/java/org/apache/camel/component/bean/DefaultAnnotationExpressionFactory.java\nindex 1038cdfbeb..cf961c3ba4 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/DefaultAnnotationExpressionFactory.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/DefaultAnnotationExpressionFactory.java\n@@ -21,9 +21,11 @@\n \n import org.apache.camel.CamelContext;\n import org.apache.camel.Expression;\n+import org.apache.camel.Predicate;\n import org.apache.camel.language.LanguageAnnotation;\n import org.apache.camel.spi.Language;\n import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.PredicateToExpressionAdapter;\n \n /**\n  * Default implementation of the {@link AnnotationExpressionFactory}.\n@@ -42,8 +44,14 @@ public Expression createExpression(CamelContext camelContext, Annotation annotat\n             throw new IllegalArgumentException(\"Cannot find the language: \" + languageName + \" on the classpath\");\n         }\n         String expression = getExpressionFromAnnotation(annotation);\n+\n+        if (expressionReturnType == Boolean.class || expressionReturnType == boolean.class) {\n+            Predicate predicate = language.createPredicate(expression);\n+            return PredicateToExpressionAdapter.toExpression(predicate);\n+        } else {\n             return language.createExpression(expression);\n         }\n+    }\n \n     protected String getExpressionFromAnnotation(Annotation annotation) {\n         Object value = getAnnotationObjectValue(annotation, \"value\");\n",
        "project": "camel",
        "linesAdd": 8,
        "jira_id": "6743",
        "nb_skipped": 1,
        "commit": "745a85ab",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3323,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.converter.ObjectHelperTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/util/ObjectHelper.java b/camel-core/src/main/java/org/apache/camel/util/ObjectHelper.java\nindex 6bb393d322..636c4a8b90 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/ObjectHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/ObjectHelper.java\n@@ -38,6 +38,7 @@\n import java.util.Properties;\n import java.util.Scanner;\n \n+import org.w3c.dom.Document;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n \n@@ -1118,6 +1119,14 @@ public static boolean evaluateValuePredicate(Object value) {\n             } else if (\"false\".equalsIgnoreCase((String)value)) {\n                 return false;\n             }\n+        } else if (value instanceof NodeList) {\n+            // is it an empty dom\n+            NodeList list = (NodeList) value;\n+            return list.getLength() > 0;\n+        } else if (value instanceof Collection) {\n+            // is it an empty collection\n+            Collection col = (Collection) value;\n+            return col.size() > 0;\n         }\n         return value != null;\n     }\n",
        "project": "camel",
        "linesAdd": 7,
        "jira_id": "3531",
        "nb_skipped": 0,
        "commit": "41e4b5b9",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4720,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.aggregator.AggregateTimeoutTest",
            "org.apache.camel.component.bean.BeanWithInputStreamBodyTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java\nindex a4dd2e075c..0c22e75041 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java\n@@ -393,8 +393,6 @@ public boolean isStaticMethod() {\n     /**\n      * Returns true if this method is covariant with the specified method\n      * (this method may above or below the specified method in the class hierarchy)\n-     * @param method\n-     * @return\n      */\n     public boolean isCovariantWith(MethodInfo method) {\n         return \n@@ -541,14 +539,19 @@ private Object evaluateParameterValue(Exchange exchange, int index, Object param\n                         return Void.TYPE;\n                     }\n \n+                    // the parameter value may match the expected type, then we use it as-is\n+                    if (parameterType.isAssignableFrom(parameterValue.getClass())) {\n+                        valid = true;\n+                    } else {\n                         // the parameter value was not already valid, but since the simple language have evaluated the expression\n                         // which may change the parameterValue, so we have to check it again to see if its now valid\n-                    exp = exchange.getContext().getTypeConverter().convertTo(String.class, parameterValue);\n+                        exp = exchange.getContext().getTypeConverter().tryConvertTo(String.class, parameterValue);\n                         // String values from the simple language is always valid\n                         if (!valid) {\n                             // re validate if the parameter was not valid the first time (String values should be accepted)\n                             valid = parameterValue instanceof String || BeanHelper.isValidParameterValue(exp);\n                         }\n+                    }\n \n                     if (valid) {\n                         // we need to unquote String parameters, as the enclosing quotes is there to denote a parameter value\n",
        "project": "camel",
        "linesAdd": 5,
        "jira_id": "6810",
        "nb_skipped": 1,
        "commit": "6b210169",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5103,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.vm.VmMultipleConsumersRemoteRouteTest",
            "org.apache.camel.processor.CircuitBreakerLoadBalancerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/loadbalancer/CircuitBreakerLoadBalancer.java b/camel-core/src/main/java/org/apache/camel/processor/loadbalancer/CircuitBreakerLoadBalancer.java\nindex b8e23b4b9e..3e84e6efc4 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/loadbalancer/CircuitBreakerLoadBalancer.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/loadbalancer/CircuitBreakerLoadBalancer.java\n@@ -107,6 +107,13 @@ public boolean process(final Exchange exchange, final AsyncCallback callback) {\n \n         if (failures.get() >= threshold && System.currentTimeMillis() - lastFailure < halfOpenAfter) {\n             exchange.setException(new RejectedExecutionException(\"CircuitBreaker Open: failures: \" + failures + \", lastFailure: \" + lastFailure));\n+            /*\n+             * If the circuit opens, we have to prevent the execution of any processor.\n+             * The failures count can be set to 0.\n+             */\n+            failures.set(0);\n+            callback.done(true);\n+            return true;\n         }\n         Processor processor = getProcessors().get(0);\n         if (processor == null) {\n@@ -114,18 +121,20 @@ public boolean process(final Exchange exchange, final AsyncCallback callback) {\n         }\n \n         AsyncProcessor albp = AsyncProcessorConverterHelper.convert(processor);\n-        boolean sync = albp.process(exchange, callback);\n+        // Added a callback for processing the exchange in the callback\n+        boolean sync = albp.process(exchange, new CircuitBreakerCallback(exchange, callback));\n         \n+        // We need to check the exception here as albp is use sync call  \n+        if (sync) {\n             boolean failed = hasFailed(exchange);\n-\n             if (!failed) {\n                 failures.set(0);\n             } else {\n                 failures.incrementAndGet();\n                 lastFailure = System.currentTimeMillis();\n             }\n-\n-        if (!sync) {\n+        } else {\n+            // CircuitBreakerCallback can take care of failure check of the exchange\n             log.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n             return false;\n         }\n@@ -142,4 +151,28 @@ public String toString() {\n     public String getTraceLabel() {\n         return \"circuitbreaker\";\n     }\n+    \n+    class CircuitBreakerCallback implements AsyncCallback {\n+        private final AsyncCallback callback;\n+        private final Exchange exchange;\n+        CircuitBreakerCallback(Exchange exchange, AsyncCallback callback) {\n+            this.callback = callback;\n+            this.exchange = exchange;\n+        }\n+\n+        @Override\n+        public void done(boolean doneSync) {\n+            if (!doneSync) {\n+                boolean failed = hasFailed(exchange);\n+                if (!failed) {\n+                    failures.set(0);\n+                } else {\n+                    failures.incrementAndGet();\n+                    lastFailure = System.currentTimeMillis();\n+                }\n+            }\n+            callback.done(doneSync);\n+        }\n+        \n+    }\n }\n",
        "project": "camel",
        "linesAdd": 30,
        "jira_id": "7973",
        "nb_skipped": 3,
        "commit": "799b45df",
        "nb_failure": 3,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3316,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.issues.StopRouteShouldNotStopContextScopedErrorHandlerIssueTest",
            "org.apache.camel.issues.StopRouteImpactsErrorHandlerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java b/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java\nindex eb31c6b1ba..efbaa173f5 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java\n@@ -840,7 +840,13 @@ protected void doStart() throws Exception {\n \n     @Override\n     protected void doStop() throws Exception {\n-        ServiceHelper.stopServices(deadLetter, output, outputAsync);\n+        // noop, do not stop any services which we only do when shutting down\n+        // as the error handler can be context scoped, and should not stop in case\n+        // a route stops\n     }\n \n+    @Override\n+    protected void doShutdown() throws Exception {\n+        ServiceHelper.stopServices(deadLetter, output, outputAsync);\n+    }\n }\n",
        "project": "camel",
        "linesAdd": 4,
        "jira_id": "3878",
        "nb_skipped": 0,
        "commit": "b9094cb5",
        "nb_failure": 0,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3396,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.converter.ObjectConverterTest",
            "org.apache.camel.builder.xml.ExtractXPathWithNamespaceTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/converter/ObjectConverter.java b/camel-core/src/main/java/org/apache/camel/converter/ObjectConverter.java\nindex 465c4e93a1..24df84398a 100644\n--- a/camel-core/src/main/java/org/apache/camel/converter/ObjectConverter.java\n+++ b/camel-core/src/main/java/org/apache/camel/converter/ObjectConverter.java\n@@ -137,6 +137,9 @@ public static Short toShort(Object value) {\n         if (value instanceof Short) {\n             return (Short) value;\n         } else if (value instanceof Number) {\n+            if (value.equals(Double.NaN)) {\n+                return null;\n+            }\n             Number number = (Number) value;\n             return number.shortValue();\n         } else if (value instanceof String) {\n@@ -154,6 +157,9 @@ public static Integer toInteger(Object value) {\n         if (value instanceof Integer) {\n             return (Integer) value;\n         } else if (value instanceof Number) {\n+            if (value.equals(Double.NaN)) {\n+                return null;\n+            }\n             Number number = (Number) value;\n             return number.intValue();\n         } else if (value instanceof String) {\n@@ -171,6 +177,9 @@ public static Long toLong(Object value) {\n         if (value instanceof Long) {\n             return (Long) value;\n         } else if (value instanceof Number) {\n+            if (value.equals(Double.NaN)) {\n+                return null;\n+            }\n             Number number = (Number) value;\n             return number.longValue();\n         } else if (value instanceof String) {\n@@ -188,6 +197,9 @@ public static Float toFloat(Object value) {\n         if (value instanceof Float) {\n             return (Float) value;\n         } else if (value instanceof Number) {\n+            if (value.equals(Double.NaN)) {\n+                return null;\n+            }\n             Number number = (Number) value;\n             return number.floatValue();\n         } else if (value instanceof String) {\n",
        "project": "camel",
        "linesAdd": 12,
        "jira_id": "4011",
        "nb_skipped": 0,
        "commit": "cbffff59",
        "nb_failure": 5,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4243,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.enricher.PollEnricherTest",
            "org.apache.camel.processor.aggregator.AggregateCompletedByBatchConsumerSendEmptyMessageWhenIdleTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/ScheduledBatchPollingConsumer.java b/camel-core/src/main/java/org/apache/camel/impl/ScheduledBatchPollingConsumer.java\nindex 5ff6208656..c54240c1a3 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ScheduledBatchPollingConsumer.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ScheduledBatchPollingConsumer.java\n@@ -20,6 +20,7 @@\n \n import org.apache.camel.BatchConsumer;\n import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n import org.apache.camel.Processor;\n import org.apache.camel.ShutdownRunningTask;\n import org.apache.camel.spi.ShutdownAware;\n@@ -112,4 +113,15 @@ public boolean isBatchAllowed() {\n         // we are shutting down so only continue if we are configured to complete all tasks\n         return ShutdownRunningTask.CompleteAllTasks == shutdownRunningTask;\n     }\n+\n+    @Override\n+    protected void processEmptyMessage() throws Exception {\n+        Exchange exchange = getEndpoint().createExchange();\n+        // enrich exchange, so we send an empty message with the batch details\n+        exchange.setProperty(Exchange.BATCH_INDEX, 0);\n+        exchange.setProperty(Exchange.BATCH_SIZE, 1);\n+        exchange.setProperty(Exchange.BATCH_COMPLETE, true);\n+        log.debug(\"Sending empty message as there were no messages from polling: {}\", this.getEndpoint());\n+        getProcessor().process(exchange);\n+    }\n }\n",
        "project": "camel",
        "linesAdd": 11,
        "jira_id": "5437",
        "nb_skipped": 1,
        "commit": "da05f5aa",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 4318,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.SplitterParallelStopOnExceptionTest",
            "org.apache.camel.processor.RecipientListParallelFineGrainedErrorHandlingTest",
            "org.apache.camel.processor.MulticastParallelStopOnExceptionTest",
            "org.apache.camel.processor.onexception.DoCatchDirectRecipientListTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex e538801fab..b2930f68c6 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -200,19 +200,11 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n         final AtomicExchange result = new AtomicExchange();\n         final Iterable<ProcessorExchangePair> pairs;\n \n-        // multicast uses fine grained error handling on the output processors\n-        // so use try .. catch to cater for this\n-        boolean exhaust = false;\n         try {\n             boolean sync = true;\n \n             pairs = createProcessorExchangePairs(exchange);\n \n-            // after we have created the processors we consider the exchange as exhausted if an unhandled\n-            // exception was thrown, (used in the catch block)\n-            // if the processors is working in Streaming model, the exchange could not be processed at this point.\n-            exhaust = !isStreaming();\n-\n             if (isParallelProcessing()) {\n                 // ensure an executor is set when running in parallel\n                 ObjectHelper.notNull(executorService, \"executorService\", this);\n@@ -228,15 +220,16 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n             }\n         } catch (Throwable e) {\n             exchange.setException(e);\n+            // unexpected exception was thrown, maybe from iterator etc. so do not regard as exhausted\n             // and do the done work\n-            doDone(exchange, null, callback, true, exhaust);\n+            doDone(exchange, null, callback, true, false);\n             return true;\n         }\n \n         // multicasting was processed successfully\n         // and do the done work\n         Exchange subExchange = result.get() != null ? result.get() : null;\n-        doDone(exchange, subExchange, callback, true, exhaust);\n+        doDone(exchange, subExchange, callback, true, true);\n         return true;\n     }\n \n@@ -308,7 +301,8 @@ public Exchange call() throws Exception {\n                             // throw caused exception\n                             if (subExchange.getException() != null) {\n                                 // wrap in exception to explain where it failed\n-                                throw new CamelExchangeException(\"Parallel processing failed for number \" + number, subExchange, subExchange.getException());\n+                                CamelExchangeException cause = new CamelExchangeException(\"Parallel processing failed for number \" + number, subExchange, subExchange.getException());\n+                                subExchange.setException(cause);\n                             }\n                         }\n \n@@ -527,15 +521,15 @@ protected boolean doProcessSequential(Exchange original, AtomicExchange result,\n             if (stopOnException && !continueProcessing) {\n                 if (subExchange.getException() != null) {\n                     // wrap in exception to explain where it failed\n-                    throw new CamelExchangeException(\"Sequential processing failed for number \" + total.get(), subExchange, subExchange.getException());\n-                } else {\n+                    CamelExchangeException cause = new CamelExchangeException(\"Sequential processing failed for number \" + total.get(), subExchange, subExchange.getException());\n+                    subExchange.setException(cause);\n+                }\n                 // we want to stop on exception, and the exception was handled by the error handler\n                 // this is similar to what the pipeline does, so we should do the same to not surprise end users\n                 // so we should set the failed exchange as the result and be done\n                 result.set(subExchange);\n                 return true;\n             }\n-            }\n \n             LOG.trace(\"Sequential processing complete for number {} exchange: {}\", total, subExchange);\n \ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java\nindex 9c4b00d8e8..6cac402f18 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/TryProcessor.java\n@@ -361,6 +361,8 @@ protected boolean processNext(final Exchange exchange, final AsyncCallback callb\n             // give the rest of the pipeline another chance\n             exchange.setProperty(Exchange.EXCEPTION_CAUGHT, caught);\n             exchange.setException(null);\n+            // and we should not be regarded as exhausted as we are in a try .. catch block\n+            exchange.removeProperty(Exchange.REDELIVERY_EXHAUSTED);\n \n             // is the exception handled by the catch clause\n             final Boolean handled = catchClause.handles(exchange);\n",
        "project": "camel",
        "linesAdd": 8,
        "jira_id": "5681",
        "nb_skipped": 1,
        "commit": "78c73502",
        "nb_failure": 3,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5492,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.IdempotentConsumerRepoExceptionTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentConsumer.java b/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentConsumer.java\nindex e28a214b08..7b64546697 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentConsumer.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/idempotent/IdempotentConsumer.java\n@@ -91,13 +91,23 @@ public void process(Exchange exchange) throws Exception {\n     }\n \n     public boolean process(final Exchange exchange, final AsyncCallback callback) {\n-        final String messageId = messageIdExpression.evaluate(exchange, String.class);\n+        final AsyncCallback target;\n+\n+        final String messageId;\n+        try {\n+            messageId = messageIdExpression.evaluate(exchange, String.class);\n             if (messageId == null) {\n                 exchange.setException(new NoMessageIdException(exchange, messageIdExpression));\n                 callback.done(true);\n                 return true;\n             }\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+            callback.done(true);\n+            return true;\n+        }\n \n+        try {\n             boolean newKey;\n             if (eager) {\n                 // add the key to the repository\n@@ -132,11 +141,16 @@ public boolean process(final Exchange exchange, final AsyncCallback callback) {\n             }\n \n             final Synchronization onCompletion = new IdempotentOnCompletion(idempotentRepository, messageId, eager, removeOnFailure);\n-        final AsyncCallback target = new IdempotentConsumerCallback(exchange, onCompletion, callback, completionEager);\n+            target = new IdempotentConsumerCallback(exchange, onCompletion, callback, completionEager);\n             if (!completionEager) {\n                 // the scope is to do the idempotent completion work as an unit of work on the exchange when its done being routed\n                 exchange.addOnCompletion(onCompletion);\n             }\n+        } catch (Exception e) {\n+            exchange.setException(e);\n+            callback.done(true);\n+            return true;\n+        }\n \n         // process the exchange\n         return processor.process(exchange, target);\n",
        "project": "camel",
        "linesAdd": 17,
        "jira_id": "9480",
        "nb_skipped": 4,
        "commit": "0ead2cac",
        "nb_failure": 0,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5063,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.MDCResetTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/MDCUnitOfWork.java b/camel-core/src/main/java/org/apache/camel/impl/MDCUnitOfWork.java\nindex 62f6b167c3..1726b8004a 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/MDCUnitOfWork.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/MDCUnitOfWork.java\n@@ -217,13 +217,15 @@ public void done(boolean doneSync) {\n                     if (correlationId != null) {\n                         MDC.put(MDC_CORRELATION_ID, correlationId);\n                     }\n-                    if (routeId != null) {\n-                        MDC.put(MDC_ROUTE_ID, routeId);\n-                    }\n                     if (camelContextId != null) {\n                         MDC.put(MDC_CAMEL_CONTEXT_ID, camelContextId);\n                     }\n                 }\n+                // need to setup the routeId finally\n+                if (routeId != null) {\n+                    MDC.put(MDC_ROUTE_ID, routeId);\n+                }\n+                \n             } finally {\n                 // muse ensure delegate is invoked\n                 delegate.done(doneSync);\n",
        "project": "camel",
        "linesAdd": 4,
        "jira_id": "7795",
        "nb_skipped": 3,
        "commit": "19b2aa31",
        "nb_failure": 0,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5476,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.file.FileMoveAndMoveFailedIssueTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java b/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\nindex 907de21817..e517550225 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/GenericFile.java\n@@ -185,7 +185,7 @@ public void changeFileName(String newName) {\n \n         // Make sure the names is normalized.\n         String newFileName = FileUtil.normalizePath(newName);\n-        String newEndpointPath = FileUtil.normalizePath(endpointPath);\n+        String newEndpointPath = FileUtil.normalizePath(endpointPath.endsWith(\"\" + File.separatorChar) ? endpointPath : endpointPath + File.separatorChar);\n \n         LOG.trace(\"Normalized endpointPath: {}\", newEndpointPath);\n         LOG.trace(\"Normalized newFileName: ()\", newFileName);\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "9238",
        "nb_skipped": 4,
        "commit": "169b981e",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4886,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.impl.DefaultEndpointTest",
            "org.apache.camel.management.ManagedThrottlerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultEndpoint.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultEndpoint.java\nindex 3dae2895bf..badd48ecb6 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultEndpoint.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultEndpoint.java\n@@ -136,7 +136,13 @@ public boolean equals(Object object) {\n \n     @Override\n     public String toString() {\n-        return String.format(\"Endpoint[%s]\", URISupport.sanitizeUri(getEndpointUri()));\n+        String value = null;\n+        try {\n+            value = getEndpointUri();\n+        } catch (RuntimeException e) {\n+            // ignore any exception and use null for building the string value\n+        }\n+        return String.format(\"Endpoint[%s]\", URISupport.sanitizeUri(value));\n     }\n \n     /**\n",
        "project": "camel",
        "linesAdd": 6,
        "jira_id": "7344",
        "nb_skipped": 3,
        "commit": "91228815",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4740,
        "nb_error": 3,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.vm.VmMultipleConsumersMultipleContextTest",
            "org.apache.camel.component.vm.VmMultipleContextsStartStopTest",
            "org.apache.camel.management.ManagedThrottlerTest",
            "org.apache.camel.component.vm.VmShouldNotUseSameThreadTest",
            "org.apache.camel.component.vm.VmMultipleConsumersRemoteRouteTest",
            "org.apache.camel.impl.DefaultProducerCacheTest",
            "org.apache.camel.component.vm.VmQueueTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\nindex 6b292c0ae9..b35eca5451 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n@@ -30,6 +30,7 @@\n import org.apache.camel.Producer;\n import org.apache.camel.ProducerCallback;\n import org.apache.camel.ServicePoolAware;\n+import org.apache.camel.ShutdownableService;\n import org.apache.camel.processor.UnitOfWorkProducer;\n import org.apache.camel.spi.ServicePool;\n import org.apache.camel.support.ServiceSupport;\n@@ -137,6 +138,11 @@ public void releaseProducer(Endpoint endpoint, Producer producer) throws Excepti\n         } else if (!producer.isSingleton()) {\n             // stop non singleton producers as we should not leak resources\n             producer.stop();\n+\n+            // shutdown as well in case the producer is shutdownable\n+            if (producer instanceof ShutdownableService) {\n+                ShutdownableService.class.cast(producer).shutdown();\n+            }\n         }\n     }\n \n",
        "project": "camel",
        "linesAdd": 5,
        "jira_id": "6948",
        "nb_skipped": 1,
        "commit": "f744afd9",
        "nb_failure": 5,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5053,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.log.LogInputStreamTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/util/MessageHelper.java b/camel-core/src/main/java/org/apache/camel/util/MessageHelper.java\nindex 6576c98663..502da6adc7 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/MessageHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/MessageHelper.java\n@@ -17,6 +17,7 @@\n package org.apache.camel.util;\n \n import java.io.File;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n import java.io.Reader;\n@@ -285,12 +286,15 @@ public static String extractValueForLogging(Object obj, Message message, String\n             }\n         }\n \n-        // is the body a stream cache\n-        StreamCache cache;\n+        // is the body a stream cache or input stream\n+        StreamCache cache = null;\n+        InputStream is = null;\n         if (obj instanceof StreamCache) {\n             cache = (StreamCache)obj;\n-        } else {\n+            is = null;\n+        } else if (obj instanceof InputStream) {\n             cache = null;\n+            is = (InputStream) obj;\n         }\n \n         // grab the message body as a string\n@@ -309,6 +313,12 @@ public static String extractValueForLogging(Object obj, Message message, String\n         // reset stream cache after use\n         if (cache != null) {\n             cache.reset();\n+        } else if (is != null && is.markSupported()) {\n+            try {\n+                is.reset();\n+            } catch (IOException e) {\n+                // ignore\n+            }\n         }\n \n         if (body == null) {\n",
        "project": "camel",
        "linesAdd": 11,
        "jira_id": "7767",
        "nb_skipped": 3,
        "commit": "eab06182",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 4700,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.MessageHistoryCopyExchangeTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java\nindex b755b70f44..2c4a615645 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java\n@@ -26,6 +26,7 @@\n import org.apache.camel.Exchange;\n import org.apache.camel.ExchangePattern;\n import org.apache.camel.Message;\n+import org.apache.camel.MessageHistory;\n import org.apache.camel.spi.Synchronization;\n import org.apache.camel.spi.UnitOfWork;\n import org.apache.camel.util.ExchangeHelper;\n@@ -95,10 +96,18 @@ public Exchange copy() {\n         return exchange;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private static Map<String, Object> safeCopy(Map<String, Object> properties) {\n         if (properties == null) {\n             return null;\n         }\n+\n+        // safe copy message history using a defensive copy\n+        List<MessageHistory> history = (List<MessageHistory>) properties.remove(Exchange.MESSAGE_HISTORY);\n+        if (history != null) {\n+            properties.put(Exchange.MESSAGE_HISTORY, new ArrayList<MessageHistory>(history));\n+        }\n+\n         return new ConcurrentHashMap<String, Object>(properties);\n     }\n \ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\nindex 76b5e029c0..a9dd334fd3 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n@@ -252,6 +252,8 @@ private static Exchange copyExchangeNoAttachments(Exchange exchange, boolean pre\n         Exchange answer = ExchangeHelper.createCopy(exchange, preserveExchangeId);\n         // we do not want attachments for the splitted sub-messages\n         answer.getIn().setAttachments(null);\n+        // we do not want to copy the message history for splitted sub-messages\n+        answer.getProperties().remove(Exchange.MESSAGE_HISTORY);\n         return answer;\n     }\n }\ndiff --git a/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java b/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\nindex b6f04d87b7..bc9943d2eb 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/ExchangeHelper.java\n@@ -16,7 +16,9 @@\n  */\n package org.apache.camel.util;\n \n+import java.util.ArrayList;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ExecutionException;\n@@ -32,6 +34,7 @@\n import org.apache.camel.ExchangePattern;\n import org.apache.camel.InvalidPayloadException;\n import org.apache.camel.Message;\n+import org.apache.camel.MessageHistory;\n import org.apache.camel.NoSuchBeanException;\n import org.apache.camel.NoSuchEndpointException;\n import org.apache.camel.NoSuchHeaderException;\n@@ -813,10 +816,18 @@ public static Exchange copyExchangeAndSetCamelContext(Exchange exchange, CamelCo\n         return answer;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     private static Map<String, Object> safeCopy(Map<String, Object> properties) {\n         if (properties == null) {\n             return null;\n         }\n+\n+        // safe copy message history using a defensive copy\n+        List<MessageHistory> history = (List<MessageHistory>) properties.remove(Exchange.MESSAGE_HISTORY);\n+        if (history != null) {\n+            properties.put(Exchange.MESSAGE_HISTORY, new ArrayList<MessageHistory>(history));\n+        }\n+\n         return new ConcurrentHashMap<String, Object>(properties);\n     }\n }\n",
        "project": "camel",
        "linesAdd": 19,
        "jira_id": "6723",
        "nb_skipped": 1,
        "commit": "b92d6237",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 4242,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.seda.SedaRemoveRouteThenAddItAgainTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java b/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\nindex 5b2d8724b7..e33d21de85 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/seda/SedaEndpoint.java\n@@ -85,7 +85,7 @@ public SedaComponent getComponent() {\n     }\n \n     public Producer createProducer() throws Exception {\n-        return new SedaProducer(this, getQueue(), getWaitForTaskToComplete(), getTimeout(), isBlockWhenFull());\n+        return new SedaProducer(this, getWaitForTaskToComplete(), getTimeout(), isBlockWhenFull());\n     }\n \n     public Consumer createConsumer(Processor processor) throws Exception {\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java b/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\nindex d39e39f722..361446080a 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/seda/SedaProducer.java\n@@ -32,6 +32,10 @@\n  * @version \n  */\n public class SedaProducer extends DefaultAsyncProducer {\n+    /**\n+     * @deprecated Better make use of the {@link SedaEndpoint#getQueue()} API which delivers the accurate reference to the queue currently being used.\n+     */\n+    @Deprecated\n     protected final BlockingQueue<Exchange> queue;\n     private final SedaEndpoint endpoint;\n     private final WaitForTaskToComplete waitForTaskToComplete;\n@@ -39,17 +43,24 @@\n     private final boolean blockWhenFull;\n \n     /**\n-     * @deprecated use the other constructor\n+     * @deprecated Use {@link #SedaProducer(SedaEndpoint, WaitForTaskToComplete, long, boolean) the other constructor}.\n      */\n     @Deprecated\n     public SedaProducer(SedaEndpoint endpoint, BlockingQueue<Exchange> queue, WaitForTaskToComplete waitForTaskToComplete, long timeout) {\n-        this(endpoint, queue, waitForTaskToComplete, timeout, false);\n+        this(endpoint, waitForTaskToComplete, timeout, false);\n+    }\n+\n+    /**\n+     * @deprecated Use {@link #SedaProducer(SedaEndpoint, WaitForTaskToComplete, long, boolean) the other constructor}.\n+     */\n+    @Deprecated\n+    public SedaProducer(SedaEndpoint endpoint, BlockingQueue<Exchange> queue, WaitForTaskToComplete waitForTaskToComplete, long timeout, boolean blockWhenFull) {\n+        this(endpoint, waitForTaskToComplete, timeout, blockWhenFull);\n     }\n \n-    public SedaProducer(SedaEndpoint endpoint, BlockingQueue<Exchange> queue, WaitForTaskToComplete waitForTaskToComplete,\n-                        long timeout, boolean blockWhenFull) {\n+    public SedaProducer(SedaEndpoint endpoint, WaitForTaskToComplete waitForTaskToComplete, long timeout, boolean blockWhenFull) {\n         super(endpoint);\n-        this.queue = queue;\n+        this.queue = endpoint.getQueue();\n         this.endpoint = endpoint;\n         this.waitForTaskToComplete = waitForTaskToComplete;\n         this.timeout = timeout;\n@@ -125,7 +136,7 @@ public String toString() {\n                 if (!done) {\n                     exchange.setException(new ExchangeTimedOutException(exchange, timeout));\n                     // remove timed out Exchange from queue\n-                    queue.remove(copy);\n+                    endpoint.getQueue().remove(copy);\n                     // count down to indicate timeout\n                     latch.countDown();\n                 }\n@@ -183,6 +194,7 @@ protected void doStop() throws Exception {\n      * @param exchange the exchange to add to the queue\n      */\n     protected void addToQueue(Exchange exchange) {\n+        BlockingQueue<Exchange> queue = endpoint.getQueue();\n         if (blockWhenFull) {\n             try {\n                 queue.put(exchange);\n",
        "project": "camel",
        "linesAdd": 12,
        "jira_id": "5432",
        "nb_skipped": 1,
        "commit": "93935780",
        "nb_failure": 1,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4269,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.ThreadsMaxQueueSizeTest",
            "org.apache.camel.management.ManagedThreadPoolTest",
            "org.apache.camel.processor.ThreadsCoreAndMaxPoolTest",
            "org.apache.camel.processor.ThreadsCorePoolTest",
            "org.apache.camel.processor.ThreadsRequestReplyTest",
            "org.apache.camel.processor.ThreadsCoreAndMaxPoolKeepAliveTimeTest",
            "org.apache.camel.management.ManagedThreadPoolWithIdTest",
            "org.apache.camel.impl.DefaultProducerTemplateAsyncTest",
            "org.apache.camel.builder.RouteBuilderTest",
            "org.apache.camel.processor.ThreadsRejectedPolicyTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\nindex 28b7eb9aa8..3ba39cb1be 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/ProcessorDefinition.java\n@@ -1130,7 +1130,7 @@ public ThreadsDefinition threads() {\n      * @return the builder\n      */\n     public ThreadsDefinition threads(int poolSize) {\n-        ThreadsDefinition answer = threads();\n+        ThreadsDefinition answer = new ThreadsDefinition();\n         answer.setPoolSize(poolSize);\n         addOutput(answer);\n         return answer;\n@@ -1144,7 +1144,7 @@ public ThreadsDefinition threads(int poolSize) {\n      * @return the builder\n      */\n     public ThreadsDefinition threads(int poolSize, int maxPoolSize) {\n-        ThreadsDefinition answer = threads();\n+        ThreadsDefinition answer = new ThreadsDefinition();\n         answer.setPoolSize(poolSize);\n         answer.setMaxPoolSize(maxPoolSize);\n         addOutput(answer);\n@@ -1160,7 +1160,7 @@ public ThreadsDefinition threads(int poolSize, int maxPoolSize) {\n      * @return the builder\n      */\n     public ThreadsDefinition threads(int poolSize, int maxPoolSize, String threadName) {\n-        ThreadsDefinition answer = threads();\n+        ThreadsDefinition answer = new ThreadsDefinition();\n         answer.setPoolSize(poolSize);\n         answer.setMaxPoolSize(maxPoolSize);\n         answer.setThreadName(threadName);\n",
        "project": "camel",
        "linesAdd": 3,
        "jira_id": "5515",
        "nb_skipped": 1,
        "commit": "b3bb8670",
        "nb_failure": 9,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 4959,
        "nb_error": 2,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.BeanOgnMethodWithXPathInjectionTest",
            "org.apache.camel.language.BeanLanguageOGNLTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\nindex 53c1254ba0..5b8804d567 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n@@ -228,6 +228,8 @@ private MethodInvocation createInvocation(Object pojo, Exchange exchange, Method\n                     List<ParameterInfo> lpi = new ArrayList<ParameterInfo>(1);\n                     lpi.add(pi);\n                     methodInfo = new MethodInfo(exchange.getContext(), pojo.getClass(), method, lpi, lpi, false, false);\n+                    // Need to update the message body to be pojo for the invocation\n+                    exchange.getIn().setBody(pojo);\n                 } catch (NoSuchMethodException e) {\n                     throw new MethodNotFoundException(exchange, pojo, \"getClass\");\n                 }\ndiff --git a/camel-core/src/main/java/org/apache/camel/language/bean/BeanExpression.java b/camel-core/src/main/java/org/apache/camel/language/bean/BeanExpression.java\nindex 1092f6e5df..3cbc2fae39 100644\n--- a/camel-core/src/main/java/org/apache/camel/language/bean/BeanExpression.java\n+++ b/camel-core/src/main/java/org/apache/camel/language/bean/BeanExpression.java\n@@ -300,8 +300,6 @@ public void process(Exchange exchange) throws Exception {\n \n                 // prepare for next bean to invoke\n                 beanToCall = result;\n-                // we need to set the result to the exchange for further processing\n-                resultExchange.getIn().setBody(result);\n             }\n         }\n \n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "7478",
        "nb_skipped": 3,
        "commit": "69b00a31",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4796,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.aggregator.CustomListAggregationStrategySplitTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex 84c488a7ab..69e4667cef 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -47,6 +47,7 @@\n import org.apache.camel.Producer;\n import org.apache.camel.Traceable;\n import org.apache.camel.processor.aggregate.AggregationStrategy;\n+import org.apache.camel.processor.aggregate.CompletionAwareAggregationStrategy;\n import org.apache.camel.processor.aggregate.TimeoutAwareAggregationStrategy;\n import org.apache.camel.spi.RouteContext;\n import org.apache.camel.spi.TracedRouteNodes;\n@@ -747,6 +748,12 @@ protected void doDone(Exchange original, Exchange subExchange, final Iterable<Pr\n             IOHelper.close((Closeable) pairs, \"pairs\", LOG);\n         }\n \n+        AggregationStrategy strategy = getAggregationStrategy(subExchange);\n+        // invoke the on completion callback\n+        if (strategy instanceof CompletionAwareAggregationStrategy) {\n+            ((CompletionAwareAggregationStrategy) strategy).onCompletion(subExchange);\n+        }\n+\n         // cleanup any per exchange aggregation strategy\n         removeAggregationStrategyFromExchange(original);\n \n",
        "project": "camel",
        "linesAdd": 6,
        "jira_id": "7167",
        "nb_skipped": 3,
        "commit": "1e33fcbc",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4668,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.aggregator.CustomListAggregationStrategyCompletionFromBatchConsumerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AbstractListAggregationStrategy.java b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AbstractListAggregationStrategy.java\nindex d37bba343d..a19bdbcd5e 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/aggregate/AbstractListAggregationStrategy.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/aggregate/AbstractListAggregationStrategy.java\n@@ -80,11 +80,9 @@ public void onCompletion(Exchange exchange) {\n      */\n     public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\n         List<V> list;\n-        Exchange answer = oldExchange;\n \n         if (oldExchange == null) {\n-            answer = new DefaultExchange(newExchange);\n-            list = getList(answer);\n+            list = getList(newExchange);\n         } else {\n             list = getList(oldExchange);\n         }\n@@ -96,7 +94,7 @@ public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\n             }\n         }\n \n-        return answer;\n+        return oldExchange != null ? oldExchange : newExchange;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "6557",
        "nb_skipped": 1,
        "commit": "2c5a42db",
        "nb_failure": 1,
        "linesRem": 4,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5293,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.CircuitBreakerLoadBalancerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/loadbalancer/CircuitBreakerLoadBalancer.java b/camel-core/src/main/java/org/apache/camel/processor/loadbalancer/CircuitBreakerLoadBalancer.java\nindex f76031173d..645b477bfe 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/loadbalancer/CircuitBreakerLoadBalancer.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/loadbalancer/CircuitBreakerLoadBalancer.java\n@@ -200,11 +200,6 @@ private boolean executeProcessor(final Exchange exchange, final AsyncCallback ca\n \n     private boolean rejectExchange(final Exchange exchange, final AsyncCallback callback) {\n         exchange.setException(new RejectedExecutionException(\"CircuitBreaker Open: failures: \" + failures + \", lastFailure: \" + lastFailure));\n-        /*\n-         * If the circuit opens, we have to prevent the execution of any\n-         * processor. The failures count can be set to 0.\n-         */\n-        failures.set(0);\n         callback.done(true);\n         return true;\n     }\n",
        "project": "camel",
        "linesAdd": 0,
        "jira_id": "8584",
        "nb_skipped": 4,
        "commit": "dd0f74c0",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": true
    },
    {
        "files": 1,
        "nb_test": 4686,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.aggregator.AggregateTimeoutTest",
            "org.apache.camel.component.bean.BeanOgnlBodyMethodReturnNullValueTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java\nindex 7160d3dfe7..cc58c50172 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/MethodInfo.java\n@@ -512,13 +512,15 @@ private Object evaluateParameterValue(Exchange exchange, int index, Object param\n                     try {\n                         expression = exchange.getContext().resolveLanguage(\"simple\").createExpression(exp);\n                         parameterValue = expression.evaluate(exchange, Object.class);\n+                        // use \"null\" to indicate the expression returned a null value which is a valid response we need to honor\n+                        if (parameterValue == null) {\n+                            parameterValue = \"null\";\n+                        }\n                     } catch (Exception e) {\n                         throw new ExpressionEvaluationException(expression, \"Cannot create/evaluate simple expression: \" + exp\n                                 + \" to be bound to parameter at index: \" + index + \" on method: \" + getMethod(), exchange, e);\n                     }\n \n-                    if (parameterValue != null) {\n-\n                     // special for explicit null parameter values (as end users can explicit indicate they want null as parameter)\n                     // see method javadoc for details\n                     if (\"null\".equals(parameterValue)) {\n@@ -555,7 +557,6 @@ private Object evaluateParameterValue(Exchange exchange, int index, Object param\n                         }\n                     }\n                 }\n-                }\n \n                 return answer;\n             }\n",
        "project": "camel",
        "linesAdd": 3,
        "jira_id": "6687",
        "nb_skipped": 1,
        "commit": "617eab1c",
        "nb_failure": 2,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3588,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.util.URISupportTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/util/URISupport.java b/camel-core/src/main/java/org/apache/camel/util/URISupport.java\nindex 71abd941d1..267578641c 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/URISupport.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/URISupport.java\n@@ -22,7 +22,9 @@\n import java.net.URLDecoder;\n import java.net.URLEncoder;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n+import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n@@ -74,7 +76,28 @@ public static String sanitizeUri(String uri) {\n                     if (p >= 0) {\n                         String name = URLDecoder.decode(parameter.substring(0, p), CHARSET);\n                         String value = URLDecoder.decode(parameter.substring(p + 1), CHARSET);\n+\n+                        // does the key already exist?\n+                        if (rc.containsKey(name)) {\n+                            // yes it does, so make sure we can support multiple values, but using a list\n+                            // to hold the multiple values\n+                            Object existing = rc.get(name);\n+                            List<String> list;\n+                            if (existing instanceof List) {\n+                                list = CastUtils.cast((List<?>) existing);\n+                            } else {\n+                                // create a new list to hold the multiple values\n+                                list = new ArrayList<String>();\n+                                String s = existing != null ? existing.toString() : null;\n+                                if (s != null) {\n+                                    list.add(s);\n+                                }\n+                            }\n+                            list.add(value);\n+                            rc.put(name, list);\n+                        } else {\n                             rc.put(name, value);\n+                        }\n                     } else {\n                         rc.put(parameter, null);\n                     }\n@@ -134,6 +157,7 @@ public static String stripPrefix(String value, String prefix) {\n         return value;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public static String createQueryString(Map<Object, Object> options) throws URISyntaxException {\n         try {\n             if (options.size() > 0) {\n@@ -147,12 +171,23 @@ public static String createQueryString(Map<Object, Object> options) throws URISy\n                     }\n \n                     String key = (String) o;\n-                    String value = (String) options.get(key);\n-                    rc.append(URLEncoder.encode(key, CHARSET));\n-                    // only append if value is not null\n-                    if (value != null) {\n-                        rc.append(\"=\");\n-                        rc.append(URLEncoder.encode(value, CHARSET));\n+                    Object value = options.get(key);\n+\n+                    // the value may be a list since the same key has multiple values\n+                    if (value instanceof List) {\n+                        List<String> list = (List<String>) value;\n+                        for (Iterator<String> it = list.iterator(); it.hasNext();) {\n+                            String s = it.next();\n+                            appendQueryStringParameter(key, s, rc);\n+                            // append & separator if there is more in the list to append\n+                            if (it.hasNext()) {\n+                                rc.append(\"&\");\n+                            }\n+                        }\n+                    } else {\n+                        // use the value as a String\n+                        String s = value != null ? value.toString() : null;\n+                        appendQueryStringParameter(key, s, rc);\n                     }\n                 }\n                 return rc.toString();\n@@ -166,6 +201,16 @@ public static String createQueryString(Map<Object, Object> options) throws URISy\n         }\n     }\n \n+    private static void appendQueryStringParameter(String key, String value, StringBuilder rc) throws UnsupportedEncodingException {\n+        rc.append(URLEncoder.encode(key, CHARSET));\n+        // only append if value is not null\n+        if (value != null) {\n+            rc.append(\"=\");\n+            rc.append(URLEncoder.encode(value, CHARSET));\n+        }\n+    }\n+\n+\n     /**\n      * Creates a URI from the original URI and the remaining parameters\n      * <p/>\n",
        "project": "camel",
        "linesAdd": 43,
        "jira_id": "4211",
        "nb_skipped": 0,
        "commit": "4efddb3f",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4371,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.DefaultErrorHandlerOnExceptionTraceTest",
            "org.apache.camel.processor.OnCompletionGlobalTraceTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/WrapProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/WrapProcessor.java\nindex cb7eb9fda5..adb508ab65 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/WrapProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/WrapProcessor.java\n@@ -19,14 +19,14 @@\n import java.util.List;\n \n import org.apache.camel.Processor;\n-import org.apache.camel.Traceable;\n import org.apache.camel.util.ServiceHelper;\n \n /**\n  * A processor which ensures wrapping processors is having lifecycle handled.\n+ *\n+ * @version \n  */\n-public class WrapProcessor extends DelegateAsyncProcessor implements Traceable {\n-\n+public class WrapProcessor extends DelegateAsyncProcessor {\n     private final Processor wrapped;\n \n     public WrapProcessor(Processor processor, Processor wrapped) {\n@@ -39,10 +39,6 @@ public String toString() {\n         return \"Wrap[\" + wrapped + \"] -> \" + processor;\n     }\n \n-    public String getTraceLabel() {\n-        return \"wrap[\" + wrapped + \"]\";\n-    }\n-\n     @Override\n     public List<Processor> next() {\n         // must include wrapped in navigate\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "5844",
        "nb_skipped": 1,
        "commit": "e775071b",
        "nb_failure": 4,
        "linesRem": 7,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3897,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.impl.DefaultCamelContextWithLifecycleStrategyRestartTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\nindex 5cc505b8cc..7857a78f3a 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java\n@@ -1560,7 +1560,7 @@ protected synchronized void doStop() throws Exception {\n         // shutdown management as the last one\n         shutdownServices(managementStrategy);\n         shutdownServices(lifecycleStrategies);\n-        lifecycleStrategies.clear();\n+        // do not clear lifecycleStrategies as we can start Camel again and get the route back as before\n \n         // stop the lazy created so they can be re-created on restart\n         forceStopLazyInitialization();\n",
        "project": "camel",
        "linesAdd": 0,
        "jira_id": "4682",
        "nb_skipped": 0,
        "commit": "1e54865c",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": true
    },
    {
        "files": 1,
        "nb_test": 2999,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.issues.SplitterThrowExceptionInExpressionTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex fcb8bfc150..bdee56f5a9 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -174,10 +174,16 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n \n         // multicast uses fine grained error handling on the output processors\n         // so use try .. catch to cater for this\n+        boolean exhaust = false;\n         try {\n             boolean sync = true;\n \n             pairs = createProcessorExchangePairs(exchange);\n+\n+            // after we have created the processors we consider the exchange as exhausted if an unhandled\n+            // exception was thrown, (used in the catch block)\n+            exhaust = true;\n+\n             if (isParallelProcessing()) {\n                 // ensure an executor is set when running in parallel\n                 ObjectHelper.notNull(executorService, \"executorService\", this);\n@@ -194,14 +200,14 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n         } catch (Throwable e) {\n             exchange.setException(e);\n             // and do the done work\n-            doDone(exchange, null, callback, true);\n+            doDone(exchange, null, callback, true, exhaust);\n             return true;\n         }\n \n         // multicasting was processed successfully\n         // and do the done work\n         Exchange subExchange = result.get() != null ? result.get() : null;\n-        doDone(exchange, subExchange, callback, true);\n+        doDone(exchange, subExchange, callback, true, exhaust);\n         return true;\n     }\n \n@@ -455,7 +461,7 @@ public void done(boolean doneSync) {\n                             result.set(subExchange);\n                         }\n                         // and do the done work\n-                        doDone(original, subExchange, callback, false);\n+                        doDone(original, subExchange, callback, false, true);\n                         return;\n                     }\n \n@@ -465,7 +471,7 @@ public void done(boolean doneSync) {\n                         // wrap in exception to explain where it failed\n                         subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\n                         // and do the done work\n-                        doDone(original, subExchange, callback, false);\n+                        doDone(original, subExchange, callback, false, true);\n                         return;\n                     }\n \n@@ -501,7 +507,7 @@ public void done(boolean doneSync) {\n                                 result.set(subExchange);\n                             }\n                             // and do the done work\n-                            doDone(original, subExchange, callback, false);\n+                            doDone(original, subExchange, callback, false, true);\n                             return;\n                         }\n \n@@ -511,7 +517,7 @@ public void done(boolean doneSync) {\n                             // wrap in exception to explain where it failed\n                             subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\n                             // and do the done work\n-                            doDone(original, subExchange, callback, false);\n+                            doDone(original, subExchange, callback, false, true);\n                             return;\n                         }\n \n@@ -520,7 +526,7 @@ public void done(boolean doneSync) {\n \n                     // do the done work\n                     subExchange = result.get() != null ? result.get() : null;\n-                    doDone(original, subExchange, callback, false);\n+                    doDone(original, subExchange, callback, false, true);\n                 }\n             });\n         } finally {\n@@ -589,15 +595,16 @@ private void doProcessParallel(final ProcessorExchangePair pair) throws Exceptio\n      * @param subExchange the current sub exchange, can be <tt>null</tt> for the synchronous part\n      * @param callback    the callback\n      * @param doneSync    the <tt>doneSync</tt> parameter to call on callback\n+     * @param exhaust     whether or not error handling is exhausted\n      */\n-    protected void doDone(Exchange original, Exchange subExchange, AsyncCallback callback, boolean doneSync) {\n+    protected void doDone(Exchange original, Exchange subExchange, AsyncCallback callback, boolean doneSync, boolean exhaust) {\n         // cleanup any per exchange aggregation strategy\n         removeAggregationStrategyFromExchange(original);\n         if (original.getException() != null) {\n             // multicast uses error handling on its output processors and they have tried to redeliver\n             // so we shall signal back to the other error handlers that we are exhausted and they should not\n             // also try to redeliver as we will then do that twice\n-            original.setProperty(Exchange.REDELIVERY_EXHAUSTED, Boolean.TRUE);\n+            original.setProperty(Exchange.REDELIVERY_EXHAUSTED, exhaust);\n         }\n         if (subExchange != null) {\n             // and copy the current result to original so it will contain this exception\n",
        "project": "camel",
        "linesAdd": 13,
        "jira_id": "3394",
        "nb_skipped": 0,
        "commit": "18e1a142",
        "nb_failure": 0,
        "linesRem": 9,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 3235,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.RecipientListParallelAggregateThreadPoolIssueTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex a427b25e7a..3d4fec29a5 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -888,11 +888,22 @@ protected void doStart() throws Exception {\n             // keep at least one thread in the pool so we re-use the thread avoiding to create new threads because\n             // the pool shrank to zero.\n             String name = getClass().getSimpleName() + \"-AggregateTask\";\n-            aggregateExecutorService = camelContext.getExecutorServiceStrategy().newThreadPool(this, name, 1, Integer.MAX_VALUE);\n+            aggregateExecutorService = createAggregateExecutorService(name);\n         }\n         ServiceHelper.startServices(processors);\n     }\n \n+    /**\n+     * Strategy to create the thread pool for the aggregator background task which waits for and aggregates\n+     * completed tasks when running in parallel mode.\n+     *\n+     * @param name  the suggested name for the background thread\n+     * @return the thread pool\n+     */\n+    protected ExecutorService createAggregateExecutorService(String name) {\n+        return camelContext.getExecutorServiceStrategy().newThreadPool(this, name, 1, Integer.MAX_VALUE);\n+    }\n+\n     protected void doStop() throws Exception {\n         ServiceHelper.stopServices(processors);\n         errorHandlers.clear();\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/RecipientList.java b/camel-core/src/main/java/org/apache/camel/processor/RecipientList.java\nindex 8260c93813..f2a163f9bc 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/RecipientList.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/RecipientList.java\n@@ -55,6 +55,7 @@\n     private boolean streaming;\n     private long timeout;\n     private ExecutorService executorService;\n+    private ExecutorService aggregateExecutorService;\n     private AggregationStrategy aggregationStrategy = new UseLatestAggregationStrategy();\n \n     public RecipientList(CamelContext camelContext) {\n@@ -108,7 +109,16 @@ public boolean sendToRecipientList(Exchange exchange, Object recipientList, Asyn\n         Iterator<Object> iter = ObjectHelper.createIterator(recipientList, delimiter);\n \n         RecipientListProcessor rlp = new RecipientListProcessor(exchange.getContext(), producerCache, iter, getAggregationStrategy(),\n-                                                                isParallelProcessing(), getExecutorService(), isStreaming(), isStopOnException(), getTimeout());\n+                                                                isParallelProcessing(), getExecutorService(), isStreaming(), isStopOnException(), getTimeout()) {\n+            @Override\n+            protected ExecutorService createAggregateExecutorService(String name) {\n+                // use a shared executor service to avoid creating new thread pools\n+                if (aggregateExecutorService == null) {\n+                    aggregateExecutorService = super.createAggregateExecutorService(\"RecipientList-AggregateTask\");\n+                }\n+                return aggregateExecutorService;\n+            }\n+        };\n         rlp.setIgnoreInvalidEndpoints(isIgnoreInvalidEndpoints());\n \n         // start the service\n",
        "project": "camel",
        "linesAdd": 15,
        "jira_id": "3727",
        "nb_skipped": 0,
        "commit": "ff2713d1",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 2913,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.onexception.OnExceptionAfterRouteTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/RouteBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/RouteBuilder.java\nindex 1300f7d..a5cd8d1 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/RouteBuilder.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/RouteBuilder.java\n@@ -136,6 +136,9 @@ public RouteDefinition from(Endpoint... endpoints) {\n      * @return the current builder with the error handler configured\n      */\n     public RouteBuilder errorHandler(ErrorHandlerBuilder errorHandlerBuilder) {\n+        if (!routeCollection.getRoutes().isEmpty()) {\n+            throw new IllegalArgumentException(\"errorHandler must be defined before any routes in the RouteBuilder\");\n+        }\n         routeCollection.setCamelContext(getContext());\n         setErrorHandlerBuilder(errorHandlerBuilder);\n         return this;\n@@ -147,6 +150,9 @@ public RouteBuilder errorHandler(ErrorHandlerBuilder errorHandlerBuilder) {\n      * @return the builder\n      */\n     public InterceptDefinition intercept() {\n+        if (!routeCollection.getRoutes().isEmpty()) {\n+            throw new IllegalArgumentException(\"intercept must be defined before any routes in the RouteBuilder\");\n+        }\n         routeCollection.setCamelContext(getContext());\n         return routeCollection.intercept();\n     }\n@@ -157,6 +163,9 @@ public InterceptDefinition intercept() {\n      * @return the builder\n      */\n     public InterceptFromDefinition interceptFrom() {\n+        if (!routeCollection.getRoutes().isEmpty()) {\n+            throw new IllegalArgumentException(\"interceptFrom must be defined before any routes in the RouteBuilder\");\n+        }\n         routeCollection.setCamelContext(getContext());\n         return routeCollection.interceptFrom();\n     }\n@@ -168,6 +177,9 @@ public InterceptFromDefinition interceptFrom() {\n      * @return the builder\n      */\n     public InterceptFromDefinition interceptFrom(String uri) {\n+        if (!routeCollection.getRoutes().isEmpty()) {\n+            throw new IllegalArgumentException(\"interceptFrom must be defined before any routes in the RouteBuilder\");\n+        }\n         routeCollection.setCamelContext(getContext());\n         return routeCollection.interceptFrom(uri);\n     }\n@@ -179,6 +191,9 @@ public InterceptFromDefinition interceptFrom(String uri) {\n      * @return the builder\n      */\n     public InterceptSendToEndpointDefinition interceptSendToEndpoint(String uri) {\n+        if (!routeCollection.getRoutes().isEmpty()) {\n+            throw new IllegalArgumentException(\"interceptSendToEndpoint must be defined before any routes in the RouteBuilder\");\n+        }\n         routeCollection.setCamelContext(getContext());\n         return routeCollection.interceptSendToEndpoint(uri);\n     }\n@@ -191,6 +206,10 @@ public InterceptSendToEndpointDefinition interceptSendToEndpoint(String uri) {\n      * @return the builder\n      */\n     public OnExceptionDefinition onException(Class exception) {\n+        // is only allowed at the top currently\n+        if (!routeCollection.getRoutes().isEmpty()) {\n+            throw new IllegalArgumentException(\"onException must be defined before any routes in the RouteBuilder\");\n+        }\n         routeCollection.setCamelContext(getContext());\n         return routeCollection.onException(exception);\n     }\n@@ -217,6 +236,10 @@ public OnExceptionDefinition onException(Class... exceptions) {\n      * @return the builder\n      */\n     public OnCompletionDefinition onCompletion() {\n+        // is only allowed at the top currently\n+        if (!routeCollection.getRoutes().isEmpty()) {\n+            throw new IllegalArgumentException(\"onCompletion must be defined before any routes in the RouteBuilder\");\n+        }\n         routeCollection.setCamelContext(getContext());\n         return routeCollection.onCompletion();\n     }\n",
        "project": "camel",
        "linesAdd": 21,
        "jira_id": "3281",
        "nb_skipped": 0,
        "commit": "f7dd2fff",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 3122,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.file.FileAbsolutePathIssueTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/xml/DefaultTransformErrorHandler.java b/camel-core/src/main/java/org/apache/camel/builder/xml/DefaultTransformErrorHandler.java\nindex 214ea39dd7..6e6b59d82f 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/xml/DefaultTransformErrorHandler.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/xml/DefaultTransformErrorHandler.java\n@@ -19,12 +19,13 @@\n import javax.xml.transform.ErrorListener;\n import javax.xml.transform.TransformerException;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.xml.sax.ErrorHandler;\n import org.xml.sax.SAXException;\n import org.xml.sax.SAXParseException;\n \n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n /**\n  * {@link ErrorHandler} and {@link ErrorListener} which will log warnings,\n  * and throws error and fatal as exception, which ensures those can be caught by Camel and dealt-with.\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/FileConsumer.java b/camel-core/src/main/java/org/apache/camel/component/file/FileConsumer.java\nindex 8e8b320581..6d2c809efc 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/FileConsumer.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/FileConsumer.java\n@@ -137,10 +137,8 @@ protected boolean pollDirectory(String fileName, List<GenericFile<File>> fileLis\n         answer.setAbsolute(FileUtil.isAbsolute(file));\n         answer.setAbsoluteFilePath(file.getAbsolutePath());\n         answer.setLastModified(file.lastModified());\n-        if (answer.isAbsolute()) {\n-            // use absolute path as relative\n-            answer.setRelativeFilePath(file.getAbsolutePath());\n-        } else {\n+\n+        // compute the file path as relative to the starting directory\n         File path;\n         String endpointNormalized = FileUtil.normalizePath(endpointPath);\n         if (file.getPath().startsWith(endpointNormalized)) {\n@@ -155,7 +153,6 @@ protected boolean pollDirectory(String fileName, List<GenericFile<File>> fileLis\n         } else {\n             answer.setRelativeFilePath(path.getName());\n         }\n-        }\n \n         // the file name should be the relative path\n         answer.setFileName(answer.getRelativeFilePath());\n",
        "project": "camel",
        "linesAdd": 4,
        "jira_id": "3617",
        "nb_skipped": 0,
        "commit": "02626724",
        "nb_failure": 0,
        "linesRem": 6,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4629,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.language.TokenizerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/support/TokenXMLExpressionIterator.java b/camel-core/src/main/java/org/apache/camel/support/TokenXMLExpressionIterator.java\nindex b8d43743cf..938b1d6c58 100644\n--- a/camel-core/src/main/java/org/apache/camel/support/TokenXMLExpressionIterator.java\n+++ b/camel-core/src/main/java/org/apache/camel/support/TokenXMLExpressionIterator.java\n@@ -47,7 +47,7 @@\n public class TokenXMLExpressionIterator extends ExpressionAdapter {\n     private static final Pattern NAMESPACE_PATTERN = Pattern.compile(\"xmlns(:\\\\w+|)\\\\s*=\\\\s*('[^']+'|\\\"[^\\\"]+\\\")\");\n     private static final String SCAN_TOKEN_NS_PREFIX_REGEX = \"([^:<>]{1,15}?:|)\";\n-    private static final String SCAN_BLOCK_TOKEN_REGEX_TEMPLATE = \"<{0}(\\\\s+[^/]*)?/>|<{0}(\\\\s+[^>]*)?>(?:(?!</{0}).)*</{0}\\\\s*>\";\n+    private static final String SCAN_BLOCK_TOKEN_REGEX_TEMPLATE = \"<{0}(\\\\s+[^/]*)?/>|<{0}(\\\\s+[^>]*)?>(?:(?!(</{0}\\\\s*>)).)*</{0}\\\\s*>\";\n     private static final String SCAN_PARENT_TOKEN_REGEX_TEMPLATE = \"<{0}(\\\\s+[^>]*\\\\s*)?>\";\n     \n     protected final String tagToken;\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "6607",
        "nb_skipped": 1,
        "commit": "2d7051ed",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4322,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.file.FileSplitInSplitTest",
            "org.apache.camel.processor.aggregator.AggregateTimeoutWithExecutorServiceTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex b2930f68c6..399308605f 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -1002,6 +1002,10 @@ protected void setAggregationStrategyOnExchange(Exchange exchange, AggregationSt\n         Map<Object, AggregationStrategy> map = CastUtils.cast(property);\n         if (map == null) {\n             map = new HashMap<Object, AggregationStrategy>();\n+        } else {\n+            // it is not safe to use the map directly as the exchange doesn't have the deep copy of it's properties\n+            // we just create a new copy if we need to change the map\n+            map = new HashMap<Object, AggregationStrategy>(map);\n         }\n         // store the strategy using this processor as the key\n         // (so we can store multiple strategies on the same exchange)\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "5704",
        "nb_skipped": 1,
        "commit": "708e756d",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false,
        "rtElixir": true
    },
    {
        "files": 6,
        "nb_test": 4175,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.file.FileProducerCharsetUTFtoISOTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/file/FileBinding.java b/camel-core/src/main/java/org/apache/camel/component/file/FileBinding.java\nindex 4fd01626f4..8a63748c3b 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/FileBinding.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/FileBinding.java\n@@ -54,7 +54,7 @@ public void setBody(GenericFile<File> file, Object body) {\n     public void loadContent(Exchange exchange, GenericFile<?> file) throws IOException {\n         if (content == null) {\n             try {\n-                content = exchange.getContext().getTypeConverter().mandatoryConvertTo(byte[].class, file.getFile());\n+                content = exchange.getContext().getTypeConverter().mandatoryConvertTo(byte[].class, exchange, file.getFile());\n             } catch (NoTypeConversionAvailableException e) {\n                 throw new IOException(\"Cannot load file content: \" + file.getAbsoluteFilePath(), e);\n             }\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java b/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java\nindex f22056eafd..fbc60bc9f1 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java\n@@ -21,7 +21,10 @@\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.InputStreamReader;\n import java.io.RandomAccessFile;\n+import java.io.Reader;\n+import java.io.Writer;\n import java.nio.ByteBuffer;\n import java.nio.channels.FileChannel;\n import java.util.Date;\n@@ -29,6 +32,8 @@\n \n import org.apache.camel.Exchange;\n import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.converter.IOConverter;\n import org.apache.camel.util.FileUtil;\n import org.apache.camel.util.IOHelper;\n import org.apache.camel.util.ObjectHelper;\n@@ -173,10 +178,24 @@ public boolean storeFile(String fileName, Exchange exchange) throws GenericFileO\n         // 3. write stream to file\n         try {\n \n-            // is the body file based\n+            // determine charset, exchange property overrides endpoint configuration\n+            String charset = IOHelper.getCharsetName(exchange, false);\n+            if (charset == null) {\n+                charset = endpoint.getCharset();\n+            }\n+\n+            // we can optimize and use file based if no charset must be used, and the input body is a file\n             File source = null;\n-            // get the File Object from in message\n-            source = exchange.getIn().getBody(File.class);\n+            if (charset == null) {\n+                // if no charset, then we can try using file directly (optimized)\n+                Object body = exchange.getIn().getBody();\n+                if (body instanceof WrappedFile) {\n+                    body = ((WrappedFile) body).getFile();\n+                }\n+                if (body instanceof File) {\n+                    source = (File) body;\n+                }\n+            }\n \n             if (source != null) {\n                 // okay we know the body is a file type\n@@ -205,9 +224,22 @@ public boolean storeFile(String fileName, Exchange exchange) throws GenericFileO\n                 }\n             }\n \n+            if (charset != null) {\n+                // charset configured so we must use a reader so we can write with encoding\n+                Reader in = exchange.getIn().getBody(Reader.class);\n+                if (in == null) {\n+                    // okay no direct reader conversion, so use an input stream (which a lot can be converted as)\n+                    InputStream is = exchange.getIn().getMandatoryBody(InputStream.class);\n+                    in = new InputStreamReader(is);\n+                }\n+                // buffer the reader\n+                in = IOHelper.buffered(in);\n+                writeFileByReaderWithCharset(in, file, charset);\n+            } else {\n                 // fallback and use stream based\n                 InputStream in = exchange.getIn().getMandatoryBody(InputStream.class);\n                 writeFileByStream(in, file);\n+            }\n             // try to keep last modified timestamp if configured to do so\n             keepLastModified(exchange, file);\n             return true;\n@@ -286,6 +317,19 @@ private void writeFileByStream(InputStream in, File target) throws IOException {\n         }\n     }\n \n+    private void writeFileByReaderWithCharset(Reader in, File target, String charset) throws IOException {\n+        boolean append = endpoint.getFileExist() == GenericFileExist.Append;\n+        Writer out = IOConverter.toWriter(target, append, charset);\n+        try {\n+            LOG.trace(\"Using Reader to transfer from: {} to: {} with charset: {}\", new Object[]{in, out, charset});\n+            int size = endpoint.getBufferSize();\n+            IOHelper.copy(in, out, size);\n+        } finally {\n+            IOHelper.close(in, target.getName(), LOG);\n+            IOHelper.close(out, target.getName(), LOG);\n+        }\n+    }\n+\n     /**\n      * Creates and prepares the output file channel. Will position itself in correct position if the file is writable\n      * eg. it should append or override any existing content.\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConverter.java b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConverter.java\nindex 76bb929023..49bc19d9d1 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConverter.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileConverter.java\n@@ -17,7 +17,6 @@\n package org.apache.camel.component.file;\n \n import java.io.File;\n-import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.Serializable;\n@@ -25,9 +24,9 @@\n import org.apache.camel.Converter;\n import org.apache.camel.Exchange;\n import org.apache.camel.FallbackConverter;\n+import org.apache.camel.NoTypeConversionAvailableException;\n import org.apache.camel.TypeConverter;\n import org.apache.camel.spi.TypeConverterRegistry;\n-import org.apache.camel.util.IOHelper;\n \n /**\n  * A set of converter methods for working with generic file types\n@@ -64,11 +63,15 @@ public static Object convertTo(Class<?> type, Exchange exchange, Object value, T\n     }\n \n     @Converter\n-    public static InputStream genericFileToInputStream(GenericFile<?> file, Exchange exchange) throws IOException {\n+    public static InputStream genericFileToInputStream(GenericFile<?> file, Exchange exchange) throws IOException, NoTypeConversionAvailableException {\n         if (exchange != null) {\n-            // use a file input stream if its a java.io.File\n             if (file.getFile() instanceof java.io.File) {\n-                return IOHelper.buffered(new FileInputStream((File) file.getFile()));\n+                // prefer to use a file input stream if its a java.io.File (must use type converter to take care of encoding)\n+                File f = (File) file.getFile();\n+                InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, f);\n+                if (is != null) {\n+                    return is;\n+                }\n             }\n             // otherwise ensure the body is loaded as we want the input stream of the body\n             file.getBinding().loadContent(exchange, file);\ndiff --git a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileProducer.java b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileProducer.java\nindex b00cdf0ee6..feab07beb2 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/file/GenericFileProducer.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/file/GenericFileProducer.java\n@@ -59,8 +59,6 @@ public String normalizePath(String name) {\n     }\n \n     public void process(Exchange exchange) throws Exception {\n-        endpoint.configureExchange(exchange);\n-\n         String target = createFileName(exchange);\n \n         // use lock for same file name to avoid concurrent writes to the same file\ndiff --git a/camel-core/src/main/java/org/apache/camel/converter/IOConverter.java b/camel-core/src/main/java/org/apache/camel/converter/IOConverter.java\nindex 0307aef035..fcc6fc86a1 100644\n--- a/camel-core/src/main/java/org/apache/camel/converter/IOConverter.java\n+++ b/camel-core/src/main/java/org/apache/camel/converter/IOConverter.java\n@@ -101,12 +101,16 @@ public static OutputStream toOutputStream(File file) throws FileNotFoundExceptio\n      */\n     @Deprecated\n     public static BufferedWriter toWriter(File file) throws IOException {\n-        return toWriter(file, null);\n+        return toWriter(file, false, IOHelper.getCharsetName(null, true));\n     }\n     \n     @Converter\n     public static BufferedWriter toWriter(File file, Exchange exchange) throws IOException {\n-        return IOHelper.buffered(new EncodingFileWriter(file, IOHelper.getCharsetName(exchange)));\n+        return toWriter(file, false, IOHelper.getCharsetName(exchange));\n+    }\n+\n+    public static BufferedWriter toWriter(File file, boolean append, String charset) throws IOException {\n+        return IOHelper.buffered(new EncodingFileWriter(file, append, charset));\n     }\n \n     /**\n@@ -434,6 +438,16 @@ public EncodingFileWriter(File file, String charset)\n             super(new FileOutputStream(file), charset);\n         }\n \n+        /**\n+         * @param file file to write\n+         * @param append whether to append to the file\n+         * @param charset character set to use\n+         */\n+        public EncodingFileWriter(File file, boolean append, String charset)\n+            throws FileNotFoundException, UnsupportedEncodingException {\n+            super(new FileOutputStream(file, append), charset);\n+        }\n+\n     }\n     \n     /**\ndiff --git a/camel-core/src/main/java/org/apache/camel/util/IOHelper.java b/camel-core/src/main/java/org/apache/camel/util/IOHelper.java\nindex 79aa06a399..903ce19a7d 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/IOHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/IOHelper.java\n@@ -191,6 +191,20 @@ public static void copyAndCloseInput(InputStream input, OutputStream output, int\n         close(input, null, LOG);\n     }\n \n+    public static int copy(final Reader input, final Writer output, int bufferSize) throws IOException {\n+        final char[] buffer = new char[bufferSize];\n+        int n = input.read(buffer);\n+        int total = 0;\n+        while (-1 != n) {\n+            output.write(buffer, 0, n);\n+            total += n;\n+            n = input.read(buffer);\n+        }\n+        output.flush();\n+        return total;\n+    }\n+\n+\n     /**\n      * Forces any updates to this channel's file to be written to the storage device that contains it.\n      *\n",
        "project": "camel",
        "linesAdd": 75,
        "jira_id": "5215",
        "nb_skipped": 1,
        "commit": "033eb6fe",
        "nb_failure": 1,
        "linesRem": 10,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 3836,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.builder.xml.XPathTest",
            "org.apache.camel.processor.SplitterThrowExceptionFromExpressionTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex 8727befba1..f9b361e8e0 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -797,6 +797,12 @@ protected Integer getExchangeIndex(Exchange exchange) {\n             result.add(createProcessorExchangePair(index++, processor, copy, routeContext));\n         }\n \n+        if (exchange.getException() != null) {\n+            // force any exceptions occurred during creation of exchange paris to be thrown\n+            // before returning the answer;\n+            throw exchange.getException();\n+        }\n+\n         return result;\n     }\n \ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\nindex bb7783aaf3..ce146579a7 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/Splitter.java\n@@ -98,14 +98,26 @@ public boolean process(Exchange exchange, final AsyncCallback callback) {\n     }\n \n     @Override\n-    protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) {\n+    protected Iterable<ProcessorExchangePair> createProcessorExchangePairs(Exchange exchange) throws Exception {\n         Object value = expression.evaluate(exchange, Object.class);\n+        if (exchange.getException() != null) {\n+            // force any exceptions occurred during evaluation to be thrown\n+            throw exchange.getException();\n+        }\n \n+        Iterable<ProcessorExchangePair> answer;\n         if (isStreaming()) {\n-            return createProcessorExchangePairsIterable(exchange, value);\n+            answer = createProcessorExchangePairsIterable(exchange, value);\n         } else {\n-            return createProcessorExchangePairsList(exchange, value);\n+            answer = createProcessorExchangePairsList(exchange, value);\n+        }\n+        if (exchange.getException() != null) {\n+            // force any exceptions occurred during creation of exchange paris to be thrown\n+            // before returning the answer;\n+            throw exchange.getException();\n         }\n+\n+        return answer;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n",
        "project": "camel",
        "linesAdd": 16,
        "jira_id": "4482",
        "nb_skipped": 0,
        "commit": "e38494f1",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5469,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.builder.NotifyBuilderFromRouteTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/NotifyBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/NotifyBuilder.java\nindex 1c42ad90ad..e5933494d6 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/NotifyBuilder.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/NotifyBuilder.java\n@@ -154,6 +154,11 @@ public boolean isAbstract() {\n             @Override\n             public boolean onExchange(Exchange exchange) {\n                 String id = EndpointHelper.getRouteIdFromEndpoint(exchange.getFromEndpoint());\n+\n+                if (id == null) {\n+                    id = exchange.getFromRouteId();\n+                }\n+\n                 // filter non matching exchanges\n                 return EndpointHelper.matchPattern(id, routeId);\n             }\n",
        "project": "camel",
        "linesAdd": 5,
        "jira_id": "9269",
        "nb_skipped": 4,
        "commit": "62b2042b",
        "nb_failure": 1,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5166,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.language.simple.SimpleTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\nindex 1c19945e41..fb9c533200 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java\n@@ -311,8 +311,12 @@ private void introspect(Class<?> clazz) {\n             methods.addAll(extraMethods);\n         }\n \n-        // it may have duplicate methods already, even from declared or from interfaces + declared\n         Set<Method> overrides = new HashSet<Method>();\n+\n+        // do not remove duplicates form class from the Java itself as they have some \"duplicates\" we need\n+        boolean javaClass = clazz.getName().startsWith(\"java.\") || clazz.getName().startsWith(\"javax.\");\n+        if (!javaClass) {\n+            // it may have duplicate methods already, even from declared or from interfaces + declared\n             for (Method source : methods) {\n                 for (Method target : methods) {\n                     // skip ourselves\n@@ -327,6 +331,7 @@ private void introspect(Class<?> clazz) {\n             }\n             methods.removeAll(overrides);\n             overrides.clear();\n+        }\n \n         // if we are a public class, then add non duplicate interface classes also\n         if (Modifier.isPublic(clazz.getModifiers())) {\n",
        "project": "camel",
        "linesAdd": 4,
        "jira_id": "8137",
        "nb_skipped": 4,
        "commit": "53b4e90c",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4870,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.intercept.InterceptSendToEndpointNormalizePatternTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/model/InterceptSendToEndpointDefinition.java b/camel-core/src/main/java/org/apache/camel/model/InterceptSendToEndpointDefinition.java\nindex 9b8bdc3ec2..be2dcb96c8 100644\n--- a/camel-core/src/main/java/org/apache/camel/model/InterceptSendToEndpointDefinition.java\n+++ b/camel-core/src/main/java/org/apache/camel/model/InterceptSendToEndpointDefinition.java\n@@ -22,6 +22,7 @@\n import javax.xml.bind.annotation.XmlAttribute;\n import javax.xml.bind.annotation.XmlRootElement;\n \n+import org.apache.camel.CamelContext;\n import org.apache.camel.Endpoint;\n import org.apache.camel.Predicate;\n import org.apache.camel.Processor;\n@@ -30,6 +31,7 @@\n import org.apache.camel.spi.EndpointStrategy;\n import org.apache.camel.spi.RouteContext;\n import org.apache.camel.util.EndpointHelper;\n+import org.apache.camel.util.URISupport;\n \n /**\n  * Represents an XML &lt;interceptToEndpoint/&gt; element\n@@ -95,7 +97,7 @@ public Endpoint registerEndpoint(String uri, Endpoint endpoint) {\n                 if (endpoint instanceof InterceptSendToEndpoint) {\n                     // endpoint already decorated\n                     return endpoint;\n-                } else if (getUri() == null || EndpointHelper.matchEndpoint(routeContext.getCamelContext(), uri, getUri())) {\n+                } else if (getUri() == null || matchPattern(routeContext.getCamelContext(), uri, getUri())) {\n                     // only proxy if the uri is matched decorate endpoint with our proxy\n                     // should be false by default\n                     boolean skip = isSkipSendToOriginalEndpoint();\n@@ -120,6 +122,29 @@ public Endpoint registerEndpoint(String uri, Endpoint endpoint) {\n         return new InterceptEndpointProcessor(uri, detour);\n     }\n \n+    /**\n+     * Does the uri match the pattern.\n+     *\n+     * @param camelContext the CamelContext\n+     * @param uri the uri\n+     * @param pattern the pattern, which can be an endpoint uri as well\n+     * @return <tt>true</tt> if matched and we should intercept, <tt>false</tt> if not matched, and not intercept.\n+     */\n+    protected boolean matchPattern(CamelContext camelContext, String uri, String pattern) {\n+        // match using the pattern as-is\n+        boolean match = EndpointHelper.matchEndpoint(camelContext, uri, pattern);\n+        if (!match) {\n+            try {\n+                // the pattern could be an uri, so we need to normalize it before matching again\n+                pattern = URISupport.normalizeUri(pattern);\n+                match = EndpointHelper.matchEndpoint(camelContext, uri, pattern);\n+            } catch (Exception e) {\n+                // ignore\n+            }\n+        }\n+        return match;\n+    }\n+\n     /**\n      * Applies this interceptor only if the given predicate is true\n      *\n",
        "project": "camel",
        "linesAdd": 15,
        "jira_id": "7304",
        "nb_skipped": 3,
        "commit": "fa165d6b",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4218,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.file.FromFilePollThirdTimeOkTest",
            "org.apache.camel.processor.aggregator.AggregateTimeoutWithExecutorServiceTest",
            "org.apache.camel.util.UnsafeCharactersEncoderTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/util/UnsafeUriCharactersEncoder.java b/camel-core/src/main/java/org/apache/camel/util/UnsafeUriCharactersEncoder.java\nindex 39659e49dc..4bc707f550 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/UnsafeUriCharactersEncoder.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/UnsafeUriCharactersEncoder.java\n@@ -20,6 +20,8 @@\n \n /**\n  * Encoder for unsafe URI characters.\n+ * <p/>\n+ * A good source for details is <a href=\"http://en.wikipedia.org/wiki/Url_encode\">wikipedia url encode</a> article.\n  */\n public final class UnsafeUriCharactersEncoder {\n     private static BitSet unsafeCharacters;   \n@@ -33,7 +35,7 @@\n         unsafeCharacters.set('<');\n         unsafeCharacters.set('>');\n         unsafeCharacters.set('#');\n-        // unsafeCharacters.set('%');\n+        unsafeCharacters.set('%');\n         unsafeCharacters.set('{');\n         unsafeCharacters.set('}');\n         unsafeCharacters.set('|');\n@@ -70,10 +72,27 @@ public static String encode(String s) {\n         }\n \n         // okay there are some unsafe characters so we do need to encode\n+        // see details at: http://en.wikipedia.org/wiki/Url_encode\n         StringBuilder sb = new StringBuilder();\n-        for (char ch : chars) {\n+        for (int i = 0; i < chars.length; i++) {\n+            char ch = chars[i];\n             if (ch > 0 && ch < 128 && unsafeCharacters.get(ch)) {\n+                // special for % sign as it may be a decimal encoded value\n+                if (ch == '%') {\n+                    char next = i + 1 < chars.length ? chars[i + 1] : ' ';\n+                    char next2 = i + 2 < chars.length ? chars[i + 2] : ' ';\n+\n+                    if (isHexDigit(next) && isHexDigit(next2)) {\n+                        // its already encoded (decimal encoded) so just append as is\n+                        sb.append(ch);\n+                    } else {\n+                        // must escape then, as its an unsafe character\n+                        appendEscape(sb, (byte)ch);\n+                    }\n+                } else {\n+                    // must escape then, as its an unsafe character\n                     appendEscape(sb, (byte)ch);\n+                }\n             } else {\n                 sb.append(ch);\n             }\n@@ -88,4 +106,13 @@ private static void appendEscape(StringBuilder sb, byte b) {\n         sb.append(HEX_DIGITS[(b >> 0) & 0x0f]);\n     }\n \n+    private static boolean isHexDigit(char ch) {\n+        for (char hex : HEX_DIGITS) {\n+            if (hex == ch) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n }\n",
        "project": "camel",
        "linesAdd": 23,
        "jira_id": "5357",
        "nb_skipped": 1,
        "commit": "4cf7e80e",
        "nb_failure": 2,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 2,
        "nb_test": 5172,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.file.FileConsumerRestartNotLeakThreadTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultScheduledPollConsumerScheduler.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultScheduledPollConsumerScheduler.java\nindex c132cadb41..729ee758ea 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultScheduledPollConsumerScheduler.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultScheduledPollConsumerScheduler.java\n@@ -156,13 +156,10 @@ protected void doStart() throws Exception {\n     protected void doStop() throws Exception {\n         if (future != null) {\n             LOG.debug(\"This consumer is stopping, so cancelling scheduled task: \" + future);\n-            future.cancel(false);\n+            future.cancel(true);\n             future = null;\n         }\n-    }\n \n-    @Override\n-    protected void doShutdown() throws Exception {\n         if (shutdownExecutor && scheduledExecutorService != null) {\n             getCamelContext().getExecutorServiceManager().shutdownNow(scheduledExecutorService);\n             scheduledExecutorService = null;\ndiff --git a/camel-core/src/main/java/org/apache/camel/impl/ScheduledPollConsumer.java b/camel-core/src/main/java/org/apache/camel/impl/ScheduledPollConsumer.java\nindex 5d080e2950..e300d4952b 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ScheduledPollConsumer.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ScheduledPollConsumer.java\n@@ -514,7 +514,8 @@ public void startScheduler() {\n \n     @Override\n     protected void doStop() throws Exception {\n-        ServiceHelper.stopService(scheduler);\n+        scheduler.unscheduleTask();\n+        ServiceHelper.stopAndShutdownServices(scheduler);\n \n         // clear counters\n         backoffCounter = 0;\n",
        "project": "camel",
        "linesAdd": 3,
        "jira_id": "8146",
        "nb_skipped": 4,
        "commit": "17475d80",
        "nb_failure": 1,
        "linesRem": 5,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5459,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.issues.ServicePoolAwareLeakyTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\nindex 5b799547c0..586cc696e3 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n@@ -60,23 +60,31 @@\n     private boolean eventNotifierEnabled = true;\n     private boolean extendedStatistics;\n     private int maxCacheSize;\n+    private boolean stopServicePool;\n \n     public ProducerCache(Object source, CamelContext camelContext) {\n         this(source, camelContext, CamelContextHelper.getMaximumCachePoolSize(camelContext));\n     }\n \n     public ProducerCache(Object source, CamelContext camelContext, int cacheSize) {\n-        this(source, camelContext, camelContext.getProducerServicePool(), createLRUCache(cacheSize));\n+        this(source, camelContext, null, createLRUCache(cacheSize));\n     }\n \n     public ProducerCache(Object source, CamelContext camelContext, Map<String, Producer> cache) {\n-        this(source, camelContext, camelContext.getProducerServicePool(), cache);\n+        this(source, camelContext, null, cache);\n     }\n \n     public ProducerCache(Object source, CamelContext camelContext, ServicePool<Endpoint, Producer> producerServicePool, Map<String, Producer> cache) {\n         this.source = source;\n         this.camelContext = camelContext;\n+        if (producerServicePool == null) {\n+            // use shared producer pool which lifecycle is managed by CamelContext\n+            this.pool = camelContext.getProducerServicePool();\n+            this.stopServicePool = false;\n+        } else {\n             this.pool = producerServicePool;\n+            this.stopServicePool = true;\n+        }\n         this.producers = cache;\n         if (producers instanceof LRUCache) {\n             maxCacheSize = ((LRUCache) producers).getMaxCacheSize();\n@@ -468,7 +476,10 @@ protected void doStart() throws Exception {\n \n     protected void doStop() throws Exception {\n         // when stopping we intend to shutdown\n-        ServiceHelper.stopAndShutdownServices(statistics, pool);\n+        ServiceHelper.stopAndShutdownService(statistics);\n+        if (stopServicePool) {\n+            ServiceHelper.stopAndShutdownService(pool);\n+        }\n         try {\n             ServiceHelper.stopAndShutdownServices(producers.values());\n         } finally {\n",
        "project": "camel",
        "linesAdd": 13,
        "jira_id": "9143",
        "nb_skipped": 4,
        "commit": "08077733",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4984,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.impl.JndiRegistryTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/JndiRegistry.java b/camel-core/src/main/java/org/apache/camel/impl/JndiRegistry.java\nindex dc663e3d4e..8a077b3ee1 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/JndiRegistry.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/JndiRegistry.java\n@@ -78,8 +78,8 @@ public Object lookupByName(String name) {\n             NamingEnumeration<NameClassPair> list = getContext().list(\"\");\n             while (list.hasMore()) {\n                 NameClassPair pair = list.next();\n-                if (type.isInstance(pair.getClass()) || type.getName().equals(pair.getClassName())) {\n                 Object instance = context.lookup(pair.getName());\n+                if (type.isInstance(instance)) {\n                     answer.put(pair.getName(), type.cast(instance));\n                 }\n             }\n@@ -96,8 +96,8 @@ public Object lookupByName(String name) {\n             NamingEnumeration<NameClassPair> list = getContext().list(\"\");\n             while (list.hasMore()) {\n                 NameClassPair pair = list.next();\n-                if (type.isInstance(pair.getClass()) || type.getName().equals(pair.getClassName())) {\n                 Object instance = context.lookup(pair.getName());\n+                if (type.isInstance(instance)) {\n                     answer.add(type.cast(instance));\n                 }\n             }\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "7418",
        "nb_skipped": 3,
        "commit": "cabee0e9",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 3245,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.onexception.OnExceptionUseOriginalMessageTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java b/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java\nindex 51fe6bfa21..d7f11e0694 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/RedeliveryErrorHandler.java\n@@ -591,18 +591,23 @@ protected boolean deliverToFailureProcessor(final Processor processor, final Exc\n         // is the a failure processor to process the Exchange\n         if (processor != null) {\n \n-            // reset cached streams so they can be read again\n-            MessageHelper.resetStreamCache(exchange.getIn());\n-\n             // prepare original IN body if it should be moved instead of current body\n             if (data.useOriginalInMessage) {\n                 if (log.isTraceEnabled()) {\n                     log.trace(\"Using the original IN message instead of current\");\n                 }\n-\n                 Message original = exchange.getUnitOfWork().getOriginalInMessage();\n                 exchange.setIn(original);\n+                if (exchange.hasOut()) {\n+                    if (log.isTraceEnabled()) {\n+                        log.trace(\"Removing the out message to avoid some uncertain behavior\");\n                     }\n+                    exchange.setOut(null);\n+                }\n+            }\n+            \n+            // reset cached streams so they can be read again\n+            MessageHelper.resetStreamCache(exchange.getIn());\n \n             if (log.isTraceEnabled()) {\n                 log.trace(\"Failure processor \" + processor + \" is processing Exchange: \" + exchange);\n",
        "project": "camel",
        "linesAdd": 8,
        "jira_id": "3791",
        "nb_skipped": 0,
        "commit": "52106681",
        "nb_failure": 1,
        "linesRem": 3,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4359,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.ResequenceStreamRejectOldExchangesTest",
            "org.apache.camel.component.log.LogFormatterTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/component/log/LogFormatter.java b/camel-core/src/main/java/org/apache/camel/component/log/LogFormatter.java\nindex 19eba1b882..c19097444e 100644\n--- a/camel-core/src/main/java/org/apache/camel/component/log/LogFormatter.java\n+++ b/camel-core/src/main/java/org/apache/camel/component/log/LogFormatter.java\n@@ -167,12 +167,24 @@ public String format(Exchange exchange) {\n                 }\n             }\n \n-            // get rid of the leading space comma if needed\n-            return \"Exchange[\" + (multiline ? answer.append(']').toString() : answer.toString().substring(2) + \"]\");\n+            // switch string buffer\n+            sb = answer;\n         }\n \n+        if (multiline) {\n+            sb.insert(0, \"Exchange[\");\n+            sb.append(\"]\");\n+            return sb.toString();\n+        } else {\n             // get rid of the leading space comma if needed\n-        return \"Exchange[\" + (multiline ? sb.append(']').toString() : sb.toString().substring(2) + \"]\");\n+            if (sb.length() > 0 && sb.charAt(0) == ',' && sb.charAt(1) == ' ') {\n+                sb.replace(0, 2, \"\");\n+            }\n+            sb.insert(0, \"Exchange[\");\n+            sb.append(\"]\");\n+\n+            return sb.toString();\n+        }\n     }\n \n     public boolean isShowExchangeId() {\n",
        "project": "camel",
        "linesAdd": 14,
        "jira_id": "5699",
        "nb_skipped": 1,
        "commit": "6d63a502",
        "nb_failure": 1,
        "linesRem": 2,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4781,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.xslt.XsltDTDTest",
            "org.apache.camel.management.ManagedThrottlerTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/builder/xml/XsltBuilder.java b/camel-core/src/main/java/org/apache/camel/builder/xml/XsltBuilder.java\nindex 8984828968..3a7b9a4fff 100644\n--- a/camel-core/src/main/java/org/apache/camel/builder/xml/XsltBuilder.java\n+++ b/camel-core/src/main/java/org/apache/camel/builder/xml/XsltBuilder.java\n@@ -79,7 +79,7 @@\n     private URIResolver uriResolver;\n     private boolean deleteOutputFile;\n     private ErrorListener errorListener = new XsltErrorListener();\n-    private boolean allowStAX;\n+    private boolean allowStAX = true;\n \n     public XsltBuilder() {\n     }\n",
        "project": "camel",
        "linesAdd": 1,
        "jira_id": "7130",
        "nb_skipped": 2,
        "commit": "7c9326f4",
        "nb_failure": 1,
        "linesRem": 1,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 5485,
        "nb_error": 1,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.FileIdempotentConsumerCreateRepoTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/idempotent/FileIdempotentRepository.java b/camel-core/src/main/java/org/apache/camel/processor/idempotent/FileIdempotentRepository.java\nindex 301fb0d8c6..2451daf8eb 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/idempotent/FileIdempotentRepository.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/idempotent/FileIdempotentRepository.java\n@@ -290,7 +290,9 @@ protected void loadStore() throws IOException {\n         if (!fileStore.exists()) {\n             LOG.debug(\"Creating filestore: {}\", fileStore);\n             File parent = fileStore.getParentFile();\n+            if (parent != null) {\n                 parent.mkdirs();\n+            }\n             boolean created = FileUtil.createNewFile(fileStore);\n             if (!created) {\n                 throw new IOException(\"Cannot create filestore: \" + fileStore);\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "9340",
        "nb_skipped": 4,
        "commit": "1cab39f6",
        "nb_failure": 0,
        "linesRem": 0,
        "singleLine": false
    },
    {
        "files": 3,
        "nb_test": 5190,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.processor.SendExchangePatternOptionTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/RecipientListProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/RecipientListProcessor.java\nindex 1087da6636..db6af86a58 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/RecipientListProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/RecipientListProcessor.java\n@@ -17,12 +17,11 @@\n package org.apache.camel.processor;\n \n import java.io.UnsupportedEncodingException;\n-import java.net.URI;\n+import java.net.MalformedURLException;\n import java.net.URISyntaxException;\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.List;\n-import java.util.Map;\n import java.util.concurrent.ExecutorService;\n \n import org.apache.camel.CamelContext;\n@@ -34,6 +33,7 @@\n import org.apache.camel.impl.ProducerCache;\n import org.apache.camel.processor.aggregate.AggregationStrategy;\n import org.apache.camel.spi.RouteContext;\n+import org.apache.camel.util.EndpointHelper;\n import org.apache.camel.util.ExchangeHelper;\n import org.apache.camel.util.MessageHelper;\n import org.apache.camel.util.ServiceHelper;\n@@ -191,7 +191,7 @@ public void setIgnoreInvalidEndpoints(boolean ignoreInvalidEndpoints) {\n             ExchangePattern pattern;\n             try {\n                 endpoint = resolveEndpoint(exchange, recipient);\n-                pattern = resolveExchangePattern(exchange, recipient);\n+                pattern = resolveExchangePattern(recipient);\n                 producer = producerCache.acquireProducer(endpoint);\n             } catch (Exception e) {\n                 if (isIgnoreInvalidEndpoints()) {\n@@ -254,18 +254,13 @@ protected static Endpoint resolveEndpoint(Exchange exchange, Object recipient) {\n         return ExchangeHelper.resolveEndpoint(exchange, recipient);\n     }\n \n-    protected ExchangePattern resolveExchangePattern(Exchange exchange, Object recipient) throws UnsupportedEncodingException, URISyntaxException {\n+    protected ExchangePattern resolveExchangePattern(Object recipient) throws UnsupportedEncodingException, URISyntaxException, MalformedURLException {\n         // trim strings as end users might have added spaces between separators\n         if (recipient instanceof String) {\n             String s = ((String) recipient).trim();\n             // see if exchangePattern is a parameter in the url\n             s = URISupport.normalizeUri(s);\n-            URI url = new URI(s);\n-            Map<String, Object> parameters = URISupport.parseParameters(url);\n-            String pattern = (String) parameters.get(\"exchangePattern\");\n-            if (pattern != null) {\n-                return ExchangePattern.asEnum(pattern);\n-            }\n+            return EndpointHelper.resolveExchangePatternFromUrl(s);\n         }\n         return null;\n     }\ndiff --git a/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java\nindex d8e8803f65..efd6a6043c 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/SendProcessor.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.camel.processor;\n \n+import java.net.URISyntaxException;\n import java.util.HashMap;\n \n import org.apache.camel.AsyncCallback;\n@@ -33,6 +34,7 @@\n import org.apache.camel.support.ServiceSupport;\n import org.apache.camel.util.AsyncProcessorConverterHelper;\n import org.apache.camel.util.AsyncProcessorHelper;\n+import org.apache.camel.util.EndpointHelper;\n import org.apache.camel.util.EventHelper;\n import org.apache.camel.util.ObjectHelper;\n import org.apache.camel.util.ServiceHelper;\n@@ -53,6 +55,7 @@\n     protected ProducerCache producerCache;\n     protected AsyncProcessor producer;\n     protected Endpoint destination;\n+    protected ExchangePattern destinationExchangePattern;\n     protected final boolean unhandleException;\n \n     public SendProcessor(Endpoint destination) {\n@@ -69,6 +72,12 @@ public SendProcessor(Endpoint destination, ExchangePattern pattern, boolean unha\n         this.camelContext = destination.getCamelContext();\n         this.pattern = pattern;\n         this.unhandleException = unhandleException;\n+        try {\n+            this.destinationExchangePattern = null;\n+            this.destinationExchangePattern = EndpointHelper.resolveExchangePatternFromUrl(destination.getEndpointUri());\n+        } catch (URISyntaxException e) {\n+            throw ObjectHelper.wrapRuntimeCamelException(e);\n+        }\n         ObjectHelper.notNull(this.camelContext, \"camelContext\");\n     }\n \n@@ -133,11 +142,9 @@ public void done(boolean doneSync) {\n                     }\n                 });\n             } catch (Throwable throwable) {\n-                if (exchange != null) {\n                 exchange.setException(throwable);\n                 checkException(exchange);\n-                }\n-\n+                callback.done(sync);\n             }\n \n             return sync;\n@@ -180,7 +187,10 @@ public ExchangePattern getPattern() {\n     }\n \n     protected Exchange configureExchange(Exchange exchange, ExchangePattern pattern) {\n-        if (pattern != null) {\n+        // destination exchange pattern overrides pattern\n+        if (destinationExchangePattern != null) {\n+            exchange.setPattern(destinationExchangePattern);\n+        } else if (pattern != null) {\n             exchange.setPattern(pattern);\n         }\n         // set property which endpoint we send to\ndiff --git a/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java b/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java\nindex 9df3ca2060..18181b33bb 100644\n--- a/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java\n+++ b/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.camel.util;\n \n+import java.net.URI;\n+import java.net.URISyntaxException;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n@@ -29,6 +31,7 @@\n import org.apache.camel.DelegateEndpoint;\n import org.apache.camel.Endpoint;\n import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n import org.apache.camel.Message;\n import org.apache.camel.PollingConsumer;\n import org.apache.camel.Processor;\n@@ -487,4 +490,21 @@ public static String browseRangeMessagesAsXml(BrowsableEndpoint endpoint, Intege\n         return sb.toString();\n     }\n \n+    /**\n+     * Attempts to resolve if the url has an <tt>exchangePattern</tt> option configured\n+     *\n+     * @param url the url\n+     * @return the exchange pattern, or <tt>null</tt> if the url has no <tt>exchangePattern</tt> configured.\n+     * @throws URISyntaxException is thrown if uri is invalid\n+     */\n+    public static ExchangePattern resolveExchangePatternFromUrl(String url) throws URISyntaxException {\n+        URI uri = new URI(url);\n+        Map<String, Object> parameters = URISupport.parseParameters(uri);\n+        String pattern = (String) parameters.get(\"exchangePattern\");\n+        if (pattern != null) {\n+            return ExchangePattern.asEnum(pattern);\n+        }\n+        return null;\n+    }\n+\n }\n",
        "project": "camel",
        "linesAdd": 31,
        "jira_id": "8227",
        "nb_skipped": 4,
        "commit": "54d7fc59",
        "nb_failure": 1,
        "linesRem": 14,
        "singleLine": false
    },
    {
        "files": 1,
        "nb_test": 4619,
        "nb_error": 0,
        "classification": {
            "singleLine": false
        },
        "failing_tests": [
            "org.apache.camel.component.file.FileProducerFileExistAppendTest",
            "org.apache.camel.processor.StreamCachingRecipientListTest"
        ],
        "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/RecipientListProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/RecipientListProcessor.java\nindex 92b34224f7..9a9bf91002 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/RecipientListProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/RecipientListProcessor.java\n@@ -30,6 +30,7 @@\n import org.apache.camel.processor.aggregate.AggregationStrategy;\n import org.apache.camel.spi.RouteContext;\n import org.apache.camel.util.ExchangeHelper;\n+import org.apache.camel.util.MessageHelper;\n import org.apache.camel.util.ServiceHelper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -100,6 +101,8 @@ public void begin() {\n             // we have already acquired and prepare the producer\n             LOG.trace(\"RecipientProcessorExchangePair #{} begin: {}\", index, exchange);\n             exchange.setProperty(Exchange.RECIPIENT_LIST_ENDPOINT, endpoint.getEndpointUri());\n+            // ensure stream caching is reset\n+            MessageHelper.resetStreamCache(exchange.getIn());\n         }\n \n         public void done() {\n",
        "project": "camel",
        "linesAdd": 2,
        "jira_id": "6604",
        "nb_skipped": 1,
        "commit": "4209fabb",
        "nb_failure": 2,
        "linesRem": 0,
        "singleLine": false
    }
]
